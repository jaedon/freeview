/*
 * Copyright (c) 2007 Strategy and Technology Limited. All Rights Reserved.
 *
 * Copyright in the whole and every part of this file belongs to
 * Strategy and Technology Limited ("the Owner") and may not be used,
 * sold, supplied, transferred, copied, reproduced in whole or in part,
 * in any manner or form or in or on any media for the benefit of any person
 * other than in accordance with the terms of the Owner's agreement or
 * otherwise without the prior written consent of the Owner.
 *
 */
#if !defined ITK_DISPLAY_H__
#define ITK_DISPLAY_H__

#include "itk_types.h"
#include "itk_avstream.h"
#include "itk_audioclip.h"

/**
 * @file
 *
 * Display Interface
 */

 /**
  * @ingroup host
  * @defgroup display Host display interface
  * @{
  */
struct itk_dfb_t;
struct itk_graphics_pipeline_t;
struct itk_display_t;
struct itk_image_t;

/**
 * Display capabilities flags. The values form a bitfield
 * that is returned from itk_display_t::getCaps().
 */
typedef enum itk_display_caps_t
{
    ITK_DISPLAY_CAPS_PIPELINE               = 1 << 0,  /**< The display implements a pipeline */
    ITK_DISPLAY_CAPS_HD_VIDEO               = 1 << 1,  /**< The display can present HD video */
    ITK_DISPLAY_CAPS_HD_GRAPHICS            = 1 << 2,  /**< The display can present HD graphics via the pipeline */
    ITK_DISPLAY_CAPS_KEYBOARD               = 1 << 3,  /**< The display has an alpha-numeric keyboard */
    ITK_DISPLAY_CAPS_BACKGROUND             = 1 << 4,  /**< The display has programmable background colour */
    ITK_DISPLAY_CAPS_STILL_PLANE            = 1 << 5,  /**< The display has a secondary still image plane */
    ITK_DISPLAY_CAPS_SIMUL_SUBS             = 1 << 6,  /**< The display can present subtitles and MHEG graphics simultaneously */
    ITK_DISPLAY_CAPS_NLP_KEYS               = 1 << 7,  /**< The display can generate non-linear playback button events */
    ITK_DISPLAY_CAPS_PALETTE                = 1 << 8,  /**< The display implements a colour palette instead of direct colours */
    ITK_DISPLAY_CAPS_IP_STREAMING           = 1 << 9,  /**< The display can decode and present IP streamed data */
    ITK_DISPLAY_CAPS_IPS_BUFFER_RESTRICTION = 1 << 10, /**< The display has implemented IP Stream Buffer Restrictions defined in DBook6 Sec 16.3.8.3 */
    ITK_DISPLAY_CAPS_IPS_BUFFERING          = 1 << 11, /**< The display has implemented IP Stream Buffer model specified in DBook6 Sec 16.3.8 */
    ITK_DISPLAY_CAPS_IPS_ENCRYPTION         = 1 << 12, /**< The display can decode and present encrypted IP streamed data */
    ITK_DISPLAY_CAPS_IPS_HD                 = 1 << 13  /**< The display can decode and present IP streamed data at HD resolutions and at up to 4096 Kbps */
} itk_display_caps_t;

/**
 * Events generated by the display
 */
typedef enum itk_display_event_t
{
    ITK_DISPLAY_EV_REDRAW = 0,       /**< The client needs to redraw the graphics plane. Note:
                                          If this is sent to trigger a redraw after a physical size
                                          change (e.g. switch from SD to HD), the pipeline should
                                          ignore all subsequent draw operations until its
                                          getPhysicalSize() function is called. */
    ITK_DISPLAY_EV_ASPECT,           /**< Sent when viewer preference for aspect ratio handling changed.
                                          This is usually caused by a change of tube shape or
                                          in handling of 16:9 on 4:3 - which would not change the value
                                          returned by itk_display_t::getShape() */
    ITK_DISPLAY_EV_SUBS_CHANGED      /**< The subtitle presentation state has changed, i.e. subtitles have been
                                          turned on or off. CI+ only. */
} itk_display_event_t;

/**
 * The video and image decode display plane values
 */
typedef enum itk_display_plane_t
{
    ITK_DISPLAY_PLANE_VIDEO = 0, /**< Upper most (closest to the viewer) plane */
    ITK_DISPLAY_PLANE_STILL      /**< Lower most (furthest from the viewer) plane; Freesat only */
} itk_display_plane_t;

/**
 * Prototype for an event callback function
 *
 * @param[in] context The context given when the callback was registered
 * @param[in] ev The event type
 */
typedef void (*itk_display_event_callback_t)(void *context, itk_display_event_t ev);

/**
 * Display aspect ratio settings
 */
typedef enum itk_display_shape_t
{
    ITK_SHAPE_16_9 = 0, /**< 16:9 */
    ITK_SHAPE_4_3,      /**< 4:3 */
    ITK_SHAPE_UND,      /**< Undefined, follow the rules for video display */ 
    ITK_SHAPE_UNSET
} itk_display_shape_t;

/**
 * Drawing modes.
 * The Mix operation uses the Porter-Duff SRC_OVER function.
 */
typedef enum itk_draw_mode_t
    {
        DRAWMODE_REPLACE = 0, /**< Replace the current pixel value with the new value */
        DRAWMODE_MIX          /**< Replace the current pixel value with a mix
                                 of the current and new values */
    } itk_draw_mode_t;

/**
 * @defgroup gp The graphics pipeline
 * @{
 */

/**
 * Supported formats for bitmap pixels.
 */
typedef enum itk_pixel_format_t 
{
     /**
      * 8bpp paletted. Each pixel is represented as an 8-bit index into the
      * colour palette.
      */
    ITK_FB_LUT8 = 0,

    /**
     * 16bpp, rgba. Each pixel is represented by a byte-pair. The byte at
     * the lower memory address contains the blue value in bits 4-7 and the
     * alpha value in bits 0-3. The byte at the higher address contains the
     * red value in bits 4-7 and the green value in bits 0-3.
     */
    ITK_FB_RGBA4444,

    /**
     * 16bpp, argb. Each pixel is represented by a byte-pair. The byte at
     * the lower memory address contains the green value in bits 4-7 and the
     * blue value in bits 0-3. The byte at the higher address contains the
     * alpha value in bits 4-7 and the red value in bits 0-3.
     */
    ITK_FB_ARGB4444,

    /**
     * 32bpp, rgba. Each pixel is represented by 4 bytes. The byte at
     * the lowest memory address contains an 8-bit alpha value; consecutive
     * bytes hold the blue, green and red values in that order.
     */
    ITK_FB_RGBA8888,

    /**
     * 32bpp, argba. Each pixel is represented by 4 bytes. The byte at
     * the lowest memory address contains an 8-bit blue value; consecutive
     * bytes hold the green, red and alpha values in that order.
     */
    ITK_FB_ARGB8888
} itk_pixel_format_t;

/**
 * Mask type. Masks are typically used for text rendering. A depth of
 * 8, for example, could be used for anti-aliased text.
 */
typedef struct itk_mask_t
{
    itk_int32_t width;   /**< Pixels in each row */
    itk_int32_t height;  /**< Rows in the mask */
    itk_int32_t pitch;   /**< Bytes in each row (each new row starts at a
                           byte boundary). */
    itk_int32_t depth;   /**< Depth in bits of each multiplier in the mask data (e.g. 1
                            or 8) */
    itk_uint8_t * mask;  /**< Mask data (alpha multipliers). */
} itk_mask_t;

/**
 * Bitmap type. Bitmaps are typically used for rendering pictures (PNG, JPEG,
 * ...). The pixel resolution allows bitmaps to be encoded for HD resolutions
 * of 1920 x 1080, and 1280 x 720, as well as for SD resolution of 720 x 576.
 * Bitmaps are created by the graphics pipeline, and pixel data will be
 * in the pipeline's native pixel format.
 */
typedef struct itk_bitmap_t
{
    itk_int32_t width;   /**< Pixels in each row */
    itk_int32_t height;  /**< Rows in the bitmap */
    itk_int32_t pitch;   /**< Bytes in each row */
    itk_pixel_format_t format; /**< Format of pixels in the bitmap */  
    itk_int32_t pixel_resolution_w; /**< The horizontal pixel resolution */
    itk_int32_t pixel_resolution_h; /**< The vertical pixel resolution */
    itk_uint8_t * bitmap;  /**< Bitmap pixel data */
} itk_bitmap_t;

/**
 * Supported bitmap tiling modes.
 */
typedef enum itk_tiling_t
{
    ITK_TILING_NOT_TILED, /**< Do not tile the bitmap */
    ITK_TILING_TILED,     /**< Tile the bitmap to fill target rectangle */
    ITK_TILING_SCALED     /**< Scale the bitmap to fill target rectangle (only used on HD platforms) */
} itk_tiling_t;

/**
 * Picture formats
 */
typedef enum itk_picture_format_t
{
    ITK_PICTURE_PNG = 4, /**< Portable Network Graphics */
    ITK_PICTURE_JPEG     /**< Joint Photographic Experts Group */
} itk_picture_format_t;

/**
 * Image formats
 */
typedef enum itk_image_format_t
{
    ITK_IMAGE_MPEG2 = 0, /**< MPEG-2 I frame still */
    ITK_IMAGE_H264       /**< MPEG-4 H.264 Intra still */
} itk_image_format_t;

/**
 * Accelerated graphics pipeline interface. This interface abstracts the
 * physical capabilities of a graphics plane attached to a display.
 *
 * Graphics pipeline clients use physical coordinate space, which they obtain
 * by querying the pipeline. The fillArea() and fillMask() functions are
 * in physical space, and the graphics clipping region is also in physical
 * space.  The copyBitmap() function requires the pipeline to map from the
 * bitmap's native resolution to the pipeline's physical coordinate space:
 * this may not be a one-to-one mapping, for example in the case when an SD
 * image is being displayed on an HD platform. Note that the client
 * fills pixels in a bitmap with alpha values pre-multiplied into the red,
 * green, blue pixel components. The client will not modify the pixels of a
 * bitmap returned by createBitmapFromData(). 
 */
typedef struct itk_graphics_pipeline_t
{
    /**
     * Release the graphics pipeline and any associated resources.
     * @param thiz The pipeline to release.
     */
    void (*release)(struct itk_graphics_pipeline_t * thiz);

    /**
     * Obtain the physical size of the graphics display.
     * @param thiz The pipeline.
     * @returns The physical size in pixels of the graphics display.
     */
    itk_rect_t (*getPhysicalSize)(struct itk_graphics_pipeline_t * thiz);

    /**
     * Start drawing to the pipeline. The output device is locked. A call to this
     * function is succeeded by calls to the various drawing commands, and finally a
     * call to endDraw() which flushes changes to the display.
     * @param thiz The pipeline to draw on.
     * @param clip The clipping region (in physical space). The effect of
     * subsequent calls to draw commands must be restricted to lie within this region.
     * @returns ITKE_OK on success, ITKE_FAIL otherwise.
     */
    itk_errcode_t (*startDraw)(struct itk_graphics_pipeline_t * thiz, itk_rect_t const * clip);

    /**
     * End drawing sequence. Output is flushed to the display. It is an error
     * to call this function unless startDraw() has previously been called
     * and succeeded.
     * @param thiz The pipeline.
     * See also startDraw().
     */
    void (*endDraw)(struct itk_graphics_pipeline_t * thiz);

    /**
     * Clear a rectangular area of the pipeline (e.g. by setting all pixels in that
     * area to be fully transparent).
     * The operation must be clipped by the pipeline within the current clipping region.
     * @param thiz The pipeline.
     * @param area_to_clear
     */
    void (*clearArea)(struct itk_graphics_pipeline_t * thiz,
                      itk_rect_t const * area_to_clear);

    /**
     * Alpha blend a fixed colour into a rectangular area of the display.
     * The operation must be clipped by the pipeline within the current clipping region.
     * @param thiz The pipeline.
     * @param fill_colour
     * @param area_to_fill
     */
    void (*fillArea)(struct itk_graphics_pipeline_t * thiz,
                     itk_colour_t const * fill_colour,
                     itk_rect_t const * area_to_fill);

    /**
     * Allocate a mask of the supplied dimensions. This function allows the
     * pipeline to choose exactly how to allocate the mask buffer.
     * The client will not normally call this function directly, but it is
     * called by the font driver.
     * @param width The number of pixels in each row of the mask
     * @param height The height of the mask in pixels
     * @param depth  The minimum depth of the mask, bits per pixel, 1 or 8.
     * @returns The mask, on success, NULL otherwise.
     * @note The returned mask must have all fields filled with valid values.
     * The depth of the returned mask must be at least the depth requested, 
     * but could be larger. That means it is acceptable to return an 8-bit 
     * mask when a 1-bit mask is requested, but not vice versa.
     */
    itk_mask_t *(*createMask)(struct itk_graphics_pipeline_t * thiz,
                              itk_int32_t width,
                              itk_int32_t height,
                              itk_int32_t depth);

    /**
     * Release a non-NULL mask previously returned by createMask().
     */
    void (*releaseMask)(struct itk_graphics_pipeline_t * thiz,
                        itk_mask_t *mask);
    /**
     * Alpha blend a mask onto a rectangular area of the pipeline using a
     * fixed colour and an alpha mask.
     * @param thiz The pipeline.
     * @param mask The mask.
     * @param pen The pen colour to use for drawing the mask.
     * @param top_left_corner_of_mask
     * @note The operation should be clipped within the current clipping
     * region.
     * @note Mask dimensions and the top-left corner position are in the
     * pipeline's physical coordinate space.
     * @note Currently, the mask depth will either be 1 bit or 8 bits.
     * @note There are no guarantees about how long data referenced by the
     * mask will persist. The pipeline should make a copy of the mask if it cannot use
     * it immediately.
     */
    void (*fillMask)(struct itk_graphics_pipeline_t * thiz,
                     itk_mask_t const * mask,
                     itk_colour_t const * pen,
                     itk_point_t const * top_left_corner_of_mask);

    /**
     * Allocate a bitmap of the supplied dimensions. This function allows the
     * pipeline to choose exactly how to allocate the bitmap pixel buffer.
     * @param width The number of pixels in each row of the bitmap
     * @param height The height of the bitmap in pixels
     * @returns The bitmap, on success, NULL otherwise.
     * @note The returned bitmap must have width, height, pitch, format and bitmap
     * fields filled in. The pixel resolution fields will be overwritten by
     * the client.
     */
    itk_bitmap_t * (*createBitmap)(struct itk_graphics_pipeline_t * thiz,
                                   itk_int32_t width,
                                   itk_int32_t height);

    /**
     * Creates a picture object from the defined source data.
     *
     * @note The source data will not exist for the lifetime
     *       of the picture. Therefore if it is not consumed when the
     *       picture is created then it must be copied before returning.
     *
     * @param[in] format The source data encoding format
     * @param[in] data The source data
     * @param[in] dataSize The number of bytes of source data
     * @return An opaque handle to the picture, NULL if the data could not be used
     */
    itk_bitmap_t * (*createBitmapFromData)(struct itk_graphics_pipeline_t * thiz,
                                           itk_picture_format_t format,
                                           itk_uint8_t const * data,
                                           size_t dataSize);

    /**
     * Release a non-NULL bitmap previously returned by createBitmap() or createBitmapFromData().
     */
    void (*releaseBitmap)(struct itk_graphics_pipeline_t * thiz,
                          itk_bitmap_t * bitmap);

    /**
     * Alpha blend a bitmap to an area on the display.
     * @param bitmap The bitmap to copy. The bitmap will have been created by
     * createBitmap() or createBitmapFromData().
     * @param destination The physical region in which to display the bitmap.
     * @param tile Whether or not to tile the bitmap
     * @note The operation should be clipped within the current clipping region.
     * @note The bitmap will not change or be released (by releaseBitmap()) before the
     * next call to endDraw().
     */
    void (*copyBitmap)(struct itk_graphics_pipeline_t * thiz,
                       itk_bitmap_t const * bitmap,
                       itk_rect_t const * destination,
                       itk_tiling_t tile);

} itk_graphics_pipeline_t;

/**
 * Frame buffer configuration
 */
typedef struct itk_frame_buffer_config_t
{
    itk_pixel_format_t format;        /**< The pixel format */
    itk_int32_t width;                /**< Width in pixels */
    itk_int32_t height;               /**< Height in pixels */
    itk_int32_t pitch;                /**< Number of bytes between the start of 
                                           a pixel and the start of the pixel below it */
    itk_uint8_t *buffer;              /**< Pointer to the start of the top left corner pixel */
} itk_frame_buffer_config_t;

/**
 * Frame buffer interface
 */
typedef struct itk_dfb_t
{
    /**
     * Releases a frame buffer
     *
     * When a frame buffer is released it is no longer visible. Anything in the
     * display stack frame buffer is removed. The handle is no longer valid.
     *
     * @param[in] thiz A pointer to the frame buffer object.
     */
    void (*release)(struct itk_dfb_t *thiz);

    /**
     * Gets the physical buffer size
     *
     * The physical size is the number of addressable pixels in the buffer. Note
     * that this is the same value as is returned in the config structure in lock().
     *
     * @param[in] thiz A pointer to the frame buffer object
     *
     * @return An itk_rect_t whose w and h parameters contain the width and height
     *         in pixels of the physical scratchpad buffer
     */
    itk_rect_t (*getPhysicalSize)(struct itk_dfb_t *thiz);

    /**
     * Sets the frame buffer's palette
     *
     * @param[in] thiz The handle of the frame buffer
     * @param[in] palette A pointer to the palette values
     * @note This function shall not be called for direct (non-palette) pixel
     * formats.
     */
    void (*setPalette)(struct itk_dfb_t *thiz, const itk_palette_t *palette);

    /**
     * Locks the frame buffer's scratchpad in memory for update
     *
     * On successful return the frame buffer sets the configuration structure pointed to by config with the
     * physical parameters of the scratchpad. The pitch is the number of bytes per
     * line in the buffer and buffer points to the start of the first pixel in the display.
     * The format must be the value set when the frame buffer was acquired.
     *
     * @param[in] thiz The handle of the frame buffer
     * @param[out] config A pointer to a itk_frame_buffer_config_t to be filled with the FB's settings.
     *
     * @return ITKE_OK if the frame buffer is locked for update
     * @return ITKE_FAIL if the call fails
     */
    itk_errcode_t (*lock)(struct itk_dfb_t *thiz, itk_frame_buffer_config_t *config);

    /**
     * Unlocks the frame buffer scratchpad
     *
     * On return from this call the config values provided in a previous call to
     * lock are no longer considered to be valid. In particular the buffer pointer is
     * no longer valid.
     *
     * @param[in] thiz The handle of the frame buffer
     */
    void (*unlock)(struct itk_dfb_t *thiz);

    /**
     * Causes the frame buffer's display buffer and scratchpad to be synchronised
     *
     * The frame buffer must transfer pixels from the scratchpad buffer provided 
     * in the last call to lock to the display buffer. 
     * The operation is synchronous, i.e. the display must be fully updated before 
     * returning from the call. The update rectangle is the smallest bounding box 
     * of the regions of the buffer that have been changed since the last time 
     * this call was made.
     *
     * @param[in] thiz The handle of the frame buffer
     * @param[in] rect A pointer to a rectangle that describes the area of the display
     *            that has changed
     */
    void (*flip)(struct itk_dfb_t *thiz, const itk_rect_t *rect);

    /**
     * Allocate a bitmap of the supplied dimensions. This function allows the
     * host to choose exactly how to allocate the bitmap pixel buffer.
     * @param width The number of pixels in each row of the bitmap
     * @param height The height of the bitmap in pixels
     * @returns The bitmap, on success, NULL otherwise.
     * @note The returned bitmap must have width, height, pitch, format and bitmap
     * fields filled in. The pixel resolution fields will be overwritten by
     * the client.
     */
    itk_bitmap_t * (*createBitmap)(struct itk_dfb_t * thiz,
                                   itk_int32_t width,
                                   itk_int32_t height);
    /**
     * Creates a picture bitmap from the defined source data.
     *
     * The pixel format of the bitmap created must be the same as the
     * framebuffer pixel format.
     *
     * @param[in] format The source data encoding format
     * @param[in] data The source data
     * @param[in] dataSize The number of bytes of source data
     * @return An opaque handle to the picture, NULL if the data could not be
     * used
     *
     * @note Pixels in the returned bitmap should be in alpha pre-multiplied
     * format: i.e. if the true red, green, blue, alpha colour components
     * are R, G, B, A respectively, then the bitmap pixel values should be set
     * to RA, GA, BA, A.
     */
    itk_bitmap_t * (*createBitmapFromData)(struct itk_dfb_t * thiz,
                                           itk_picture_format_t format,
                                           itk_uint8_t const * data,
                                           size_t dataSize);

    /**
     * Release a non-NULL bitmap previously returned by createBitmapFromData().
     */
    void (*releaseBitmap)(struct itk_dfb_t * thiz,
                          itk_bitmap_t * bitmap);

} itk_dfb_t;

/**
 * @} End of Frame Buffer
 */

/**
 * Types of Decoder Format Conversion
 */
typedef enum itk_display_dfc_t
{
    ITK_DFC_UND = 0,   /**< Follow the platform's rules */
    ITK_DFC_NONE,      /**< No conversion (may cause aspect distortion) */
    ITK_DFC_CCO,       /**< Centre Cut Out 16:9 on 4:3 */
    ITK_DFC_LETTERBOX, /**< Letterbox 16:9 on 4:3 */
    ITK_DFC_PILLARBOX, /**< Pillarbox 4:3 on 16:9 (where this is not supported emulate ITK_DFC_NONE) */
    ITK_DFC_UNSET
} itk_display_dfc_t;

/**
 * Key event callback
 *
 * Callbacks of this format are used for both Remote Control key events
 * and alpha-numeric keyboard events (where these are supported).
 *
 * @return ITK_VALID if the key was consumed by the client
 * @return ITK_NOT_VALID if the key was not consumed; the host is free to process the key
 */
typedef itk_validation_t (*itk_display_key_callback_t)(void *context, struct itk_display_t *display, itk_int32_t key);

/**
 * Key codes
 */
#define ITK_KEY_UP              1
#define ITK_KEY_DOWN            2
#define ITK_KEY_LEFT            3
#define ITK_KEY_RIGHT           4
#define ITK_KEY_0               5   // will be '0'
#define ITK_KEY_1               6   // will be '1'
#define ITK_KEY_2               7   // will be '2'
#define ITK_KEY_3               8   // will be '3'
#define ITK_KEY_4               9   // will be '4'
#define ITK_KEY_5               10  // will be '5'
#define ITK_KEY_6               11  // will be '6'
#define ITK_KEY_7               12  // will be '7'
#define ITK_KEY_8               13  // will be '8'
#define ITK_KEY_9               14  // will be '9'
#define ITK_KEY_SELECT          15  // will be ?
#define ITK_KEY_CANCEL          16
#define ITK_KEY_HELP            17
#define ITK_KEY_RED             100 // will be 5
#define ITK_KEY_GREEN           101
#define ITK_KEY_YELLOW          102
#define ITK_KEY_BLUE            103
#define ITK_KEY_TEXT            104 
    /* DVR support */
#define ITK_KEY_INFO            105
#define ITK_KEY_STOP            120
#define ITK_KEY_PLAY            121
#define ITK_KEY_PAUSE           122
#define ITK_KEY_SKIP_FORWARD    123
#define ITK_KEY_SKIP_BACK       124
#define ITK_KEY_FAST_FORWARD    125
#define ITK_KEY_REWIND          126
#define ITK_KEY_PLAY_PAUSE      127 //For receivers that have a single combined play and pause key.

#define ITK_KEY_GUIDE           300 //EPG
#define ITK_KEY_MENU            301
#define ITK_KEY_LANGUAGE        302
#define ITK_KEY_INTERACTIVITY   304
#define ITK_KEY_RECORD          400

/**
 * @defgroup image Still Image
 * @{
 *
 *
 * @see itk_display_t::newImage()
 */

/**
 * Image jump table
 */
typedef struct itk_image_t
{
    /**
     * Releases an image
     *
     * @param[in] thiz The image
     */
    void (*release)(struct itk_image_t *thiz);

    /**
     * Shows the image on the display
     *
     * The image is presented using the scaling, positioning and masking
     * values defined by the Display that created it for the target
     * plane.
     *
     * @param[in] thiz The image
     */
    void (*show)(struct itk_image_t *thiz);

    /**
     * Hides the image
     *
     * @param[in] thiz The image
     */
    void (*hide)(struct itk_image_t *thiz);
} itk_image_t;
/**
 * @}
 */



/**
 * Display jump table
 */
typedef struct itk_display_t
{
    /**
     * Returns a bitfield of display capabilities
     *
     * @param[in] thiz The display to change
     * @return A bitfield built from the values of itk_display_caps_t
     */
    itk_display_caps_t (*getCaps)(struct itk_display_t *thiz);

    /**
     * Configures the co-ordinate system for the display
     *
     * The display is configured for a specified co-ordinate system. All dimensions of
     * video, still image and frame buffer co-ordinates are based on this logical size.
     *
     * Note that this need not be the same as the physical dimensions used in the decoder.
     *
     * @param[in] thiz The display to change
     * @param[in] logicalSize The pixel co-ordinate size to use for all API references to this display.
     *            The x and y values are always 0 and can be ignored. Only w and  are used.
     */
    void (*setLogicalSize)(struct itk_display_t *thiz, const itk_rect_t *logicalSize);

    /**
     * Adds a callback function to the display.
     *
     * @note There is at most one callback required for a display
     *
     * @param[in] thiz The display
     * @param[in] callback A pointer to the callback function
     * @param[in] context Context data to provide to the callback when it is invoked
     *
     * @return ITKE_OK if the callback is registered
     * @return ITKE_NO_RESOURCE if there is already a callback registered
     */
    itk_errcode_t (*addEventCallback)(struct itk_display_t *thiz, itk_display_event_callback_t callback, void *context);

    /**
     * Removes an event callback function from the display.
     *
     * @param[in] thiz The display
     */
    void (*removeEventCallback)(struct itk_display_t *thiz);

    /**
     * Adds a callback function to the display to receive key events
     *
     * @note There is at most one callback required for a display
     *
     * @param[in] thiz The display
     * @param[in] callback A pointer to the callback function
     * @param[in] context Context data to provide to the callback when it is invoked
     *
     * @return ITKE_OK if the callback is registered
     * @return ITKE_NO_RESOURCE if there is already a callback registered
     */
    itk_errcode_t (*addKeyCallback)(struct itk_display_t *thiz, itk_display_key_callback_t callback, void *context);

    /**
     * Checks if the specified set of key event values is supported and available 
     * for use by the MHEG application. If all of the key event values are available
     * then the function shall return ITK_VALID, otherwise it shall return ITK_NOT_VALID.
     *
     * @param[in] thiz The display
     * @param[in] keys a list of key values to pass
     * @param[in] keysCount the number of values in keys
     */
    itk_validation_t (*checkKeyMask)(struct itk_display_t *thiz, const itk_int32_t *keys, size_t keysCount);

    /**
     * Specifies a set of key event values to pass to the client
     *
     * The key mask gives a list of the key events for which the event callback will
     * return ITK_VALID. This can be used for platforms where there is no option
     * to provide all keys before they will know if they are consumed.
     *
     * @note keysCount may be 0, which indicates that the client is not
     * in a state to receive key events.
     *
     * @param[in] thiz The display
     * @param[in] keys a list of key values to pass
     * @param[in] keysCount the number of values in keys
     */
    void (*setKeyMask)(struct itk_display_t *thiz, const itk_int32_t *keys, size_t keysCount);

    /**
     * Removes a key event callback function from the display.
     *
     * @param[in] thiz The display
     */
    void (*removeKeyCallback)(struct itk_display_t *thiz);

    /**
     * Enables and disables an extended keyboard
     *
     * The extended keyboard is used where it is implemented to input alpha-numeric
     * data. Keys are received through the key callback function. When the keyboard
     * is enabled the parameter keyFilter points to a set of key values that are
     * expected (which may be used to limit the keys displayed for input).
     *
     * The keyFilter parameter is a null terminated string of 8-bit character codes
     * with the following meanings: 
     *
     * 0x01: UP ARROW KEY, 0x02: DOWN ARROW KEY,
     * 0x03: LEFT ARROW/BACKSPACE KEY, 0x04: RIGHT ARROW KEY, 0x0F: SELECT/ENTER,
     * 0x10: CANCEL/EXIT/ESCAPE KEY, 0x11-0x1F: reserved, 0x20-0x7F: STANDARD UNICODE
     * CHARACTER CODES, 0x80-0xFF: reserved
     *
     * @param[in] thiz The display
     * @param[in] control ITK_ENABLE to enable the extended keyboard
     * @param[in] keyFilter A pointer to a set of key values that should be recognised and sent, NULL
     *            if control is ITK_DISABLE
     *
     * @return ITKE_FAIL if the display does not support an extended keyboard
     * @return ITKE_OK if the keyboard is enabled or disabled correctly
     */
    itk_errcode_t (*setKeyboard)(struct itk_display_t *thiz, itk_control_t control, const itk_uint8_t *keyFilter);

    /**
     * Gets the (emulated) aspect ratio of the display.
     *
     * In most cases this will be the physical shape of the display.
     * Some displays (e.g. a computer screen) may be different from the
     * standard 16:9 and 4:3 shapes. In this case the shape is likely to be the closest
     * available.
     *
     * @note The value itk_display_shape_t::ITK_SHAPE_UND is not allowed as a
     * return value
     *
     * @param[in] thiz The display
     *
     * @return The display's emulated aspect ratio
     */
    itk_display_shape_t (*getShape)(struct itk_display_t *thiz);

    /**
     * Sets the output aspect ratio to be used by the display.
     *
     * Most of the time the value of aspect ratio is itk_display_shape_t::ITK_SHAPE_UND, 
     * or undefined. In this case the output aspect ratio signalling is 
     * controlled by the platform's rules for processing and presenting
     * the input video stream. However, in certain cases the client may have
     * to force a particular aspect ratio by calling this method. In this 
     * case the output is forced to 16:9 or 4:3, with any induced distortions
     * this creates. Note that following the standard decoder model as
     * described in @ref decodermodel, the ultimate output is controlled
     * by the Display Format Conversion - this aspect ratio is only an
     * input to that conversion.
     *
     * The default value for output aspect ratio is "undefined".
     *
     * @param[in] thiz The display
     * @param[in] mode The widescreen mode to use
     */
    void (*setPresentationShape)(struct itk_display_t *thiz, itk_display_shape_t shape);

    /**
     * Sets the decoder format conversion to be used for video presentation.
     * 
     * @see itk_display_dfc_t
     *
     * @note The DFC mode is not used for presentation of images on any plane.
     *
     * @param[in] thiz The media
     * @param[in] dfcFor4_3 The DFC mode to use for presenting 4:3 video source
     * @param[in] dfcFor16_9 The DFC mode to use for presenting 16:9 video source
     */
    void (*setDFCMode)(struct itk_display_t *thiz, 
                       itk_display_dfc_t dfcFor4_3, 
                       itk_display_dfc_t dfcFor16_9);

    /**
     * Sets the display's background colour. The transparency of the colour
     * is ignored. The background colour is presented wherever it is not masked
     * out by the planes above it.
     *
     * @param[in] thiz The display
     * @param[in] colour The colour
     */
    void (*setBackgroundColour)(struct itk_display_t *thiz, itk_colour_t const *colour);

    /**
     * Enables or disables subtitle decoding for a video stream
     *
     * Note that setting this control to ITK_ENABLE only causes subtitles to be
     * presented if:
     * - the viewer has enabled presentation
     * - the service has subtitles
     * - the host allows simultaneous MHEG and subtitles
     *
     * @see subtitle
     *
     * @param[in] thiz The media
     * @param[in] control The subtitle control to operate
     */
    void (*setSubtitle)(struct itk_display_t *thiz, itk_control_t control);

    /**
     * Sets a planes's output rectangles
     *
     * Two rectangles are specified in the call. Decode is the rectangle where the video
     * or image being presented should be scaled and positioned. View is the area of 
     * the display that should be masked for presentation. Anywhere outside the view rectangle 
     * must be transparent so that the still and background planes behind the video plane show
     * through. The view rectangle is filled with black (r = g = b = 0) anywhere that the
     * decode rectangle does not show.
     *
     * @param[in] thiz   The media
     * @param[in] plane  Which plane to change the display window of.  Can be set to either the 
     *                   still picture or video plane.
     * @param[in] decode A pointer to the decode area rectangle
     * @param[in] view   A pointer to the viewable area rectangle
     */
    void (*setDisplayWindow)(struct itk_display_t *thiz, 
                             itk_display_plane_t plane, 
                             const itk_rect_t *decode, 
                             const itk_rect_t *view);

    /**
     * Maps a point on the video presented in a plane to its logical co-ordinate. 
     *
     * The video point is on the input video frame. It will be transformed by a combination
     * of the following factors:
     * - the DFC being performed on the video
     * - the scaling factor of the video
     * - the decode position of the video
     *
     * @note Support is only required for video presentation (therefore only the video
     * plane, not the still image plane).
     *
     * @param[in] thiz The media
     * @param[in] videoPoint A pointer to a co-ordinate value on the source video frame
     * @param[out] outputPoint A pointer to a co-ordinate to set with the logical co-ordinate
     */
    void (*getDisplayPoint)(struct itk_display_t *thiz,
                            const itk_point_t *videoPoint, 
                            itk_point_t *outputPoint);

    /**
     * Sets the player output volume.
     *
     * The level has the following values:
     * - 0 means leave the volume unchanged
     * - <-256 means mute
     * - >0 means louder than current
     * - <0 means quiet than current (may be implemented as mute)
     *
     * @param[in] thiz The media
     * @param[in] level The volume to set
     */
    void (*setVolume)(struct itk_display_t *thiz, itk_int32_t level);

    /**
     * Returns an object that can be used to present an I-frame image on the
     * video or still planes.
     *
     * @see image
     *
     * @warning The parameter content is transitory and can not be assumed to be
     * valid on return from this call. An implementation that wishes to keep this
     * source data will need to make a local copy of the data.
     *
     * @param[in] thiz The display
     * @param[in] format The image data encoded format
     * @param[in] targetPlane The plane this image is to be displayed on
     * @param[in] content A pointer to a buffer that holds the content to present
     * @param[in] contentSize The number of bytes of content in the buffer
     *
     * @return NULL if the image can not be created
     * @return An image for the content
     */
    itk_image_t *(*newImage)(struct itk_display_t *thiz,
                             itk_image_format_t format,
                             itk_display_plane_t targetPlane,
                             const void *content, 
                             size_t contentSize);

    /**
     * Returns an object that can be used to present an audio clip.
     *
     * @see audioclip
     *
     * @note Unlike struct itk_display_t::newImage(), the content buffer referenced
     * in the call remains valid for the lifetime of the itk_audioclip_t (i.e.
     * until it is released). This means that the host does not need to make
     * a local copy of the audio sample (although it is free to do so if this
     * is required).
     *
     * @param[in] thiz The display
     * @param[in] content A pointer to a buffer that holds the content to present
     * @param[in] contentSize The number of bytes of content in the buffer
     * @param[in] presentationCount The number of times to present the sample, 0 
     *            indicates that the sample should be presented continuously until
     *            it is stopped with itk_audioclip_t::stop().
     * @param[in] callback A pointer to a callback function to be invoked when
     *            playback begins or the final presentation is made
     * @param[in] callbackContext Context data to send to the callback when it is invoked
     *
     * @return NULL if the media player can not be created
     * @return An audioclip for the content
     */
    itk_audioclip_t *(*newAudioclip)(struct itk_display_t *thiz,
                                     const void *content, 
                                     size_t contentSize,
                                     itk_int32_t presentationCount,
                                     itk_audioclip_callback_t callback, 
                                     void *callbackContext);

    /**
     * Returns an object that can be used to control AVStream presentation for
     * content sourced and presented by the host.
     *
     * @see avstream
     *
     * @param[in] thiz The display
     * @param[in] reference A content reference string.
     * @param[in] presentationCount The number of times to present the stream. A value
     *            of 0 indicates that the sample should be presented continuously until
     *            it is stopped with itk_avstream_t::stop().
     * @param[in] bufferPriority The priority with which the stream content should
     *            be buffered, primary streams being buffered first.  
     *            Applicable only for IC streams.
     * @param[in] callback A pointer to a callback function
     * @param[in] callbackContext Context data to send to the callback when it is invoked
     *     
     * @return NULL if the AVStream can not be created
     * @return An AVStream for the content
     *
     * @note The callback function may be NULL.
     */
    itk_avstream_t *(*newAvstream)(struct itk_display_t *thiz,
                                   const char *reference,
                                   itk_int32_t presentationCount,
                                   itk_media_buffer_priority_t bufferPriority,
                                   itk_avstream_callback_t callback, 
                                   void *callbackContext);

    /**
     * Gets a graphics pipeline from the display.
     *
     * @param[in] thiz The display
     *
     * @return A handle to the pipeline on success, NULL otherwise.
     *
     * Note that if the display cannot provide a graphics pipeline, clients
     * will ask instead for a display framebuffer using
     * struct itk_display_t::getFrameBuffer(). The pipeline is preferred since it can
     * take advantage of hardware capabilities.
     */
    itk_graphics_pipeline_t *(*getPipeline)(struct itk_display_t *thiz);

    /**
     * Gets a frame buffer from the display.
     *
     * @param[in] thiz The display
     *
     * @return A handle to the frame buffer on success, NULL otherwise.
     */
    itk_dfb_t *(*getFrameBuffer)(struct itk_display_t *thiz);

    /**
     * Gets the presentation state of subtitles.  If the user has selected to
     * to display subtitles and the subtitle data is being received then the 
     * subtitles are considered to be "present".
     * 
     * @param[in] thiz The display
     *
     * @return ITK_PRESENT If subtitles are being displayed.
     * @return ITK_NOT_PRESENT If subtitles are not being displayed.
     *
     */
    itk_present_t (*getSubtitlePresentationState)(struct itk_display_t *thiz);

    /**
     * Creates an AVStream object which, when played, will play the A/V content
     * using the host's native UI.
     * 
     * All AVStreams created by this method are presented using the native UI.
     * The reference to a native AVStream can be an IP stream or a DVR recording.
     * Native AVStreams are preloaded in the same manner as 'normal' AVStreams
     * but can return the extended error codes as defined in itk_preload_error_t.
     * Only the default (-1) components can be selected in native AVStreams.
     * Native playout is activated with itk_avstream_t::play() and stopped with 
     * itk_avstream_t::stop().
     * The host need only support a single native AVStream object at any one time.
     * 
     * @param[in] thiz The display
     * @param[in] reference A content reference string
     * @param[in] name A name to display for the content (e.g. when the viewer presses INFO)
     * @param[in] description A brief description of the content
     * @param[in] resume 0 = start at the beginning, 1 = resume from last point played
     * @param[in] guidance 0 = no guidance given, 1 = suitable for all, 2 = restricted guidance
     * @param[in] callback A callback function to send status updates during the playout
     * @param[in] callbackContext Context to send to the callback
     *
     * @return an AVStream object if successful
     * @return NULL if a native AVStream cannot be created
     * @note returning an AVStream object from this function does not indicate the host's 
     * ability to play out the content.
     */
    itk_avstream_t *(*newNativeAvstream)(struct itk_display_t const *thiz,
                                         const char *reference,
                                         const char *name,
                                         const char *description,
                                         itk_int8_t resume,
                                         itk_int8_t guidance,
                                         itk_avstream_callback_t callback, 
                                         void *callbackContext);

    /**
     * Verify that MPEG decoder is available for MHEG application.
     *
     * An MHEG application calls this function to request access to the MPEG decoder.
     * Applications will only control audio/video or use the decoder for presentation of
     * I-frames after calling this function.
     * 
     * @note This function is required for CI+ profile v1.2 and later.
     *
     * @param[in] thiz      The display
     * @param[in] request   ITK_ENABLE = request decoder; ITK_DISABLE = release decoder
     *
     * @return ITK_PRESENT If MPEG decoder is not used by another application environment, e.g. MHP.
     * @return ITK_NOT_PRESENT If MPEG decoder is not available for MHEG application,
     *         either because a request operation failed or an release operation was successful.
     */
    itk_present_t (*requestMPEGDecoder)(struct itk_display_t *thiz, itk_control_t request);

    /**
     * Inform host that MHEG has released control of the graphics plane.
     *
     * A CI+ MHEG application calls this function to inform the host that it has suspended
     * or restarted use of the graphics plane. While suspended, the host is then free to use
     * the graphics plane for other purposes, such as subtitle display, without terminating
     * the mheg applications. This function is intended for hosts that cannot display mheg
     * and subtitles at the same time. If the platform is capable of displaying mheg and
     * subtitles simultaneously, this function should be ignored.
     * 
     * @note This function is required for CI+ profile v1.3 and later.
     *
     * @param[in] thiz      The display
     * @param[in] request   ITK_ENABLE = graphics plane is released for host use.
     *                      ITK_DISABLE = graphics plane is reserved for mheg use.
     */
    void (*releaseGraphicsPlane)(struct itk_display_t *thiz, itk_control_t request);
} itk_display_t;

/**
 * @}
 */
#endif
