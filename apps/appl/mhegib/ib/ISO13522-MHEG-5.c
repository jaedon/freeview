/*
 * This file was automatically generated by external script. Do not edit directly!
 */

#include "ISO13522-MHEG-5.h"
#include "MHEGEngine.h"
#include "rtti.h"
#include "RootClass.h"

int
der_decode_ExternalReference(FILE *der, ExternalReference *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ExternalReference>\n");
#endif

	VK_memset(type, 0x00, sizeof(ExternalReference));

	/* SEQUENCE */
	/* group_identifier */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ExternalReference");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 4))
		return der_error("ExternalReference: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_OctetString(der, &type->group_identifier, tag.length);
	if(sublen < 0)
		return der_error("ExternalReference");
	left -= sublen;

	/* object_number */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ExternalReference");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2))
		return der_error("ExternalReference: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_Integer(der, (int *) &type->object_number, tag.length);
	if(sublen < 0)
		return der_error("ExternalReference");
	left -= sublen;

	if(left != 0)
		return der_error("ExternalReference: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ExternalReference>\n");
#endif

	return length;
}

void
free_ExternalReference(ExternalReference *type)
{
	free_OctetString(&type->group_identifier);

	return;
}

int
der_decode_ObjectReference(FILE *der, ObjectReference *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ObjectReference>\n");
#endif

	VK_memset(type, 0x00, sizeof(ObjectReference));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ObjectReference");
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	{
		/* internal_reference */
		left -= sublen;
		type->choice = ObjectReference_internal_reference;
		sublen = der_decode_Integer(der, (int *) &type->u.internal_reference, tag.length);
		if(sublen < 0)
			return der_error("ObjectReference");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)
	{
		/* external_reference */
		left -= sublen;
		type->choice = ObjectReference_external_reference;
		sublen = der_decode_ExternalReference(der, &type->u.external_reference, tag.length);
		if(sublen < 0)
			return der_error("ObjectReference");
		left -= sublen;
	}
	else
		return der_error("ObjectReference: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("ObjectReference: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ObjectReference>\n");
#endif

	return length;
}

void
free_ObjectReference(ObjectReference *type)
{
	switch(type->choice)
	{
	case ObjectReference_internal_reference:
		break;

	case ObjectReference_external_reference:
		free_ExternalReference(&type->u.external_reference);
		break;

	default:
		der_error("free_ObjectReference: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_RootClass(FILE *der, RootClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<RootClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(RootClass));

	sublen = der_decode_ObjectReference(der, &type->ObjectReference, length);
	if(sublen < 0)
		return der_error("RootClass");
	left -= sublen;

	if(left != 0)
		return der_error("RootClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</RootClass>\n");
#endif

	RootClass_registerObject(type);

	return length;
}

void
free_RootClass(RootClass *type)
{
	free_ObjectReference(&type->ObjectReference);

	RootClass_unregisterObject(type);

	return;
}

int
der_decode_ContentReference(FILE *der, ContentReference *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<ContentReference>\n");
#endif

	VK_memset(type, 0x00, sizeof(ContentReference));

	sublen = der_decode_OctetString(der, (OctetString *) type, length);
	if(sublen < 0)
		return der_error("ContentReference");
	left -= sublen;

	if(left != 0)
		return der_error("ContentReference: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ContentReference>\n");
#endif

	return length;
}

void
free_ContentReference(ContentReference *type)
{
	free_OctetString((OctetString *) type);

	return;
}

int
der_decode_ReferencedContent(FILE *der, ReferencedContent *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ReferencedContent>\n");
#endif

	VK_memset(type, 0x00, sizeof(ReferencedContent));

	/* DEFAULT values */
	type->content_cache_priority = 127;

	/* SEQUENCE */
	/* content_reference */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ReferencedContent");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 4))
		return der_error("ReferencedContent: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_ContentReference(der, &type->content_reference, tag.length);
	if(sublen < 0)
		return der_error("ReferencedContent");
	left -= sublen;

	/* content_size OPTIONAL */
	if(left > 0)
	{
		sublen = der_peek_Tag(der, &tag);
		if(sublen < 0)
			return der_error("ReferencedContent");
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 60)
		{
			fseek(der, sublen, SEEK_CUR);
			left -= sublen;
			type->have_content_size = true;
			sublen = der_decode_Integer(der, (int *) &type->content_size, tag.length);
			if(sublen < 0)
				return der_error("ReferencedContent");
			left -= sublen;
		}
	}

	/* content_cache_priority DEFAULT 127 */
	if(left > 0)
	{
		sublen = der_peek_Tag(der, &tag);
		if(sublen < 0)
			return der_error("ReferencedContent");
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 61)
		{
			fseek(der, sublen, SEEK_CUR);
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->content_cache_priority, tag.length);
			if(sublen < 0)
				return der_error("ReferencedContent");
			left -= sublen;
		}
	}

	if(left != 0)
		return der_error("ReferencedContent: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ReferencedContent>\n");
#endif

	return length;
}

void
free_ReferencedContent(ReferencedContent *type)
{
	free_ContentReference(&type->content_reference);

	return;
}

int
der_decode_ContentBody(FILE *der, ContentBody *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ContentBody>\n");
#endif

	VK_memset(type, 0x00, sizeof(ContentBody));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ContentBody");
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	{
		/* included_content */
		left -= sublen;
		type->choice = ContentBody_included_content;
		sublen = der_decode_OctetString(der, &type->u.included_content, tag.length);
		if(sublen < 0)
			return der_error("ContentBody");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)
	{
		/* referenced_content */
		left -= sublen;
		type->choice = ContentBody_referenced_content;
		sublen = der_decode_ReferencedContent(der, &type->u.referenced_content, tag.length);
		if(sublen < 0)
			return der_error("ContentBody");
		left -= sublen;
	}
	else
		return der_error("ContentBody: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("ContentBody: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ContentBody>\n");
#endif

	return length;
}

void
free_ContentBody(ContentBody *type)
{
	switch(type->choice)
	{
	case ContentBody_included_content:
		free_OctetString(&type->u.included_content);
		break;

	case ContentBody_referenced_content:
		free_ReferencedContent(&type->u.referenced_content);
		break;

	default:
		der_error("free_ContentBody: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_IngredientClass(FILE *der, IngredientClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<IngredientClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(IngredientClass));

	/* DEFAULT values */
	type->initially_active = true;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("IngredientClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("IngredientClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("IngredientClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("IngredientClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("IngredientClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("IngredientClass");
			left -= sublen;
		}
		else
			return der_error("IngredientClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("IngredientClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</IngredientClass>\n");
#endif

	return length;
}

void
free_IngredientClass(IngredientClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	return;
}

int
der_decode_PresentableClass(FILE *der, PresentableClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<PresentableClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(PresentableClass));

	sublen = der_decode_IngredientClass(der, (IngredientClass *) type, length);
	if(sublen < 0)
		return der_error("PresentableClass");
	left -= sublen;

	if(left != 0)
		return der_error("PresentableClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</PresentableClass>\n");
#endif

	return length;
}

void
free_PresentableClass(PresentableClass *type)
{
	free_IngredientClass((IngredientClass *) type);

	return;
}

int
der_decode_StandardIdentifier(FILE *der, StandardIdentifier *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<StandardIdentifier>\n");
#endif

	VK_memset(type, 0x00, sizeof(StandardIdentifier));

	/* SEQUENCE */
	/* joint_iso_itu_t */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("StandardIdentifier");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2))
		return der_error("StandardIdentifier: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_Integer(der, (int *) &type->joint_iso_itu_t, tag.length);
	if(sublen < 0)
		return der_error("StandardIdentifier");
	left -= sublen;

	/* mheg */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("StandardIdentifier");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2))
		return der_error("StandardIdentifier: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_Integer(der, (int *) &type->mheg, tag.length);
	if(sublen < 0)
		return der_error("StandardIdentifier");
	left -= sublen;

	if(left != 0)
		return der_error("StandardIdentifier: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</StandardIdentifier>\n");
#endif

	return length;
}

void
free_StandardIdentifier(StandardIdentifier *type)
{
	return;
}

int
der_decode_IndirectReference(FILE *der, IndirectReference *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<IndirectReference>\n");
#endif

	VK_memset(type, 0x00, sizeof(IndirectReference));

	sublen = der_decode_ObjectReference(der, (ObjectReference *) type, length);
	if(sublen < 0)
		return der_error("IndirectReference");
	left -= sublen;

	if(left != 0)
		return der_error("IndirectReference: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</IndirectReference>\n");
#endif

	return length;
}

void
free_IndirectReference(IndirectReference *type)
{
	free_ObjectReference((ObjectReference *) type);

	return;
}

int
der_decode_GenericObjectReference(FILE *der, GenericObjectReference *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GenericObjectReference>\n");
#endif

	VK_memset(type, 0x00, sizeof(GenericObjectReference));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GenericObjectReference");
	if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	{
		/* direct_reference */
		fseek(der, -sublen, SEEK_CUR);
		type->choice = GenericObjectReference_direct_reference;
		sublen = der_decode_ObjectReference(der, &type->u.direct_reference, length);
		if(sublen < 0)
			return der_error("GenericObjectReference");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 236)
	{
		/* indirect_reference */
		left -= sublen;
		type->choice = GenericObjectReference_indirect_reference;
		sublen = der_decode_IndirectReference(der, &type->u.indirect_reference, tag.length);
		if(sublen < 0)
			return der_error("GenericObjectReference");
		left -= sublen;
	}
	else
		return der_error("GenericObjectReference: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("GenericObjectReference: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GenericObjectReference>\n");
#endif

	return length;
}

void
free_GenericObjectReference(GenericObjectReference *type)
{
	switch(type->choice)
	{
	case GenericObjectReference_direct_reference:
		free_ObjectReference(&type->u.direct_reference);
		break;

	case GenericObjectReference_indirect_reference:
		free_IndirectReference(&type->u.indirect_reference);
		break;

	default:
		der_error("free_GenericObjectReference: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_GenericInteger(FILE *der, GenericInteger *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GenericInteger>\n");
#endif

	VK_memset(type, 0x00, sizeof(GenericInteger));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GenericInteger");
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	{
		/* integer */
		left -= sublen;
		type->choice = GenericInteger_integer;
		sublen = der_decode_Integer(der, (int *) &type->u.integer, tag.length);
		if(sublen < 0)
			return der_error("GenericInteger");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 236)
	{
		/* indirect_reference */
		left -= sublen;
		type->choice = GenericInteger_indirect_reference;
		sublen = der_decode_IndirectReference(der, &type->u.indirect_reference, tag.length);
		if(sublen < 0)
			return der_error("GenericInteger");
		left -= sublen;
	}
	else
		return der_error("GenericInteger: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("GenericInteger: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GenericInteger>\n");
#endif

	return length;
}

void
free_GenericInteger(GenericInteger *type)
{
	switch(type->choice)
	{
	case GenericInteger_integer:
		break;

	case GenericInteger_indirect_reference:
		free_IndirectReference(&type->u.indirect_reference);
		break;

	default:
		der_error("free_GenericInteger: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_Add(FILE *der, Add *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<Add>\n");
#endif

	VK_memset(type, 0x00, sizeof(Add));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Add");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Add: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("Add");
	left -= sublen;

	/* value */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Add");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Add: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->value, sublen + tag.length);
	if(sublen < 0)
		return der_error("Add");
	left -= sublen;

	if(left != 0)
		return der_error("Add: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Add>\n");
#endif

	return length;
}

void
free_Add(Add *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->value);

	return;
}

int
der_decode_AddItem(FILE *der, AddItem *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<AddItem>\n");
#endif

	VK_memset(type, 0x00, sizeof(AddItem));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("AddItem");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("AddItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("AddItem");
	left -= sublen;

	/* item_index */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("AddItem");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("AddItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->item_index, sublen + tag.length);
	if(sublen < 0)
		return der_error("AddItem");
	left -= sublen;

	/* visible_reference */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("AddItem");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("AddItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->visible_reference, sublen + tag.length);
	if(sublen < 0)
		return der_error("AddItem");
	left -= sublen;

	if(left != 0)
		return der_error("AddItem: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</AddItem>\n");
#endif

	return length;
}

void
free_AddItem(AddItem *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->item_index);

	free_GenericObjectReference(&type->visible_reference);

	return;
}

int
der_decode_GenericOctetString(FILE *der, GenericOctetString *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GenericOctetString>\n");
#endif

	VK_memset(type, 0x00, sizeof(GenericOctetString));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GenericOctetString");
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	{
		/* octetstring */
		left -= sublen;
		type->choice = GenericOctetString_octetstring;
		sublen = der_decode_OctetString(der, &type->u.octetstring, tag.length);
		if(sublen < 0)
			return der_error("GenericOctetString");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 236)
	{
		/* indirect_reference */
		left -= sublen;
		type->choice = GenericOctetString_indirect_reference;
		sublen = der_decode_IndirectReference(der, &type->u.indirect_reference, tag.length);
		if(sublen < 0)
			return der_error("GenericOctetString");
		left -= sublen;
	}
	else
		return der_error("GenericOctetString: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("GenericOctetString: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GenericOctetString>\n");
#endif

	return length;
}

void
free_GenericOctetString(GenericOctetString *type)
{
	switch(type->choice)
	{
	case GenericOctetString_octetstring:
		free_OctetString(&type->u.octetstring);
		break;

	case GenericOctetString_indirect_reference:
		free_IndirectReference(&type->u.indirect_reference);
		break;

	default:
		der_error("free_GenericOctetString: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_Append(FILE *der, Append *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<Append>\n");
#endif

	VK_memset(type, 0x00, sizeof(Append));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Append");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Append: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("Append");
	left -= sublen;

	/* append_value */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Append");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Append: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericOctetString(der, &type->append_value, sublen + tag.length);
	if(sublen < 0)
		return der_error("Append");
	left -= sublen;

	if(left != 0)
		return der_error("Append: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Append>\n");
#endif

	return length;
}

void
free_Append(Append *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericOctetString(&type->append_value);

	return;
}

int
der_decode_GenericBoolean(FILE *der, GenericBoolean *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GenericBoolean>\n");
#endif

	VK_memset(type, 0x00, sizeof(GenericBoolean));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GenericBoolean");
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 1)
	{
		/* boolean */
		left -= sublen;
		type->choice = GenericBoolean_boolean;
		sublen = der_decode_Boolean(der, &type->u.boolean, tag.length);
		if(sublen < 0)
			return der_error("GenericBoolean");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 236)
	{
		/* indirect_reference */
		left -= sublen;
		type->choice = GenericBoolean_indirect_reference;
		sublen = der_decode_IndirectReference(der, &type->u.indirect_reference, tag.length);
		if(sublen < 0)
			return der_error("GenericBoolean");
		left -= sublen;
	}
	else
		return der_error("GenericBoolean: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("GenericBoolean: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GenericBoolean>\n");
#endif

	return length;
}

void
free_GenericBoolean(GenericBoolean *type)
{
	switch(type->choice)
	{
	case GenericBoolean_boolean:
		break;

	case GenericBoolean_indirect_reference:
		free_IndirectReference(&type->u.indirect_reference);
		break;

	default:
		der_error("free_GenericBoolean: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_GenericContentReference(FILE *der, GenericContentReference *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GenericContentReference>\n");
#endif

	VK_memset(type, 0x00, sizeof(GenericContentReference));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GenericContentReference");
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 69)
	{
		/* content_reference */
		left -= sublen;
		type->choice = GenericContentReference_content_reference;
		sublen = der_decode_ContentReference(der, &type->u.content_reference, tag.length);
		if(sublen < 0)
			return der_error("GenericContentReference");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 236)
	{
		/* indirect_reference */
		left -= sublen;
		type->choice = GenericContentReference_indirect_reference;
		sublen = der_decode_IndirectReference(der, &type->u.indirect_reference, tag.length);
		if(sublen < 0)
			return der_error("GenericContentReference");
		left -= sublen;
	}
	else
		return der_error("GenericContentReference: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("GenericContentReference: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GenericContentReference>\n");
#endif

	return length;
}

void
free_GenericContentReference(GenericContentReference *type)
{
	switch(type->choice)
	{
	case GenericContentReference_content_reference:
		free_ContentReference(&type->u.content_reference);
		break;

	case GenericContentReference_indirect_reference:
		free_IndirectReference(&type->u.indirect_reference);
		break;

	default:
		der_error("free_GenericContentReference: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_Parameter(FILE *der, Parameter *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<Parameter>\n");
#endif

	VK_memset(type, 0x00, sizeof(Parameter));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Parameter");
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 225)
	{
		/* new_generic_boolean */
		left -= sublen;
		type->choice = Parameter_new_generic_boolean;
		sublen = der_decode_GenericBoolean(der, &type->u.new_generic_boolean, tag.length);
		if(sublen < 0)
			return der_error("Parameter");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 226)
	{
		/* new_generic_integer */
		left -= sublen;
		type->choice = Parameter_new_generic_integer;
		sublen = der_decode_GenericInteger(der, &type->u.new_generic_integer, tag.length);
		if(sublen < 0)
			return der_error("Parameter");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 227)
	{
		/* new_generic_octetstring */
		left -= sublen;
		type->choice = Parameter_new_generic_octetstring;
		sublen = der_decode_GenericOctetString(der, &type->u.new_generic_octetstring, tag.length);
		if(sublen < 0)
			return der_error("Parameter");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 228)
	{
		/* new_generic_object_reference */
		left -= sublen;
		type->choice = Parameter_new_generic_object_reference;
		sublen = der_decode_GenericObjectReference(der, &type->u.new_generic_object_reference, tag.length);
		if(sublen < 0)
			return der_error("Parameter");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 229)
	{
		/* new_generic_content_reference */
		left -= sublen;
		type->choice = Parameter_new_generic_content_reference;
		sublen = der_decode_GenericContentReference(der, &type->u.new_generic_content_reference, tag.length);
		if(sublen < 0)
			return der_error("Parameter");
		left -= sublen;
	}
	else
		return der_error("Parameter: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("Parameter: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Parameter>\n");
#endif

	return length;
}

void
free_Parameter(Parameter *type)
{
	switch(type->choice)
	{
	case Parameter_new_generic_boolean:
		free_GenericBoolean(&type->u.new_generic_boolean);
		break;

	case Parameter_new_generic_integer:
		free_GenericInteger(&type->u.new_generic_integer);
		break;

	case Parameter_new_generic_octetstring:
		free_GenericOctetString(&type->u.new_generic_octetstring);
		break;

	case Parameter_new_generic_object_reference:
		free_GenericObjectReference(&type->u.new_generic_object_reference);
		break;

	case Parameter_new_generic_content_reference:
		free_GenericContentReference(&type->u.new_generic_content_reference);
		break;

	default:
		der_error("free_Parameter: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_Call(FILE *der, Call *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;
	der_tag seqtag;

#if (DER_VERBOSE)
	VK_Print("<Call>\n");
#endif

	VK_memset(type, 0x00, sizeof(Call));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Call");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Call: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("Call");
	left -= sublen;

	/* call_succeeded */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Call");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("Call: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->call_succeeded, sublen + tag.length);
	if(sublen < 0)
		return der_error("Call");
	left -= sublen;

	/* parameters OPTIONAL */
	if(left > 0)
	{
		/* SEQUENCE OF Parameter */
		sublen = der_decode_Tag(der, &seqtag);
		if(sublen < 0)
			return der_error("Call");
		if(seqtag.class != DER_CLASS_UNIVERSAL || seqtag.number != 16)
			return der_error("Call: unexpected tag %u", seqtag.number);
		left -= sublen + seqtag.length;
		while(seqtag.length > 0)
		{
			LIST_TYPE(Parameter) *new_item;
			sublen = der_decode_Tag(der, &tag);
			if(sublen < 0)
				return der_error("Call");
			if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 225)
			|| (tag.class == DER_CLASS_CONTEXT && tag.number == 226)
			|| (tag.class == DER_CLASS_CONTEXT && tag.number == 227)
			|| (tag.class == DER_CLASS_CONTEXT && tag.number == 228)
			|| (tag.class == DER_CLASS_CONTEXT && tag.number == 229)))
				return der_error("Call: unexpected tag %u", tag.number);
			fseek(der, -sublen, SEEK_CUR);
			if((new_item = der_alloc(sizeof(LIST_TYPE(Parameter)))) == NULL)
				return der_error("Call: out of memory");
			LIST_APPEND(&type->parameters, new_item);
			sublen = der_decode_Parameter(der, &new_item->item, sublen + tag.length);
			if(sublen < 0)
				return der_error("Call");
			if(sublen > seqtag.length)
				return der_error("Call: %u bytes left", seqtag.length);
			seqtag.length -= sublen;
		}
	}

	if(left != 0)
		return der_error("Call: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Call>\n");
#endif

	return length;
}

void
free_Call(Call *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->call_succeeded);

	LIST_FREE_ITEMS(&type->parameters, Parameter, free_Parameter, der_free);

	return;
}

int
der_decode_CallActionSlot(FILE *der, CallActionSlot *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<CallActionSlot>\n");
#endif

	VK_memset(type, 0x00, sizeof(CallActionSlot));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("CallActionSlot");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("CallActionSlot: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("CallActionSlot");
	left -= sublen;

	/* index */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("CallActionSlot");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("CallActionSlot: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->index, sublen + tag.length);
	if(sublen < 0)
		return der_error("CallActionSlot");
	left -= sublen;

	if(left != 0)
		return der_error("CallActionSlot: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</CallActionSlot>\n");
#endif

	return length;
}

void
free_CallActionSlot(CallActionSlot *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->index);

	return;
}

int
der_decode_Clone(FILE *der, Clone *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<Clone>\n");
#endif

	VK_memset(type, 0x00, sizeof(Clone));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Clone");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Clone: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("Clone");
	left -= sublen;

	/* clone_ref_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Clone");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("Clone: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->clone_ref_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("Clone");
	left -= sublen;

	if(left != 0)
		return der_error("Clone: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Clone>\n");
#endif

	return length;
}

void
free_Clone(Clone *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->clone_ref_var);

	return;
}

int
der_decode_CloseConnection(FILE *der, CloseConnection *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<CloseConnection>\n");
#endif

	VK_memset(type, 0x00, sizeof(CloseConnection));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("CloseConnection");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("CloseConnection: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("CloseConnection");
	left -= sublen;

	/* connection_tag */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("CloseConnection");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("CloseConnection: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->connection_tag, sublen + tag.length);
	if(sublen < 0)
		return der_error("CloseConnection");
	left -= sublen;

	if(left != 0)
		return der_error("CloseConnection: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</CloseConnection>\n");
#endif

	return length;
}

void
free_CloseConnection(CloseConnection *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->connection_tag);

	return;
}

int
der_decode_DelItem(FILE *der, DelItem *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<DelItem>\n");
#endif

	VK_memset(type, 0x00, sizeof(DelItem));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DelItem");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DelItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("DelItem");
	left -= sublen;

	/* visible_reference */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DelItem");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DelItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->visible_reference, sublen + tag.length);
	if(sublen < 0)
		return der_error("DelItem");
	left -= sublen;

	if(left != 0)
		return der_error("DelItem: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</DelItem>\n");
#endif

	return length;
}

void
free_DelItem(DelItem *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericObjectReference(&type->visible_reference);

	return;
}

int
der_decode_DeselectItem(FILE *der, DeselectItem *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<DeselectItem>\n");
#endif

	VK_memset(type, 0x00, sizeof(DeselectItem));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DeselectItem");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DeselectItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("DeselectItem");
	left -= sublen;

	/* item_index */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DeselectItem");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DeselectItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->item_index, sublen + tag.length);
	if(sublen < 0)
		return der_error("DeselectItem");
	left -= sublen;

	if(left != 0)
		return der_error("DeselectItem: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</DeselectItem>\n");
#endif

	return length;
}

void
free_DeselectItem(DeselectItem *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->item_index);

	return;
}

int
der_decode_Divide(FILE *der, Divide *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<Divide>\n");
#endif

	VK_memset(type, 0x00, sizeof(Divide));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Divide");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Divide: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("Divide");
	left -= sublen;

	/* value */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Divide");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Divide: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->value, sublen + tag.length);
	if(sublen < 0)
		return der_error("Divide");
	left -= sublen;

	if(left != 0)
		return der_error("Divide: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Divide>\n");
#endif

	return length;
}

void
free_Divide(Divide *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->value);

	return;
}

int
der_decode_DrawArc(FILE *der, DrawArc *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<DrawArc>\n");
#endif

	VK_memset(type, 0x00, sizeof(DrawArc));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawArc");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawArc: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawArc");
	left -= sublen;

	/* x */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawArc");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawArc: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->x, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawArc");
	left -= sublen;

	/* y */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawArc");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawArc: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->y, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawArc");
	left -= sublen;

	/* ellipse_width */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawArc");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawArc: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->ellipse_width, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawArc");
	left -= sublen;

	/* ellipse_height */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawArc");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawArc: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->ellipse_height, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawArc");
	left -= sublen;

	/* start_angle */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawArc");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawArc: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->start_angle, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawArc");
	left -= sublen;

	/* arc_angle */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawArc");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawArc: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->arc_angle, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawArc");
	left -= sublen;

	if(left != 0)
		return der_error("DrawArc: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</DrawArc>\n");
#endif

	return length;
}

void
free_DrawArc(DrawArc *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->x);

	free_GenericInteger(&type->y);

	free_GenericInteger(&type->ellipse_width);

	free_GenericInteger(&type->ellipse_height);

	free_GenericInteger(&type->start_angle);

	free_GenericInteger(&type->arc_angle);

	return;
}

int
der_decode_DrawLine(FILE *der, DrawLine *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<DrawLine>\n");
#endif

	VK_memset(type, 0x00, sizeof(DrawLine));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawLine");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawLine: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawLine");
	left -= sublen;

	/* x1 */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawLine");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawLine: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->x1, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawLine");
	left -= sublen;

	/* y1 */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawLine");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawLine: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->y1, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawLine");
	left -= sublen;

	/* x2 */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawLine");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawLine: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->x2, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawLine");
	left -= sublen;

	/* y2 */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawLine");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawLine: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->y2, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawLine");
	left -= sublen;

	if(left != 0)
		return der_error("DrawLine: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</DrawLine>\n");
#endif

	return length;
}

void
free_DrawLine(DrawLine *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->x1);

	free_GenericInteger(&type->y1);

	free_GenericInteger(&type->x2);

	free_GenericInteger(&type->y2);

	return;
}

int
der_decode_DrawOval(FILE *der, DrawOval *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<DrawOval>\n");
#endif

	VK_memset(type, 0x00, sizeof(DrawOval));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawOval");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawOval: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawOval");
	left -= sublen;

	/* x */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawOval");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawOval: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->x, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawOval");
	left -= sublen;

	/* y */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawOval");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawOval: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->y, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawOval");
	left -= sublen;

	/* ellipse_width */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawOval");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawOval: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->ellipse_width, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawOval");
	left -= sublen;

	/* ellipse_height */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawOval");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawOval: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->ellipse_height, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawOval");
	left -= sublen;

	if(left != 0)
		return der_error("DrawOval: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</DrawOval>\n");
#endif

	return length;
}

void
free_DrawOval(DrawOval *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->x);

	free_GenericInteger(&type->y);

	free_GenericInteger(&type->ellipse_width);

	free_GenericInteger(&type->ellipse_height);

	return;
}

int
der_decode_Point(FILE *der, Point *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<Point>\n");
#endif

	VK_memset(type, 0x00, sizeof(Point));

	/* SEQUENCE */
	/* x */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Point");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Point: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->x, sublen + tag.length);
	if(sublen < 0)
		return der_error("Point");
	left -= sublen;

	/* y */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Point");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Point: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->y, sublen + tag.length);
	if(sublen < 0)
		return der_error("Point");
	left -= sublen;

	if(left != 0)
		return der_error("Point: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Point>\n");
#endif

	return length;
}

void
free_Point(Point *type)
{
	free_GenericInteger(&type->x);

	free_GenericInteger(&type->y);

	return;
}

int
der_decode_DrawPolygon(FILE *der, DrawPolygon *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;
	der_tag seqtag;

#if (DER_VERBOSE)
	VK_Print("<DrawPolygon>\n");
#endif

	VK_memset(type, 0x00, sizeof(DrawPolygon));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawPolygon");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawPolygon: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawPolygon");
	left -= sublen;

	/* pointlist */
	/* SEQUENCE OF Point */
	sublen = der_decode_Tag(der, &seqtag);
	if(sublen < 0)
		return der_error("DrawPolygon");
	if(seqtag.class != DER_CLASS_UNIVERSAL || seqtag.number != 16)
		return der_error("DrawPolygon: unexpected tag %u", seqtag.number);
	left -= sublen + seqtag.length;
	while(seqtag.length > 0)
	{
		LIST_TYPE(Point) *new_item;
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("DrawPolygon");
		if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
			return der_error("DrawPolygon: unexpected tag %u", tag.number);
		seqtag.length -= sublen;
		if((new_item = der_alloc(sizeof(LIST_TYPE(Point)))) == NULL)
			return der_error("DrawPolygon: out of memory");
		LIST_APPEND(&type->pointlist, new_item);
		sublen = der_decode_Point(der, &new_item->item, tag.length);
		if(sublen < 0)
			return der_error("DrawPolygon");
		if(sublen > seqtag.length)
			return der_error("DrawPolygon: %u bytes left", seqtag.length);
		seqtag.length -= sublen;
	}

	if(left != 0)
		return der_error("DrawPolygon: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</DrawPolygon>\n");
#endif

	return length;
}

void
free_DrawPolygon(DrawPolygon *type)
{
	free_GenericObjectReference(&type->target);

	LIST_FREE_ITEMS(&type->pointlist, Point, free_Point, der_free);

	return;
}

int
der_decode_DrawPolyline(FILE *der, DrawPolyline *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;
	der_tag seqtag;

#if (DER_VERBOSE)
	VK_Print("<DrawPolyline>\n");
#endif

	VK_memset(type, 0x00, sizeof(DrawPolyline));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawPolyline");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawPolyline: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawPolyline");
	left -= sublen;

	/* pointlist */
	/* SEQUENCE OF Point */
	sublen = der_decode_Tag(der, &seqtag);
	if(sublen < 0)
		return der_error("DrawPolyline");
	if(seqtag.class != DER_CLASS_UNIVERSAL || seqtag.number != 16)
		return der_error("DrawPolyline: unexpected tag %u", seqtag.number);
	left -= sublen + seqtag.length;
	while(seqtag.length > 0)
	{
		LIST_TYPE(Point) *new_item;
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("DrawPolyline");
		if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
			return der_error("DrawPolyline: unexpected tag %u", tag.number);
		seqtag.length -= sublen;
		if((new_item = der_alloc(sizeof(LIST_TYPE(Point)))) == NULL)
			return der_error("DrawPolyline: out of memory");
		LIST_APPEND(&type->pointlist, new_item);
		sublen = der_decode_Point(der, &new_item->item, tag.length);
		if(sublen < 0)
			return der_error("DrawPolyline");
		if(sublen > seqtag.length)
			return der_error("DrawPolyline: %u bytes left", seqtag.length);
		seqtag.length -= sublen;
	}

	if(left != 0)
		return der_error("DrawPolyline: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</DrawPolyline>\n");
#endif

	return length;
}

void
free_DrawPolyline(DrawPolyline *type)
{
	free_GenericObjectReference(&type->target);

	LIST_FREE_ITEMS(&type->pointlist, Point, free_Point, der_free);

	return;
}

int
der_decode_DrawRectangle(FILE *der, DrawRectangle *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<DrawRectangle>\n");
#endif

	VK_memset(type, 0x00, sizeof(DrawRectangle));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawRectangle");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawRectangle: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawRectangle");
	left -= sublen;

	/* x1 */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawRectangle");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawRectangle: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->x1, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawRectangle");
	left -= sublen;

	/* y1 */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawRectangle");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawRectangle: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->y1, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawRectangle");
	left -= sublen;

	/* x2 */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawRectangle");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawRectangle: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->x2, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawRectangle");
	left -= sublen;

	/* y2 */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawRectangle");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawRectangle: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->y2, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawRectangle");
	left -= sublen;

	if(left != 0)
		return der_error("DrawRectangle: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</DrawRectangle>\n");
#endif

	return length;
}

void
free_DrawRectangle(DrawRectangle *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->x1);

	free_GenericInteger(&type->y1);

	free_GenericInteger(&type->x2);

	free_GenericInteger(&type->y2);

	return;
}

int
der_decode_DrawSector(FILE *der, DrawSector *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<DrawSector>\n");
#endif

	VK_memset(type, 0x00, sizeof(DrawSector));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawSector");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawSector: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawSector");
	left -= sublen;

	/* x */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawSector");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawSector: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->x, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawSector");
	left -= sublen;

	/* y */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawSector");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawSector: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->y, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawSector");
	left -= sublen;

	/* ellipse_width */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawSector");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawSector: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->ellipse_width, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawSector");
	left -= sublen;

	/* ellipse_height */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawSector");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawSector: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->ellipse_height, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawSector");
	left -= sublen;

	/* start_angle */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawSector");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawSector: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->start_angle, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawSector");
	left -= sublen;

	/* arc_angle */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DrawSector");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("DrawSector: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->arc_angle, sublen + tag.length);
	if(sublen < 0)
		return der_error("DrawSector");
	left -= sublen;

	if(left != 0)
		return der_error("DrawSector: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</DrawSector>\n");
#endif

	return length;
}

void
free_DrawSector(DrawSector *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->x);

	free_GenericInteger(&type->y);

	free_GenericInteger(&type->ellipse_width);

	free_GenericInteger(&type->ellipse_height);

	free_GenericInteger(&type->start_angle);

	free_GenericInteger(&type->arc_angle);

	return;
}

int
der_decode_Fork(FILE *der, Fork *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;
	der_tag seqtag;

#if (DER_VERBOSE)
	VK_Print("<Fork>\n");
#endif

	VK_memset(type, 0x00, sizeof(Fork));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Fork");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Fork: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("Fork");
	left -= sublen;

	/* fork_succeeded */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Fork");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("Fork: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->fork_succeeded, sublen + tag.length);
	if(sublen < 0)
		return der_error("Fork");
	left -= sublen;

	/* parameters OPTIONAL */
	if(left > 0)
	{
		/* SEQUENCE OF Parameter */
		sublen = der_decode_Tag(der, &seqtag);
		if(sublen < 0)
			return der_error("Fork");
		if(seqtag.class != DER_CLASS_UNIVERSAL || seqtag.number != 16)
			return der_error("Fork: unexpected tag %u", seqtag.number);
		left -= sublen + seqtag.length;
		while(seqtag.length > 0)
		{
			LIST_TYPE(Parameter) *new_item;
			sublen = der_decode_Tag(der, &tag);
			if(sublen < 0)
				return der_error("Fork");
			if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 225)
			|| (tag.class == DER_CLASS_CONTEXT && tag.number == 226)
			|| (tag.class == DER_CLASS_CONTEXT && tag.number == 227)
			|| (tag.class == DER_CLASS_CONTEXT && tag.number == 228)
			|| (tag.class == DER_CLASS_CONTEXT && tag.number == 229)))
				return der_error("Fork: unexpected tag %u", tag.number);
			fseek(der, -sublen, SEEK_CUR);
			if((new_item = der_alloc(sizeof(LIST_TYPE(Parameter)))) == NULL)
				return der_error("Fork: out of memory");
			LIST_APPEND(&type->parameters, new_item);
			sublen = der_decode_Parameter(der, &new_item->item, sublen + tag.length);
			if(sublen < 0)
				return der_error("Fork");
			if(sublen > seqtag.length)
				return der_error("Fork: %u bytes left", seqtag.length);
			seqtag.length -= sublen;
		}
	}

	if(left != 0)
		return der_error("Fork: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Fork>\n");
#endif

	return length;
}

void
free_Fork(Fork *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->fork_succeeded);

	LIST_FREE_ITEMS(&type->parameters, Parameter, free_Parameter, der_free);

	return;
}

int
der_decode_GetAvailabilityStatus(FILE *der, GetAvailabilityStatus *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetAvailabilityStatus>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetAvailabilityStatus));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetAvailabilityStatus");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetAvailabilityStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetAvailabilityStatus");
	left -= sublen;

	/* availability_status_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetAvailabilityStatus");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetAvailabilityStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->availability_status_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetAvailabilityStatus");
	left -= sublen;

	if(left != 0)
		return der_error("GetAvailabilityStatus: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetAvailabilityStatus>\n");
#endif

	return length;
}

void
free_GetAvailabilityStatus(GetAvailabilityStatus *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->availability_status_var);

	return;
}

int
der_decode_GetBoxSize(FILE *der, GetBoxSize *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetBoxSize>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetBoxSize));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetBoxSize");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetBoxSize: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetBoxSize");
	left -= sublen;

	/* x_box_size_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetBoxSize");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetBoxSize: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->x_box_size_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetBoxSize");
	left -= sublen;

	/* y_box_size_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetBoxSize");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetBoxSize: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->y_box_size_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetBoxSize");
	left -= sublen;

	if(left != 0)
		return der_error("GetBoxSize: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetBoxSize>\n");
#endif

	return length;
}

void
free_GetBoxSize(GetBoxSize *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->x_box_size_var);

	free_ObjectReference(&type->y_box_size_var);

	return;
}

int
der_decode_GetCellItem(FILE *der, GetCellItem *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetCellItem>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetCellItem));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetCellItem");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetCellItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetCellItem");
	left -= sublen;

	/* cell_index */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetCellItem");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetCellItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->cell_index, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetCellItem");
	left -= sublen;

	/* item_ref_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetCellItem");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetCellItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->item_ref_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetCellItem");
	left -= sublen;

	if(left != 0)
		return der_error("GetCellItem: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetCellItem>\n");
#endif

	return length;
}

void
free_GetCellItem(GetCellItem *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->cell_index);

	free_ObjectReference(&type->item_ref_var);

	return;
}

int
der_decode_GetCursorPosition(FILE *der, GetCursorPosition *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetCursorPosition>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetCursorPosition));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetCursorPosition");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetCursorPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetCursorPosition");
	left -= sublen;

	/* x_out */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetCursorPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetCursorPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->x_out, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetCursorPosition");
	left -= sublen;

	/* y_out */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetCursorPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetCursorPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->y_out, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetCursorPosition");
	left -= sublen;

	if(left != 0)
		return der_error("GetCursorPosition: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetCursorPosition>\n");
#endif

	return length;
}

void
free_GetCursorPosition(GetCursorPosition *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->x_out);

	free_ObjectReference(&type->y_out);

	return;
}

int
der_decode_GetEngineSupport(FILE *der, GetEngineSupport *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetEngineSupport>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetEngineSupport));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetEngineSupport");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetEngineSupport: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetEngineSupport");
	left -= sublen;

	/* feature */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetEngineSupport");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetEngineSupport: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericOctetString(der, &type->feature, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetEngineSupport");
	left -= sublen;

	/* answer */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetEngineSupport");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetEngineSupport: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->answer, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetEngineSupport");
	left -= sublen;

	if(left != 0)
		return der_error("GetEngineSupport: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetEngineSupport>\n");
#endif

	return length;
}

void
free_GetEngineSupport(GetEngineSupport *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericOctetString(&type->feature);

	free_ObjectReference(&type->answer);

	return;
}

int
der_decode_GetEntryPoint(FILE *der, GetEntryPoint *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetEntryPoint>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetEntryPoint));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetEntryPoint");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetEntryPoint: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetEntryPoint");
	left -= sublen;

	/* entry_point_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetEntryPoint");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetEntryPoint: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->entry_point_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetEntryPoint");
	left -= sublen;

	if(left != 0)
		return der_error("GetEntryPoint: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetEntryPoint>\n");
#endif

	return length;
}

void
free_GetEntryPoint(GetEntryPoint *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->entry_point_var);

	return;
}

int
der_decode_GetFillColour(FILE *der, GetFillColour *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetFillColour>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetFillColour));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetFillColour");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetFillColour: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetFillColour");
	left -= sublen;

	/* fill_colour_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetFillColour");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetFillColour: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->fill_colour_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetFillColour");
	left -= sublen;

	if(left != 0)
		return der_error("GetFillColour: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetFillColour>\n");
#endif

	return length;
}

void
free_GetFillColour(GetFillColour *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->fill_colour_var);

	return;
}

int
der_decode_GetFirstItem(FILE *der, GetFirstItem *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetFirstItem>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetFirstItem));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetFirstItem");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetFirstItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetFirstItem");
	left -= sublen;

	/* first_item_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetFirstItem");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetFirstItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->first_item_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetFirstItem");
	left -= sublen;

	if(left != 0)
		return der_error("GetFirstItem: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetFirstItem>\n");
#endif

	return length;
}

void
free_GetFirstItem(GetFirstItem *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->first_item_var);

	return;
}

int
der_decode_GetHighlightStatus(FILE *der, GetHighlightStatus *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetHighlightStatus>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetHighlightStatus));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetHighlightStatus");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetHighlightStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetHighlightStatus");
	left -= sublen;

	/* highlight_status_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetHighlightStatus");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetHighlightStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->highlight_status_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetHighlightStatus");
	left -= sublen;

	if(left != 0)
		return der_error("GetHighlightStatus: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetHighlightStatus>\n");
#endif

	return length;
}

void
free_GetHighlightStatus(GetHighlightStatus *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->highlight_status_var);

	return;
}

int
der_decode_GetInteractionStatus(FILE *der, GetInteractionStatus *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetInteractionStatus>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetInteractionStatus));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetInteractionStatus");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetInteractionStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetInteractionStatus");
	left -= sublen;

	/* interaction_status_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetInteractionStatus");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetInteractionStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->interaction_status_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetInteractionStatus");
	left -= sublen;

	if(left != 0)
		return der_error("GetInteractionStatus: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetInteractionStatus>\n");
#endif

	return length;
}

void
free_GetInteractionStatus(GetInteractionStatus *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->interaction_status_var);

	return;
}

int
der_decode_GetItemStatus(FILE *der, GetItemStatus *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetItemStatus>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetItemStatus));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetItemStatus");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetItemStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetItemStatus");
	left -= sublen;

	/* item_index */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetItemStatus");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetItemStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->item_index, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetItemStatus");
	left -= sublen;

	/* item_status_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetItemStatus");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetItemStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->item_status_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetItemStatus");
	left -= sublen;

	if(left != 0)
		return der_error("GetItemStatus: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetItemStatus>\n");
#endif

	return length;
}

void
free_GetItemStatus(GetItemStatus *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->item_index);

	free_ObjectReference(&type->item_status_var);

	return;
}

int
der_decode_GetLabel(FILE *der, GetLabel *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetLabel>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetLabel));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetLabel");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetLabel: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetLabel");
	left -= sublen;

	/* label_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetLabel");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetLabel: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->label_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetLabel");
	left -= sublen;

	if(left != 0)
		return der_error("GetLabel: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetLabel>\n");
#endif

	return length;
}

void
free_GetLabel(GetLabel *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->label_var);

	return;
}

int
der_decode_GetLastAnchorFired(FILE *der, GetLastAnchorFired *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetLastAnchorFired>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetLastAnchorFired));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetLastAnchorFired");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetLastAnchorFired: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetLastAnchorFired");
	left -= sublen;

	/* last_anchor_fired_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetLastAnchorFired");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetLastAnchorFired: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->last_anchor_fired_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetLastAnchorFired");
	left -= sublen;

	if(left != 0)
		return der_error("GetLastAnchorFired: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetLastAnchorFired>\n");
#endif

	return length;
}

void
free_GetLastAnchorFired(GetLastAnchorFired *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->last_anchor_fired_var);

	return;
}

int
der_decode_GetLineColour(FILE *der, GetLineColour *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetLineColour>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetLineColour));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetLineColour");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetLineColour: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetLineColour");
	left -= sublen;

	/* line_colour_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetLineColour");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetLineColour: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->line_colour_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetLineColour");
	left -= sublen;

	if(left != 0)
		return der_error("GetLineColour: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetLineColour>\n");
#endif

	return length;
}

void
free_GetLineColour(GetLineColour *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->line_colour_var);

	return;
}

int
der_decode_GetLineStyle(FILE *der, GetLineStyle *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetLineStyle>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetLineStyle));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetLineStyle");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetLineStyle: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetLineStyle");
	left -= sublen;

	/* line_style_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetLineStyle");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetLineStyle: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->line_style_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetLineStyle");
	left -= sublen;

	if(left != 0)
		return der_error("GetLineStyle: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetLineStyle>\n");
#endif

	return length;
}

void
free_GetLineStyle(GetLineStyle *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->line_style_var);

	return;
}

int
der_decode_GetLineWidth(FILE *der, GetLineWidth *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetLineWidth>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetLineWidth));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetLineWidth");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetLineWidth: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetLineWidth");
	left -= sublen;

	/* line_width_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetLineWidth");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetLineWidth: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->line_width_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetLineWidth");
	left -= sublen;

	if(left != 0)
		return der_error("GetLineWidth: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetLineWidth>\n");
#endif

	return length;
}

void
free_GetLineWidth(GetLineWidth *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->line_width_var);

	return;
}

int
der_decode_GetListItem(FILE *der, GetListItem *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetListItem>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetListItem));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetListItem");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetListItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetListItem");
	left -= sublen;

	/* item_index */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetListItem");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetListItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->item_index, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetListItem");
	left -= sublen;

	/* item_ref_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetListItem");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetListItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->item_ref_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetListItem");
	left -= sublen;

	if(left != 0)
		return der_error("GetListItem: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetListItem>\n");
#endif

	return length;
}

void
free_GetListItem(GetListItem *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->item_index);

	free_ObjectReference(&type->item_ref_var);

	return;
}

int
der_decode_GetListSize(FILE *der, GetListSize *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetListSize>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetListSize));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetListSize");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetListSize: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetListSize");
	left -= sublen;

	/* size_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetListSize");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetListSize: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->size_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetListSize");
	left -= sublen;

	if(left != 0)
		return der_error("GetListSize: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetListSize>\n");
#endif

	return length;
}

void
free_GetListSize(GetListSize *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->size_var);

	return;
}

int
der_decode_GetOverwriteMode(FILE *der, GetOverwriteMode *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetOverwriteMode>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetOverwriteMode));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetOverwriteMode");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetOverwriteMode: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetOverwriteMode");
	left -= sublen;

	/* overwrite_mode_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetOverwriteMode");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetOverwriteMode: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->overwrite_mode_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetOverwriteMode");
	left -= sublen;

	if(left != 0)
		return der_error("GetOverwriteMode: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetOverwriteMode>\n");
#endif

	return length;
}

void
free_GetOverwriteMode(GetOverwriteMode *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->overwrite_mode_var);

	return;
}

int
der_decode_GetPortion(FILE *der, GetPortion *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetPortion>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetPortion));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetPortion");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetPortion: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetPortion");
	left -= sublen;

	/* portion_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetPortion");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetPortion: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->portion_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetPortion");
	left -= sublen;

	if(left != 0)
		return der_error("GetPortion: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetPortion>\n");
#endif

	return length;
}

void
free_GetPortion(GetPortion *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->portion_var);

	return;
}

int
der_decode_GetPosition(FILE *der, GetPosition *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetPosition>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetPosition));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetPosition");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetPosition");
	left -= sublen;

	/* x_position_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->x_position_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetPosition");
	left -= sublen;

	/* y_position_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->y_position_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetPosition");
	left -= sublen;

	if(left != 0)
		return der_error("GetPosition: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetPosition>\n");
#endif

	return length;
}

void
free_GetPosition(GetPosition *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->x_position_var);

	free_ObjectReference(&type->y_position_var);

	return;
}

int
der_decode_GetRunningStatus(FILE *der, GetRunningStatus *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetRunningStatus>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetRunningStatus));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetRunningStatus");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetRunningStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetRunningStatus");
	left -= sublen;

	/* running_status_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetRunningStatus");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetRunningStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->running_status_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetRunningStatus");
	left -= sublen;

	if(left != 0)
		return der_error("GetRunningStatus: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetRunningStatus>\n");
#endif

	return length;
}

void
free_GetRunningStatus(GetRunningStatus *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->running_status_var);

	return;
}

int
der_decode_GetSelectionStatus(FILE *der, GetSelectionStatus *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetSelectionStatus>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetSelectionStatus));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetSelectionStatus");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetSelectionStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetSelectionStatus");
	left -= sublen;

	/* selection_status_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetSelectionStatus");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetSelectionStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->selection_status_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetSelectionStatus");
	left -= sublen;

	if(left != 0)
		return der_error("GetSelectionStatus: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetSelectionStatus>\n");
#endif

	return length;
}

void
free_GetSelectionStatus(GetSelectionStatus *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->selection_status_var);

	return;
}

int
der_decode_GetSliderValue(FILE *der, GetSliderValue *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetSliderValue>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetSliderValue));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetSliderValue");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetSliderValue: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetSliderValue");
	left -= sublen;

	/* slider_value_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetSliderValue");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetSliderValue: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->slider_value_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetSliderValue");
	left -= sublen;

	if(left != 0)
		return der_error("GetSliderValue: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetSliderValue>\n");
#endif

	return length;
}

void
free_GetSliderValue(GetSliderValue *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->slider_value_var);

	return;
}

int
der_decode_GetTextContent(FILE *der, GetTextContent *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetTextContent>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetTextContent));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetTextContent");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetTextContent: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetTextContent");
	left -= sublen;

	/* text_content_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetTextContent");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetTextContent: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->text_content_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetTextContent");
	left -= sublen;

	if(left != 0)
		return der_error("GetTextContent: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetTextContent>\n");
#endif

	return length;
}

void
free_GetTextContent(GetTextContent *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->text_content_var);

	return;
}

int
der_decode_GetTextData(FILE *der, GetTextData *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetTextData>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetTextData));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetTextData");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetTextData: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetTextData");
	left -= sublen;

	/* text_data_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetTextData");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetTextData: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->text_data_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetTextData");
	left -= sublen;

	if(left != 0)
		return der_error("GetTextData: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetTextData>\n");
#endif

	return length;
}

void
free_GetTextData(GetTextData *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->text_data_var);

	return;
}

int
der_decode_GetTokenPosition(FILE *der, GetTokenPosition *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetTokenPosition>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetTokenPosition));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetTokenPosition");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetTokenPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetTokenPosition");
	left -= sublen;

	/* token_position_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetTokenPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetTokenPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->token_position_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetTokenPosition");
	left -= sublen;

	if(left != 0)
		return der_error("GetTokenPosition: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetTokenPosition>\n");
#endif

	return length;
}

void
free_GetTokenPosition(GetTokenPosition *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->token_position_var);

	return;
}

int
der_decode_GetVolume(FILE *der, GetVolume *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetVolume>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetVolume));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetVolume");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetVolume: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetVolume");
	left -= sublen;

	/* volume_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetVolume");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetVolume: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->volume_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetVolume");
	left -= sublen;

	if(left != 0)
		return der_error("GetVolume: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetVolume>\n");
#endif

	return length;
}

void
free_GetVolume(GetVolume *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->volume_var);

	return;
}

int
der_decode_Modulo(FILE *der, Modulo *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<Modulo>\n");
#endif

	VK_memset(type, 0x00, sizeof(Modulo));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Modulo");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Modulo: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("Modulo");
	left -= sublen;

	/* value */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Modulo");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Modulo: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->value, sublen + tag.length);
	if(sublen < 0)
		return der_error("Modulo");
	left -= sublen;

	if(left != 0)
		return der_error("Modulo: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Modulo>\n");
#endif

	return length;
}

void
free_Modulo(Modulo *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->value);

	return;
}

int
der_decode_Move(FILE *der, Move *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<Move>\n");
#endif

	VK_memset(type, 0x00, sizeof(Move));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Move");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Move: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("Move");
	left -= sublen;

	/* movement_identifier */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Move");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Move: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->movement_identifier, sublen + tag.length);
	if(sublen < 0)
		return der_error("Move");
	left -= sublen;

	if(left != 0)
		return der_error("Move: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Move>\n");
#endif

	return length;
}

void
free_Move(Move *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->movement_identifier);

	return;
}

int
der_decode_MoveTo(FILE *der, MoveTo *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<MoveTo>\n");
#endif

	VK_memset(type, 0x00, sizeof(MoveTo));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("MoveTo");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("MoveTo: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("MoveTo");
	left -= sublen;

	/* index */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("MoveTo");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("MoveTo: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->index, sublen + tag.length);
	if(sublen < 0)
		return der_error("MoveTo");
	left -= sublen;

	if(left != 0)
		return der_error("MoveTo: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</MoveTo>\n");
#endif

	return length;
}

void
free_MoveTo(MoveTo *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->index);

	return;
}

int
der_decode_Multiply(FILE *der, Multiply *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<Multiply>\n");
#endif

	VK_memset(type, 0x00, sizeof(Multiply));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Multiply");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Multiply: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("Multiply");
	left -= sublen;

	/* value */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Multiply");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Multiply: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->value, sublen + tag.length);
	if(sublen < 0)
		return der_error("Multiply");
	left -= sublen;

	if(left != 0)
		return der_error("Multiply: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Multiply>\n");
#endif

	return length;
}

void
free_Multiply(Multiply *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->value);

	return;
}

int
der_decode_OpenConnection(FILE *der, OpenConnection *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<OpenConnection>\n");
#endif

	VK_memset(type, 0x00, sizeof(OpenConnection));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("OpenConnection");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("OpenConnection: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("OpenConnection");
	left -= sublen;

	/* open_succeeded */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("OpenConnection");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("OpenConnection: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->open_succeeded, sublen + tag.length);
	if(sublen < 0)
		return der_error("OpenConnection");
	left -= sublen;

	/* protocol */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("OpenConnection");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("OpenConnection: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericOctetString(der, &type->protocol, sublen + tag.length);
	if(sublen < 0)
		return der_error("OpenConnection");
	left -= sublen;

	/* address */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("OpenConnection");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("OpenConnection: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericOctetString(der, &type->address, sublen + tag.length);
	if(sublen < 0)
		return der_error("OpenConnection");
	left -= sublen;

	/* connection_tag */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("OpenConnection");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("OpenConnection: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->connection_tag, sublen + tag.length);
	if(sublen < 0)
		return der_error("OpenConnection");
	left -= sublen;

	if(left != 0)
		return der_error("OpenConnection: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</OpenConnection>\n");
#endif

	return length;
}

void
free_OpenConnection(OpenConnection *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->open_succeeded);

	free_GenericOctetString(&type->protocol);

	free_GenericOctetString(&type->address);

	free_GenericInteger(&type->connection_tag);

	return;
}

int
der_decode_PutBefore(FILE *der, PutBefore *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<PutBefore>\n");
#endif

	VK_memset(type, 0x00, sizeof(PutBefore));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("PutBefore");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("PutBefore: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("PutBefore");
	left -= sublen;

	/* reference_visible */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("PutBefore");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("PutBefore: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->reference_visible, sublen + tag.length);
	if(sublen < 0)
		return der_error("PutBefore");
	left -= sublen;

	if(left != 0)
		return der_error("PutBefore: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</PutBefore>\n");
#endif

	return length;
}

void
free_PutBefore(PutBefore *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericObjectReference(&type->reference_visible);

	return;
}

int
der_decode_PutBehind(FILE *der, PutBehind *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<PutBehind>\n");
#endif

	VK_memset(type, 0x00, sizeof(PutBehind));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("PutBehind");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("PutBehind: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("PutBehind");
	left -= sublen;

	/* reference_visible */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("PutBehind");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("PutBehind: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->reference_visible, sublen + tag.length);
	if(sublen < 0)
		return der_error("PutBehind");
	left -= sublen;

	if(left != 0)
		return der_error("PutBehind: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</PutBehind>\n");
#endif

	return length;
}

void
free_PutBehind(PutBehind *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericObjectReference(&type->reference_visible);

	return;
}

int
der_decode_ReadPersistent(FILE *der, ReadPersistent *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;
	der_tag seqtag;

#if (DER_VERBOSE)
	VK_Print("<ReadPersistent>\n");
#endif

	VK_memset(type, 0x00, sizeof(ReadPersistent));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ReadPersistent");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("ReadPersistent: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("ReadPersistent");
	left -= sublen;

	/* read_succeeded */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ReadPersistent");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("ReadPersistent: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->read_succeeded, sublen + tag.length);
	if(sublen < 0)
		return der_error("ReadPersistent");
	left -= sublen;

	/* out_variables */
	/* SEQUENCE OF ObjectReference */
	sublen = der_decode_Tag(der, &seqtag);
	if(sublen < 0)
		return der_error("ReadPersistent");
	if(seqtag.class != DER_CLASS_UNIVERSAL || seqtag.number != 16)
		return der_error("ReadPersistent: unexpected tag %u", seqtag.number);
	left -= sublen + seqtag.length;
	while(seqtag.length > 0)
	{
		LIST_TYPE(ObjectReference) *new_item;
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("ReadPersistent");
		if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
			return der_error("ReadPersistent: unexpected tag %u", tag.number);
		fseek(der, -sublen, SEEK_CUR);
		if((new_item = der_alloc(sizeof(LIST_TYPE(ObjectReference)))) == NULL)
			return der_error("ReadPersistent: out of memory");
		LIST_APPEND(&type->out_variables, new_item);
		sublen = der_decode_ObjectReference(der, &new_item->item, sublen + tag.length);
		if(sublen < 0)
			return der_error("ReadPersistent");
		if(sublen > seqtag.length)
			return der_error("ReadPersistent: %u bytes left", seqtag.length);
		seqtag.length -= sublen;
	}

	/* in_file_name */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ReadPersistent");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("ReadPersistent: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericOctetString(der, &type->in_file_name, sublen + tag.length);
	if(sublen < 0)
		return der_error("ReadPersistent");
	left -= sublen;

	if(left != 0)
		return der_error("ReadPersistent: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ReadPersistent>\n");
#endif

	return length;
}

void
free_ReadPersistent(ReadPersistent *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->read_succeeded);

	LIST_FREE_ITEMS(&type->out_variables, ObjectReference, free_ObjectReference, der_free);

	free_GenericOctetString(&type->in_file_name);

	return;
}

int
der_decode_ScaleBitmap(FILE *der, ScaleBitmap *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ScaleBitmap>\n");
#endif

	VK_memset(type, 0x00, sizeof(ScaleBitmap));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ScaleBitmap");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("ScaleBitmap: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("ScaleBitmap");
	left -= sublen;

	/* x_scale */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ScaleBitmap");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("ScaleBitmap: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->x_scale, sublen + tag.length);
	if(sublen < 0)
		return der_error("ScaleBitmap");
	left -= sublen;

	/* y_scale */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ScaleBitmap");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("ScaleBitmap: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->y_scale, sublen + tag.length);
	if(sublen < 0)
		return der_error("ScaleBitmap");
	left -= sublen;

	if(left != 0)
		return der_error("ScaleBitmap: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ScaleBitmap>\n");
#endif

	return length;
}

void
free_ScaleBitmap(ScaleBitmap *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->x_scale);

	free_GenericInteger(&type->y_scale);

	return;
}

int
der_decode_ScaleVideo(FILE *der, ScaleVideo *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ScaleVideo>\n");
#endif

	VK_memset(type, 0x00, sizeof(ScaleVideo));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ScaleVideo");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("ScaleVideo: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("ScaleVideo");
	left -= sublen;

	/* x_scale */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ScaleVideo");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("ScaleVideo: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->x_scale, sublen + tag.length);
	if(sublen < 0)
		return der_error("ScaleVideo");
	left -= sublen;

	/* y_scale */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ScaleVideo");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("ScaleVideo: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->y_scale, sublen + tag.length);
	if(sublen < 0)
		return der_error("ScaleVideo");
	left -= sublen;

	if(left != 0)
		return der_error("ScaleVideo: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ScaleVideo>\n");
#endif

	return length;
}

void
free_ScaleVideo(ScaleVideo *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->x_scale);

	free_GenericInteger(&type->y_scale);

	return;
}

int
der_decode_ScrollItems(FILE *der, ScrollItems *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ScrollItems>\n");
#endif

	VK_memset(type, 0x00, sizeof(ScrollItems));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ScrollItems");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("ScrollItems: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("ScrollItems");
	left -= sublen;

	/* items_to_scroll */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ScrollItems");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("ScrollItems: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->items_to_scroll, sublen + tag.length);
	if(sublen < 0)
		return der_error("ScrollItems");
	left -= sublen;

	if(left != 0)
		return der_error("ScrollItems: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ScrollItems>\n");
#endif

	return length;
}

void
free_ScrollItems(ScrollItems *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->items_to_scroll);

	return;
}

int
der_decode_SelectItem(FILE *der, SelectItem *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SelectItem>\n");
#endif

	VK_memset(type, 0x00, sizeof(SelectItem));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SelectItem");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SelectItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SelectItem");
	left -= sublen;

	/* item_index */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SelectItem");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SelectItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->item_index, sublen + tag.length);
	if(sublen < 0)
		return der_error("SelectItem");
	left -= sublen;

	if(left != 0)
		return der_error("SelectItem: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SelectItem>\n");
#endif

	return length;
}

void
free_SelectItem(SelectItem *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->item_index);

	return;
}

int
der_decode_EventType(FILE *der, EventType *type, int length)
{
	int left = length;
	int sublen;
	int value;

#if (DER_VERBOSE)
	VK_Print("<EventType>\n");
#endif

	VK_memset(type, 0x00, sizeof(EventType));

	/* ENUMERATED */
	sublen = der_decode_Integer(der, (int *) &value, length);
	if(sublen < 0)
		return der_error("EventType");
	left -= sublen;

	*type = (EventType) value;

	if(left != 0)
		return der_error("EventType: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</EventType>\n");
#endif

	return length;
}

void
free_EventType(EventType *type)
{
	return;
}

int
der_decode_EmulatedEventData(FILE *der, EmulatedEventData *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<EmulatedEventData>\n");
#endif

	VK_memset(type, 0x00, sizeof(EmulatedEventData));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("EmulatedEventData");
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 225)
	{
		/* new_generic_boolean */
		left -= sublen;
		type->choice = EmulatedEventData_new_generic_boolean;
		sublen = der_decode_GenericBoolean(der, &type->u.new_generic_boolean, tag.length);
		if(sublen < 0)
			return der_error("EmulatedEventData");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 226)
	{
		/* new_generic_integer */
		left -= sublen;
		type->choice = EmulatedEventData_new_generic_integer;
		sublen = der_decode_GenericInteger(der, &type->u.new_generic_integer, tag.length);
		if(sublen < 0)
			return der_error("EmulatedEventData");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 227)
	{
		/* new_generic_octet_string */
		left -= sublen;
		type->choice = EmulatedEventData_new_generic_octet_string;
		sublen = der_decode_GenericOctetString(der, &type->u.new_generic_octet_string, tag.length);
		if(sublen < 0)
			return der_error("EmulatedEventData");
		left -= sublen;
	}
	else
		return der_error("EmulatedEventData: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("EmulatedEventData: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</EmulatedEventData>\n");
#endif

	return length;
}

void
free_EmulatedEventData(EmulatedEventData *type)
{
	switch(type->choice)
	{
	case EmulatedEventData_new_generic_boolean:
		free_GenericBoolean(&type->u.new_generic_boolean);
		break;

	case EmulatedEventData_new_generic_integer:
		free_GenericInteger(&type->u.new_generic_integer);
		break;

	case EmulatedEventData_new_generic_octet_string:
		free_GenericOctetString(&type->u.new_generic_octet_string);
		break;

	default:
		der_error("free_EmulatedEventData: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_SendEvent(FILE *der, SendEvent *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SendEvent>\n");
#endif

	VK_memset(type, 0x00, sizeof(SendEvent));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SendEvent");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SendEvent: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SendEvent");
	left -= sublen;

	/* emulated_event_source */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SendEvent");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SendEvent: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->emulated_event_source, sublen + tag.length);
	if(sublen < 0)
		return der_error("SendEvent");
	left -= sublen;

	/* emulated_event_type */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SendEvent");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 10))
		return der_error("SendEvent: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_EventType(der, &type->emulated_event_type, tag.length);
	if(sublen < 0)
		return der_error("SendEvent");
	left -= sublen;

	/* emulated_event_data OPTIONAL */
	if(left > 0)
	{
		sublen = der_peek_Tag(der, &tag);
		if(sublen < 0)
			return der_error("SendEvent");
		if((tag.class == DER_CLASS_CONTEXT && tag.number == 225)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 226)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 227))
		{
			type->have_emulated_event_data = true;
			sublen = der_decode_EmulatedEventData(der, &type->emulated_event_data, sublen + tag.length);
			if(sublen < 0)
				return der_error("SendEvent");
			left -= sublen;
		}
	}

	if(left != 0)
		return der_error("SendEvent: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SendEvent>\n");
#endif

	return length;
}

void
free_SendEvent(SendEvent *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericObjectReference(&type->emulated_event_source);

	free_EventType(&type->emulated_event_type);

	if(type->have_emulated_event_data)
		free_EmulatedEventData(&type->emulated_event_data);

	return;
}

int
der_decode_SetBoxSize(FILE *der, SetBoxSize *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetBoxSize>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetBoxSize));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetBoxSize");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetBoxSize: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetBoxSize");
	left -= sublen;

	/* x_new_box_size */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetBoxSize");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetBoxSize: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->x_new_box_size, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetBoxSize");
	left -= sublen;

	/* y_new_box_size */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetBoxSize");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetBoxSize: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->y_new_box_size, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetBoxSize");
	left -= sublen;

	if(left != 0)
		return der_error("SetBoxSize: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetBoxSize>\n");
#endif

	return length;
}

void
free_SetBoxSize(SetBoxSize *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->x_new_box_size);

	free_GenericInteger(&type->y_new_box_size);

	return;
}

int
der_decode_SetCachePriority(FILE *der, SetCachePriority *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetCachePriority>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetCachePriority));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCachePriority");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCachePriority: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCachePriority");
	left -= sublen;

	/* new_cache_priority */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCachePriority");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCachePriority: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_cache_priority, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCachePriority");
	left -= sublen;

	if(left != 0)
		return der_error("SetCachePriority: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetCachePriority>\n");
#endif

	return length;
}

void
free_SetCachePriority(SetCachePriority *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_cache_priority);

	return;
}

int
der_decode_SetCounterEndPosition(FILE *der, SetCounterEndPosition *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetCounterEndPosition>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetCounterEndPosition));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCounterEndPosition");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCounterEndPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCounterEndPosition");
	left -= sublen;

	/* new_counter_end_position */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCounterEndPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCounterEndPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_counter_end_position, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCounterEndPosition");
	left -= sublen;

	if(left != 0)
		return der_error("SetCounterEndPosition: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetCounterEndPosition>\n");
#endif

	return length;
}

void
free_SetCounterEndPosition(SetCounterEndPosition *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_counter_end_position);

	return;
}

int
der_decode_SetCounterPosition(FILE *der, SetCounterPosition *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetCounterPosition>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetCounterPosition));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCounterPosition");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCounterPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCounterPosition");
	left -= sublen;

	/* new_counter_position */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCounterPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCounterPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_counter_position, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCounterPosition");
	left -= sublen;

	if(left != 0)
		return der_error("SetCounterPosition: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetCounterPosition>\n");
#endif

	return length;
}

void
free_SetCounterPosition(SetCounterPosition *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_counter_position);

	return;
}

int
der_decode_SetCounterTrigger(FILE *der, SetCounterTrigger *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetCounterTrigger>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetCounterTrigger));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCounterTrigger");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCounterTrigger: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCounterTrigger");
	left -= sublen;

	/* trigger_identifier */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCounterTrigger");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCounterTrigger: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->trigger_identifier, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCounterTrigger");
	left -= sublen;

	/* new_counter_value OPTIONAL */
	if(left > 0)
	{
		sublen = der_peek_Tag(der, &tag);
		if(sublen < 0)
			return der_error("SetCounterTrigger");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236))
		{
			type->have_new_counter_value = true;
			sublen = der_decode_GenericInteger(der, &type->new_counter_value, sublen + tag.length);
			if(sublen < 0)
				return der_error("SetCounterTrigger");
			left -= sublen;
		}
	}

	if(left != 0)
		return der_error("SetCounterTrigger: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetCounterTrigger>\n");
#endif

	return length;
}

void
free_SetCounterTrigger(SetCounterTrigger *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->trigger_identifier);

	if(type->have_new_counter_value)
		free_GenericInteger(&type->new_counter_value);

	return;
}

int
der_decode_SetCursorPosition(FILE *der, SetCursorPosition *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetCursorPosition>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetCursorPosition));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCursorPosition");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCursorPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCursorPosition");
	left -= sublen;

	/* x_cursor */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCursorPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCursorPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->x_cursor, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCursorPosition");
	left -= sublen;

	/* y_cursor */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCursorPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCursorPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->y_cursor, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCursorPosition");
	left -= sublen;

	if(left != 0)
		return der_error("SetCursorPosition: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetCursorPosition>\n");
#endif

	return length;
}

void
free_SetCursorPosition(SetCursorPosition *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->x_cursor);

	free_GenericInteger(&type->y_cursor);

	return;
}

int
der_decode_SetCursorShape(FILE *der, SetCursorShape *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetCursorShape>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetCursorShape));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCursorShape");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCursorShape: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCursorShape");
	left -= sublen;

	/* new_cursor_shape OPTIONAL */
	if(left > 0)
	{
		sublen = der_peek_Tag(der, &tag);
		if(sublen < 0)
			return der_error("SetCursorShape");
		if(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236))
		{
			type->have_new_cursor_shape = true;
			sublen = der_decode_GenericObjectReference(der, &type->new_cursor_shape, sublen + tag.length);
			if(sublen < 0)
				return der_error("SetCursorShape");
			left -= sublen;
		}
	}

	if(left != 0)
		return der_error("SetCursorShape: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetCursorShape>\n");
#endif

	return length;
}

void
free_SetCursorShape(SetCursorShape *type)
{
	free_GenericObjectReference(&type->target);

	if(type->have_new_cursor_shape)
		free_GenericObjectReference(&type->new_cursor_shape);

	return;
}

int
der_decode_NewContentSize(FILE *der, NewContentSize *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<NewContentSize>\n");
#endif

	VK_memset(type, 0x00, sizeof(NewContentSize));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("NewContentSize");
	if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236))
	{
		/* content_size */
		fseek(der, -sublen, SEEK_CUR);
		type->choice = NewContentSize_content_size;
		sublen = der_decode_GenericInteger(der, &type->u.content_size, length);
		if(sublen < 0)
			return der_error("NewContentSize");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 5)
	{
		/* null */
		left -= sublen;
		type->choice = NewContentSize_null;
		sublen = der_decode_Null(der, &type->u.null, tag.length);
		if(sublen < 0)
			return der_error("NewContentSize");
		left -= sublen;
	}
	else
		return der_error("NewContentSize: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("NewContentSize: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</NewContentSize>\n");
#endif

	return length;
}

void
free_NewContentSize(NewContentSize *type)
{
	switch(type->choice)
	{
	case NewContentSize_content_size:
		free_GenericInteger(&type->u.content_size);
		break;

	case NewContentSize_null:
		break;

	default:
		der_error("free_NewContentSize: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_NewReferencedContent(FILE *der, NewReferencedContent *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<NewReferencedContent>\n");
#endif

	VK_memset(type, 0x00, sizeof(NewReferencedContent));

	/* SEQUENCE */
	/* generic_content_reference */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("NewReferencedContent");
	if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 69)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("NewReferencedContent: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericContentReference(der, &type->generic_content_reference, sublen + tag.length);
	if(sublen < 0)
		return der_error("NewReferencedContent");
	left -= sublen;

	/* new_content_size */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("NewReferencedContent");
	if(!(tag.class == DER_CLASS_CONTEXT && tag.number == 234))
		return der_error("NewReferencedContent: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_NewContentSize(der, &type->new_content_size, tag.length);
	if(sublen < 0)
		return der_error("NewReferencedContent");
	left -= sublen;

	/* new_content_cache_priority OPTIONAL */
	if(left > 0)
	{
		sublen = der_peek_Tag(der, &tag);
		if(sublen < 0)
			return der_error("NewReferencedContent");
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 235)
		{
			fseek(der, sublen, SEEK_CUR);
			left -= sublen;
			type->have_new_content_cache_priority = true;
			sublen = der_decode_GenericInteger(der, &type->new_content_cache_priority, tag.length);
			if(sublen < 0)
				return der_error("NewReferencedContent");
			left -= sublen;
		}
	}

	if(left != 0)
		return der_error("NewReferencedContent: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</NewReferencedContent>\n");
#endif

	return length;
}

void
free_NewReferencedContent(NewReferencedContent *type)
{
	free_GenericContentReference(&type->generic_content_reference);

	free_NewContentSize(&type->new_content_size);

	if(type->have_new_content_cache_priority)
		free_GenericInteger(&type->new_content_cache_priority);

	return;
}

int
der_decode_NewContent(FILE *der, NewContent *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<NewContent>\n");
#endif

	VK_memset(type, 0x00, sizeof(NewContent));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("NewContent");
	if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236))
	{
		/* new_included_content */
		fseek(der, -sublen, SEEK_CUR);
		type->choice = NewContent_new_included_content;
		sublen = der_decode_GenericOctetString(der, &type->u.new_included_content, length);
		if(sublen < 0)
			return der_error("NewContent");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)
	{
		/* new_referenced_content */
		left -= sublen;
		type->choice = NewContent_new_referenced_content;
		sublen = der_decode_NewReferencedContent(der, &type->u.new_referenced_content, tag.length);
		if(sublen < 0)
			return der_error("NewContent");
		left -= sublen;
	}
	else
		return der_error("NewContent: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("NewContent: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</NewContent>\n");
#endif

	return length;
}

void
free_NewContent(NewContent *type)
{
	switch(type->choice)
	{
	case NewContent_new_included_content:
		free_GenericOctetString(&type->u.new_included_content);
		break;

	case NewContent_new_referenced_content:
		free_NewReferencedContent(&type->u.new_referenced_content);
		break;

	default:
		der_error("free_NewContent: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_SetData(FILE *der, SetData *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetData>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetData));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetData");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetData: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetData");
	left -= sublen;

	/* new_content */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetData");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236))
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("SetData: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_NewContent(der, &type->new_content, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetData");
	left -= sublen;

	if(left != 0)
		return der_error("SetData: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetData>\n");
#endif

	return length;
}

void
free_SetData(SetData *type)
{
	free_GenericObjectReference(&type->target);

	free_NewContent(&type->new_content);

	return;
}

int
der_decode_SetEntryPoint(FILE *der, SetEntryPoint *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetEntryPoint>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetEntryPoint));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetEntryPoint");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetEntryPoint: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetEntryPoint");
	left -= sublen;

	/* new_entry_point */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetEntryPoint");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetEntryPoint: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_entry_point, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetEntryPoint");
	left -= sublen;

	if(left != 0)
		return der_error("SetEntryPoint: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetEntryPoint>\n");
#endif

	return length;
}

void
free_SetEntryPoint(SetEntryPoint *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_entry_point);

	return;
}

int
der_decode_NewColour(FILE *der, NewColour *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<NewColour>\n");
#endif

	VK_memset(type, 0x00, sizeof(NewColour));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("NewColour");
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 230)
	{
		/* new_colour_index */
		left -= sublen;
		type->choice = NewColour_new_colour_index;
		sublen = der_decode_GenericInteger(der, &type->u.new_colour_index, tag.length);
		if(sublen < 0)
			return der_error("NewColour");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 231)
	{
		/* new_absolute_colour */
		left -= sublen;
		type->choice = NewColour_new_absolute_colour;
		sublen = der_decode_GenericOctetString(der, &type->u.new_absolute_colour, tag.length);
		if(sublen < 0)
			return der_error("NewColour");
		left -= sublen;
	}
	else
		return der_error("NewColour: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("NewColour: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</NewColour>\n");
#endif

	return length;
}

void
free_NewColour(NewColour *type)
{
	switch(type->choice)
	{
	case NewColour_new_colour_index:
		free_GenericInteger(&type->u.new_colour_index);
		break;

	case NewColour_new_absolute_colour:
		free_GenericOctetString(&type->u.new_absolute_colour);
		break;

	default:
		der_error("free_NewColour: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_SetFillColour(FILE *der, SetFillColour *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetFillColour>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetFillColour));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetFillColour");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetFillColour: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetFillColour");
	left -= sublen;

	/* new_fill_colour OPTIONAL */
	if(left > 0)
	{
		sublen = der_peek_Tag(der, &tag);
		if(sublen < 0)
			return der_error("SetFillColour");
		if((tag.class == DER_CLASS_CONTEXT && tag.number == 230)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 231))
		{
			type->have_new_fill_colour = true;
			sublen = der_decode_NewColour(der, &type->new_fill_colour, sublen + tag.length);
			if(sublen < 0)
				return der_error("SetFillColour");
			left -= sublen;
		}
	}

	if(left != 0)
		return der_error("SetFillColour: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetFillColour>\n");
#endif

	return length;
}

void
free_SetFillColour(SetFillColour *type)
{
	free_GenericObjectReference(&type->target);

	if(type->have_new_fill_colour)
		free_NewColour(&type->new_fill_colour);

	return;
}

int
der_decode_SetFirstItem(FILE *der, SetFirstItem *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetFirstItem>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetFirstItem));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetFirstItem");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetFirstItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetFirstItem");
	left -= sublen;

	/* new_first_item */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetFirstItem");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetFirstItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_first_item, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetFirstItem");
	left -= sublen;

	if(left != 0)
		return der_error("SetFirstItem: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetFirstItem>\n");
#endif

	return length;
}

void
free_SetFirstItem(SetFirstItem *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_first_item);

	return;
}

int
der_decode_NewFont(FILE *der, NewFont *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<NewFont>\n");
#endif

	VK_memset(type, 0x00, sizeof(NewFont));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("NewFont");
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 232)
	{
		/* new_font_name */
		left -= sublen;
		type->choice = NewFont_new_font_name;
		sublen = der_decode_GenericOctetString(der, &type->u.new_font_name, tag.length);
		if(sublen < 0)
			return der_error("NewFont");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 233)
	{
		/* new_font_reference */
		left -= sublen;
		type->choice = NewFont_new_font_reference;
		sublen = der_decode_GenericObjectReference(der, &type->u.new_font_reference, tag.length);
		if(sublen < 0)
			return der_error("NewFont");
		left -= sublen;
	}
	else
		return der_error("NewFont: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("NewFont: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</NewFont>\n");
#endif

	return length;
}

void
free_NewFont(NewFont *type)
{
	switch(type->choice)
	{
	case NewFont_new_font_name:
		free_GenericOctetString(&type->u.new_font_name);
		break;

	case NewFont_new_font_reference:
		free_GenericObjectReference(&type->u.new_font_reference);
		break;

	default:
		der_error("free_NewFont: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_SetFontRef(FILE *der, SetFontRef *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetFontRef>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetFontRef));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetFontRef");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetFontRef: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetFontRef");
	left -= sublen;

	/* new_font */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetFontRef");
	if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 232)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 233)))
		return der_error("SetFontRef: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_NewFont(der, &type->new_font, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetFontRef");
	left -= sublen;

	if(left != 0)
		return der_error("SetFontRef: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetFontRef>\n");
#endif

	return length;
}

void
free_SetFontRef(SetFontRef *type)
{
	free_GenericObjectReference(&type->target);

	free_NewFont(&type->new_font);

	return;
}

int
der_decode_SetHighlightStatus(FILE *der, SetHighlightStatus *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetHighlightStatus>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetHighlightStatus));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetHighlightStatus");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetHighlightStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetHighlightStatus");
	left -= sublen;

	/* new_highlight_status */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetHighlightStatus");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 1)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetHighlightStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericBoolean(der, &type->new_highlight_status, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetHighlightStatus");
	left -= sublen;

	if(left != 0)
		return der_error("SetHighlightStatus: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetHighlightStatus>\n");
#endif

	return length;
}

void
free_SetHighlightStatus(SetHighlightStatus *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericBoolean(&type->new_highlight_status);

	return;
}

int
der_decode_SetInteractionStatus(FILE *der, SetInteractionStatus *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetInteractionStatus>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetInteractionStatus));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetInteractionStatus");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetInteractionStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetInteractionStatus");
	left -= sublen;

	/* new_interaction_status */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetInteractionStatus");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 1)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetInteractionStatus: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericBoolean(der, &type->new_interaction_status, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetInteractionStatus");
	left -= sublen;

	if(left != 0)
		return der_error("SetInteractionStatus: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetInteractionStatus>\n");
#endif

	return length;
}

void
free_SetInteractionStatus(SetInteractionStatus *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericBoolean(&type->new_interaction_status);

	return;
}

int
der_decode_SetLabel(FILE *der, SetLabel *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetLabel>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetLabel));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetLabel");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetLabel: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetLabel");
	left -= sublen;

	/* new_label */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetLabel");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetLabel: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericOctetString(der, &type->new_label, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetLabel");
	left -= sublen;

	if(left != 0)
		return der_error("SetLabel: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetLabel>\n");
#endif

	return length;
}

void
free_SetLabel(SetLabel *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericOctetString(&type->new_label);

	return;
}

int
der_decode_SetLineColour(FILE *der, SetLineColour *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetLineColour>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetLineColour));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetLineColour");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetLineColour: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetLineColour");
	left -= sublen;

	/* new_line_colour */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetLineColour");
	if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 230)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 231)))
		return der_error("SetLineColour: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_NewColour(der, &type->new_line_colour, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetLineColour");
	left -= sublen;

	if(left != 0)
		return der_error("SetLineColour: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetLineColour>\n");
#endif

	return length;
}

void
free_SetLineColour(SetLineColour *type)
{
	free_GenericObjectReference(&type->target);

	free_NewColour(&type->new_line_colour);

	return;
}

int
der_decode_SetLineStyle(FILE *der, SetLineStyle *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetLineStyle>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetLineStyle));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetLineStyle");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetLineStyle: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetLineStyle");
	left -= sublen;

	/* new_line_style */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetLineStyle");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetLineStyle: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_line_style, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetLineStyle");
	left -= sublen;

	if(left != 0)
		return der_error("SetLineStyle: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetLineStyle>\n");
#endif

	return length;
}

void
free_SetLineStyle(SetLineStyle *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_line_style);

	return;
}

int
der_decode_SetLineWidth(FILE *der, SetLineWidth *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetLineWidth>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetLineWidth));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetLineWidth");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetLineWidth: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetLineWidth");
	left -= sublen;

	/* new_line_width */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetLineWidth");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetLineWidth: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_line_width, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetLineWidth");
	left -= sublen;

	if(left != 0)
		return der_error("SetLineWidth: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetLineWidth>\n");
#endif

	return length;
}

void
free_SetLineWidth(SetLineWidth *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_line_width);

	return;
}

int
der_decode_SetOverwriteMode(FILE *der, SetOverwriteMode *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetOverwriteMode>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetOverwriteMode));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetOverwriteMode");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetOverwriteMode: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetOverwriteMode");
	left -= sublen;

	/* new_overwrite_mode */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetOverwriteMode");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 1)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetOverwriteMode: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericBoolean(der, &type->new_overwrite_mode, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetOverwriteMode");
	left -= sublen;

	if(left != 0)
		return der_error("SetOverwriteMode: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetOverwriteMode>\n");
#endif

	return length;
}

void
free_SetOverwriteMode(SetOverwriteMode *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericBoolean(&type->new_overwrite_mode);

	return;
}

int
der_decode_SetPaletteRef(FILE *der, SetPaletteRef *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetPaletteRef>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetPaletteRef));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetPaletteRef");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetPaletteRef: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetPaletteRef");
	left -= sublen;

	/* new_palette_ref */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetPaletteRef");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetPaletteRef: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->new_palette_ref, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetPaletteRef");
	left -= sublen;

	if(left != 0)
		return der_error("SetPaletteRef: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetPaletteRef>\n");
#endif

	return length;
}

void
free_SetPaletteRef(SetPaletteRef *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericObjectReference(&type->new_palette_ref);

	return;
}

int
der_decode_SetPortion(FILE *der, SetPortion *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetPortion>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetPortion));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetPortion");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetPortion: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetPortion");
	left -= sublen;

	/* new_portion */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetPortion");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetPortion: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_portion, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetPortion");
	left -= sublen;

	if(left != 0)
		return der_error("SetPortion: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetPortion>\n");
#endif

	return length;
}

void
free_SetPortion(SetPortion *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_portion);

	return;
}

int
der_decode_SetPosition(FILE *der, SetPosition *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetPosition>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetPosition));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetPosition");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetPosition");
	left -= sublen;

	/* new_x_position */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_x_position, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetPosition");
	left -= sublen;

	/* new_y_position */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_y_position, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetPosition");
	left -= sublen;

	if(left != 0)
		return der_error("SetPosition: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetPosition>\n");
#endif

	return length;
}

void
free_SetPosition(SetPosition *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_x_position);

	free_GenericInteger(&type->new_y_position);

	return;
}

int
der_decode_SetSliderValue(FILE *der, SetSliderValue *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetSliderValue>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetSliderValue));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetSliderValue");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetSliderValue: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetSliderValue");
	left -= sublen;

	/* new_slider_value */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetSliderValue");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetSliderValue: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_slider_value, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetSliderValue");
	left -= sublen;

	if(left != 0)
		return der_error("SetSliderValue: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetSliderValue>\n");
#endif

	return length;
}

void
free_SetSliderValue(SetSliderValue *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_slider_value);

	return;
}

int
der_decode_Rational(FILE *der, Rational *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<Rational>\n");
#endif

	VK_memset(type, 0x00, sizeof(Rational));

	/* SEQUENCE */
	/* numerator */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Rational");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Rational: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->numerator, sublen + tag.length);
	if(sublen < 0)
		return der_error("Rational");
	left -= sublen;

	/* denominator OPTIONAL */
	if(left > 0)
	{
		sublen = der_peek_Tag(der, &tag);
		if(sublen < 0)
			return der_error("Rational");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236))
		{
			type->have_denominator = true;
			sublen = der_decode_GenericInteger(der, &type->denominator, sublen + tag.length);
			if(sublen < 0)
				return der_error("Rational");
			left -= sublen;
		}
	}

	if(left != 0)
		return der_error("Rational: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Rational>\n");
#endif

	return length;
}

void
free_Rational(Rational *type)
{
	free_GenericInteger(&type->numerator);

	if(type->have_denominator)
		free_GenericInteger(&type->denominator);

	return;
}

int
der_decode_SetSpeed(FILE *der, SetSpeed *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetSpeed>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetSpeed));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetSpeed");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetSpeed: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetSpeed");
	left -= sublen;

	/* new_speed */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetSpeed");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		return der_error("SetSpeed: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_Rational(der, &type->new_speed, tag.length);
	if(sublen < 0)
		return der_error("SetSpeed");
	left -= sublen;

	if(left != 0)
		return der_error("SetSpeed: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetSpeed>\n");
#endif

	return length;
}

void
free_SetSpeed(SetSpeed *type)
{
	free_GenericObjectReference(&type->target);

	free_Rational(&type->new_speed);

	return;
}

int
der_decode_NewTimer(FILE *der, NewTimer *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<NewTimer>\n");
#endif

	VK_memset(type, 0x00, sizeof(NewTimer));

	/* SEQUENCE */
	/* timer_value */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("NewTimer");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("NewTimer: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->timer_value, sublen + tag.length);
	if(sublen < 0)
		return der_error("NewTimer");
	left -= sublen;

	/* absolute_time OPTIONAL */
	if(left > 0)
	{
		sublen = der_peek_Tag(der, &tag);
		if(sublen < 0)
			return der_error("NewTimer");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 1)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236))
		{
			type->have_absolute_time = true;
			sublen = der_decode_GenericBoolean(der, &type->absolute_time, sublen + tag.length);
			if(sublen < 0)
				return der_error("NewTimer");
			left -= sublen;
		}
	}

	if(left != 0)
		return der_error("NewTimer: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</NewTimer>\n");
#endif

	return length;
}

void
free_NewTimer(NewTimer *type)
{
	free_GenericInteger(&type->timer_value);

	if(type->have_absolute_time)
		free_GenericBoolean(&type->absolute_time);

	return;
}

int
der_decode_SetTimer(FILE *der, SetTimer *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetTimer>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetTimer));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetTimer");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetTimer: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetTimer");
	left -= sublen;

	/* timer_id */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetTimer");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetTimer: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->timer_id, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetTimer");
	left -= sublen;

	/* new_timer OPTIONAL */
	if(left > 0)
	{
		sublen = der_peek_Tag(der, &tag);
		if(sublen < 0)
			return der_error("SetTimer");
		if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)
		{
			fseek(der, sublen, SEEK_CUR);
			left -= sublen;
			type->have_new_timer = true;
			sublen = der_decode_NewTimer(der, &type->new_timer, tag.length);
			if(sublen < 0)
				return der_error("SetTimer");
			left -= sublen;
		}
	}

	if(left != 0)
		return der_error("SetTimer: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetTimer>\n");
#endif

	return length;
}

void
free_SetTimer(SetTimer *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->timer_id);

	if(type->have_new_timer)
		free_NewTimer(&type->new_timer);

	return;
}

int
der_decode_SetTransparency(FILE *der, SetTransparency *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetTransparency>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetTransparency));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetTransparency");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetTransparency: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetTransparency");
	left -= sublen;

	/* new_transparency */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetTransparency");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetTransparency: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_transparency, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetTransparency");
	left -= sublen;

	if(left != 0)
		return der_error("SetTransparency: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetTransparency>\n");
#endif

	return length;
}

void
free_SetTransparency(SetTransparency *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_transparency);

	return;
}

int
der_decode_NewVariableValue(FILE *der, NewVariableValue *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<NewVariableValue>\n");
#endif

	VK_memset(type, 0x00, sizeof(NewVariableValue));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("NewVariableValue");
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 225)
	{
		/* new_generic_boolean */
		left -= sublen;
		type->choice = NewVariableValue_new_generic_boolean;
		sublen = der_decode_GenericBoolean(der, &type->u.new_generic_boolean, tag.length);
		if(sublen < 0)
			return der_error("NewVariableValue");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 226)
	{
		/* new_generic_integer */
		left -= sublen;
		type->choice = NewVariableValue_new_generic_integer;
		sublen = der_decode_GenericInteger(der, &type->u.new_generic_integer, tag.length);
		if(sublen < 0)
			return der_error("NewVariableValue");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 227)
	{
		/* new_generic_octet_string */
		left -= sublen;
		type->choice = NewVariableValue_new_generic_octet_string;
		sublen = der_decode_GenericOctetString(der, &type->u.new_generic_octet_string, tag.length);
		if(sublen < 0)
			return der_error("NewVariableValue");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 228)
	{
		/* new_generic_object_reference */
		left -= sublen;
		type->choice = NewVariableValue_new_generic_object_reference;
		sublen = der_decode_GenericObjectReference(der, &type->u.new_generic_object_reference, tag.length);
		if(sublen < 0)
			return der_error("NewVariableValue");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 229)
	{
		/* new_generic_content_reference */
		left -= sublen;
		type->choice = NewVariableValue_new_generic_content_reference;
		sublen = der_decode_GenericContentReference(der, &type->u.new_generic_content_reference, tag.length);
		if(sublen < 0)
			return der_error("NewVariableValue");
		left -= sublen;
	}
	else
		return der_error("NewVariableValue: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("NewVariableValue: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</NewVariableValue>\n");
#endif

	return length;
}

void
free_NewVariableValue(NewVariableValue *type)
{
	switch(type->choice)
	{
	case NewVariableValue_new_generic_boolean:
		free_GenericBoolean(&type->u.new_generic_boolean);
		break;

	case NewVariableValue_new_generic_integer:
		free_GenericInteger(&type->u.new_generic_integer);
		break;

	case NewVariableValue_new_generic_octet_string:
		free_GenericOctetString(&type->u.new_generic_octet_string);
		break;

	case NewVariableValue_new_generic_object_reference:
		free_GenericObjectReference(&type->u.new_generic_object_reference);
		break;

	case NewVariableValue_new_generic_content_reference:
		free_GenericContentReference(&type->u.new_generic_content_reference);
		break;

	default:
		der_error("free_NewVariableValue: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_SetVariable(FILE *der, SetVariable *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetVariable>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetVariable));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetVariable");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetVariable: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetVariable");
	left -= sublen;

	/* new_variable_value */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetVariable");
	if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 225)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 226)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 227)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 228)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 229)))
		return der_error("SetVariable: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_NewVariableValue(der, &type->new_variable_value, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetVariable");
	left -= sublen;

	if(left != 0)
		return der_error("SetVariable: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetVariable>\n");
#endif

	return length;
}

void
free_SetVariable(SetVariable *type)
{
	free_GenericObjectReference(&type->target);

	free_NewVariableValue(&type->new_variable_value);

	return;
}

int
der_decode_SetVolume(FILE *der, SetVolume *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetVolume>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetVolume));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetVolume");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetVolume: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetVolume");
	left -= sublen;

	/* new_volume */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetVolume");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetVolume: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_volume, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetVolume");
	left -= sublen;

	if(left != 0)
		return der_error("SetVolume: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetVolume>\n");
#endif

	return length;
}

void
free_SetVolume(SetVolume *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_volume);

	return;
}

int
der_decode_Step(FILE *der, Step *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<Step>\n");
#endif

	VK_memset(type, 0x00, sizeof(Step));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Step");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Step: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("Step");
	left -= sublen;

	/* nb_of_steps */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Step");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Step: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->nb_of_steps, sublen + tag.length);
	if(sublen < 0)
		return der_error("Step");
	left -= sublen;

	if(left != 0)
		return der_error("Step: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Step>\n");
#endif

	return length;
}

void
free_Step(Step *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->nb_of_steps);

	return;
}

int
der_decode_StorePersistent(FILE *der, StorePersistent *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;
	der_tag seqtag;

#if (DER_VERBOSE)
	VK_Print("<StorePersistent>\n");
#endif

	VK_memset(type, 0x00, sizeof(StorePersistent));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("StorePersistent");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("StorePersistent: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("StorePersistent");
	left -= sublen;

	/* store_succeeded */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("StorePersistent");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("StorePersistent: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->store_succeeded, sublen + tag.length);
	if(sublen < 0)
		return der_error("StorePersistent");
	left -= sublen;

	/* in_variables */
	/* SEQUENCE OF ObjectReference */
	sublen = der_decode_Tag(der, &seqtag);
	if(sublen < 0)
		return der_error("StorePersistent");
	if(seqtag.class != DER_CLASS_UNIVERSAL || seqtag.number != 16)
		return der_error("StorePersistent: unexpected tag %u", seqtag.number);
	left -= sublen + seqtag.length;
	while(seqtag.length > 0)
	{
		LIST_TYPE(ObjectReference) *new_item;
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("StorePersistent");
		if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
			return der_error("StorePersistent: unexpected tag %u", tag.number);
		fseek(der, -sublen, SEEK_CUR);
		if((new_item = der_alloc(sizeof(LIST_TYPE(ObjectReference)))) == NULL)
			return der_error("StorePersistent: out of memory");
		LIST_APPEND(&type->in_variables, new_item);
		sublen = der_decode_ObjectReference(der, &new_item->item, sublen + tag.length);
		if(sublen < 0)
			return der_error("StorePersistent");
		if(sublen > seqtag.length)
			return der_error("StorePersistent: %u bytes left", seqtag.length);
		seqtag.length -= sublen;
	}

	/* out_file_name */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("StorePersistent");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("StorePersistent: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericOctetString(der, &type->out_file_name, sublen + tag.length);
	if(sublen < 0)
		return der_error("StorePersistent");
	left -= sublen;

	if(left != 0)
		return der_error("StorePersistent: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</StorePersistent>\n");
#endif

	return length;
}

void
free_StorePersistent(StorePersistent *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->store_succeeded);

	LIST_FREE_ITEMS(&type->in_variables, ObjectReference, free_ObjectReference, der_free);

	free_GenericOctetString(&type->out_file_name);

	return;
}

int
der_decode_Subtract(FILE *der, Subtract *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<Subtract>\n");
#endif

	VK_memset(type, 0x00, sizeof(Subtract));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Subtract");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Subtract: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("Subtract");
	left -= sublen;

	/* value */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Subtract");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("Subtract: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->value, sublen + tag.length);
	if(sublen < 0)
		return der_error("Subtract");
	left -= sublen;

	if(left != 0)
		return der_error("Subtract: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Subtract>\n");
#endif

	return length;
}

void
free_Subtract(Subtract *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->value);

	return;
}

int
der_decode_ComparisonValue(FILE *der, ComparisonValue *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ComparisonValue>\n");
#endif

	VK_memset(type, 0x00, sizeof(ComparisonValue));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ComparisonValue");
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 225)
	{
		/* new_generic_boolean */
		left -= sublen;
		type->choice = ComparisonValue_new_generic_boolean;
		sublen = der_decode_GenericBoolean(der, &type->u.new_generic_boolean, tag.length);
		if(sublen < 0)
			return der_error("ComparisonValue");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 226)
	{
		/* new_generic_integer */
		left -= sublen;
		type->choice = ComparisonValue_new_generic_integer;
		sublen = der_decode_GenericInteger(der, &type->u.new_generic_integer, tag.length);
		if(sublen < 0)
			return der_error("ComparisonValue");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 227)
	{
		/* new_generic_octetstring */
		left -= sublen;
		type->choice = ComparisonValue_new_generic_octetstring;
		sublen = der_decode_GenericOctetString(der, &type->u.new_generic_octetstring, tag.length);
		if(sublen < 0)
			return der_error("ComparisonValue");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 228)
	{
		/* new_generic_object_reference */
		left -= sublen;
		type->choice = ComparisonValue_new_generic_object_reference;
		sublen = der_decode_GenericObjectReference(der, &type->u.new_generic_object_reference, tag.length);
		if(sublen < 0)
			return der_error("ComparisonValue");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 229)
	{
		/* new_generic_content_reference */
		left -= sublen;
		type->choice = ComparisonValue_new_generic_content_reference;
		sublen = der_decode_GenericContentReference(der, &type->u.new_generic_content_reference, tag.length);
		if(sublen < 0)
			return der_error("ComparisonValue");
		left -= sublen;
	}
	else
		return der_error("ComparisonValue: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("ComparisonValue: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ComparisonValue>\n");
#endif

	return length;
}

void
free_ComparisonValue(ComparisonValue *type)
{
	switch(type->choice)
	{
	case ComparisonValue_new_generic_boolean:
		free_GenericBoolean(&type->u.new_generic_boolean);
		break;

	case ComparisonValue_new_generic_integer:
		free_GenericInteger(&type->u.new_generic_integer);
		break;

	case ComparisonValue_new_generic_octetstring:
		free_GenericOctetString(&type->u.new_generic_octetstring);
		break;

	case ComparisonValue_new_generic_object_reference:
		free_GenericObjectReference(&type->u.new_generic_object_reference);
		break;

	case ComparisonValue_new_generic_content_reference:
		free_GenericContentReference(&type->u.new_generic_content_reference);
		break;

	default:
		der_error("free_ComparisonValue: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_TestVariable(FILE *der, TestVariable *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<TestVariable>\n");
#endif

	VK_memset(type, 0x00, sizeof(TestVariable));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("TestVariable");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("TestVariable: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("TestVariable");
	left -= sublen;

	/* operator */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("TestVariable");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("TestVariable: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->operator, sublen + tag.length);
	if(sublen < 0)
		return der_error("TestVariable");
	left -= sublen;

	/* comparison_value */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("TestVariable");
	if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 225)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 226)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 227)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 228)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 229)))
		return der_error("TestVariable: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ComparisonValue(der, &type->comparison_value, sublen + tag.length);
	if(sublen < 0)
		return der_error("TestVariable");
	left -= sublen;

	if(left != 0)
		return der_error("TestVariable: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</TestVariable>\n");
#endif

	return length;
}

void
free_TestVariable(TestVariable *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->operator);

	free_ComparisonValue(&type->comparison_value);

	return;
}

int
der_decode_ToggleItem(FILE *der, ToggleItem *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ToggleItem>\n");
#endif

	VK_memset(type, 0x00, sizeof(ToggleItem));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ToggleItem");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("ToggleItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("ToggleItem");
	left -= sublen;

	/* item_index */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ToggleItem");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("ToggleItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->item_index, sublen + tag.length);
	if(sublen < 0)
		return der_error("ToggleItem");
	left -= sublen;

	if(left != 0)
		return der_error("ToggleItem: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ToggleItem>\n");
#endif

	return length;
}

void
free_ToggleItem(ToggleItem *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->item_index);

	return;
}

int
der_decode_ConnectionTagOrNull(FILE *der, ConnectionTagOrNull *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ConnectionTagOrNull>\n");
#endif

	VK_memset(type, 0x00, sizeof(ConnectionTagOrNull));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ConnectionTagOrNull");
	if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236))
	{
		/* connection_tag */
		fseek(der, -sublen, SEEK_CUR);
		type->choice = ConnectionTagOrNull_connection_tag;
		sublen = der_decode_GenericInteger(der, &type->u.connection_tag, length);
		if(sublen < 0)
			return der_error("ConnectionTagOrNull");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 5)
	{
		/* null */
		left -= sublen;
		type->choice = ConnectionTagOrNull_null;
		sublen = der_decode_Null(der, &type->u.null, tag.length);
		if(sublen < 0)
			return der_error("ConnectionTagOrNull");
		left -= sublen;
	}
	else
		return der_error("ConnectionTagOrNull: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("ConnectionTagOrNull: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ConnectionTagOrNull>\n");
#endif

	return length;
}

void
free_ConnectionTagOrNull(ConnectionTagOrNull *type)
{
	switch(type->choice)
	{
	case ConnectionTagOrNull_connection_tag:
		free_GenericInteger(&type->u.connection_tag);
		break;

	case ConnectionTagOrNull_null:
		break;

	default:
		der_error("free_ConnectionTagOrNull: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_TransitionTo(FILE *der, TransitionTo *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<TransitionTo>\n");
#endif

	VK_memset(type, 0x00, sizeof(TransitionTo));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("TransitionTo");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("TransitionTo: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("TransitionTo");
	left -= sublen;

	/* connection_tag_or_null */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("TransitionTo");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236))
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 5)))
		return der_error("TransitionTo: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ConnectionTagOrNull(der, &type->connection_tag_or_null, sublen + tag.length);
	if(sublen < 0)
		return der_error("TransitionTo");
	left -= sublen;

	/* transition_effect OPTIONAL */
	if(left > 0)
	{
		sublen = der_peek_Tag(der, &tag);
		if(sublen < 0)
			return der_error("TransitionTo");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236))
		{
			type->have_transition_effect = true;
			sublen = der_decode_GenericInteger(der, &type->transition_effect, sublen + tag.length);
			if(sublen < 0)
				return der_error("TransitionTo");
			left -= sublen;
		}
	}

	if(left != 0)
		return der_error("TransitionTo: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</TransitionTo>\n");
#endif

	return length;
}

void
free_TransitionTo(TransitionTo *type)
{
	free_GenericObjectReference(&type->target);

	free_ConnectionTagOrNull(&type->connection_tag_or_null);

	if(type->have_transition_effect)
		free_GenericInteger(&type->transition_effect);

	return;
}

int
der_decode_SetBackgroundColour(FILE *der, SetBackgroundColour *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetBackgroundColour>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetBackgroundColour));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetBackgroundColour");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetBackgroundColour: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetBackgroundColour");
	left -= sublen;

	/* new_background_colour */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetBackgroundColour");
	if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 230)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 231)))
		return der_error("SetBackgroundColour: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_NewColour(der, &type->new_background_colour, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetBackgroundColour");
	left -= sublen;

	if(left != 0)
		return der_error("SetBackgroundColour: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetBackgroundColour>\n");
#endif

	return length;
}

void
free_SetBackgroundColour(SetBackgroundColour *type)
{
	free_GenericObjectReference(&type->target);

	free_NewColour(&type->new_background_colour);

	return;
}

int
der_decode_SetCellPosition(FILE *der, SetCellPosition *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetCellPosition>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetCellPosition));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCellPosition");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCellPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCellPosition");
	left -= sublen;

	/* index */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCellPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCellPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->index, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCellPosition");
	left -= sublen;

	/* new_x_position */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCellPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCellPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_x_position, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCellPosition");
	left -= sublen;

	/* new_y_position */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetCellPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetCellPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_y_position, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetCellPosition");
	left -= sublen;

	if(left != 0)
		return der_error("SetCellPosition: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetCellPosition>\n");
#endif

	return length;
}

void
free_SetCellPosition(SetCellPosition *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->index);

	free_GenericInteger(&type->new_x_position);

	free_GenericInteger(&type->new_y_position);

	return;
}

int
der_decode_SetInputRegister(FILE *der, SetInputRegister *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetInputRegister>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetInputRegister));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetInputRegister");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetInputRegister: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetInputRegister");
	left -= sublen;

	/* new_input_register */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetInputRegister");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetInputRegister: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_input_register, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetInputRegister");
	left -= sublen;

	if(left != 0)
		return der_error("SetInputRegister: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetInputRegister>\n");
#endif

	return length;
}

void
free_SetInputRegister(SetInputRegister *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_input_register);

	return;
}

int
der_decode_SetTextColour(FILE *der, SetTextColour *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetTextColour>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetTextColour));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetTextColour");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetTextColour: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetTextColour");
	left -= sublen;

	/* new_text_colour */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetTextColour");
	if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 230)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 231)))
		return der_error("SetTextColour: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_NewColour(der, &type->new_text_colour, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetTextColour");
	left -= sublen;

	if(left != 0)
		return der_error("SetTextColour: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetTextColour>\n");
#endif

	return length;
}

void
free_SetTextColour(SetTextColour *type)
{
	free_GenericObjectReference(&type->target);

	free_NewColour(&type->new_text_colour);

	return;
}

int
der_decode_SetFontAttributes(FILE *der, SetFontAttributes *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetFontAttributes>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetFontAttributes));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetFontAttributes");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetFontAttributes: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetFontAttributes");
	left -= sublen;

	/* new_font_attribute */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetFontAttributes");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetFontAttributes: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericOctetString(der, &type->new_font_attribute, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetFontAttributes");
	left -= sublen;

	if(left != 0)
		return der_error("SetFontAttributes: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetFontAttributes>\n");
#endif

	return length;
}

void
free_SetFontAttributes(SetFontAttributes *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericOctetString(&type->new_font_attribute);

	return;
}

int
der_decode_SetVideoDecodeOffset(FILE *der, SetVideoDecodeOffset *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetVideoDecodeOffset>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetVideoDecodeOffset));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetVideoDecodeOffset");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetVideoDecodeOffset: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetVideoDecodeOffset");
	left -= sublen;

	/* new_x_offset */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetVideoDecodeOffset");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetVideoDecodeOffset: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_x_offset, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetVideoDecodeOffset");
	left -= sublen;

	/* new_y_offset */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetVideoDecodeOffset");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetVideoDecodeOffset: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_y_offset, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetVideoDecodeOffset");
	left -= sublen;

	if(left != 0)
		return der_error("SetVideoDecodeOffset: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetVideoDecodeOffset>\n");
#endif

	return length;
}

void
free_SetVideoDecodeOffset(SetVideoDecodeOffset *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_x_offset);

	free_GenericInteger(&type->new_y_offset);

	return;
}

int
der_decode_GetVideoDecodeOffset(FILE *der, GetVideoDecodeOffset *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetVideoDecodeOffset>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetVideoDecodeOffset));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetVideoDecodeOffset");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetVideoDecodeOffset: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetVideoDecodeOffset");
	left -= sublen;

	/* x_offset_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetVideoDecodeOffset");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetVideoDecodeOffset: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->x_offset_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetVideoDecodeOffset");
	left -= sublen;

	/* y_offset_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetVideoDecodeOffset");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetVideoDecodeOffset: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->y_offset_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetVideoDecodeOffset");
	left -= sublen;

	if(left != 0)
		return der_error("GetVideoDecodeOffset: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetVideoDecodeOffset>\n");
#endif

	return length;
}

void
free_GetVideoDecodeOffset(GetVideoDecodeOffset *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->x_offset_var);

	free_ObjectReference(&type->y_offset_var);

	return;
}

int
der_decode_GetFocusPosition(FILE *der, GetFocusPosition *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetFocusPosition>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetFocusPosition));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetFocusPosition");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetFocusPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetFocusPosition");
	left -= sublen;

	/* focus_position_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetFocusPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetFocusPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->focus_position_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetFocusPosition");
	left -= sublen;

	if(left != 0)
		return der_error("GetFocusPosition: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetFocusPosition>\n");
#endif

	return length;
}

void
free_GetFocusPosition(GetFocusPosition *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->focus_position_var);

	return;
}

int
der_decode_SetFocusPosition(FILE *der, SetFocusPosition *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetFocusPosition>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetFocusPosition));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetFocusPosition");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetFocusPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetFocusPosition");
	left -= sublen;

	/* new_focus_position */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetFocusPosition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetFocusPosition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_focus_position, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetFocusPosition");
	left -= sublen;

	if(left != 0)
		return der_error("SetFocusPosition: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetFocusPosition>\n");
#endif

	return length;
}

void
free_SetFocusPosition(SetFocusPosition *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_focus_position);

	return;
}

int
der_decode_SetBitmapDecodeOffset(FILE *der, SetBitmapDecodeOffset *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetBitmapDecodeOffset>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetBitmapDecodeOffset));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetBitmapDecodeOffset");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetBitmapDecodeOffset: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetBitmapDecodeOffset");
	left -= sublen;

	/* new_x_offset */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetBitmapDecodeOffset");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetBitmapDecodeOffset: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_x_offset, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetBitmapDecodeOffset");
	left -= sublen;

	/* new_y_offset */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetBitmapDecodeOffset");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetBitmapDecodeOffset: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_y_offset, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetBitmapDecodeOffset");
	left -= sublen;

	if(left != 0)
		return der_error("SetBitmapDecodeOffset: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetBitmapDecodeOffset>\n");
#endif

	return length;
}

void
free_SetBitmapDecodeOffset(SetBitmapDecodeOffset *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_x_offset);

	free_GenericInteger(&type->new_y_offset);

	return;
}

int
der_decode_GetBitmapDecodeOffset(FILE *der, GetBitmapDecodeOffset *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GetBitmapDecodeOffset>\n");
#endif

	VK_memset(type, 0x00, sizeof(GetBitmapDecodeOffset));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetBitmapDecodeOffset");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("GetBitmapDecodeOffset: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetBitmapDecodeOffset");
	left -= sublen;

	/* x_offset_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetBitmapDecodeOffset");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetBitmapDecodeOffset: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->x_offset_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetBitmapDecodeOffset");
	left -= sublen;

	/* y_offset_var */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GetBitmapDecodeOffset");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("GetBitmapDecodeOffset: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->y_offset_var, sublen + tag.length);
	if(sublen < 0)
		return der_error("GetBitmapDecodeOffset");
	left -= sublen;

	if(left != 0)
		return der_error("GetBitmapDecodeOffset: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GetBitmapDecodeOffset>\n");
#endif

	return length;
}

void
free_GetBitmapDecodeOffset(GetBitmapDecodeOffset *type)
{
	free_GenericObjectReference(&type->target);

	free_ObjectReference(&type->x_offset_var);

	free_ObjectReference(&type->y_offset_var);

	return;
}

int
der_decode_SetSliderParameters(FILE *der, SetSliderParameters *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetSliderParameters>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetSliderParameters));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetSliderParameters");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetSliderParameters: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetSliderParameters");
	left -= sublen;

	/* new_min_value */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetSliderParameters");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetSliderParameters: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_min_value, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetSliderParameters");
	left -= sublen;

	/* new_max_value */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetSliderParameters");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetSliderParameters: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_max_value, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetSliderParameters");
	left -= sublen;

	/* new_step_size */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetSliderParameters");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetSliderParameters: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericInteger(der, &type->new_step_size, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetSliderParameters");
	left -= sublen;

	if(left != 0)
		return der_error("SetSliderParameters: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetSliderParameters>\n");
#endif

	return length;
}

void
free_SetSliderParameters(SetSliderParameters *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericInteger(&type->new_min_value);

	free_GenericInteger(&type->new_max_value);

	free_GenericInteger(&type->new_step_size);

	return;
}

int
der_decode_SetInputMask(FILE *der, SetInputMask *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SetInputMask>\n");
#endif

	VK_memset(type, 0x00, sizeof(SetInputMask));

	/* SEQUENCE */
	/* target */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetInputMask");
	if(!(((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetInputMask: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericObjectReference(der, &type->target, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetInputMask");
	left -= sublen;

	/* new_input_mask */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SetInputMask");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	|| (tag.class == DER_CLASS_CONTEXT && tag.number == 236)))
		return der_error("SetInputMask: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_GenericOctetString(der, &type->new_input_mask, sublen + tag.length);
	if(sublen < 0)
		return der_error("SetInputMask");
	left -= sublen;

	if(left != 0)
		return der_error("SetInputMask: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SetInputMask>\n");
#endif

	return length;
}

void
free_SetInputMask(SetInputMask *type)
{
	free_GenericObjectReference(&type->target);

	free_GenericOctetString(&type->new_input_mask);

	return;
}

int
der_decode_ElementaryAction(FILE *der, ElementaryAction *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ElementaryAction>\n");
#endif

	VK_memset(type, 0x00, sizeof(ElementaryAction));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ElementaryAction");
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 115)
	{
		/* activate */
		left -= sublen;
		type->choice = ElementaryAction_activate;
		sublen = der_decode_GenericObjectReference(der, &type->u.activate, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 116)
	{
		/* add */
		left -= sublen;
		type->choice = ElementaryAction_add;
		sublen = der_decode_Add(der, &type->u.add, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 117)
	{
		/* add_item */
		left -= sublen;
		type->choice = ElementaryAction_add_item;
		sublen = der_decode_AddItem(der, &type->u.add_item, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 118)
	{
		/* append */
		left -= sublen;
		type->choice = ElementaryAction_append;
		sublen = der_decode_Append(der, &type->u.append, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 119)
	{
		/* bring_to_front */
		left -= sublen;
		type->choice = ElementaryAction_bring_to_front;
		sublen = der_decode_GenericObjectReference(der, &type->u.bring_to_front, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 120)
	{
		/* call */
		left -= sublen;
		type->choice = ElementaryAction_call;
		sublen = der_decode_Call(der, &type->u.call, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 121)
	{
		/* call_action_slot */
		left -= sublen;
		type->choice = ElementaryAction_call_action_slot;
		sublen = der_decode_CallActionSlot(der, &type->u.call_action_slot, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 122)
	{
		/* clear */
		left -= sublen;
		type->choice = ElementaryAction_clear;
		sublen = der_decode_GenericObjectReference(der, &type->u.clear, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 123)
	{
		/* clone */
		left -= sublen;
		type->choice = ElementaryAction_clone;
		sublen = der_decode_Clone(der, &type->u.clone, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 124)
	{
		/* close_connection */
		left -= sublen;
		type->choice = ElementaryAction_close_connection;
		sublen = der_decode_CloseConnection(der, &type->u.close_connection, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 125)
	{
		/* deactivate */
		left -= sublen;
		type->choice = ElementaryAction_deactivate;
		sublen = der_decode_GenericObjectReference(der, &type->u.deactivate, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 126)
	{
		/* del_item */
		left -= sublen;
		type->choice = ElementaryAction_del_item;
		sublen = der_decode_DelItem(der, &type->u.del_item, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 127)
	{
		/* deselect */
		left -= sublen;
		type->choice = ElementaryAction_deselect;
		sublen = der_decode_GenericObjectReference(der, &type->u.deselect, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 128)
	{
		/* deselect_item */
		left -= sublen;
		type->choice = ElementaryAction_deselect_item;
		sublen = der_decode_DeselectItem(der, &type->u.deselect_item, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 129)
	{
		/* divide */
		left -= sublen;
		type->choice = ElementaryAction_divide;
		sublen = der_decode_Divide(der, &type->u.divide, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 130)
	{
		/* draw_arc */
		left -= sublen;
		type->choice = ElementaryAction_draw_arc;
		sublen = der_decode_DrawArc(der, &type->u.draw_arc, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 131)
	{
		/* draw_line */
		left -= sublen;
		type->choice = ElementaryAction_draw_line;
		sublen = der_decode_DrawLine(der, &type->u.draw_line, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 132)
	{
		/* draw_oval */
		left -= sublen;
		type->choice = ElementaryAction_draw_oval;
		sublen = der_decode_DrawOval(der, &type->u.draw_oval, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 133)
	{
		/* draw_polygon */
		left -= sublen;
		type->choice = ElementaryAction_draw_polygon;
		sublen = der_decode_DrawPolygon(der, &type->u.draw_polygon, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 134)
	{
		/* draw_polyline */
		left -= sublen;
		type->choice = ElementaryAction_draw_polyline;
		sublen = der_decode_DrawPolyline(der, &type->u.draw_polyline, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 135)
	{
		/* draw_rectangle */
		left -= sublen;
		type->choice = ElementaryAction_draw_rectangle;
		sublen = der_decode_DrawRectangle(der, &type->u.draw_rectangle, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 136)
	{
		/* draw_sector */
		left -= sublen;
		type->choice = ElementaryAction_draw_sector;
		sublen = der_decode_DrawSector(der, &type->u.draw_sector, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 137)
	{
		/* fork */
		left -= sublen;
		type->choice = ElementaryAction_fork;
		sublen = der_decode_Fork(der, &type->u.fork, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 138)
	{
		/* get_availability_status */
		left -= sublen;
		type->choice = ElementaryAction_get_availability_status;
		sublen = der_decode_GetAvailabilityStatus(der, &type->u.get_availability_status, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 139)
	{
		/* get_box_size */
		left -= sublen;
		type->choice = ElementaryAction_get_box_size;
		sublen = der_decode_GetBoxSize(der, &type->u.get_box_size, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 140)
	{
		/* get_cell_item */
		left -= sublen;
		type->choice = ElementaryAction_get_cell_item;
		sublen = der_decode_GetCellItem(der, &type->u.get_cell_item, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 141)
	{
		/* get_cursor_position */
		left -= sublen;
		type->choice = ElementaryAction_get_cursor_position;
		sublen = der_decode_GetCursorPosition(der, &type->u.get_cursor_position, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 142)
	{
		/* get_engine_support */
		left -= sublen;
		type->choice = ElementaryAction_get_engine_support;
		sublen = der_decode_GetEngineSupport(der, &type->u.get_engine_support, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 143)
	{
		/* get_entry_point */
		left -= sublen;
		type->choice = ElementaryAction_get_entry_point;
		sublen = der_decode_GetEntryPoint(der, &type->u.get_entry_point, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 144)
	{
		/* get_fill_colour */
		left -= sublen;
		type->choice = ElementaryAction_get_fill_colour;
		sublen = der_decode_GetFillColour(der, &type->u.get_fill_colour, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 145)
	{
		/* get_first_item */
		left -= sublen;
		type->choice = ElementaryAction_get_first_item;
		sublen = der_decode_GetFirstItem(der, &type->u.get_first_item, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 146)
	{
		/* get_highlight_status */
		left -= sublen;
		type->choice = ElementaryAction_get_highlight_status;
		sublen = der_decode_GetHighlightStatus(der, &type->u.get_highlight_status, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 147)
	{
		/* get_interaction_status */
		left -= sublen;
		type->choice = ElementaryAction_get_interaction_status;
		sublen = der_decode_GetInteractionStatus(der, &type->u.get_interaction_status, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 148)
	{
		/* get_item_status */
		left -= sublen;
		type->choice = ElementaryAction_get_item_status;
		sublen = der_decode_GetItemStatus(der, &type->u.get_item_status, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 149)
	{
		/* get_label */
		left -= sublen;
		type->choice = ElementaryAction_get_label;
		sublen = der_decode_GetLabel(der, &type->u.get_label, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 150)
	{
		/* get_last_anchor_fired */
		left -= sublen;
		type->choice = ElementaryAction_get_last_anchor_fired;
		sublen = der_decode_GetLastAnchorFired(der, &type->u.get_last_anchor_fired, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 151)
	{
		/* get_line_colour */
		left -= sublen;
		type->choice = ElementaryAction_get_line_colour;
		sublen = der_decode_GetLineColour(der, &type->u.get_line_colour, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 152)
	{
		/* get_line_style */
		left -= sublen;
		type->choice = ElementaryAction_get_line_style;
		sublen = der_decode_GetLineStyle(der, &type->u.get_line_style, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 153)
	{
		/* get_line_width */
		left -= sublen;
		type->choice = ElementaryAction_get_line_width;
		sublen = der_decode_GetLineWidth(der, &type->u.get_line_width, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 154)
	{
		/* get_list_item */
		left -= sublen;
		type->choice = ElementaryAction_get_list_item;
		sublen = der_decode_GetListItem(der, &type->u.get_list_item, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 155)
	{
		/* get_list_size */
		left -= sublen;
		type->choice = ElementaryAction_get_list_size;
		sublen = der_decode_GetListSize(der, &type->u.get_list_size, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 156)
	{
		/* get_overwrite_mode */
		left -= sublen;
		type->choice = ElementaryAction_get_overwrite_mode;
		sublen = der_decode_GetOverwriteMode(der, &type->u.get_overwrite_mode, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 157)
	{
		/* get_portion */
		left -= sublen;
		type->choice = ElementaryAction_get_portion;
		sublen = der_decode_GetPortion(der, &type->u.get_portion, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 158)
	{
		/* get_position */
		left -= sublen;
		type->choice = ElementaryAction_get_position;
		sublen = der_decode_GetPosition(der, &type->u.get_position, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 159)
	{
		/* get_running_status */
		left -= sublen;
		type->choice = ElementaryAction_get_running_status;
		sublen = der_decode_GetRunningStatus(der, &type->u.get_running_status, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 160)
	{
		/* get_selection_status */
		left -= sublen;
		type->choice = ElementaryAction_get_selection_status;
		sublen = der_decode_GetSelectionStatus(der, &type->u.get_selection_status, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 161)
	{
		/* get_slider_value */
		left -= sublen;
		type->choice = ElementaryAction_get_slider_value;
		sublen = der_decode_GetSliderValue(der, &type->u.get_slider_value, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 162)
	{
		/* get_text_content */
		left -= sublen;
		type->choice = ElementaryAction_get_text_content;
		sublen = der_decode_GetTextContent(der, &type->u.get_text_content, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 163)
	{
		/* get_text_data */
		left -= sublen;
		type->choice = ElementaryAction_get_text_data;
		sublen = der_decode_GetTextData(der, &type->u.get_text_data, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 164)
	{
		/* get_token_position */
		left -= sublen;
		type->choice = ElementaryAction_get_token_position;
		sublen = der_decode_GetTokenPosition(der, &type->u.get_token_position, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 165)
	{
		/* get_volume */
		left -= sublen;
		type->choice = ElementaryAction_get_volume;
		sublen = der_decode_GetVolume(der, &type->u.get_volume, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 166)
	{
		/* launch */
		left -= sublen;
		type->choice = ElementaryAction_launch;
		sublen = der_decode_GenericObjectReference(der, &type->u.launch, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 167)
	{
		/* lock_screen */
		left -= sublen;
		type->choice = ElementaryAction_lock_screen;
		sublen = der_decode_GenericObjectReference(der, &type->u.lock_screen, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 168)
	{
		/* modulo */
		left -= sublen;
		type->choice = ElementaryAction_modulo;
		sublen = der_decode_Modulo(der, &type->u.modulo, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 169)
	{
		/* move */
		left -= sublen;
		type->choice = ElementaryAction_move;
		sublen = der_decode_Move(der, &type->u.move, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 170)
	{
		/* move_to */
		left -= sublen;
		type->choice = ElementaryAction_move_to;
		sublen = der_decode_MoveTo(der, &type->u.move_to, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 171)
	{
		/* multiply */
		left -= sublen;
		type->choice = ElementaryAction_multiply;
		sublen = der_decode_Multiply(der, &type->u.multiply, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 172)
	{
		/* open_connection */
		left -= sublen;
		type->choice = ElementaryAction_open_connection;
		sublen = der_decode_OpenConnection(der, &type->u.open_connection, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 173)
	{
		/* preload */
		left -= sublen;
		type->choice = ElementaryAction_preload;
		sublen = der_decode_GenericObjectReference(der, &type->u.preload, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 174)
	{
		/* put_before */
		left -= sublen;
		type->choice = ElementaryAction_put_before;
		sublen = der_decode_PutBefore(der, &type->u.put_before, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 175)
	{
		/* put_behind */
		left -= sublen;
		type->choice = ElementaryAction_put_behind;
		sublen = der_decode_PutBehind(der, &type->u.put_behind, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 176)
	{
		/* quit */
		left -= sublen;
		type->choice = ElementaryAction_quit;
		sublen = der_decode_GenericObjectReference(der, &type->u.quit, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 177)
	{
		/* read_persistent */
		left -= sublen;
		type->choice = ElementaryAction_read_persistent;
		sublen = der_decode_ReadPersistent(der, &type->u.read_persistent, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 178)
	{
		/* run */
		left -= sublen;
		type->choice = ElementaryAction_run;
		sublen = der_decode_GenericObjectReference(der, &type->u.run, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 179)
	{
		/* scale_bitmap */
		left -= sublen;
		type->choice = ElementaryAction_scale_bitmap;
		sublen = der_decode_ScaleBitmap(der, &type->u.scale_bitmap, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 180)
	{
		/* scale_video */
		left -= sublen;
		type->choice = ElementaryAction_scale_video;
		sublen = der_decode_ScaleVideo(der, &type->u.scale_video, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 181)
	{
		/* scroll_items */
		left -= sublen;
		type->choice = ElementaryAction_scroll_items;
		sublen = der_decode_ScrollItems(der, &type->u.scroll_items, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 182)
	{
		/* select */
		left -= sublen;
		type->choice = ElementaryAction_select;
		sublen = der_decode_GenericObjectReference(der, &type->u.select, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 183)
	{
		/* select_item */
		left -= sublen;
		type->choice = ElementaryAction_select_item;
		sublen = der_decode_SelectItem(der, &type->u.select_item, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 184)
	{
		/* send_event */
		left -= sublen;
		type->choice = ElementaryAction_send_event;
		sublen = der_decode_SendEvent(der, &type->u.send_event, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 185)
	{
		/* send_to_back */
		left -= sublen;
		type->choice = ElementaryAction_send_to_back;
		sublen = der_decode_GenericObjectReference(der, &type->u.send_to_back, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 186)
	{
		/* set_box_size */
		left -= sublen;
		type->choice = ElementaryAction_set_box_size;
		sublen = der_decode_SetBoxSize(der, &type->u.set_box_size, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 187)
	{
		/* set_cache_priority */
		left -= sublen;
		type->choice = ElementaryAction_set_cache_priority;
		sublen = der_decode_SetCachePriority(der, &type->u.set_cache_priority, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 188)
	{
		/* set_counter_end_position */
		left -= sublen;
		type->choice = ElementaryAction_set_counter_end_position;
		sublen = der_decode_SetCounterEndPosition(der, &type->u.set_counter_end_position, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 189)
	{
		/* set_counter_position */
		left -= sublen;
		type->choice = ElementaryAction_set_counter_position;
		sublen = der_decode_SetCounterPosition(der, &type->u.set_counter_position, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 190)
	{
		/* set_counter_trigger */
		left -= sublen;
		type->choice = ElementaryAction_set_counter_trigger;
		sublen = der_decode_SetCounterTrigger(der, &type->u.set_counter_trigger, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 191)
	{
		/* set_cursor_position */
		left -= sublen;
		type->choice = ElementaryAction_set_cursor_position;
		sublen = der_decode_SetCursorPosition(der, &type->u.set_cursor_position, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 192)
	{
		/* set_cursor_shape */
		left -= sublen;
		type->choice = ElementaryAction_set_cursor_shape;
		sublen = der_decode_SetCursorShape(der, &type->u.set_cursor_shape, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 193)
	{
		/* set_data */
		left -= sublen;
		type->choice = ElementaryAction_set_data;
		sublen = der_decode_SetData(der, &type->u.set_data, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 194)
	{
		/* set_entry_point */
		left -= sublen;
		type->choice = ElementaryAction_set_entry_point;
		sublen = der_decode_SetEntryPoint(der, &type->u.set_entry_point, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 195)
	{
		/* set_fill_colour */
		left -= sublen;
		type->choice = ElementaryAction_set_fill_colour;
		sublen = der_decode_SetFillColour(der, &type->u.set_fill_colour, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 196)
	{
		/* set_first_item */
		left -= sublen;
		type->choice = ElementaryAction_set_first_item;
		sublen = der_decode_SetFirstItem(der, &type->u.set_first_item, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 197)
	{
		/* set_font_ref */
		left -= sublen;
		type->choice = ElementaryAction_set_font_ref;
		sublen = der_decode_SetFontRef(der, &type->u.set_font_ref, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 198)
	{
		/* set_highlight_status */
		left -= sublen;
		type->choice = ElementaryAction_set_highlight_status;
		sublen = der_decode_SetHighlightStatus(der, &type->u.set_highlight_status, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 199)
	{
		/* set_interaction_status */
		left -= sublen;
		type->choice = ElementaryAction_set_interaction_status;
		sublen = der_decode_SetInteractionStatus(der, &type->u.set_interaction_status, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 200)
	{
		/* set_label */
		left -= sublen;
		type->choice = ElementaryAction_set_label;
		sublen = der_decode_SetLabel(der, &type->u.set_label, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 201)
	{
		/* set_line_colour */
		left -= sublen;
		type->choice = ElementaryAction_set_line_colour;
		sublen = der_decode_SetLineColour(der, &type->u.set_line_colour, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 202)
	{
		/* set_line_style */
		left -= sublen;
		type->choice = ElementaryAction_set_line_style;
		sublen = der_decode_SetLineStyle(der, &type->u.set_line_style, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 203)
	{
		/* set_line_width */
		left -= sublen;
		type->choice = ElementaryAction_set_line_width;
		sublen = der_decode_SetLineWidth(der, &type->u.set_line_width, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 204)
	{
		/* set_overwrite_mode */
		left -= sublen;
		type->choice = ElementaryAction_set_overwrite_mode;
		sublen = der_decode_SetOverwriteMode(der, &type->u.set_overwrite_mode, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 205)
	{
		/* set_palette_ref */
		left -= sublen;
		type->choice = ElementaryAction_set_palette_ref;
		sublen = der_decode_SetPaletteRef(der, &type->u.set_palette_ref, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 206)
	{
		/* set_portion */
		left -= sublen;
		type->choice = ElementaryAction_set_portion;
		sublen = der_decode_SetPortion(der, &type->u.set_portion, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 207)
	{
		/* set_position */
		left -= sublen;
		type->choice = ElementaryAction_set_position;
		sublen = der_decode_SetPosition(der, &type->u.set_position, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 208)
	{
		/* set_slider_value */
		left -= sublen;
		type->choice = ElementaryAction_set_slider_value;
		sublen = der_decode_SetSliderValue(der, &type->u.set_slider_value, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 209)
	{
		/* set_speed */
		left -= sublen;
		type->choice = ElementaryAction_set_speed;
		sublen = der_decode_SetSpeed(der, &type->u.set_speed, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 210)
	{
		/* set_timer */
		left -= sublen;
		type->choice = ElementaryAction_set_timer;
		sublen = der_decode_SetTimer(der, &type->u.set_timer, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 211)
	{
		/* set_transparency */
		left -= sublen;
		type->choice = ElementaryAction_set_transparency;
		sublen = der_decode_SetTransparency(der, &type->u.set_transparency, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 212)
	{
		/* set_variable */
		left -= sublen;
		type->choice = ElementaryAction_set_variable;
		sublen = der_decode_SetVariable(der, &type->u.set_variable, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 213)
	{
		/* set_volume */
		left -= sublen;
		type->choice = ElementaryAction_set_volume;
		sublen = der_decode_SetVolume(der, &type->u.set_volume, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 214)
	{
		/* spawn */
		left -= sublen;
		type->choice = ElementaryAction_spawn;
		sublen = der_decode_GenericObjectReference(der, &type->u.spawn, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 215)
	{
		/* step */
		left -= sublen;
		type->choice = ElementaryAction_step;
		sublen = der_decode_Step(der, &type->u.step, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 216)
	{
		/* stop */
		left -= sublen;
		type->choice = ElementaryAction_stop;
		sublen = der_decode_GenericObjectReference(der, &type->u.stop, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 217)
	{
		/* store_persistent */
		left -= sublen;
		type->choice = ElementaryAction_store_persistent;
		sublen = der_decode_StorePersistent(der, &type->u.store_persistent, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 218)
	{
		/* subtract */
		left -= sublen;
		type->choice = ElementaryAction_subtract;
		sublen = der_decode_Subtract(der, &type->u.subtract, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 219)
	{
		/* test_variable */
		left -= sublen;
		type->choice = ElementaryAction_test_variable;
		sublen = der_decode_TestVariable(der, &type->u.test_variable, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 220)
	{
		/* toggle */
		left -= sublen;
		type->choice = ElementaryAction_toggle;
		sublen = der_decode_GenericObjectReference(der, &type->u.toggle, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 221)
	{
		/* toggle_item */
		left -= sublen;
		type->choice = ElementaryAction_toggle_item;
		sublen = der_decode_ToggleItem(der, &type->u.toggle_item, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 222)
	{
		/* transition_to */
		left -= sublen;
		type->choice = ElementaryAction_transition_to;
		sublen = der_decode_TransitionTo(der, &type->u.transition_to, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 223)
	{
		/* unload */
		left -= sublen;
		type->choice = ElementaryAction_unload;
		sublen = der_decode_GenericObjectReference(der, &type->u.unload, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 224)
	{
		/* unlock_screen */
		left -= sublen;
		type->choice = ElementaryAction_unlock_screen;
		sublen = der_decode_GenericObjectReference(der, &type->u.unlock_screen, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 237)
	{
		/* set_background_colour */
		left -= sublen;
		type->choice = ElementaryAction_set_background_colour;
		sublen = der_decode_SetBackgroundColour(der, &type->u.set_background_colour, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 238)
	{
		/* set_cell_position */
		left -= sublen;
		type->choice = ElementaryAction_set_cell_position;
		sublen = der_decode_SetCellPosition(der, &type->u.set_cell_position, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 239)
	{
		/* set_input_register */
		left -= sublen;
		type->choice = ElementaryAction_set_input_register;
		sublen = der_decode_SetInputRegister(der, &type->u.set_input_register, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 240)
	{
		/* set_text_colour */
		left -= sublen;
		type->choice = ElementaryAction_set_text_colour;
		sublen = der_decode_SetTextColour(der, &type->u.set_text_colour, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 241)
	{
		/* set_font_attributes */
		left -= sublen;
		type->choice = ElementaryAction_set_font_attributes;
		sublen = der_decode_SetFontAttributes(der, &type->u.set_font_attributes, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 242)
	{
		/* set_video_decode_offset */
		left -= sublen;
		type->choice = ElementaryAction_set_video_decode_offset;
		sublen = der_decode_SetVideoDecodeOffset(der, &type->u.set_video_decode_offset, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 243)
	{
		/* get_video_decode_offset */
		left -= sublen;
		type->choice = ElementaryAction_get_video_decode_offset;
		sublen = der_decode_GetVideoDecodeOffset(der, &type->u.get_video_decode_offset, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 244)
	{
		/* get_focus_position */
		left -= sublen;
		type->choice = ElementaryAction_get_focus_position;
		sublen = der_decode_GetFocusPosition(der, &type->u.get_focus_position, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 245)
	{
		/* set_focus_position */
		left -= sublen;
		type->choice = ElementaryAction_set_focus_position;
		sublen = der_decode_SetFocusPosition(der, &type->u.set_focus_position, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 246)
	{
		/* set_bitmap_decode_offset */
		left -= sublen;
		type->choice = ElementaryAction_set_bitmap_decode_offset;
		sublen = der_decode_SetBitmapDecodeOffset(der, &type->u.set_bitmap_decode_offset, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 247)
	{
		/* get_bitmap_decode_offset */
		left -= sublen;
		type->choice = ElementaryAction_get_bitmap_decode_offset;
		sublen = der_decode_GetBitmapDecodeOffset(der, &type->u.get_bitmap_decode_offset, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 248)
	{
		/* set_slider_parameters */
		left -= sublen;
		type->choice = ElementaryAction_set_slider_parameters;
		sublen = der_decode_SetSliderParameters(der, &type->u.set_slider_parameters, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 254)
	{
		/* set_input_mask */
		left -= sublen;
		type->choice = ElementaryAction_set_input_mask;
		sublen = der_decode_SetInputMask(der, &type->u.set_input_mask, tag.length);
		if(sublen < 0)
			return der_error("ElementaryAction");
		left -= sublen;
	}
	else
		return der_error("ElementaryAction: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("ElementaryAction: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ElementaryAction>\n");
#endif

	return length;
}

void
free_ElementaryAction(ElementaryAction *type)
{
	switch(type->choice)
	{
	case ElementaryAction_activate:
		free_GenericObjectReference(&type->u.activate);
		break;

	case ElementaryAction_add:
		free_Add(&type->u.add);
		break;

	case ElementaryAction_add_item:
		free_AddItem(&type->u.add_item);
		break;

	case ElementaryAction_append:
		free_Append(&type->u.append);
		break;

	case ElementaryAction_bring_to_front:
		free_GenericObjectReference(&type->u.bring_to_front);
		break;

	case ElementaryAction_call:
		free_Call(&type->u.call);
		break;

	case ElementaryAction_call_action_slot:
		free_CallActionSlot(&type->u.call_action_slot);
		break;

	case ElementaryAction_clear:
		free_GenericObjectReference(&type->u.clear);
		break;

	case ElementaryAction_clone:
		free_Clone(&type->u.clone);
		break;

	case ElementaryAction_close_connection:
		free_CloseConnection(&type->u.close_connection);
		break;

	case ElementaryAction_deactivate:
		free_GenericObjectReference(&type->u.deactivate);
		break;

	case ElementaryAction_del_item:
		free_DelItem(&type->u.del_item);
		break;

	case ElementaryAction_deselect:
		free_GenericObjectReference(&type->u.deselect);
		break;

	case ElementaryAction_deselect_item:
		free_DeselectItem(&type->u.deselect_item);
		break;

	case ElementaryAction_divide:
		free_Divide(&type->u.divide);
		break;

	case ElementaryAction_draw_arc:
		free_DrawArc(&type->u.draw_arc);
		break;

	case ElementaryAction_draw_line:
		free_DrawLine(&type->u.draw_line);
		break;

	case ElementaryAction_draw_oval:
		free_DrawOval(&type->u.draw_oval);
		break;

	case ElementaryAction_draw_polygon:
		free_DrawPolygon(&type->u.draw_polygon);
		break;

	case ElementaryAction_draw_polyline:
		free_DrawPolyline(&type->u.draw_polyline);
		break;

	case ElementaryAction_draw_rectangle:
		free_DrawRectangle(&type->u.draw_rectangle);
		break;

	case ElementaryAction_draw_sector:
		free_DrawSector(&type->u.draw_sector);
		break;

	case ElementaryAction_fork:
		free_Fork(&type->u.fork);
		break;

	case ElementaryAction_get_availability_status:
		free_GetAvailabilityStatus(&type->u.get_availability_status);
		break;

	case ElementaryAction_get_box_size:
		free_GetBoxSize(&type->u.get_box_size);
		break;

	case ElementaryAction_get_cell_item:
		free_GetCellItem(&type->u.get_cell_item);
		break;

	case ElementaryAction_get_cursor_position:
		free_GetCursorPosition(&type->u.get_cursor_position);
		break;

	case ElementaryAction_get_engine_support:
		free_GetEngineSupport(&type->u.get_engine_support);
		break;

	case ElementaryAction_get_entry_point:
		free_GetEntryPoint(&type->u.get_entry_point);
		break;

	case ElementaryAction_get_fill_colour:
		free_GetFillColour(&type->u.get_fill_colour);
		break;

	case ElementaryAction_get_first_item:
		free_GetFirstItem(&type->u.get_first_item);
		break;

	case ElementaryAction_get_highlight_status:
		free_GetHighlightStatus(&type->u.get_highlight_status);
		break;

	case ElementaryAction_get_interaction_status:
		free_GetInteractionStatus(&type->u.get_interaction_status);
		break;

	case ElementaryAction_get_item_status:
		free_GetItemStatus(&type->u.get_item_status);
		break;

	case ElementaryAction_get_label:
		free_GetLabel(&type->u.get_label);
		break;

	case ElementaryAction_get_last_anchor_fired:
		free_GetLastAnchorFired(&type->u.get_last_anchor_fired);
		break;

	case ElementaryAction_get_line_colour:
		free_GetLineColour(&type->u.get_line_colour);
		break;

	case ElementaryAction_get_line_style:
		free_GetLineStyle(&type->u.get_line_style);
		break;

	case ElementaryAction_get_line_width:
		free_GetLineWidth(&type->u.get_line_width);
		break;

	case ElementaryAction_get_list_item:
		free_GetListItem(&type->u.get_list_item);
		break;

	case ElementaryAction_get_list_size:
		free_GetListSize(&type->u.get_list_size);
		break;

	case ElementaryAction_get_overwrite_mode:
		free_GetOverwriteMode(&type->u.get_overwrite_mode);
		break;

	case ElementaryAction_get_portion:
		free_GetPortion(&type->u.get_portion);
		break;

	case ElementaryAction_get_position:
		free_GetPosition(&type->u.get_position);
		break;

	case ElementaryAction_get_running_status:
		free_GetRunningStatus(&type->u.get_running_status);
		break;

	case ElementaryAction_get_selection_status:
		free_GetSelectionStatus(&type->u.get_selection_status);
		break;

	case ElementaryAction_get_slider_value:
		free_GetSliderValue(&type->u.get_slider_value);
		break;

	case ElementaryAction_get_text_content:
		free_GetTextContent(&type->u.get_text_content);
		break;

	case ElementaryAction_get_text_data:
		free_GetTextData(&type->u.get_text_data);
		break;

	case ElementaryAction_get_token_position:
		free_GetTokenPosition(&type->u.get_token_position);
		break;

	case ElementaryAction_get_volume:
		free_GetVolume(&type->u.get_volume);
		break;

	case ElementaryAction_launch:
		free_GenericObjectReference(&type->u.launch);
		break;

	case ElementaryAction_lock_screen:
		free_GenericObjectReference(&type->u.lock_screen);
		break;

	case ElementaryAction_modulo:
		free_Modulo(&type->u.modulo);
		break;

	case ElementaryAction_move:
		free_Move(&type->u.move);
		break;

	case ElementaryAction_move_to:
		free_MoveTo(&type->u.move_to);
		break;

	case ElementaryAction_multiply:
		free_Multiply(&type->u.multiply);
		break;

	case ElementaryAction_open_connection:
		free_OpenConnection(&type->u.open_connection);
		break;

	case ElementaryAction_preload:
		free_GenericObjectReference(&type->u.preload);
		break;

	case ElementaryAction_put_before:
		free_PutBefore(&type->u.put_before);
		break;

	case ElementaryAction_put_behind:
		free_PutBehind(&type->u.put_behind);
		break;

	case ElementaryAction_quit:
		free_GenericObjectReference(&type->u.quit);
		break;

	case ElementaryAction_read_persistent:
		free_ReadPersistent(&type->u.read_persistent);
		break;

	case ElementaryAction_run:
		free_GenericObjectReference(&type->u.run);
		break;

	case ElementaryAction_scale_bitmap:
		free_ScaleBitmap(&type->u.scale_bitmap);
		break;

	case ElementaryAction_scale_video:
		free_ScaleVideo(&type->u.scale_video);
		break;

	case ElementaryAction_scroll_items:
		free_ScrollItems(&type->u.scroll_items);
		break;

	case ElementaryAction_select:
		free_GenericObjectReference(&type->u.select);
		break;

	case ElementaryAction_select_item:
		free_SelectItem(&type->u.select_item);
		break;

	case ElementaryAction_send_event:
		free_SendEvent(&type->u.send_event);
		break;

	case ElementaryAction_send_to_back:
		free_GenericObjectReference(&type->u.send_to_back);
		break;

	case ElementaryAction_set_box_size:
		free_SetBoxSize(&type->u.set_box_size);
		break;

	case ElementaryAction_set_cache_priority:
		free_SetCachePriority(&type->u.set_cache_priority);
		break;

	case ElementaryAction_set_counter_end_position:
		free_SetCounterEndPosition(&type->u.set_counter_end_position);
		break;

	case ElementaryAction_set_counter_position:
		free_SetCounterPosition(&type->u.set_counter_position);
		break;

	case ElementaryAction_set_counter_trigger:
		free_SetCounterTrigger(&type->u.set_counter_trigger);
		break;

	case ElementaryAction_set_cursor_position:
		free_SetCursorPosition(&type->u.set_cursor_position);
		break;

	case ElementaryAction_set_cursor_shape:
		free_SetCursorShape(&type->u.set_cursor_shape);
		break;

	case ElementaryAction_set_data:
		free_SetData(&type->u.set_data);
		break;

	case ElementaryAction_set_entry_point:
		free_SetEntryPoint(&type->u.set_entry_point);
		break;

	case ElementaryAction_set_fill_colour:
		free_SetFillColour(&type->u.set_fill_colour);
		break;

	case ElementaryAction_set_first_item:
		free_SetFirstItem(&type->u.set_first_item);
		break;

	case ElementaryAction_set_font_ref:
		free_SetFontRef(&type->u.set_font_ref);
		break;

	case ElementaryAction_set_highlight_status:
		free_SetHighlightStatus(&type->u.set_highlight_status);
		break;

	case ElementaryAction_set_interaction_status:
		free_SetInteractionStatus(&type->u.set_interaction_status);
		break;

	case ElementaryAction_set_label:
		free_SetLabel(&type->u.set_label);
		break;

	case ElementaryAction_set_line_colour:
		free_SetLineColour(&type->u.set_line_colour);
		break;

	case ElementaryAction_set_line_style:
		free_SetLineStyle(&type->u.set_line_style);
		break;

	case ElementaryAction_set_line_width:
		free_SetLineWidth(&type->u.set_line_width);
		break;

	case ElementaryAction_set_overwrite_mode:
		free_SetOverwriteMode(&type->u.set_overwrite_mode);
		break;

	case ElementaryAction_set_palette_ref:
		free_SetPaletteRef(&type->u.set_palette_ref);
		break;

	case ElementaryAction_set_portion:
		free_SetPortion(&type->u.set_portion);
		break;

	case ElementaryAction_set_position:
		free_SetPosition(&type->u.set_position);
		break;

	case ElementaryAction_set_slider_value:
		free_SetSliderValue(&type->u.set_slider_value);
		break;

	case ElementaryAction_set_speed:
		free_SetSpeed(&type->u.set_speed);
		break;

	case ElementaryAction_set_timer:
		free_SetTimer(&type->u.set_timer);
		break;

	case ElementaryAction_set_transparency:
		free_SetTransparency(&type->u.set_transparency);
		break;

	case ElementaryAction_set_variable:
		free_SetVariable(&type->u.set_variable);
		break;

	case ElementaryAction_set_volume:
		free_SetVolume(&type->u.set_volume);
		break;

	case ElementaryAction_spawn:
		free_GenericObjectReference(&type->u.spawn);
		break;

	case ElementaryAction_step:
		free_Step(&type->u.step);
		break;

	case ElementaryAction_stop:
		free_GenericObjectReference(&type->u.stop);
		break;

	case ElementaryAction_store_persistent:
		free_StorePersistent(&type->u.store_persistent);
		break;

	case ElementaryAction_subtract:
		free_Subtract(&type->u.subtract);
		break;

	case ElementaryAction_test_variable:
		free_TestVariable(&type->u.test_variable);
		break;

	case ElementaryAction_toggle:
		free_GenericObjectReference(&type->u.toggle);
		break;

	case ElementaryAction_toggle_item:
		free_ToggleItem(&type->u.toggle_item);
		break;

	case ElementaryAction_transition_to:
		free_TransitionTo(&type->u.transition_to);
		break;

	case ElementaryAction_unload:
		free_GenericObjectReference(&type->u.unload);
		break;

	case ElementaryAction_unlock_screen:
		free_GenericObjectReference(&type->u.unlock_screen);
		break;

	case ElementaryAction_set_background_colour:
		free_SetBackgroundColour(&type->u.set_background_colour);
		break;

	case ElementaryAction_set_cell_position:
		free_SetCellPosition(&type->u.set_cell_position);
		break;

	case ElementaryAction_set_input_register:
		free_SetInputRegister(&type->u.set_input_register);
		break;

	case ElementaryAction_set_text_colour:
		free_SetTextColour(&type->u.set_text_colour);
		break;

	case ElementaryAction_set_font_attributes:
		free_SetFontAttributes(&type->u.set_font_attributes);
		break;

	case ElementaryAction_set_video_decode_offset:
		free_SetVideoDecodeOffset(&type->u.set_video_decode_offset);
		break;

	case ElementaryAction_get_video_decode_offset:
		free_GetVideoDecodeOffset(&type->u.get_video_decode_offset);
		break;

	case ElementaryAction_get_focus_position:
		free_GetFocusPosition(&type->u.get_focus_position);
		break;

	case ElementaryAction_set_focus_position:
		free_SetFocusPosition(&type->u.set_focus_position);
		break;

	case ElementaryAction_set_bitmap_decode_offset:
		free_SetBitmapDecodeOffset(&type->u.set_bitmap_decode_offset);
		break;

	case ElementaryAction_get_bitmap_decode_offset:
		free_GetBitmapDecodeOffset(&type->u.get_bitmap_decode_offset);
		break;

	case ElementaryAction_set_slider_parameters:
		free_SetSliderParameters(&type->u.set_slider_parameters);
		break;

	case ElementaryAction_set_input_mask:
		free_SetInputMask(&type->u.set_input_mask);
		break;

	default:
		der_error("free_ElementaryAction: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_ActionClass(FILE *der, ActionClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ActionClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(ActionClass));

	/* SEQUENCE OF ElementaryAction */
	while(left > 0)
	{
		LIST_TYPE(ElementaryAction) *new_item;
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("ActionClass");
		if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 115)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 116)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 117)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 118)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 119)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 120)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 121)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 122)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 123)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 124)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 125)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 126)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 127)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 128)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 129)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 130)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 131)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 132)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 133)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 134)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 135)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 136)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 137)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 138)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 139)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 140)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 141)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 142)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 143)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 144)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 145)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 146)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 147)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 148)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 149)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 150)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 151)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 152)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 153)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 154)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 155)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 156)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 157)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 158)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 159)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 160)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 161)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 162)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 163)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 164)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 165)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 166)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 167)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 168)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 169)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 170)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 171)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 172)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 173)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 174)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 175)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 176)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 177)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 178)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 179)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 180)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 181)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 182)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 183)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 184)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 185)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 186)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 187)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 188)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 189)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 190)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 191)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 192)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 193)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 194)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 195)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 196)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 197)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 198)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 199)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 200)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 201)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 202)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 203)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 204)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 205)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 206)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 207)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 208)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 209)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 210)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 211)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 212)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 213)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 214)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 215)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 216)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 217)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 218)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 219)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 220)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 221)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 222)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 223)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 224)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 237)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 238)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 239)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 240)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 241)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 242)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 243)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 244)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 245)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 246)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 247)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 248)
		|| (tag.class == DER_CLASS_CONTEXT && tag.number == 254)))
			return der_error("ActionClass: unexpected tag %u", tag.number);
		fseek(der, -sublen, SEEK_CUR);
		if((new_item = der_alloc(sizeof(LIST_TYPE(ElementaryAction)))) == NULL)
			return der_error("ActionClass: out of memory");
		LIST_APPEND(type, new_item);
		sublen = der_decode_ElementaryAction(der, &new_item->item, sublen + tag.length);
		if(sublen < 0)
			return der_error("ActionClass");
		left -= sublen;
	}

	if(left != 0)
		return der_error("ActionClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ActionClass>\n");
#endif

	return length;
}

void
free_ActionClass(ActionClass *type)
{
	LIST_FREE_ITEMS(type, ElementaryAction, free_ElementaryAction, der_free);

	return;
}

int
der_decode_ProgramClass(FILE *der, ProgramClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ProgramClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(ProgramClass));

	/* DEFAULT values */
	type->initially_active = false;
	type->initially_available = true;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("ProgramClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("ProgramClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT false */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("ProgramClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("ProgramClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("ProgramClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("ProgramClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 64)
		{
			/* name */
			left -= sublen;
			sublen = der_decode_OctetString(der, &type->name, tag.length);
			if(sublen < 0)
				return der_error("ProgramClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 65)
		{
			/* initially_available DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_available, tag.length);
			if(sublen < 0)
				return der_error("ProgramClass");
			left -= sublen;
		}
		else
			return der_error("ProgramClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("ProgramClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ProgramClass>\n");
#endif

	return length;
}

void
free_ProgramClass(ProgramClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OctetString(&type->name);

	return;
}

int
der_decode_ResidentProgramClass(FILE *der, ResidentProgramClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<ResidentProgramClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(ResidentProgramClass));

	sublen = der_decode_ProgramClass(der, (ProgramClass *) type, length);
	if(sublen < 0)
		return der_error("ResidentProgramClass");
	left -= sublen;

	if(left != 0)
		return der_error("ResidentProgramClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ResidentProgramClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_ResidentProgramClass;

	return length;
}

void
free_ResidentProgramClass(ResidentProgramClass *type)
{
	free_ProgramClass((ProgramClass *) type);

	return;
}

int
der_decode_RemoteProgramClass(FILE *der, RemoteProgramClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<RemoteProgramClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(RemoteProgramClass));

	/* DEFAULT values */
	type->initially_active = false;
	type->initially_available = true;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("RemoteProgramClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("RemoteProgramClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT false */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("RemoteProgramClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("RemoteProgramClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("RemoteProgramClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("RemoteProgramClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 64)
		{
			/* name */
			left -= sublen;
			sublen = der_decode_OctetString(der, &type->name, tag.length);
			if(sublen < 0)
				return der_error("RemoteProgramClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 65)
		{
			/* initially_available DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_available, tag.length);
			if(sublen < 0)
				return der_error("RemoteProgramClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 66)
		{
			/* program_connection_tag OPTIONAL */
			left -= sublen;
			type->have_program_connection_tag = true;
			sublen = der_decode_Integer(der, (int *) &type->program_connection_tag, tag.length);
			if(sublen < 0)
				return der_error("RemoteProgramClass");
			left -= sublen;
		}
		else
			return der_error("RemoteProgramClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("RemoteProgramClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</RemoteProgramClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_RemoteProgramClass;

	return length;
}

void
free_RemoteProgramClass(RemoteProgramClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OctetString(&type->name);

	return;
}

int
der_decode_InterchangedProgramClass(FILE *der, InterchangedProgramClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<InterchangedProgramClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(InterchangedProgramClass));

	sublen = der_decode_ProgramClass(der, (ProgramClass *) type, length);
	if(sublen < 0)
		return der_error("InterchangedProgramClass");
	left -= sublen;

	if(left != 0)
		return der_error("InterchangedProgramClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</InterchangedProgramClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_InterchangedProgramClass;

	return length;
}

void
free_InterchangedProgramClass(InterchangedProgramClass *type)
{
	free_ProgramClass((ProgramClass *) type);

	return;
}

int
der_decode_PaletteClass(FILE *der, PaletteClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<PaletteClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(PaletteClass));

	sublen = der_decode_IngredientClass(der, (IngredientClass *) type, length);
	if(sublen < 0)
		return der_error("PaletteClass");
	left -= sublen;

	if(left != 0)
		return der_error("PaletteClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</PaletteClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_PaletteClass;

	return length;
}

void
free_PaletteClass(PaletteClass *type)
{
	free_IngredientClass((IngredientClass *) type);

	return;
}

int
der_decode_FontClass(FILE *der, FontClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<FontClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(FontClass));

	sublen = der_decode_IngredientClass(der, (IngredientClass *) type, length);
	if(sublen < 0)
		return der_error("FontClass");
	left -= sublen;

	if(left != 0)
		return der_error("FontClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</FontClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_FontClass;

	return length;
}

void
free_FontClass(FontClass *type)
{
	free_IngredientClass((IngredientClass *) type);

	return;
}

int
der_decode_CursorShapeClass(FILE *der, CursorShapeClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<CursorShapeClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(CursorShapeClass));

	sublen = der_decode_IngredientClass(der, (IngredientClass *) type, length);
	if(sublen < 0)
		return der_error("CursorShapeClass");
	left -= sublen;

	if(left != 0)
		return der_error("CursorShapeClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</CursorShapeClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_CursorShapeClass;

	return length;
}

void
free_CursorShapeClass(CursorShapeClass *type)
{
	free_IngredientClass((IngredientClass *) type);

	return;
}

int
der_decode_OriginalValue(FILE *der, OriginalValue *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<OriginalValue>\n");
#endif

	VK_memset(type, 0x00, sizeof(OriginalValue));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("OriginalValue");
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 1)
	{
		/* boolean */
		left -= sublen;
		type->choice = OriginalValue_boolean;
		sublen = der_decode_Boolean(der, &type->u.boolean, tag.length);
		if(sublen < 0)
			return der_error("OriginalValue");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	{
		/* integer */
		left -= sublen;
		type->choice = OriginalValue_integer;
		sublen = der_decode_Integer(der, (int *) &type->u.integer, tag.length);
		if(sublen < 0)
			return der_error("OriginalValue");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	{
		/* octetstring */
		left -= sublen;
		type->choice = OriginalValue_octetstring;
		sublen = der_decode_OctetString(der, &type->u.octetstring, tag.length);
		if(sublen < 0)
			return der_error("OriginalValue");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 68)
	{
		/* object_reference */
		left -= sublen;
		type->choice = OriginalValue_object_reference;
		sublen = der_decode_ObjectReference(der, &type->u.object_reference, tag.length);
		if(sublen < 0)
			return der_error("OriginalValue");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 69)
	{
		/* content_reference */
		left -= sublen;
		type->choice = OriginalValue_content_reference;
		sublen = der_decode_ContentReference(der, &type->u.content_reference, tag.length);
		if(sublen < 0)
			return der_error("OriginalValue");
		left -= sublen;
	}
	else
		return der_error("OriginalValue: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("OriginalValue: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</OriginalValue>\n");
#endif

	return length;
}

void
free_OriginalValue(OriginalValue *type)
{
	switch(type->choice)
	{
	case OriginalValue_boolean:
		break;

	case OriginalValue_integer:
		break;

	case OriginalValue_octetstring:
		free_OctetString(&type->u.octetstring);
		break;

	case OriginalValue_object_reference:
		free_ObjectReference(&type->u.object_reference);
		break;

	case OriginalValue_content_reference:
		free_ContentReference(&type->u.content_reference);
		break;

	default:
		der_error("free_OriginalValue: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_VariableClass(FILE *der, VariableClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<VariableClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(VariableClass));

	/* DEFAULT values */
	type->initially_active = true;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("VariableClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("VariableClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("VariableClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("VariableClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("VariableClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("VariableClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 67)
		{
			/* original_value */
			left -= sublen;
			sublen = der_decode_OriginalValue(der, &type->original_value, tag.length);
			if(sublen < 0)
				return der_error("VariableClass");
			left -= sublen;
		}
		else
			return der_error("VariableClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("VariableClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</VariableClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_VariableClass;

	return length;
}

void
free_VariableClass(VariableClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OriginalValue(&type->original_value);

	return;
}

int
der_decode_BooleanVariableClass(FILE *der, BooleanVariableClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<BooleanVariableClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(BooleanVariableClass));

	sublen = der_decode_VariableClass(der, (VariableClass *) type, length);
	if(sublen < 0)
		return der_error("BooleanVariableClass");
	left -= sublen;

	if(left != 0)
		return der_error("BooleanVariableClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</BooleanVariableClass>\n");
#endif

	return length;
}

void
free_BooleanVariableClass(BooleanVariableClass *type)
{
	free_VariableClass((VariableClass *) type);

	return;
}

int
der_decode_IntegerVariableClass(FILE *der, IntegerVariableClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<IntegerVariableClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(IntegerVariableClass));

	sublen = der_decode_VariableClass(der, (VariableClass *) type, length);
	if(sublen < 0)
		return der_error("IntegerVariableClass");
	left -= sublen;

	if(left != 0)
		return der_error("IntegerVariableClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</IntegerVariableClass>\n");
#endif

	return length;
}

void
free_IntegerVariableClass(IntegerVariableClass *type)
{
	free_VariableClass((VariableClass *) type);

	return;
}

int
der_decode_OctetStringVariableClass(FILE *der, OctetStringVariableClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<OctetStringVariableClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(OctetStringVariableClass));

	sublen = der_decode_VariableClass(der, (VariableClass *) type, length);
	if(sublen < 0)
		return der_error("OctetStringVariableClass");
	left -= sublen;

	if(left != 0)
		return der_error("OctetStringVariableClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</OctetStringVariableClass>\n");
#endif

	return length;
}

void
free_OctetStringVariableClass(OctetStringVariableClass *type)
{
	free_VariableClass((VariableClass *) type);

	return;
}

int
der_decode_ObjectRefVariableClass(FILE *der, ObjectRefVariableClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<ObjectRefVariableClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(ObjectRefVariableClass));

	sublen = der_decode_VariableClass(der, (VariableClass *) type, length);
	if(sublen < 0)
		return der_error("ObjectRefVariableClass");
	left -= sublen;

	if(left != 0)
		return der_error("ObjectRefVariableClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ObjectRefVariableClass>\n");
#endif

	return length;
}

void
free_ObjectRefVariableClass(ObjectRefVariableClass *type)
{
	free_VariableClass((VariableClass *) type);

	return;
}

int
der_decode_ContentRefVariableClass(FILE *der, ContentRefVariableClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<ContentRefVariableClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(ContentRefVariableClass));

	sublen = der_decode_VariableClass(der, (VariableClass *) type, length);
	if(sublen < 0)
		return der_error("ContentRefVariableClass");
	left -= sublen;

	if(left != 0)
		return der_error("ContentRefVariableClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ContentRefVariableClass>\n");
#endif

	return length;
}

void
free_ContentRefVariableClass(ContentRefVariableClass *type)
{
	free_VariableClass((VariableClass *) type);

	return;
}

int
der_decode_EventData(FILE *der, EventData *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<EventData>\n");
#endif

	VK_memset(type, 0x00, sizeof(EventData));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("EventData");
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 1)
	{
		/* boolean */
		left -= sublen;
		type->choice = EventData_boolean;
		sublen = der_decode_Boolean(der, &type->u.boolean, tag.length);
		if(sublen < 0)
			return der_error("EventData");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	{
		/* integer */
		left -= sublen;
		type->choice = EventData_integer;
		sublen = der_decode_Integer(der, (int *) &type->u.integer, tag.length);
		if(sublen < 0)
			return der_error("EventData");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	{
		/* octetstring */
		left -= sublen;
		type->choice = EventData_octetstring;
		sublen = der_decode_OctetString(der, &type->u.octetstring, tag.length);
		if(sublen < 0)
			return der_error("EventData");
		left -= sublen;
	}
	else
		return der_error("EventData: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("EventData: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</EventData>\n");
#endif

	return length;
}

void
free_EventData(EventData *type)
{
	switch(type->choice)
	{
	case EventData_boolean:
		break;

	case EventData_integer:
		break;

	case EventData_octetstring:
		free_OctetString(&type->u.octetstring);
		break;

	default:
		der_error("free_EventData: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_LinkCondition(FILE *der, LinkCondition *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<LinkCondition>\n");
#endif

	VK_memset(type, 0x00, sizeof(LinkCondition));

	/* SEQUENCE */
	/* event_source */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("LinkCondition");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("LinkCondition: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->event_source, sublen + tag.length);
	if(sublen < 0)
		return der_error("LinkCondition");
	left -= sublen;

	/* event_type */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("LinkCondition");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 10))
		return der_error("LinkCondition: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_EventType(der, &type->event_type, tag.length);
	if(sublen < 0)
		return der_error("LinkCondition");
	left -= sublen;

	/* event_data OPTIONAL */
	if(left > 0)
	{
		sublen = der_peek_Tag(der, &tag);
		if(sublen < 0)
			return der_error("LinkCondition");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 1)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 4))
		{
			type->have_event_data = true;
			sublen = der_decode_EventData(der, &type->event_data, sublen + tag.length);
			if(sublen < 0)
				return der_error("LinkCondition");
			left -= sublen;
		}
	}

	if(left != 0)
		return der_error("LinkCondition: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</LinkCondition>\n");
#endif

	return length;
}

void
free_LinkCondition(LinkCondition *type)
{
	free_ObjectReference(&type->event_source);

	free_EventType(&type->event_type);

	if(type->have_event_data)
		free_EventData(&type->event_data);

	return;
}

int
der_decode_LinkClass(FILE *der, LinkClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<LinkClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(LinkClass));

	/* DEFAULT values */
	type->initially_active = true;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("LinkClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("LinkClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("LinkClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("LinkClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("LinkClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("LinkClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 62)
		{
			/* link_condition */
			left -= sublen;
			sublen = der_decode_LinkCondition(der, &type->link_condition, tag.length);
			if(sublen < 0)
				return der_error("LinkClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 63)
		{
			/* link_effect */
			left -= sublen;
			sublen = der_decode_ActionClass(der, &type->link_effect, tag.length);
			if(sublen < 0)
				return der_error("LinkClass");
			left -= sublen;
		}
		else
			return der_error("LinkClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("LinkClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</LinkClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_LinkClass;

	return length;
}

void
free_LinkClass(LinkClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_LinkCondition(&type->link_condition);

	free_ActionClass(&type->link_effect);

	return;
}

int
der_decode_AudioClass(FILE *der, AudioClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<AudioClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(AudioClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->original_volume = 0;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("AudioClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("AudioClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("AudioClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("AudioClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("AudioClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("AudioClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 98)
		{
			/* component_tag */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->component_tag, tag.length);
			if(sublen < 0)
				return der_error("AudioClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 99)
		{
			/* original_volume DEFAULT 0 */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->original_volume, tag.length);
			if(sublen < 0)
				return der_error("AudioClass");
			left -= sublen;
		}
		else
			return der_error("AudioClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("AudioClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</AudioClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_AudioClass;

	return length;
}

void
free_AudioClass(AudioClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	return;
}

int
der_decode_OriginalBoxSize(FILE *der, OriginalBoxSize *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<OriginalBoxSize>\n");
#endif

	VK_memset(type, 0x00, sizeof(OriginalBoxSize));

	/* SEQUENCE */
	/* x_length */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("OriginalBoxSize");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2))
		return der_error("OriginalBoxSize: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_Integer(der, (int *) &type->x_length, tag.length);
	if(sublen < 0)
		return der_error("OriginalBoxSize");
	left -= sublen;

	/* y_length */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("OriginalBoxSize");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2))
		return der_error("OriginalBoxSize: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_Integer(der, (int *) &type->y_length, tag.length);
	if(sublen < 0)
		return der_error("OriginalBoxSize");
	left -= sublen;

	if(left != 0)
		return der_error("OriginalBoxSize: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</OriginalBoxSize>\n");
#endif

	return length;
}

void
free_OriginalBoxSize(OriginalBoxSize *type)
{
	return;
}

int
der_decode_XYPosition(FILE *der, XYPosition *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<XYPosition>\n");
#endif

	VK_memset(type, 0x00, sizeof(XYPosition));

	/* SEQUENCE */
	/* x_position */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("XYPosition");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2))
		return der_error("XYPosition: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_Integer(der, (int *) &type->x_position, tag.length);
	if(sublen < 0)
		return der_error("XYPosition");
	left -= sublen;

	/* y_position */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("XYPosition");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2))
		return der_error("XYPosition: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_Integer(der, (int *) &type->y_position, tag.length);
	if(sublen < 0)
		return der_error("XYPosition");
	left -= sublen;

	if(left != 0)
		return der_error("XYPosition: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</XYPosition>\n");
#endif

	return length;
}

void
free_XYPosition(XYPosition *type)
{
	return;
}

int
der_decode_Termination(FILE *der, Termination *type, int length)
{
	int left = length;
	int sublen;
	int value;

#if (DER_VERBOSE)
	VK_Print("<Termination>\n");
#endif

	VK_memset(type, 0x00, sizeof(Termination));

	/* ENUMERATED */
	sublen = der_decode_Integer(der, (int *) &value, length);
	if(sublen < 0)
		return der_error("Termination");
	left -= sublen;

	*type = (Termination) value;

	if(left != 0)
		return der_error("Termination: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Termination>\n");
#endif

	return length;
}

void
free_Termination(Termination *type)
{
	return;
}

int
der_decode_VideoClass(FILE *der, VideoClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<VideoClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(VideoClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->original_position.x_position = 0;
	type->original_position.y_position = 0;
	type->termination = Termination_disappear;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("VideoClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("VideoClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("VideoClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("VideoClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("VideoClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("VideoClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 76)
		{
			/* original_box_size */
			left -= sublen;
			sublen = der_decode_OriginalBoxSize(der, &type->original_box_size, tag.length);
			if(sublen < 0)
				return der_error("VideoClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 77)
		{
			/* original_position DEFAULT {x_position 0, y_position 0} */
			left -= sublen;
			sublen = der_decode_XYPosition(der, &type->original_position, tag.length);
			if(sublen < 0)
				return der_error("VideoClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 78)
		{
			/* original_palette_ref OPTIONAL */
			left -= sublen;
			type->have_original_palette_ref = true;
			sublen = der_decode_ObjectReference(der, &type->original_palette_ref, tag.length);
			if(sublen < 0)
				return der_error("VideoClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 98)
		{
			/* component_tag */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->component_tag, tag.length);
			if(sublen < 0)
				return der_error("VideoClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 100)
		{
			/* termination DEFAULT disappear */
			left -= sublen;
			sublen = der_decode_Termination(der, &type->termination, tag.length);
			if(sublen < 0)
				return der_error("VideoClass");
			left -= sublen;
		}
		else
			return der_error("VideoClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("VideoClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</VideoClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_VideoClass;

	return length;
}

void
free_VideoClass(VideoClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OriginalBoxSize(&type->original_box_size);

	free_XYPosition(&type->original_position);

	if(type->have_original_palette_ref)
		free_ObjectReference(&type->original_palette_ref);

	free_Termination(&type->termination);

	return;
}

int
der_decode_RTGraphicsClass(FILE *der, RTGraphicsClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<RTGraphicsClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(RTGraphicsClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->original_position.x_position = 0;
	type->original_position.y_position = 0;
	type->termination = Termination_disappear;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("RTGraphicsClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("RTGraphicsClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("RTGraphicsClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("RTGraphicsClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("RTGraphicsClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("RTGraphicsClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 76)
		{
			/* original_box_size */
			left -= sublen;
			sublen = der_decode_OriginalBoxSize(der, &type->original_box_size, tag.length);
			if(sublen < 0)
				return der_error("RTGraphicsClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 77)
		{
			/* original_position DEFAULT {x_position 0, y_position 0} */
			left -= sublen;
			sublen = der_decode_XYPosition(der, &type->original_position, tag.length);
			if(sublen < 0)
				return der_error("RTGraphicsClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 78)
		{
			/* original_palette_ref OPTIONAL */
			left -= sublen;
			type->have_original_palette_ref = true;
			sublen = der_decode_ObjectReference(der, &type->original_palette_ref, tag.length);
			if(sublen < 0)
				return der_error("RTGraphicsClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 98)
		{
			/* component_tag */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->component_tag, tag.length);
			if(sublen < 0)
				return der_error("RTGraphicsClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 100)
		{
			/* termination DEFAULT disappear */
			left -= sublen;
			sublen = der_decode_Termination(der, &type->termination, tag.length);
			if(sublen < 0)
				return der_error("RTGraphicsClass");
			left -= sublen;
		}
		else
			return der_error("RTGraphicsClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("RTGraphicsClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</RTGraphicsClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_RTGraphicsClass;

	return length;
}

void
free_RTGraphicsClass(RTGraphicsClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OriginalBoxSize(&type->original_box_size);

	free_XYPosition(&type->original_position);

	if(type->have_original_palette_ref)
		free_ObjectReference(&type->original_palette_ref);

	free_Termination(&type->termination);

	return;
}

int
der_decode_StreamComponent(FILE *der, StreamComponent *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<StreamComponent>\n");
#endif

	VK_memset(type, 0x00, sizeof(StreamComponent));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("StreamComponent");
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 95)
	{
		/* audio */
		left -= sublen;
		type->choice = StreamComponent_audio;
		sublen = der_decode_AudioClass(der, &type->u.audio, tag.length);
		if(sublen < 0)
			return der_error("StreamComponent");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 96)
	{
		/* video */
		left -= sublen;
		type->choice = StreamComponent_video;
		sublen = der_decode_VideoClass(der, &type->u.video, tag.length);
		if(sublen < 0)
			return der_error("StreamComponent");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 97)
	{
		/* rtgraphics */
		left -= sublen;
		type->choice = StreamComponent_rtgraphics;
		sublen = der_decode_RTGraphicsClass(der, &type->u.rtgraphics, tag.length);
		if(sublen < 0)
			return der_error("StreamComponent");
		left -= sublen;
	}
	else
		return der_error("StreamComponent: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("StreamComponent: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</StreamComponent>\n");
#endif

	return length;
}

void
free_StreamComponent(StreamComponent *type)
{
	switch(type->choice)
	{
	case StreamComponent_audio:
		free_AudioClass(&type->u.audio);
		break;

	case StreamComponent_video:
		free_VideoClass(&type->u.video);
		break;

	case StreamComponent_rtgraphics:
		free_RTGraphicsClass(&type->u.rtgraphics);
		break;

	default:
		der_error("free_StreamComponent: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_Storage(FILE *der, Storage *type, int length)
{
	int left = length;
	int sublen;
	int value;

#if (DER_VERBOSE)
	VK_Print("<Storage>\n");
#endif

	VK_memset(type, 0x00, sizeof(Storage));

	/* ENUMERATED */
	sublen = der_decode_Integer(der, (int *) &value, length);
	if(sublen < 0)
		return der_error("Storage");
	left -= sublen;

	*type = (Storage) value;

	if(left != 0)
		return der_error("Storage: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Storage>\n");
#endif

	return length;
}

void
free_Storage(Storage *type)
{
	return;
}

int
der_decode_StreamClass(FILE *der, StreamClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<StreamClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(StreamClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->storage = Storage_stream;
	type->looping = 1;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("StreamClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("StreamClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("StreamClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("StreamClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("StreamClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("StreamClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 92)
		{
			/* multiplex OPTIONAL */
			/* SEQUENCE OF StreamComponent */
			int seqlen = tag.length;
			left -= sublen + seqlen;
			while(seqlen > 0)
			{
				der_tag tag;
				LIST_TYPE(StreamComponent) *new_item;
				sublen = der_decode_Tag(der, &tag);
				if(sublen < 0)
					return der_error("StreamClass");
				if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 95)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 96)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 97)))
					return der_error("StreamClass: unexpected tag %u", tag.number);
				fseek(der, -sublen, SEEK_CUR);
				if((new_item = der_alloc(sizeof(LIST_TYPE(StreamComponent)))) == NULL)
					return der_error("StreamClass: out of memory");
				LIST_APPEND(&type->multiplex, new_item);
				sublen = der_decode_StreamComponent(der, &new_item->item, sublen + tag.length);
				if(sublen < 0)
					return der_error("StreamClass");
				if(sublen > seqlen)
					return der_error("StreamClass: %u bytes left", seqlen);
				seqlen -= sublen;
			}
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 93)
		{
			/* storage DEFAULT stream */
			left -= sublen;
			sublen = der_decode_Storage(der, &type->storage, tag.length);
			if(sublen < 0)
				return der_error("StreamClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 94)
		{
			/* looping DEFAULT 1 */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->looping, tag.length);
			if(sublen < 0)
				return der_error("StreamClass");
			left -= sublen;
		}
		else
			return der_error("StreamClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("StreamClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</StreamClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_StreamClass;

	return length;
}

void
free_StreamClass(StreamClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	LIST_FREE_ITEMS(&type->multiplex, StreamComponent, free_StreamComponent, der_free);

	free_Storage(&type->storage);

	return;
}

int
der_decode_BitmapClass(FILE *der, BitmapClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<BitmapClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(BitmapClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->original_position.x_position = 0;
	type->original_position.y_position = 0;
	type->tiling = false;
	type->original_transparency = 0;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("BitmapClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("BitmapClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("BitmapClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("BitmapClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("BitmapClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("BitmapClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 76)
		{
			/* original_box_size */
			left -= sublen;
			sublen = der_decode_OriginalBoxSize(der, &type->original_box_size, tag.length);
			if(sublen < 0)
				return der_error("BitmapClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 77)
		{
			/* original_position DEFAULT {x_position 0, y_position 0} */
			left -= sublen;
			sublen = der_decode_XYPosition(der, &type->original_position, tag.length);
			if(sublen < 0)
				return der_error("BitmapClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 78)
		{
			/* original_palette_ref OPTIONAL */
			left -= sublen;
			type->have_original_palette_ref = true;
			sublen = der_decode_ObjectReference(der, &type->original_palette_ref, tag.length);
			if(sublen < 0)
				return der_error("BitmapClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 79)
		{
			/* tiling DEFAULT false */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->tiling, tag.length);
			if(sublen < 0)
				return der_error("BitmapClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 80)
		{
			/* original_transparency DEFAULT 0 */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->original_transparency, tag.length);
			if(sublen < 0)
				return der_error("BitmapClass");
			left -= sublen;
		}
		else
			return der_error("BitmapClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("BitmapClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</BitmapClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_BitmapClass;

	return length;
}

void
free_BitmapClass(BitmapClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OriginalBoxSize(&type->original_box_size);

	free_XYPosition(&type->original_position);

	if(type->have_original_palette_ref)
		free_ObjectReference(&type->original_palette_ref);

	return;
}

int
der_decode_Colour(FILE *der, Colour *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<Colour>\n");
#endif

	VK_memset(type, 0x00, sizeof(Colour));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("Colour");
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	{
		/* colour_index */
		left -= sublen;
		type->choice = Colour_colour_index;
		sublen = der_decode_Integer(der, (int *) &type->u.colour_index, tag.length);
		if(sublen < 0)
			return der_error("Colour");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	{
		/* absolute_colour */
		left -= sublen;
		type->choice = Colour_absolute_colour;
		sublen = der_decode_OctetString(der, &type->u.absolute_colour, tag.length);
		if(sublen < 0)
			return der_error("Colour");
		left -= sublen;
	}
	else
		return der_error("Colour: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("Colour: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Colour>\n");
#endif

	return length;
}

void
free_Colour(Colour *type)
{
	switch(type->choice)
	{
	case Colour_colour_index:
		break;

	case Colour_absolute_colour:
		free_OctetString(&type->u.absolute_colour);
		break;

	default:
		der_error("free_Colour: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_LineArtClass(FILE *der, LineArtClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<LineArtClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(LineArtClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->original_position.x_position = 0;
	type->original_position.y_position = 0;
	type->original_line_width = 1;
	type->original_line_style = original_line_style_solid;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("LineArtClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("LineArtClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("LineArtClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("LineArtClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("LineArtClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("LineArtClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 76)
		{
			/* original_box_size */
			left -= sublen;
			sublen = der_decode_OriginalBoxSize(der, &type->original_box_size, tag.length);
			if(sublen < 0)
				return der_error("LineArtClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 77)
		{
			/* original_position DEFAULT {x_position 0, y_position 0} */
			left -= sublen;
			sublen = der_decode_XYPosition(der, &type->original_position, tag.length);
			if(sublen < 0)
				return der_error("LineArtClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 78)
		{
			/* original_palette_ref OPTIONAL */
			left -= sublen;
			type->have_original_palette_ref = true;
			sublen = der_decode_ObjectReference(der, &type->original_palette_ref, tag.length);
			if(sublen < 0)
				return der_error("LineArtClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 81)
		{
			/* bordered_bounding_box OPTIONAL */
			left -= sublen;
			type->have_bordered_bounding_box = true;
			sublen = der_decode_Boolean(der, &type->bordered_bounding_box, tag.length);
			if(sublen < 0)
				return der_error("LineArtClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 82)
		{
			/* original_line_width DEFAULT 1 */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->original_line_width, tag.length);
			if(sublen < 0)
				return der_error("LineArtClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 83)
		{
			/* original_line_style DEFAULT solid */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->original_line_style, tag.length);
			if(sublen < 0)
				return der_error("LineArtClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 84)
		{
			/* original_ref_line_colour OPTIONAL */
			left -= sublen;
			type->have_original_ref_line_colour = true;
			sublen = der_decode_Colour(der, &type->original_ref_line_colour, tag.length);
			if(sublen < 0)
				return der_error("LineArtClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 85)
		{
			/* original_ref_fill_colour OPTIONAL */
			left -= sublen;
			type->have_original_ref_fill_colour = true;
			sublen = der_decode_Colour(der, &type->original_ref_fill_colour, tag.length);
			if(sublen < 0)
				return der_error("LineArtClass");
			left -= sublen;
		}
		else
			return der_error("LineArtClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("LineArtClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</LineArtClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_LineArtClass;

	return length;
}

void
free_LineArtClass(LineArtClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OriginalBoxSize(&type->original_box_size);

	free_XYPosition(&type->original_position);

	if(type->have_original_palette_ref)
		free_ObjectReference(&type->original_palette_ref);

	if(type->have_original_ref_line_colour)
		free_Colour(&type->original_ref_line_colour);

	if(type->have_original_ref_fill_colour)
		free_Colour(&type->original_ref_fill_colour);

	return;
}

int
der_decode_DynamicLineArtClass(FILE *der, DynamicLineArtClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<DynamicLineArtClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(DynamicLineArtClass));

	sublen = der_decode_LineArtClass(der, (LineArtClass *) type, length);
	if(sublen < 0)
		return der_error("DynamicLineArtClass");
	left -= sublen;

	if(left != 0)
		return der_error("DynamicLineArtClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</DynamicLineArtClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_DynamicLineArtClass;

	return length;
}

void
free_DynamicLineArtClass(DynamicLineArtClass *type)
{
	free_LineArtClass((LineArtClass *) type);

	return;
}

int
der_decode_RectangleClass(FILE *der, RectangleClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<RectangleClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(RectangleClass));

	sublen = der_decode_LineArtClass(der, (LineArtClass *) type, length);
	if(sublen < 0)
		return der_error("RectangleClass");
	left -= sublen;

	if(left != 0)
		return der_error("RectangleClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</RectangleClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_RectangleClass;

	return length;
}

void
free_RectangleClass(RectangleClass *type)
{
	free_LineArtClass((LineArtClass *) type);

	return;
}

int
der_decode_ButtonClass(FILE *der, ButtonClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ButtonClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(ButtonClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->original_position.x_position = 0;
	type->original_position.y_position = 0;
	type->engine_resp = true;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("ButtonClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("ButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 48)
		{
			/* button_ref_colour OPTIONAL */
			left -= sublen;
			type->have_button_ref_colour = true;
			sublen = der_decode_Colour(der, &type->button_ref_colour, tag.length);
			if(sublen < 0)
				return der_error("ButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 49)
		{
			/* highlight_ref_colour OPTIONAL */
			left -= sublen;
			type->have_highlight_ref_colour = true;
			sublen = der_decode_Colour(der, &type->highlight_ref_colour, tag.length);
			if(sublen < 0)
				return der_error("ButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("ButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("ButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("ButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("ButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 76)
		{
			/* original_box_size */
			left -= sublen;
			sublen = der_decode_OriginalBoxSize(der, &type->original_box_size, tag.length);
			if(sublen < 0)
				return der_error("ButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 77)
		{
			/* original_position DEFAULT {x_position 0, y_position 0} */
			left -= sublen;
			sublen = der_decode_XYPosition(der, &type->original_position, tag.length);
			if(sublen < 0)
				return der_error("ButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 78)
		{
			/* original_palette_ref OPTIONAL */
			left -= sublen;
			type->have_original_palette_ref = true;
			sublen = der_decode_ObjectReference(der, &type->original_palette_ref, tag.length);
			if(sublen < 0)
				return der_error("ButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 101)
		{
			/* engine_resp DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->engine_resp, tag.length);
			if(sublen < 0)
				return der_error("ButtonClass");
			left -= sublen;
		}
		else
			return der_error("ButtonClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("ButtonClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ButtonClass>\n");
#endif

	return length;
}

void
free_ButtonClass(ButtonClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_button_ref_colour)
		free_Colour(&type->button_ref_colour);

	if(type->have_highlight_ref_colour)
		free_Colour(&type->highlight_ref_colour);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OriginalBoxSize(&type->original_box_size);

	free_XYPosition(&type->original_position);

	if(type->have_original_palette_ref)
		free_ObjectReference(&type->original_palette_ref);

	return;
}

int
der_decode_HotspotClass(FILE *der, HotspotClass *type, int length)
{
	int left = length;
	int sublen;

#if (DER_VERBOSE)
	VK_Print("<HotspotClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(HotspotClass));

	sublen = der_decode_ButtonClass(der, (ButtonClass *) type, length);
	if(sublen < 0)
		return der_error("HotspotClass");
	left -= sublen;

	if(left != 0)
		return der_error("HotspotClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</HotspotClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_HotspotClass;

	return length;
}

void
free_HotspotClass(HotspotClass *type)
{
	free_ButtonClass((ButtonClass *) type);

	return;
}

int
der_decode_ButtonStyle(FILE *der, ButtonStyle *type, int length)
{
	int left = length;
	int sublen;
	int value;

#if (DER_VERBOSE)
	VK_Print("<ButtonStyle>\n");
#endif

	VK_memset(type, 0x00, sizeof(ButtonStyle));

	/* ENUMERATED */
	sublen = der_decode_Integer(der, (int *) &value, length);
	if(sublen < 0)
		return der_error("ButtonStyle");
	left -= sublen;

	*type = (ButtonStyle) value;

	if(left != 0)
		return der_error("ButtonStyle: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ButtonStyle>\n");
#endif

	return length;
}

void
free_ButtonStyle(ButtonStyle *type)
{
	return;
}

int
der_decode_SwitchButtonClass(FILE *der, SwitchButtonClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SwitchButtonClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(SwitchButtonClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->original_position.x_position = 0;
	type->original_position.y_position = 0;
	type->engine_resp = true;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("SwitchButtonClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("SwitchButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 38)
		{
			/* character_set OPTIONAL */
			left -= sublen;
			type->have_character_set = true;
			sublen = der_decode_Integer(der, (int *) &type->character_set, tag.length);
			if(sublen < 0)
				return der_error("SwitchButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 48)
		{
			/* button_ref_colour OPTIONAL */
			left -= sublen;
			type->have_button_ref_colour = true;
			sublen = der_decode_Colour(der, &type->button_ref_colour, tag.length);
			if(sublen < 0)
				return der_error("SwitchButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 49)
		{
			/* highlight_ref_colour OPTIONAL */
			left -= sublen;
			type->have_highlight_ref_colour = true;
			sublen = der_decode_Colour(der, &type->highlight_ref_colour, tag.length);
			if(sublen < 0)
				return der_error("SwitchButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("SwitchButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("SwitchButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("SwitchButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("SwitchButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 76)
		{
			/* original_box_size */
			left -= sublen;
			sublen = der_decode_OriginalBoxSize(der, &type->original_box_size, tag.length);
			if(sublen < 0)
				return der_error("SwitchButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 77)
		{
			/* original_position DEFAULT {x_position 0, y_position 0} */
			left -= sublen;
			sublen = der_decode_XYPosition(der, &type->original_position, tag.length);
			if(sublen < 0)
				return der_error("SwitchButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 78)
		{
			/* original_palette_ref OPTIONAL */
			left -= sublen;
			type->have_original_palette_ref = true;
			sublen = der_decode_ObjectReference(der, &type->original_palette_ref, tag.length);
			if(sublen < 0)
				return der_error("SwitchButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 101)
		{
			/* engine_resp DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->engine_resp, tag.length);
			if(sublen < 0)
				return der_error("SwitchButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 113)
		{
			/* original_label OPTIONAL */
			left -= sublen;
			type->have_original_label = true;
			sublen = der_decode_OctetString(der, &type->original_label, tag.length);
			if(sublen < 0)
				return der_error("SwitchButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 114)
		{
			/* button_style */
			left -= sublen;
			sublen = der_decode_ButtonStyle(der, &type->button_style, tag.length);
			if(sublen < 0)
				return der_error("SwitchButtonClass");
			left -= sublen;
		}
		else
			return der_error("SwitchButtonClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("SwitchButtonClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SwitchButtonClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_SwitchButtonClass;

	return length;
}

void
free_SwitchButtonClass(SwitchButtonClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_button_ref_colour)
		free_Colour(&type->button_ref_colour);

	if(type->have_highlight_ref_colour)
		free_Colour(&type->highlight_ref_colour);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OriginalBoxSize(&type->original_box_size);

	free_XYPosition(&type->original_position);

	if(type->have_original_palette_ref)
		free_ObjectReference(&type->original_palette_ref);

	if(type->have_original_label)
		free_OctetString(&type->original_label);

	free_ButtonStyle(&type->button_style);

	return;
}

int
der_decode_PushButtonClass(FILE *der, PushButtonClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<PushButtonClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(PushButtonClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->original_position.x_position = 0;
	type->original_position.y_position = 0;
	type->engine_resp = true;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("PushButtonClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("PushButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 38)
		{
			/* character_set OPTIONAL */
			left -= sublen;
			type->have_character_set = true;
			sublen = der_decode_Integer(der, (int *) &type->character_set, tag.length);
			if(sublen < 0)
				return der_error("PushButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 48)
		{
			/* button_ref_colour OPTIONAL */
			left -= sublen;
			type->have_button_ref_colour = true;
			sublen = der_decode_Colour(der, &type->button_ref_colour, tag.length);
			if(sublen < 0)
				return der_error("PushButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 49)
		{
			/* highlight_ref_colour OPTIONAL */
			left -= sublen;
			type->have_highlight_ref_colour = true;
			sublen = der_decode_Colour(der, &type->highlight_ref_colour, tag.length);
			if(sublen < 0)
				return der_error("PushButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("PushButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("PushButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("PushButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("PushButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 76)
		{
			/* original_box_size */
			left -= sublen;
			sublen = der_decode_OriginalBoxSize(der, &type->original_box_size, tag.length);
			if(sublen < 0)
				return der_error("PushButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 77)
		{
			/* original_position DEFAULT {x_position 0, y_position 0} */
			left -= sublen;
			sublen = der_decode_XYPosition(der, &type->original_position, tag.length);
			if(sublen < 0)
				return der_error("PushButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 78)
		{
			/* original_palette_ref OPTIONAL */
			left -= sublen;
			type->have_original_palette_ref = true;
			sublen = der_decode_ObjectReference(der, &type->original_palette_ref, tag.length);
			if(sublen < 0)
				return der_error("PushButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 101)
		{
			/* engine_resp DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->engine_resp, tag.length);
			if(sublen < 0)
				return der_error("PushButtonClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 113)
		{
			/* original_label OPTIONAL */
			left -= sublen;
			type->have_original_label = true;
			sublen = der_decode_OctetString(der, &type->original_label, tag.length);
			if(sublen < 0)
				return der_error("PushButtonClass");
			left -= sublen;
		}
		else
			return der_error("PushButtonClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("PushButtonClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</PushButtonClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_PushButtonClass;

	return length;
}

void
free_PushButtonClass(PushButtonClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_button_ref_colour)
		free_Colour(&type->button_ref_colour);

	if(type->have_highlight_ref_colour)
		free_Colour(&type->highlight_ref_colour);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OriginalBoxSize(&type->original_box_size);

	free_XYPosition(&type->original_position);

	if(type->have_original_palette_ref)
		free_ObjectReference(&type->original_palette_ref);

	if(type->have_original_label)
		free_OctetString(&type->original_label);

	return;
}

int
der_decode_FontBody(FILE *der, FontBody *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<FontBody>\n");
#endif

	VK_memset(type, 0x00, sizeof(FontBody));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("FontBody");
	if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
	{
		/* indirect_font */
		fseek(der, -sublen, SEEK_CUR);
		type->choice = FontBody_indirect_font;
		sublen = der_decode_ObjectReference(der, &type->u.indirect_font, length);
		if(sublen < 0)
			return der_error("FontBody");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 4)
	{
		/* direct_font */
		left -= sublen;
		type->choice = FontBody_direct_font;
		sublen = der_decode_OctetString(der, &type->u.direct_font, tag.length);
		if(sublen < 0)
			return der_error("FontBody");
		left -= sublen;
	}
	else
		return der_error("FontBody: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("FontBody: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</FontBody>\n");
#endif

	return length;
}

void
free_FontBody(FontBody *type)
{
	switch(type->choice)
	{
	case FontBody_indirect_font:
		free_ObjectReference(&type->u.indirect_font);
		break;

	case FontBody_direct_font:
		free_OctetString(&type->u.direct_font);
		break;

	default:
		der_error("free_FontBody: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_Justification(FILE *der, Justification *type, int length)
{
	int left = length;
	int sublen;
	int value;

#if (DER_VERBOSE)
	VK_Print("<Justification>\n");
#endif

	VK_memset(type, 0x00, sizeof(Justification));

	/* ENUMERATED */
	sublen = der_decode_Integer(der, (int *) &value, length);
	if(sublen < 0)
		return der_error("Justification");
	left -= sublen;

	*type = (Justification) value;

	if(left != 0)
		return der_error("Justification: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Justification>\n");
#endif

	return length;
}

void
free_Justification(Justification *type)
{
	return;
}

int
der_decode_LineOrientation(FILE *der, LineOrientation *type, int length)
{
	int left = length;
	int sublen;
	int value;

#if (DER_VERBOSE)
	VK_Print("<LineOrientation>\n");
#endif

	VK_memset(type, 0x00, sizeof(LineOrientation));

	/* ENUMERATED */
	sublen = der_decode_Integer(der, (int *) &value, length);
	if(sublen < 0)
		return der_error("LineOrientation");
	left -= sublen;

	*type = (LineOrientation) value;

	if(left != 0)
		return der_error("LineOrientation: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</LineOrientation>\n");
#endif

	return length;
}

void
free_LineOrientation(LineOrientation *type)
{
	return;
}

int
der_decode_StartCorner(FILE *der, StartCorner *type, int length)
{
	int left = length;
	int sublen;
	int value;

#if (DER_VERBOSE)
	VK_Print("<StartCorner>\n");
#endif

	VK_memset(type, 0x00, sizeof(StartCorner));

	/* ENUMERATED */
	sublen = der_decode_Integer(der, (int *) &value, length);
	if(sublen < 0)
		return der_error("StartCorner");
	left -= sublen;

	*type = (StartCorner) value;

	if(left != 0)
		return der_error("StartCorner: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</StartCorner>\n");
#endif

	return length;
}

void
free_StartCorner(StartCorner *type)
{
	return;
}

int
der_decode_TextClass(FILE *der, TextClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<TextClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(TextClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->original_position.x_position = 0;
	type->original_position.y_position = 0;
	type->horizontal_justification = Justification_start;
	type->vertical_justification = Justification_start;
	type->line_orientation = LineOrientation_horizontal;
	type->start_corner = StartCorner_upper_left;
	type->text_wrapping = false;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("TextClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 38)
		{
			/* character_set OPTIONAL */
			left -= sublen;
			type->have_character_set = true;
			sublen = der_decode_Integer(der, (int *) &type->character_set, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 39)
		{
			/* background_colour OPTIONAL */
			left -= sublen;
			type->have_background_colour = true;
			sublen = der_decode_Colour(der, &type->background_colour, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 41)
		{
			/* text_colour OPTIONAL */
			left -= sublen;
			type->have_text_colour = true;
			sublen = der_decode_Colour(der, &type->text_colour, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 43)
		{
			/* font_attributes OPTIONAL */
			left -= sublen;
			type->have_font_attributes = true;
			sublen = der_decode_OctetString(der, &type->font_attributes, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 76)
		{
			/* original_box_size */
			left -= sublen;
			sublen = der_decode_OriginalBoxSize(der, &type->original_box_size, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 77)
		{
			/* original_position DEFAULT {x_position 0, y_position 0} */
			left -= sublen;
			sublen = der_decode_XYPosition(der, &type->original_position, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 78)
		{
			/* original_palette_ref OPTIONAL */
			left -= sublen;
			type->have_original_palette_ref = true;
			sublen = der_decode_ObjectReference(der, &type->original_palette_ref, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 86)
		{
			/* original_font OPTIONAL */
			left -= sublen;
			type->have_original_font = true;
			sublen = der_decode_FontBody(der, &type->original_font, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 87)
		{
			/* horizontal_justification DEFAULT start */
			left -= sublen;
			sublen = der_decode_Justification(der, &type->horizontal_justification, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 88)
		{
			/* vertical_justification DEFAULT start */
			left -= sublen;
			sublen = der_decode_Justification(der, &type->vertical_justification, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 89)
		{
			/* line_orientation DEFAULT horizontal */
			left -= sublen;
			sublen = der_decode_LineOrientation(der, &type->line_orientation, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 90)
		{
			/* start_corner DEFAULT upper_left */
			left -= sublen;
			sublen = der_decode_StartCorner(der, &type->start_corner, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 91)
		{
			/* text_wrapping DEFAULT false */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->text_wrapping, tag.length);
			if(sublen < 0)
				return der_error("TextClass");
			left -= sublen;
		}
		else
			return der_error("TextClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("TextClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</TextClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_TextClass;

	return length;
}

void
free_TextClass(TextClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_background_colour)
		free_Colour(&type->background_colour);

	if(type->have_text_colour)
		free_Colour(&type->text_colour);

	if(type->have_font_attributes)
		free_OctetString(&type->font_attributes);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OriginalBoxSize(&type->original_box_size);

	free_XYPosition(&type->original_position);

	if(type->have_original_palette_ref)
		free_ObjectReference(&type->original_palette_ref);

	if(type->have_original_font)
		free_FontBody(&type->original_font);

	free_Justification(&type->horizontal_justification);

	free_Justification(&type->vertical_justification);

	free_LineOrientation(&type->line_orientation);

	free_StartCorner(&type->start_corner);

	return;
}

int
der_decode_InputType(FILE *der, InputType *type, int length)
{
	int left = length;
	int sublen;
	int value;

#if (DER_VERBOSE)
	VK_Print("<InputType>\n");
#endif

	VK_memset(type, 0x00, sizeof(InputType));

	/* ENUMERATED */
	sublen = der_decode_Integer(der, (int *) &value, length);
	if(sublen < 0)
		return der_error("InputType");
	left -= sublen;

	*type = (InputType) value;

	if(left != 0)
		return der_error("InputType: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</InputType>\n");
#endif

	return length;
}

void
free_InputType(InputType *type)
{
	return;
}

int
der_decode_EntryFieldClass(FILE *der, EntryFieldClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<EntryFieldClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(EntryFieldClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->original_position.x_position = 0;
	type->original_position.y_position = 0;
	type->horizontal_justification = Justification_start;
	type->vertical_justification = Justification_start;
	type->line_orientation = LineOrientation_horizontal;
	type->start_corner = StartCorner_upper_left;
	type->text_wrapping = false;
	type->engine_resp = true;
	type->input_type = InputType_any;
	type->obscured_input = false;
	type->max_length = 0;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("EntryFieldClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 38)
		{
			/* character_set OPTIONAL */
			left -= sublen;
			type->have_character_set = true;
			sublen = der_decode_Integer(der, (int *) &type->character_set, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 39)
		{
			/* background_colour OPTIONAL */
			left -= sublen;
			type->have_background_colour = true;
			sublen = der_decode_Colour(der, &type->background_colour, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 41)
		{
			/* text_colour OPTIONAL */
			left -= sublen;
			type->have_text_colour = true;
			sublen = der_decode_Colour(der, &type->text_colour, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 43)
		{
			/* font_attributes OPTIONAL */
			left -= sublen;
			type->have_font_attributes = true;
			sublen = der_decode_OctetString(der, &type->font_attributes, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 49)
		{
			/* highlight_ref_colour OPTIONAL */
			left -= sublen;
			type->have_highlight_ref_colour = true;
			sublen = der_decode_Colour(der, &type->highlight_ref_colour, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 76)
		{
			/* original_box_size */
			left -= sublen;
			sublen = der_decode_OriginalBoxSize(der, &type->original_box_size, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 77)
		{
			/* original_position DEFAULT {x_position 0, y_position 0} */
			left -= sublen;
			sublen = der_decode_XYPosition(der, &type->original_position, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 78)
		{
			/* original_palette_ref OPTIONAL */
			left -= sublen;
			type->have_original_palette_ref = true;
			sublen = der_decode_ObjectReference(der, &type->original_palette_ref, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 86)
		{
			/* original_font OPTIONAL */
			left -= sublen;
			type->have_original_font = true;
			sublen = der_decode_FontBody(der, &type->original_font, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 87)
		{
			/* horizontal_justification DEFAULT start */
			left -= sublen;
			sublen = der_decode_Justification(der, &type->horizontal_justification, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 88)
		{
			/* vertical_justification DEFAULT start */
			left -= sublen;
			sublen = der_decode_Justification(der, &type->vertical_justification, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 89)
		{
			/* line_orientation DEFAULT horizontal */
			left -= sublen;
			sublen = der_decode_LineOrientation(der, &type->line_orientation, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 90)
		{
			/* start_corner DEFAULT upper_left */
			left -= sublen;
			sublen = der_decode_StartCorner(der, &type->start_corner, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 91)
		{
			/* text_wrapping DEFAULT false */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->text_wrapping, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 101)
		{
			/* engine_resp DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->engine_resp, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 109)
		{
			/* input_type DEFAULT any */
			left -= sublen;
			sublen = der_decode_InputType(der, &type->input_type, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 110)
		{
			/* char_list OPTIONAL */
			left -= sublen;
			type->have_char_list = true;
			sublen = der_decode_OctetString(der, &type->char_list, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 111)
		{
			/* obscured_input DEFAULT false */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->obscured_input, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 112)
		{
			/* max_length DEFAULT 0 */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->max_length, tag.length);
			if(sublen < 0)
				return der_error("EntryFieldClass");
			left -= sublen;
		}
		else
			return der_error("EntryFieldClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("EntryFieldClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</EntryFieldClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_EntryFieldClass;

	return length;
}

void
free_EntryFieldClass(EntryFieldClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_background_colour)
		free_Colour(&type->background_colour);

	if(type->have_text_colour)
		free_Colour(&type->text_colour);

	if(type->have_font_attributes)
		free_OctetString(&type->font_attributes);

	if(type->have_highlight_ref_colour)
		free_Colour(&type->highlight_ref_colour);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OriginalBoxSize(&type->original_box_size);

	free_XYPosition(&type->original_position);

	if(type->have_original_palette_ref)
		free_ObjectReference(&type->original_palette_ref);

	if(type->have_original_font)
		free_FontBody(&type->original_font);

	free_Justification(&type->horizontal_justification);

	free_Justification(&type->vertical_justification);

	free_LineOrientation(&type->line_orientation);

	free_StartCorner(&type->start_corner);

	free_InputType(&type->input_type);

	if(type->have_char_list)
		free_OctetString(&type->char_list);

	return;
}

int
der_decode_HyperTextClass(FILE *der, HyperTextClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<HyperTextClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(HyperTextClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->original_position.x_position = 0;
	type->original_position.y_position = 0;
	type->horizontal_justification = Justification_start;
	type->vertical_justification = Justification_start;
	type->line_orientation = LineOrientation_horizontal;
	type->start_corner = StartCorner_upper_left;
	type->text_wrapping = false;
	type->engine_resp = true;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("HyperTextClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 38)
		{
			/* character_set OPTIONAL */
			left -= sublen;
			type->have_character_set = true;
			sublen = der_decode_Integer(der, (int *) &type->character_set, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 39)
		{
			/* background_colour OPTIONAL */
			left -= sublen;
			type->have_background_colour = true;
			sublen = der_decode_Colour(der, &type->background_colour, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 41)
		{
			/* text_colour OPTIONAL */
			left -= sublen;
			type->have_text_colour = true;
			sublen = der_decode_Colour(der, &type->text_colour, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 43)
		{
			/* font_attributes OPTIONAL */
			left -= sublen;
			type->have_font_attributes = true;
			sublen = der_decode_OctetString(der, &type->font_attributes, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 49)
		{
			/* highlight_ref_colour OPTIONAL */
			left -= sublen;
			type->have_highlight_ref_colour = true;
			sublen = der_decode_Colour(der, &type->highlight_ref_colour, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 76)
		{
			/* original_box_size */
			left -= sublen;
			sublen = der_decode_OriginalBoxSize(der, &type->original_box_size, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 77)
		{
			/* original_position DEFAULT {x_position 0, y_position 0} */
			left -= sublen;
			sublen = der_decode_XYPosition(der, &type->original_position, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 78)
		{
			/* original_palette_ref OPTIONAL */
			left -= sublen;
			type->have_original_palette_ref = true;
			sublen = der_decode_ObjectReference(der, &type->original_palette_ref, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 86)
		{
			/* original_font OPTIONAL */
			left -= sublen;
			type->have_original_font = true;
			sublen = der_decode_FontBody(der, &type->original_font, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 87)
		{
			/* horizontal_justification DEFAULT start */
			left -= sublen;
			sublen = der_decode_Justification(der, &type->horizontal_justification, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 88)
		{
			/* vertical_justification DEFAULT start */
			left -= sublen;
			sublen = der_decode_Justification(der, &type->vertical_justification, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 89)
		{
			/* line_orientation DEFAULT horizontal */
			left -= sublen;
			sublen = der_decode_LineOrientation(der, &type->line_orientation, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 90)
		{
			/* start_corner DEFAULT upper_left */
			left -= sublen;
			sublen = der_decode_StartCorner(der, &type->start_corner, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 91)
		{
			/* text_wrapping DEFAULT false */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->text_wrapping, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 101)
		{
			/* engine_resp DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->engine_resp, tag.length);
			if(sublen < 0)
				return der_error("HyperTextClass");
			left -= sublen;
		}
		else
			return der_error("HyperTextClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("HyperTextClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</HyperTextClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_HyperTextClass;

	return length;
}

void
free_HyperTextClass(HyperTextClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_background_colour)
		free_Colour(&type->background_colour);

	if(type->have_text_colour)
		free_Colour(&type->text_colour);

	if(type->have_font_attributes)
		free_OctetString(&type->font_attributes);

	if(type->have_highlight_ref_colour)
		free_Colour(&type->highlight_ref_colour);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OriginalBoxSize(&type->original_box_size);

	free_XYPosition(&type->original_position);

	if(type->have_original_palette_ref)
		free_ObjectReference(&type->original_palette_ref);

	if(type->have_original_font)
		free_FontBody(&type->original_font);

	free_Justification(&type->horizontal_justification);

	free_Justification(&type->vertical_justification);

	free_LineOrientation(&type->line_orientation);

	free_StartCorner(&type->start_corner);

	return;
}

int
der_decode_Orientation(FILE *der, Orientation *type, int length)
{
	int left = length;
	int sublen;
	int value;

#if (DER_VERBOSE)
	VK_Print("<Orientation>\n");
#endif

	VK_memset(type, 0x00, sizeof(Orientation));

	/* ENUMERATED */
	sublen = der_decode_Integer(der, (int *) &value, length);
	if(sublen < 0)
		return der_error("Orientation");
	left -= sublen;

	*type = (Orientation) value;

	if(left != 0)
		return der_error("Orientation: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Orientation>\n");
#endif

	return length;
}

void
free_Orientation(Orientation *type)
{
	return;
}

int
der_decode_SliderStyle(FILE *der, SliderStyle *type, int length)
{
	int left = length;
	int sublen;
	int value;

#if (DER_VERBOSE)
	VK_Print("<SliderStyle>\n");
#endif

	VK_memset(type, 0x00, sizeof(SliderStyle));

	/* ENUMERATED */
	sublen = der_decode_Integer(der, (int *) &value, length);
	if(sublen < 0)
		return der_error("SliderStyle");
	left -= sublen;

	*type = (SliderStyle) value;

	if(left != 0)
		return der_error("SliderStyle: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SliderStyle>\n");
#endif

	return length;
}

void
free_SliderStyle(SliderStyle *type)
{
	return;
}

int
der_decode_SliderClass(FILE *der, SliderClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SliderClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(SliderClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->original_position.x_position = 0;
	type->original_position.y_position = 0;
	type->engine_resp = true;
	type->min_value = 1;
	type->step_size = 1;
	type->slider_style = SliderStyle_normal;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("SliderClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 49)
		{
			/* highlight_ref_colour OPTIONAL */
			left -= sublen;
			type->have_highlight_ref_colour = true;
			sublen = der_decode_Colour(der, &type->highlight_ref_colour, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 50)
		{
			/* slider_ref_colour OPTIONAL */
			left -= sublen;
			type->have_slider_ref_colour = true;
			sublen = der_decode_Colour(der, &type->slider_ref_colour, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 76)
		{
			/* original_box_size */
			left -= sublen;
			sublen = der_decode_OriginalBoxSize(der, &type->original_box_size, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 77)
		{
			/* original_position DEFAULT {x_position 0, y_position 0} */
			left -= sublen;
			sublen = der_decode_XYPosition(der, &type->original_position, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 78)
		{
			/* original_palette_ref OPTIONAL */
			left -= sublen;
			type->have_original_palette_ref = true;
			sublen = der_decode_ObjectReference(der, &type->original_palette_ref, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 101)
		{
			/* engine_resp DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->engine_resp, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 102)
		{
			/* orientation */
			left -= sublen;
			sublen = der_decode_Orientation(der, &type->orientation, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 103)
		{
			/* max_value */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->max_value, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 104)
		{
			/* min_value DEFAULT 1 */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->min_value, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 105)
		{
			/* initial_value OPTIONAL */
			left -= sublen;
			type->have_initial_value = true;
			sublen = der_decode_Integer(der, (int *) &type->initial_value, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 106)
		{
			/* initial_portion OPTIONAL */
			left -= sublen;
			type->have_initial_portion = true;
			sublen = der_decode_Integer(der, (int *) &type->initial_portion, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 107)
		{
			/* step_size DEFAULT 1 */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->step_size, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 108)
		{
			/* slider_style DEFAULT normal */
			left -= sublen;
			sublen = der_decode_SliderStyle(der, &type->slider_style, tag.length);
			if(sublen < 0)
				return der_error("SliderClass");
			left -= sublen;
		}
		else
			return der_error("SliderClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("SliderClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SliderClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_SliderClass;

	return length;
}

void
free_SliderClass(SliderClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_highlight_ref_colour)
		free_Colour(&type->highlight_ref_colour);

	if(type->have_slider_ref_colour)
		free_Colour(&type->slider_ref_colour);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OriginalBoxSize(&type->original_box_size);

	free_XYPosition(&type->original_position);

	if(type->have_original_palette_ref)
		free_ObjectReference(&type->original_palette_ref);

	free_Orientation(&type->orientation);

	free_SliderStyle(&type->slider_style);

	return;
}

int
der_decode_Movement(FILE *der, Movement *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<Movement>\n");
#endif

	VK_memset(type, 0x00, sizeof(Movement));

	/* SEQUENCE OF int */
	while(left > 0)
	{
		LIST_TYPE(int) *new_item;
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("Movement");
		if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2))
			return der_error("Movement: unexpected tag %u", tag.number);
		left -= sublen;
		if((new_item = der_alloc(sizeof(LIST_TYPE(int)))) == NULL)
			return der_error("Movement: out of memory");
		LIST_APPEND(type, new_item);
		sublen = der_decode_Integer(der, (int *) &new_item->item, tag.length);
		if(sublen < 0)
			return der_error("Movement");
		left -= sublen;
	}

	if(left != 0)
		return der_error("Movement: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</Movement>\n");
#endif

	return length;
}

void
free_Movement(Movement *type)
{
	LIST_FREE(type, int, der_free);

	return;
}

int
der_decode_ActionSlot(FILE *der, ActionSlot *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ActionSlot>\n");
#endif

	VK_memset(type, 0x00, sizeof(ActionSlot));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("ActionSlot");
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 5)
	{
		/* null */
		left -= sublen;
		type->choice = ActionSlot_null;
		sublen = der_decode_Null(der, &type->u.null, tag.length);
		if(sublen < 0)
			return der_error("ActionSlot");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)
	{
		/* action_class */
		left -= sublen;
		type->choice = ActionSlot_action_class;
		sublen = der_decode_ActionClass(der, &type->u.action_class, tag.length);
		if(sublen < 0)
			return der_error("ActionSlot");
		left -= sublen;
	}
	else
		return der_error("ActionSlot: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("ActionSlot: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ActionSlot>\n");
#endif

	return length;
}

void
free_ActionSlot(ActionSlot *type)
{
	switch(type->choice)
	{
	case ActionSlot_null:
		break;

	case ActionSlot_action_class:
		free_ActionClass(&type->u.action_class);
		break;

	default:
		der_error("free_ActionSlot: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_TokenGroupItem(FILE *der, TokenGroupItem *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;
	der_tag seqtag;

#if (DER_VERBOSE)
	VK_Print("<TokenGroupItem>\n");
#endif

	VK_memset(type, 0x00, sizeof(TokenGroupItem));

	/* SEQUENCE */
	/* a_visible */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("TokenGroupItem");
	if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
	|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
		return der_error("TokenGroupItem: unexpected tag %u", tag.number);
	fseek(der, -sublen, SEEK_CUR);
	sublen = der_decode_ObjectReference(der, &type->a_visible, sublen + tag.length);
	if(sublen < 0)
		return der_error("TokenGroupItem");
	left -= sublen;

	/* action_slots OPTIONAL */
	if(left > 0)
	{
		/* SEQUENCE OF ActionSlot */
		sublen = der_decode_Tag(der, &seqtag);
		if(sublen < 0)
			return der_error("TokenGroupItem");
		if(seqtag.class != DER_CLASS_UNIVERSAL || seqtag.number != 16)
			return der_error("TokenGroupItem: unexpected tag %u", seqtag.number);
		left -= sublen + seqtag.length;
		while(seqtag.length > 0)
		{
			LIST_TYPE(ActionSlot) *new_item;
			sublen = der_decode_Tag(der, &tag);
			if(sublen < 0)
				return der_error("TokenGroupItem");
			if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 5)
			|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
				return der_error("TokenGroupItem: unexpected tag %u", tag.number);
			fseek(der, -sublen, SEEK_CUR);
			if((new_item = der_alloc(sizeof(LIST_TYPE(ActionSlot)))) == NULL)
				return der_error("TokenGroupItem: out of memory");
			LIST_APPEND(&type->action_slots, new_item);
			sublen = der_decode_ActionSlot(der, &new_item->item, sublen + tag.length);
			if(sublen < 0)
				return der_error("TokenGroupItem");
			if(sublen > seqtag.length)
				return der_error("TokenGroupItem: %u bytes left", seqtag.length);
			seqtag.length -= sublen;
		}
	}

	if(left != 0)
		return der_error("TokenGroupItem: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</TokenGroupItem>\n");
#endif

	return length;
}

void
free_TokenGroupItem(TokenGroupItem *type)
{
	free_ObjectReference(&type->a_visible);

	LIST_FREE_ITEMS(&type->action_slots, ActionSlot, free_ActionSlot, der_free);

	return;
}

int
der_decode_TokenGroupClass(FILE *der, TokenGroupClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<TokenGroupClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(TokenGroupClass));

	/* DEFAULT values */
	type->initially_active = true;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("TokenGroupClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("TokenGroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("TokenGroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("TokenGroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("TokenGroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("TokenGroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 70)
		{
			/* movement_table OPTIONAL */
			/* SEQUENCE OF Movement */
			int seqlen = tag.length;
			left -= sublen + seqlen;
			while(seqlen > 0)
			{
				der_tag tag;
				LIST_TYPE(Movement) *new_item;
				sublen = der_decode_Tag(der, &tag);
				if(sublen < 0)
					return der_error("TokenGroupClass");
				if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
					return der_error("TokenGroupClass: unexpected tag %u", tag.number);
				seqlen -= sublen;
				if((new_item = der_alloc(sizeof(LIST_TYPE(Movement)))) == NULL)
					return der_error("TokenGroupClass: out of memory");
				LIST_APPEND(&type->movement_table, new_item);
				sublen = der_decode_Movement(der, &new_item->item, tag.length);
				if(sublen < 0)
					return der_error("TokenGroupClass");
				if(sublen > seqlen)
					return der_error("TokenGroupClass: %u bytes left", seqlen);
				seqlen -= sublen;
			}
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 71)
		{
			/* token_group_items OPTIONAL */
			/* SEQUENCE OF TokenGroupItem */
			int seqlen = tag.length;
			left -= sublen + seqlen;
			while(seqlen > 0)
			{
				der_tag tag;
				LIST_TYPE(TokenGroupItem) *new_item;
				sublen = der_decode_Tag(der, &tag);
				if(sublen < 0)
					return der_error("TokenGroupClass");
				if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
					return der_error("TokenGroupClass: unexpected tag %u", tag.number);
				seqlen -= sublen;
				if((new_item = der_alloc(sizeof(LIST_TYPE(TokenGroupItem)))) == NULL)
					return der_error("TokenGroupClass: out of memory");
				LIST_APPEND(&type->token_group_items, new_item);
				sublen = der_decode_TokenGroupItem(der, &new_item->item, tag.length);
				if(sublen < 0)
					return der_error("TokenGroupClass");
				if(sublen > seqlen)
					return der_error("TokenGroupClass: %u bytes left", seqlen);
				seqlen -= sublen;
			}
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 72)
		{
			/* no_token_action_slots OPTIONAL */
			/* SEQUENCE OF ActionSlot */
			int seqlen = tag.length;
			left -= sublen + seqlen;
			while(seqlen > 0)
			{
				der_tag tag;
				LIST_TYPE(ActionSlot) *new_item;
				sublen = der_decode_Tag(der, &tag);
				if(sublen < 0)
					return der_error("TokenGroupClass");
				if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 5)
				|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
					return der_error("TokenGroupClass: unexpected tag %u", tag.number);
				fseek(der, -sublen, SEEK_CUR);
				if((new_item = der_alloc(sizeof(LIST_TYPE(ActionSlot)))) == NULL)
					return der_error("TokenGroupClass: out of memory");
				LIST_APPEND(&type->no_token_action_slots, new_item);
				sublen = der_decode_ActionSlot(der, &new_item->item, sublen + tag.length);
				if(sublen < 0)
					return der_error("TokenGroupClass");
				if(sublen > seqlen)
					return der_error("TokenGroupClass: %u bytes left", seqlen);
				seqlen -= sublen;
			}
		}
		else
			return der_error("TokenGroupClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("TokenGroupClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</TokenGroupClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_TokenGroupClass;

	return length;
}

void
free_TokenGroupClass(TokenGroupClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	LIST_FREE_ITEMS(&type->movement_table, Movement, free_Movement, der_free);

	LIST_FREE_ITEMS(&type->token_group_items, TokenGroupItem, free_TokenGroupItem, der_free);

	LIST_FREE_ITEMS(&type->no_token_action_slots, ActionSlot, free_ActionSlot, der_free);

	return;
}

int
der_decode_ListGroupClass(FILE *der, ListGroupClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ListGroupClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(ListGroupClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->wrap_around = false;
	type->multiple_selection = false;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("ListGroupClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("ListGroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("ListGroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("ListGroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("ListGroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("ListGroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 70)
		{
			/* movement_table OPTIONAL */
			/* SEQUENCE OF Movement */
			int seqlen = tag.length;
			left -= sublen + seqlen;
			while(seqlen > 0)
			{
				der_tag tag;
				LIST_TYPE(Movement) *new_item;
				sublen = der_decode_Tag(der, &tag);
				if(sublen < 0)
					return der_error("ListGroupClass");
				if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
					return der_error("ListGroupClass: unexpected tag %u", tag.number);
				seqlen -= sublen;
				if((new_item = der_alloc(sizeof(LIST_TYPE(Movement)))) == NULL)
					return der_error("ListGroupClass: out of memory");
				LIST_APPEND(&type->movement_table, new_item);
				sublen = der_decode_Movement(der, &new_item->item, tag.length);
				if(sublen < 0)
					return der_error("ListGroupClass");
				if(sublen > seqlen)
					return der_error("ListGroupClass: %u bytes left", seqlen);
				seqlen -= sublen;
			}
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 71)
		{
			/* token_group_items OPTIONAL */
			/* SEQUENCE OF TokenGroupItem */
			int seqlen = tag.length;
			left -= sublen + seqlen;
			while(seqlen > 0)
			{
				der_tag tag;
				LIST_TYPE(TokenGroupItem) *new_item;
				sublen = der_decode_Tag(der, &tag);
				if(sublen < 0)
					return der_error("ListGroupClass");
				if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
					return der_error("ListGroupClass: unexpected tag %u", tag.number);
				seqlen -= sublen;
				if((new_item = der_alloc(sizeof(LIST_TYPE(TokenGroupItem)))) == NULL)
					return der_error("ListGroupClass: out of memory");
				LIST_APPEND(&type->token_group_items, new_item);
				sublen = der_decode_TokenGroupItem(der, &new_item->item, tag.length);
				if(sublen < 0)
					return der_error("ListGroupClass");
				if(sublen > seqlen)
					return der_error("ListGroupClass: %u bytes left", seqlen);
				seqlen -= sublen;
			}
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 72)
		{
			/* no_token_action_slots OPTIONAL */
			/* SEQUENCE OF ActionSlot */
			int seqlen = tag.length;
			left -= sublen + seqlen;
			while(seqlen > 0)
			{
				der_tag tag;
				LIST_TYPE(ActionSlot) *new_item;
				sublen = der_decode_Tag(der, &tag);
				if(sublen < 0)
					return der_error("ListGroupClass");
				if(!((tag.class == DER_CLASS_UNIVERSAL && tag.number == 5)
				|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16)))
					return der_error("ListGroupClass: unexpected tag %u", tag.number);
				fseek(der, -sublen, SEEK_CUR);
				if((new_item = der_alloc(sizeof(LIST_TYPE(ActionSlot)))) == NULL)
					return der_error("ListGroupClass: out of memory");
				LIST_APPEND(&type->no_token_action_slots, new_item);
				sublen = der_decode_ActionSlot(der, &new_item->item, sublen + tag.length);
				if(sublen < 0)
					return der_error("ListGroupClass");
				if(sublen > seqlen)
					return der_error("ListGroupClass: %u bytes left", seqlen);
				seqlen -= sublen;
			}
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 73)
		{
			/* positions */
			/* SEQUENCE OF XYPosition */
			int seqlen = tag.length;
			left -= sublen + seqlen;
			while(seqlen > 0)
			{
				der_tag tag;
				LIST_TYPE(XYPosition) *new_item;
				sublen = der_decode_Tag(der, &tag);
				if(sublen < 0)
					return der_error("ListGroupClass");
				if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
					return der_error("ListGroupClass: unexpected tag %u", tag.number);
				seqlen -= sublen;
				if((new_item = der_alloc(sizeof(LIST_TYPE(XYPosition)))) == NULL)
					return der_error("ListGroupClass: out of memory");
				LIST_APPEND(&type->positions, new_item);
				sublen = der_decode_XYPosition(der, &new_item->item, tag.length);
				if(sublen < 0)
					return der_error("ListGroupClass");
				if(sublen > seqlen)
					return der_error("ListGroupClass: %u bytes left", seqlen);
				seqlen -= sublen;
			}
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 74)
		{
			/* wrap_around DEFAULT false */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->wrap_around, tag.length);
			if(sublen < 0)
				return der_error("ListGroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 75)
		{
			/* multiple_selection DEFAULT false */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->multiple_selection, tag.length);
			if(sublen < 0)
				return der_error("ListGroupClass");
			left -= sublen;
		}
		else
			return der_error("ListGroupClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("ListGroupClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ListGroupClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_ListGroupClass;

	return length;
}

void
free_ListGroupClass(ListGroupClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	LIST_FREE_ITEMS(&type->movement_table, Movement, free_Movement, der_free);

	LIST_FREE_ITEMS(&type->token_group_items, TokenGroupItem, free_TokenGroupItem, der_free);

	LIST_FREE_ITEMS(&type->no_token_action_slots, ActionSlot, free_ActionSlot, der_free);

	LIST_FREE_ITEMS(&type->positions, XYPosition, free_XYPosition, der_free);

	return;
}

int
der_decode_GroupItem(FILE *der, GroupItem *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GroupItem>\n");
#endif

	VK_memset(type, 0x00, sizeof(GroupItem));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("GroupItem");
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 9)
	{
		/* resident_program */
		left -= sublen;
		type->choice = GroupItem_resident_program;
		sublen = der_decode_ResidentProgramClass(der, &type->u.resident_program, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 10)
	{
		/* remote_program */
		left -= sublen;
		type->choice = GroupItem_remote_program;
		sublen = der_decode_RemoteProgramClass(der, &type->u.remote_program, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 11)
	{
		/* interchanged_program */
		left -= sublen;
		type->choice = GroupItem_interchanged_program;
		sublen = der_decode_InterchangedProgramClass(der, &type->u.interchanged_program, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 12)
	{
		/* palette */
		left -= sublen;
		type->choice = GroupItem_palette;
		sublen = der_decode_PaletteClass(der, &type->u.palette, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 13)
	{
		/* font */
		left -= sublen;
		type->choice = GroupItem_font;
		sublen = der_decode_FontClass(der, &type->u.font, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 14)
	{
		/* cursor_shape */
		left -= sublen;
		type->choice = GroupItem_cursor_shape;
		sublen = der_decode_CursorShapeClass(der, &type->u.cursor_shape, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 15)
	{
		/* boolean_variable */
		left -= sublen;
		type->choice = GroupItem_boolean_variable;
		sublen = der_decode_BooleanVariableClass(der, &type->u.boolean_variable, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 16)
	{
		/* integer_variable */
		left -= sublen;
		type->choice = GroupItem_integer_variable;
		sublen = der_decode_IntegerVariableClass(der, &type->u.integer_variable, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 17)
	{
		/* octet_string_variable */
		left -= sublen;
		type->choice = GroupItem_octet_string_variable;
		sublen = der_decode_OctetStringVariableClass(der, &type->u.octet_string_variable, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 18)
	{
		/* object_ref_variable */
		left -= sublen;
		type->choice = GroupItem_object_ref_variable;
		sublen = der_decode_ObjectRefVariableClass(der, &type->u.object_ref_variable, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 19)
	{
		/* content_ref_variable */
		left -= sublen;
		type->choice = GroupItem_content_ref_variable;
		sublen = der_decode_ContentRefVariableClass(der, &type->u.content_ref_variable, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 20)
	{
		/* link */
		left -= sublen;
		type->choice = GroupItem_link;
		sublen = der_decode_LinkClass(der, &type->u.link, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 21)
	{
		/* stream */
		left -= sublen;
		type->choice = GroupItem_stream;
		sublen = der_decode_StreamClass(der, &type->u.stream, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 22)
	{
		/* bitmap */
		left -= sublen;
		type->choice = GroupItem_bitmap;
		sublen = der_decode_BitmapClass(der, &type->u.bitmap, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 23)
	{
		/* line_art */
		left -= sublen;
		type->choice = GroupItem_line_art;
		sublen = der_decode_LineArtClass(der, &type->u.line_art, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 24)
	{
		/* dynamic_line_art */
		left -= sublen;
		type->choice = GroupItem_dynamic_line_art;
		sublen = der_decode_DynamicLineArtClass(der, &type->u.dynamic_line_art, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 25)
	{
		/* rectangle */
		left -= sublen;
		type->choice = GroupItem_rectangle;
		sublen = der_decode_RectangleClass(der, &type->u.rectangle, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 26)
	{
		/* hotspot */
		left -= sublen;
		type->choice = GroupItem_hotspot;
		sublen = der_decode_HotspotClass(der, &type->u.hotspot, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 27)
	{
		/* switch_button */
		left -= sublen;
		type->choice = GroupItem_switch_button;
		sublen = der_decode_SwitchButtonClass(der, &type->u.switch_button, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 28)
	{
		/* push_button */
		left -= sublen;
		type->choice = GroupItem_push_button;
		sublen = der_decode_PushButtonClass(der, &type->u.push_button, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 29)
	{
		/* text */
		left -= sublen;
		type->choice = GroupItem_text;
		sublen = der_decode_TextClass(der, &type->u.text, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 30)
	{
		/* entry_field */
		left -= sublen;
		type->choice = GroupItem_entry_field;
		sublen = der_decode_EntryFieldClass(der, &type->u.entry_field, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 31)
	{
		/* hyper_text */
		left -= sublen;
		type->choice = GroupItem_hyper_text;
		sublen = der_decode_HyperTextClass(der, &type->u.hyper_text, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 32)
	{
		/* slider */
		left -= sublen;
		type->choice = GroupItem_slider;
		sublen = der_decode_SliderClass(der, &type->u.slider, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 33)
	{
		/* token_group */
		left -= sublen;
		type->choice = GroupItem_token_group;
		sublen = der_decode_TokenGroupClass(der, &type->u.token_group, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 34)
	{
		/* list_group */
		left -= sublen;
		type->choice = GroupItem_list_group;
		sublen = der_decode_ListGroupClass(der, &type->u.list_group, tag.length);
		if(sublen < 0)
			return der_error("GroupItem");
		left -= sublen;
	}
	else
		return der_error("GroupItem: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("GroupItem: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GroupItem>\n");
#endif

	return length;
}

void
free_GroupItem(GroupItem *type)
{
	switch(type->choice)
	{
	case GroupItem_resident_program:
		free_ResidentProgramClass(&type->u.resident_program);
		break;

	case GroupItem_remote_program:
		free_RemoteProgramClass(&type->u.remote_program);
		break;

	case GroupItem_interchanged_program:
		free_InterchangedProgramClass(&type->u.interchanged_program);
		break;

	case GroupItem_palette:
		free_PaletteClass(&type->u.palette);
		break;

	case GroupItem_font:
		free_FontClass(&type->u.font);
		break;

	case GroupItem_cursor_shape:
		free_CursorShapeClass(&type->u.cursor_shape);
		break;

	case GroupItem_boolean_variable:
		free_BooleanVariableClass(&type->u.boolean_variable);
		break;

	case GroupItem_integer_variable:
		free_IntegerVariableClass(&type->u.integer_variable);
		break;

	case GroupItem_octet_string_variable:
		free_OctetStringVariableClass(&type->u.octet_string_variable);
		break;

	case GroupItem_object_ref_variable:
		free_ObjectRefVariableClass(&type->u.object_ref_variable);
		break;

	case GroupItem_content_ref_variable:
		free_ContentRefVariableClass(&type->u.content_ref_variable);
		break;

	case GroupItem_link:
		free_LinkClass(&type->u.link);
		break;

	case GroupItem_stream:
		free_StreamClass(&type->u.stream);
		break;

	case GroupItem_bitmap:
		free_BitmapClass(&type->u.bitmap);
		break;

	case GroupItem_line_art:
		free_LineArtClass(&type->u.line_art);
		break;

	case GroupItem_dynamic_line_art:
		free_DynamicLineArtClass(&type->u.dynamic_line_art);
		break;

	case GroupItem_rectangle:
		free_RectangleClass(&type->u.rectangle);
		break;

	case GroupItem_hotspot:
		free_HotspotClass(&type->u.hotspot);
		break;

	case GroupItem_switch_button:
		free_SwitchButtonClass(&type->u.switch_button);
		break;

	case GroupItem_push_button:
		free_PushButtonClass(&type->u.push_button);
		break;

	case GroupItem_text:
		free_TextClass(&type->u.text);
		break;

	case GroupItem_entry_field:
		free_EntryFieldClass(&type->u.entry_field);
		break;

	case GroupItem_hyper_text:
		free_HyperTextClass(&type->u.hyper_text);
		break;

	case GroupItem_slider:
		free_SliderClass(&type->u.slider);
		break;

	case GroupItem_token_group:
		free_TokenGroupClass(&type->u.token_group);
		break;

	case GroupItem_list_group:
		free_ListGroupClass(&type->u.list_group);
		break;

	default:
		der_error("free_GroupItem: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_DefaultAttribute(FILE *der, DefaultAttribute *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<DefaultAttribute>\n");
#endif

	VK_memset(type, 0x00, sizeof(DefaultAttribute));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("DefaultAttribute");
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 38)
	{
		/* character_set */
		left -= sublen;
		type->choice = DefaultAttribute_character_set;
		sublen = der_decode_Integer(der, (int *) &type->u.character_set, tag.length);
		if(sublen < 0)
			return der_error("DefaultAttribute");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 39)
	{
		/* background_colour */
		left -= sublen;
		type->choice = DefaultAttribute_background_colour;
		sublen = der_decode_Colour(der, &type->u.background_colour, tag.length);
		if(sublen < 0)
			return der_error("DefaultAttribute");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 40)
	{
		/* text_content_hook */
		left -= sublen;
		type->choice = DefaultAttribute_text_content_hook;
		sublen = der_decode_Integer(der, (int *) &type->u.text_content_hook, tag.length);
		if(sublen < 0)
			return der_error("DefaultAttribute");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 41)
	{
		/* text_colour */
		left -= sublen;
		type->choice = DefaultAttribute_text_colour;
		sublen = der_decode_Colour(der, &type->u.text_colour, tag.length);
		if(sublen < 0)
			return der_error("DefaultAttribute");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 42)
	{
		/* font */
		left -= sublen;
		type->choice = DefaultAttribute_font;
		sublen = der_decode_FontBody(der, &type->u.font, tag.length);
		if(sublen < 0)
			return der_error("DefaultAttribute");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 43)
	{
		/* font_attributes */
		left -= sublen;
		type->choice = DefaultAttribute_font_attributes;
		sublen = der_decode_OctetString(der, &type->u.font_attributes, tag.length);
		if(sublen < 0)
			return der_error("DefaultAttribute");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 44)
	{
		/* interchanged_program_content_hook */
		left -= sublen;
		type->choice = DefaultAttribute_interchanged_program_content_hook;
		sublen = der_decode_Integer(der, (int *) &type->u.interchanged_program_content_hook, tag.length);
		if(sublen < 0)
			return der_error("DefaultAttribute");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 45)
	{
		/* stream_content_hook */
		left -= sublen;
		type->choice = DefaultAttribute_stream_content_hook;
		sublen = der_decode_Integer(der, (int *) &type->u.stream_content_hook, tag.length);
		if(sublen < 0)
			return der_error("DefaultAttribute");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 46)
	{
		/* bitmap_content_hook */
		left -= sublen;
		type->choice = DefaultAttribute_bitmap_content_hook;
		sublen = der_decode_Integer(der, (int *) &type->u.bitmap_content_hook, tag.length);
		if(sublen < 0)
			return der_error("DefaultAttribute");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 47)
	{
		/* line_art_content_hook */
		left -= sublen;
		type->choice = DefaultAttribute_line_art_content_hook;
		sublen = der_decode_Integer(der, (int *) &type->u.line_art_content_hook, tag.length);
		if(sublen < 0)
			return der_error("DefaultAttribute");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 48)
	{
		/* button_ref_colour */
		left -= sublen;
		type->choice = DefaultAttribute_button_ref_colour;
		sublen = der_decode_Colour(der, &type->u.button_ref_colour, tag.length);
		if(sublen < 0)
			return der_error("DefaultAttribute");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 49)
	{
		/* highlight_ref_colour */
		left -= sublen;
		type->choice = DefaultAttribute_highlight_ref_colour;
		sublen = der_decode_Colour(der, &type->u.highlight_ref_colour, tag.length);
		if(sublen < 0)
			return der_error("DefaultAttribute");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 50)
	{
		/* slider_ref_colour */
		left -= sublen;
		type->choice = DefaultAttribute_slider_ref_colour;
		sublen = der_decode_Colour(der, &type->u.slider_ref_colour, tag.length);
		if(sublen < 0)
			return der_error("DefaultAttribute");
		left -= sublen;
	}
	else
		return der_error("DefaultAttribute: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("DefaultAttribute: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</DefaultAttribute>\n");
#endif

	return length;
}

void
free_DefaultAttribute(DefaultAttribute *type)
{
	switch(type->choice)
	{
	case DefaultAttribute_character_set:
		break;

	case DefaultAttribute_background_colour:
		free_Colour(&type->u.background_colour);
		break;

	case DefaultAttribute_text_content_hook:
		break;

	case DefaultAttribute_text_colour:
		free_Colour(&type->u.text_colour);
		break;

	case DefaultAttribute_font:
		free_FontBody(&type->u.font);
		break;

	case DefaultAttribute_font_attributes:
		free_OctetString(&type->u.font_attributes);
		break;

	case DefaultAttribute_interchanged_program_content_hook:
		break;

	case DefaultAttribute_stream_content_hook:
		break;

	case DefaultAttribute_bitmap_content_hook:
		break;

	case DefaultAttribute_line_art_content_hook:
		break;

	case DefaultAttribute_button_ref_colour:
		free_Colour(&type->u.button_ref_colour);
		break;

	case DefaultAttribute_highlight_ref_colour:
		free_Colour(&type->u.highlight_ref_colour);
		break;

	case DefaultAttribute_slider_ref_colour:
		free_Colour(&type->u.slider_ref_colour);
		break;

	default:
		der_error("free_DefaultAttribute: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_ApplicationClass(FILE *der, ApplicationClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<ApplicationClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(ApplicationClass));

	/* DEFAULT values */
	type->original_group_cache_priority = 127;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("ApplicationClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("ApplicationClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 2)
		{
			/* standard_identifier OPTIONAL */
			left -= sublen;
			type->have_standard_identifier = true;
			sublen = der_decode_StandardIdentifier(der, &type->standard_identifier, tag.length);
			if(sublen < 0)
				return der_error("ApplicationClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 3)
		{
			/* standard_version OPTIONAL */
			left -= sublen;
			type->have_standard_version = true;
			sublen = der_decode_Integer(der, (int *) &type->standard_version, tag.length);
			if(sublen < 0)
				return der_error("ApplicationClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 4)
		{
			/* object_information OPTIONAL */
			left -= sublen;
			type->have_object_information = true;
			sublen = der_decode_OctetString(der, &type->object_information, tag.length);
			if(sublen < 0)
				return der_error("ApplicationClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 5)
		{
			/* on_start_up OPTIONAL */
			left -= sublen;
			type->have_on_start_up = true;
			sublen = der_decode_ActionClass(der, &type->on_start_up, tag.length);
			if(sublen < 0)
				return der_error("ApplicationClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 6)
		{
			/* on_close_down OPTIONAL */
			left -= sublen;
			type->have_on_close_down = true;
			sublen = der_decode_ActionClass(der, &type->on_close_down, tag.length);
			if(sublen < 0)
				return der_error("ApplicationClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 7)
		{
			/* original_group_cache_priority DEFAULT 127 */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->original_group_cache_priority, tag.length);
			if(sublen < 0)
				return der_error("ApplicationClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 8)
		{
			/* items OPTIONAL */
			/* SEQUENCE OF GroupItem */
			int seqlen = tag.length;
			left -= sublen + seqlen;
			while(seqlen > 0)
			{
				der_tag tag;
				LIST_TYPE(GroupItem) *new_item;
				sublen = der_decode_Tag(der, &tag);
				if(sublen < 0)
					return der_error("ApplicationClass");
				if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 9)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 10)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 11)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 12)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 13)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 14)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 15)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 16)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 17)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 18)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 19)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 20)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 21)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 22)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 23)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 24)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 25)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 26)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 27)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 28)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 29)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 30)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 31)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 32)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 33)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 34)))
					return der_error("ApplicationClass: unexpected tag %u", tag.number);
				fseek(der, -sublen, SEEK_CUR);
				if((new_item = der_alloc(sizeof(LIST_TYPE(GroupItem)))) == NULL)
					return der_error("ApplicationClass: out of memory");
				LIST_APPEND(&type->items, new_item);
				sublen = der_decode_GroupItem(der, &new_item->item, sublen + tag.length);
				if(sublen < 0)
					return der_error("ApplicationClass");
				if(sublen > seqlen)
					return der_error("ApplicationClass: %u bytes left", seqlen);
				seqlen -= sublen;
			}
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 35)
		{
			/* on_spawn_close_down OPTIONAL */
			left -= sublen;
			type->have_on_spawn_close_down = true;
			sublen = der_decode_ActionClass(der, &type->on_spawn_close_down, tag.length);
			if(sublen < 0)
				return der_error("ApplicationClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 36)
		{
			/* on_restart OPTIONAL */
			left -= sublen;
			type->have_on_restart = true;
			sublen = der_decode_ActionClass(der, &type->on_restart, tag.length);
			if(sublen < 0)
				return der_error("ApplicationClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 37)
		{
			/* default_attributes OPTIONAL */
			/* SEQUENCE OF DefaultAttribute */
			int seqlen = tag.length;
			left -= sublen + seqlen;
			while(seqlen > 0)
			{
				der_tag tag;
				LIST_TYPE(DefaultAttribute) *new_item;
				sublen = der_decode_Tag(der, &tag);
				if(sublen < 0)
					return der_error("ApplicationClass");
				if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 38)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 39)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 40)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 41)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 42)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 43)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 44)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 45)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 46)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 47)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 48)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 49)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 50)))
					return der_error("ApplicationClass: unexpected tag %u", tag.number);
				fseek(der, -sublen, SEEK_CUR);
				if((new_item = der_alloc(sizeof(LIST_TYPE(DefaultAttribute)))) == NULL)
					return der_error("ApplicationClass: out of memory");
				LIST_APPEND(&type->default_attributes, new_item);
				sublen = der_decode_DefaultAttribute(der, &new_item->item, sublen + tag.length);
				if(sublen < 0)
					return der_error("ApplicationClass");
				if(sublen > seqlen)
					return der_error("ApplicationClass: %u bytes left", seqlen);
				seqlen -= sublen;
			}
		}
		else
			return der_error("ApplicationClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("ApplicationClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</ApplicationClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_ApplicationClass;

	return length;
}

void
free_ApplicationClass(ApplicationClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_standard_identifier)
		free_StandardIdentifier(&type->standard_identifier);

	if(type->have_object_information)
		free_OctetString(&type->object_information);

	if(type->have_on_start_up)
		free_ActionClass(&type->on_start_up);

	if(type->have_on_close_down)
		free_ActionClass(&type->on_close_down);

	LIST_FREE_ITEMS(&type->items, GroupItem, free_GroupItem, der_free);

	if(type->have_on_spawn_close_down)
		free_ActionClass(&type->on_spawn_close_down);

	if(type->have_on_restart)
		free_ActionClass(&type->on_restart);

	LIST_FREE_ITEMS(&type->default_attributes, DefaultAttribute, free_DefaultAttribute, der_free);

	return;
}

int
der_decode_SceneCoordinateSystem(FILE *der, SceneCoordinateSystem *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SceneCoordinateSystem>\n");
#endif

	VK_memset(type, 0x00, sizeof(SceneCoordinateSystem));

	/* SEQUENCE */
	/* x_scene */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SceneCoordinateSystem");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2))
		return der_error("SceneCoordinateSystem: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_Integer(der, (int *) &type->x_scene, tag.length);
	if(sublen < 0)
		return der_error("SceneCoordinateSystem");
	left -= sublen;

	/* y_scene */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("SceneCoordinateSystem");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2))
		return der_error("SceneCoordinateSystem: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_Integer(der, (int *) &type->y_scene, tag.length);
	if(sublen < 0)
		return der_error("SceneCoordinateSystem");
	left -= sublen;

	if(left != 0)
		return der_error("SceneCoordinateSystem: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SceneCoordinateSystem>\n");
#endif

	return length;
}

void
free_SceneCoordinateSystem(SceneCoordinateSystem *type)
{
	return;
}

int
der_decode_AspectRatio(FILE *der, AspectRatio *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<AspectRatio>\n");
#endif

	VK_memset(type, 0x00, sizeof(AspectRatio));

	/* SEQUENCE */
	/* width */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("AspectRatio");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2))
		return der_error("AspectRatio: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_Integer(der, (int *) &type->width, tag.length);
	if(sublen < 0)
		return der_error("AspectRatio");
	left -= sublen;

	/* height */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("AspectRatio");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2))
		return der_error("AspectRatio: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_Integer(der, (int *) &type->height, tag.length);
	if(sublen < 0)
		return der_error("AspectRatio");
	left -= sublen;

	if(left != 0)
		return der_error("AspectRatio: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</AspectRatio>\n");
#endif

	return length;
}

void
free_AspectRatio(AspectRatio *type)
{
	return;
}

int
der_decode_NextScene(FILE *der, NextScene *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<NextScene>\n");
#endif

	VK_memset(type, 0x00, sizeof(NextScene));

	/* SEQUENCE */
	/* scene_ref */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("NextScene");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 4))
		return der_error("NextScene: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_OctetString(der, &type->scene_ref, tag.length);
	if(sublen < 0)
		return der_error("NextScene");
	left -= sublen;

	/* scene_weight */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("NextScene");
	if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 2))
		return der_error("NextScene: unexpected tag %u", tag.number);
	left -= sublen;
	sublen = der_decode_Integer(der, (int *) &type->scene_weight, tag.length);
	if(sublen < 0)
		return der_error("NextScene");
	left -= sublen;

	if(left != 0)
		return der_error("NextScene: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</NextScene>\n");
#endif

	return length;
}

void
free_NextScene(NextScene *type)
{
	free_OctetString(&type->scene_ref);

	return;
}

int
der_decode_SceneClass(FILE *der, SceneClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<SceneClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(SceneClass));

	/* DEFAULT values */
	type->original_group_cache_priority = 127;
	type->moving_cursor = false;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("SceneClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("SceneClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 2)
		{
			/* standard_identifier OPTIONAL */
			left -= sublen;
			type->have_standard_identifier = true;
			sublen = der_decode_StandardIdentifier(der, &type->standard_identifier, tag.length);
			if(sublen < 0)
				return der_error("SceneClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 3)
		{
			/* standard_version OPTIONAL */
			left -= sublen;
			type->have_standard_version = true;
			sublen = der_decode_Integer(der, (int *) &type->standard_version, tag.length);
			if(sublen < 0)
				return der_error("SceneClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 4)
		{
			/* object_information OPTIONAL */
			left -= sublen;
			type->have_object_information = true;
			sublen = der_decode_OctetString(der, &type->object_information, tag.length);
			if(sublen < 0)
				return der_error("SceneClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 5)
		{
			/* on_start_up OPTIONAL */
			left -= sublen;
			type->have_on_start_up = true;
			sublen = der_decode_ActionClass(der, &type->on_start_up, tag.length);
			if(sublen < 0)
				return der_error("SceneClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 6)
		{
			/* on_close_down OPTIONAL */
			left -= sublen;
			type->have_on_close_down = true;
			sublen = der_decode_ActionClass(der, &type->on_close_down, tag.length);
			if(sublen < 0)
				return der_error("SceneClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 7)
		{
			/* original_group_cache_priority DEFAULT 127 */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->original_group_cache_priority, tag.length);
			if(sublen < 0)
				return der_error("SceneClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 8)
		{
			/* items OPTIONAL */
			/* SEQUENCE OF GroupItem */
			int seqlen = tag.length;
			left -= sublen + seqlen;
			while(seqlen > 0)
			{
				der_tag tag;
				LIST_TYPE(GroupItem) *new_item;
				sublen = der_decode_Tag(der, &tag);
				if(sublen < 0)
					return der_error("SceneClass");
				if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 9)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 10)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 11)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 12)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 13)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 14)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 15)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 16)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 17)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 18)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 19)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 20)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 21)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 22)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 23)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 24)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 25)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 26)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 27)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 28)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 29)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 30)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 31)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 32)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 33)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 34)))
					return der_error("SceneClass: unexpected tag %u", tag.number);
				fseek(der, -sublen, SEEK_CUR);
				if((new_item = der_alloc(sizeof(LIST_TYPE(GroupItem)))) == NULL)
					return der_error("SceneClass: out of memory");
				LIST_APPEND(&type->items, new_item);
				sublen = der_decode_GroupItem(der, &new_item->item, sublen + tag.length);
				if(sublen < 0)
					return der_error("SceneClass");
				if(sublen > seqlen)
					return der_error("SceneClass: %u bytes left", seqlen);
				seqlen -= sublen;
			}
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 51)
		{
			/* input_event_register */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->input_event_register, tag.length);
			if(sublen < 0)
				return der_error("SceneClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 52)
		{
			/* scene_coordinate_system */
			left -= sublen;
			sublen = der_decode_SceneCoordinateSystem(der, &type->scene_coordinate_system, tag.length);
			if(sublen < 0)
				return der_error("SceneClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 53)
		{
			/* aspect_ratio OPTIONAL */
			left -= sublen;
			type->have_aspect_ratio = true;
			sublen = der_decode_AspectRatio(der, &type->aspect_ratio, tag.length);
			if(sublen < 0)
				return der_error("SceneClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 54)
		{
			/* moving_cursor DEFAULT false */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->moving_cursor, tag.length);
			if(sublen < 0)
				return der_error("SceneClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 55)
		{
			/* next_scenes OPTIONAL */
			/* SEQUENCE OF NextScene */
			int seqlen = tag.length;
			left -= sublen + seqlen;
			while(seqlen > 0)
			{
				der_tag tag;
				LIST_TYPE(NextScene) *new_item;
				sublen = der_decode_Tag(der, &tag);
				if(sublen < 0)
					return der_error("SceneClass");
				if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
					return der_error("SceneClass: unexpected tag %u", tag.number);
				seqlen -= sublen;
				if((new_item = der_alloc(sizeof(LIST_TYPE(NextScene)))) == NULL)
					return der_error("SceneClass: out of memory");
				LIST_APPEND(&type->next_scenes, new_item);
				sublen = der_decode_NextScene(der, &new_item->item, tag.length);
				if(sublen < 0)
					return der_error("SceneClass");
				if(sublen > seqlen)
					return der_error("SceneClass: %u bytes left", seqlen);
				seqlen -= sublen;
			}
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 253)
		{
			/* input_event_mask OPTIONAL */
			left -= sublen;
			type->have_input_event_mask = true;
			sublen = der_decode_OctetString(der, &type->input_event_mask, tag.length);
			if(sublen < 0)
				return der_error("SceneClass");
			left -= sublen;
		}
		else
			return der_error("SceneClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("SceneClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</SceneClass>\n");
#endif

	type->rootClass.inst.rtti = RTTI_SceneClass;

	return length;
}

void
free_SceneClass(SceneClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_standard_identifier)
		free_StandardIdentifier(&type->standard_identifier);

	if(type->have_object_information)
		free_OctetString(&type->object_information);

	if(type->have_on_start_up)
		free_ActionClass(&type->on_start_up);

	if(type->have_on_close_down)
		free_ActionClass(&type->on_close_down);

	LIST_FREE_ITEMS(&type->items, GroupItem, free_GroupItem, der_free);

	free_SceneCoordinateSystem(&type->scene_coordinate_system);

	if(type->have_aspect_ratio)
		free_AspectRatio(&type->aspect_ratio);

	LIST_FREE_ITEMS(&type->next_scenes, NextScene, free_NextScene, der_free);

	if(type->have_input_event_mask)
		free_OctetString(&type->input_event_mask);

	return;
}

int
der_decode_InterchangedObject(FILE *der, InterchangedObject *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<InterchangedObject>\n");
#endif

	VK_memset(type, 0x00, sizeof(InterchangedObject));

	/* CHOICE */
	sublen = der_decode_Tag(der, &tag);
	if(sublen < 0)
		return der_error("InterchangedObject");
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 0)
	{
		/* application */
		left -= sublen;
		type->choice = InterchangedObject_application;
		sublen = der_decode_ApplicationClass(der, &type->u.application, tag.length);
		if(sublen < 0)
			return der_error("InterchangedObject");
		left -= sublen;
	}
	else
	if(tag.class == DER_CLASS_CONTEXT && tag.number == 1)
	{
		/* scene */
		left -= sublen;
		type->choice = InterchangedObject_scene;
		sublen = der_decode_SceneClass(der, &type->u.scene, tag.length);
		if(sublen < 0)
			return der_error("InterchangedObject");
		left -= sublen;
	}
	else
		return der_error("InterchangedObject: invalid choice tag (%u)", tag.number);

	if(left != 0)
		return der_error("InterchangedObject: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</InterchangedObject>\n");
#endif

	return length;
}

void
free_InterchangedObject(InterchangedObject *type)
{
	switch(type->choice)
	{
	case InterchangedObject_application:
		free_ApplicationClass(&type->u.application);
		break;

	case InterchangedObject_scene:
		free_SceneClass(&type->u.scene);
		break;

	default:
		der_error("free_InterchangedObject: invalid choice (%u)", type->choice);
		break;
	}

	return;
}

int
der_decode_GroupClass(FILE *der, GroupClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<GroupClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(GroupClass));

	/* DEFAULT values */
	type->original_group_cache_priority = 127;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("GroupClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("GroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 2)
		{
			/* standard_identifier OPTIONAL */
			left -= sublen;
			type->have_standard_identifier = true;
			sublen = der_decode_StandardIdentifier(der, &type->standard_identifier, tag.length);
			if(sublen < 0)
				return der_error("GroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 3)
		{
			/* standard_version OPTIONAL */
			left -= sublen;
			type->have_standard_version = true;
			sublen = der_decode_Integer(der, (int *) &type->standard_version, tag.length);
			if(sublen < 0)
				return der_error("GroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 4)
		{
			/* object_information OPTIONAL */
			left -= sublen;
			type->have_object_information = true;
			sublen = der_decode_OctetString(der, &type->object_information, tag.length);
			if(sublen < 0)
				return der_error("GroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 5)
		{
			/* on_start_up OPTIONAL */
			left -= sublen;
			type->have_on_start_up = true;
			sublen = der_decode_ActionClass(der, &type->on_start_up, tag.length);
			if(sublen < 0)
				return der_error("GroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 6)
		{
			/* on_close_down OPTIONAL */
			left -= sublen;
			type->have_on_close_down = true;
			sublen = der_decode_ActionClass(der, &type->on_close_down, tag.length);
			if(sublen < 0)
				return der_error("GroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 7)
		{
			/* original_group_cache_priority DEFAULT 127 */
			left -= sublen;
			sublen = der_decode_Integer(der, (int *) &type->original_group_cache_priority, tag.length);
			if(sublen < 0)
				return der_error("GroupClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 8)
		{
			/* items OPTIONAL */
			/* SEQUENCE OF GroupItem */
			int seqlen = tag.length;
			left -= sublen + seqlen;
			while(seqlen > 0)
			{
				der_tag tag;
				LIST_TYPE(GroupItem) *new_item;
				sublen = der_decode_Tag(der, &tag);
				if(sublen < 0)
					return der_error("GroupClass");
				if(!((tag.class == DER_CLASS_CONTEXT && tag.number == 9)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 10)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 11)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 12)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 13)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 14)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 15)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 16)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 17)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 18)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 19)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 20)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 21)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 22)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 23)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 24)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 25)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 26)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 27)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 28)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 29)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 30)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 31)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 32)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 33)
				|| (tag.class == DER_CLASS_CONTEXT && tag.number == 34)))
					return der_error("GroupClass: unexpected tag %u", tag.number);
				fseek(der, -sublen, SEEK_CUR);
				if((new_item = der_alloc(sizeof(LIST_TYPE(GroupItem)))) == NULL)
					return der_error("GroupClass: out of memory");
				LIST_APPEND(&type->items, new_item);
				sublen = der_decode_GroupItem(der, &new_item->item, sublen + tag.length);
				if(sublen < 0)
					return der_error("GroupClass");
				if(sublen > seqlen)
					return der_error("GroupClass: %u bytes left", seqlen);
				seqlen -= sublen;
			}
		}
		else
			return der_error("GroupClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("GroupClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</GroupClass>\n");
#endif

	return length;
}

void
free_GroupClass(GroupClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_standard_identifier)
		free_StandardIdentifier(&type->standard_identifier);

	if(type->have_object_information)
		free_OctetString(&type->object_information);

	if(type->have_on_start_up)
		free_ActionClass(&type->on_start_up);

	if(type->have_on_close_down)
		free_ActionClass(&type->on_close_down);

	LIST_FREE_ITEMS(&type->items, GroupItem, free_GroupItem, der_free);

	return;
}

int
der_decode_TokenManagerClass(FILE *der, TokenManagerClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<TokenManagerClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(TokenManagerClass));

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("TokenManagerClass");
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 70)
		{
			/* movement_table OPTIONAL */
			/* SEQUENCE OF Movement */
			int seqlen = tag.length;
			left -= sublen + seqlen;
			while(seqlen > 0)
			{
				der_tag tag;
				LIST_TYPE(Movement) *new_item;
				sublen = der_decode_Tag(der, &tag);
				if(sublen < 0)
					return der_error("TokenManagerClass");
				if(!(tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
					return der_error("TokenManagerClass: unexpected tag %u", tag.number);
				seqlen -= sublen;
				if((new_item = der_alloc(sizeof(LIST_TYPE(Movement)))) == NULL)
					return der_error("TokenManagerClass: out of memory");
				LIST_APPEND(&type->movement_table, new_item);
				sublen = der_decode_Movement(der, &new_item->item, tag.length);
				if(sublen < 0)
					return der_error("TokenManagerClass");
				if(sublen > seqlen)
					return der_error("TokenManagerClass: %u bytes left", seqlen);
				seqlen -= sublen;
			}
		}
		else
			return der_error("TokenManagerClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("TokenManagerClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</TokenManagerClass>\n");
#endif

	return length;
}

void
free_TokenManagerClass(TokenManagerClass *type)
{
	LIST_FREE_ITEMS(&type->movement_table, Movement, free_Movement, der_free);

	return;
}

int
der_decode_VisibleClass(FILE *der, VisibleClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<VisibleClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(VisibleClass));

	/* DEFAULT values */
	type->initially_active = true;
	type->original_position.x_position = 0;
	type->original_position.y_position = 0;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("VisibleClass");
		if((tag.class == DER_CLASS_UNIVERSAL && tag.number == 2)
		|| (tag.class == DER_CLASS_UNIVERSAL && tag.number == 16))
		{
			/* rootClass */
			fseek(der, -sublen, SEEK_CUR);
			sublen = der_decode_RootClass(der, &type->rootClass, sublen + tag.length);
			if(sublen < 0)
				return der_error("VisibleClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 56)
		{
			/* initially_active DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->initially_active, tag.length);
			if(sublen < 0)
				return der_error("VisibleClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 57)
		{
			/* content_hook OPTIONAL */
			left -= sublen;
			type->have_content_hook = true;
			sublen = der_decode_Integer(der, (int *) &type->content_hook, tag.length);
			if(sublen < 0)
				return der_error("VisibleClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 58)
		{
			/* original_content OPTIONAL */
			left -= sublen;
			type->have_original_content = true;
			sublen = der_decode_ContentBody(der, &type->original_content, tag.length);
			if(sublen < 0)
				return der_error("VisibleClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 59)
		{
			/* shared OPTIONAL */
			left -= sublen;
			type->have_shared = true;
			sublen = der_decode_Boolean(der, &type->shared, tag.length);
			if(sublen < 0)
				return der_error("VisibleClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 76)
		{
			/* original_box_size */
			left -= sublen;
			sublen = der_decode_OriginalBoxSize(der, &type->original_box_size, tag.length);
			if(sublen < 0)
				return der_error("VisibleClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 77)
		{
			/* original_position DEFAULT {x_position 0, y_position 0} */
			left -= sublen;
			sublen = der_decode_XYPosition(der, &type->original_position, tag.length);
			if(sublen < 0)
				return der_error("VisibleClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 78)
		{
			/* original_palette_ref OPTIONAL */
			left -= sublen;
			type->have_original_palette_ref = true;
			sublen = der_decode_ObjectReference(der, &type->original_palette_ref, tag.length);
			if(sublen < 0)
				return der_error("VisibleClass");
			left -= sublen;
		}
		else
			return der_error("VisibleClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("VisibleClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</VisibleClass>\n");
#endif

	return length;
}

void
free_VisibleClass(VisibleClass *type)
{
	free_RootClass(&type->rootClass);

	if(type->have_original_content)
		free_ContentBody(&type->original_content);

	free_OriginalBoxSize(&type->original_box_size);

	free_XYPosition(&type->original_position);

	if(type->have_original_palette_ref)
		free_ObjectReference(&type->original_palette_ref);

	return;
}

int
der_decode_InteractibleClass(FILE *der, InteractibleClass *type, int length)
{
	int left = length;
	int sublen;
	der_tag tag;

#if (DER_VERBOSE)
	VK_Print("<InteractibleClass>\n");
#endif

	VK_memset(type, 0x00, sizeof(InteractibleClass));

	/* DEFAULT values */
	type->engine_resp = true;

	/* SET */
	while(left > 0)
	{
		sublen = der_decode_Tag(der, &tag);
		if(sublen < 0)
			return der_error("InteractibleClass");
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 49)
		{
			/* highlight_ref_colour OPTIONAL */
			left -= sublen;
			type->have_highlight_ref_colour = true;
			sublen = der_decode_Colour(der, &type->highlight_ref_colour, tag.length);
			if(sublen < 0)
				return der_error("InteractibleClass");
			left -= sublen;
		}
		else
		if(tag.class == DER_CLASS_CONTEXT && tag.number == 101)
		{
			/* engine_resp DEFAULT true */
			left -= sublen;
			sublen = der_decode_Boolean(der, &type->engine_resp, tag.length);
			if(sublen < 0)
				return der_error("InteractibleClass");
			left -= sublen;
		}
		else
			return der_error("InteractibleClass: unexpected tag %u", tag.number);
	}

	if(left != 0)
		return der_error("InteractibleClass: %d bytes left", left);

#if (DER_VERBOSE)
	VK_Print("</InteractibleClass>\n");
#endif

	return length;
}

void
free_InteractibleClass(InteractibleClass *type)
{
	if(type->have_highlight_ref_colour)
		free_Colour(&type->highlight_ref_colour);

	return;
}

