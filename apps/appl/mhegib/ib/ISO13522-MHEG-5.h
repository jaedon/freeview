/*
 * This file was automatically generated by external script. Do not edit directly!
 */

#ifndef __ISO13522_MHEG_5_H__
#define __ISO13522_MHEG_5_H__

#include "listof.h"
#include "der_decode.h"
#include "rtti.h"
#include "utils.h"

/*
 * ExternalReference
 */
typedef struct ExternalReference
{
	OctetString group_identifier;
	unsigned int object_number;
} ExternalReference;

DEFINE_LIST_OF(ExternalReference);

int der_decode_ExternalReference(FILE *, ExternalReference *, int);
/* only free's the contents, not the type itself */
void free_ExternalReference(ExternalReference *);

/*
 * ObjectReference
 */
typedef struct ObjectReference
{
	unsigned int choice;
	union {
		unsigned int internal_reference;	/* choice == 1 */
#define ObjectReference_internal_reference 1
		ExternalReference external_reference;	/* choice == 2 */
#define ObjectReference_external_reference 2
	} u;
} ObjectReference;

DEFINE_LIST_OF(ObjectReference);

int der_decode_ObjectReference(FILE *, ObjectReference *, int);
/* only free's the contents, not the type itself */
void free_ObjectReference(ObjectReference *);

/*
 * RootClass
 */
typedef struct
{
	/* runtime type info */
	RunTimeTypeInfo rtti; /* hmkim : modified (unsigned int -> RunTimeTypeInfo) */
	/* we keep a fully resolved reference (ie always includes the group identifier) */
	ExternalReference ref;
	/* true if we are waiting for external content to be available */
	bool need_content;
	/* variables defined in ISO MHEG spec */
	bool AvailabilityStatus;
	bool RunningStatus;
} RootClassInstanceVars;

typedef struct RootClass
{
	ObjectReference ObjectReference;
	/* instance variables */
	RootClassInstanceVars inst;
} RootClass;

DEFINE_LIST_OF(RootClass);

int der_decode_RootClass(FILE *, RootClass *, int);
/* only free's the contents, not the type itself */
void free_RootClass(RootClass *);

/*
 * ContentReference
 */
typedef OctetString ContentReference;

DEFINE_LIST_OF(ContentReference);

int der_decode_ContentReference(FILE *, ContentReference *, int);
/* only free's the contents, not the type itself */
void free_ContentReference(ContentReference *);

/*
 * ReferencedContent
 */
typedef struct ReferencedContent
{
	ContentReference content_reference;
	bool have_content_size;	/* OPTIONAL */
	int content_size;
	unsigned int content_cache_priority;	/* DEFAULT 127 */
} ReferencedContent;

DEFINE_LIST_OF(ReferencedContent);

int der_decode_ReferencedContent(FILE *, ReferencedContent *, int);
/* only free's the contents, not the type itself */
void free_ReferencedContent(ReferencedContent *);

/*
 * ContentBody
 */
typedef struct ContentBody
{
	unsigned int choice;
	union {
		OctetString included_content;	/* choice == 1 */
#define ContentBody_included_content 1
		ReferencedContent referenced_content;	/* choice == 2 */
#define ContentBody_referenced_content 2
	} u;
} ContentBody;

DEFINE_LIST_OF(ContentBody);

int der_decode_ContentBody(FILE *, ContentBody *, int);
/* only free's the contents, not the type itself */
void free_ContentBody(ContentBody *);

/*
 * IngredientClass
 */
typedef struct IngredientClass
{
	RootClass rootClass;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
} IngredientClass;

DEFINE_LIST_OF(IngredientClass);

int der_decode_IngredientClass(FILE *, IngredientClass *, int);
/* only free's the contents, not the type itself */
void free_IngredientClass(IngredientClass *);

/*
 * PresentableClass
 */
typedef IngredientClass PresentableClass;

DEFINE_LIST_OF(PresentableClass);

int der_decode_PresentableClass(FILE *, PresentableClass *, int);
/* only free's the contents, not the type itself */
void free_PresentableClass(PresentableClass *);

/*
 * StandardIdentifier
 */
typedef struct StandardIdentifier
{
	unsigned int joint_iso_itu_t;
	unsigned int mheg;
} StandardIdentifier;

DEFINE_LIST_OF(StandardIdentifier);

int der_decode_StandardIdentifier(FILE *, StandardIdentifier *, int);
/* only free's the contents, not the type itself */
void free_StandardIdentifier(StandardIdentifier *);

/*
 * IndirectReference
 */
typedef ObjectReference IndirectReference;

DEFINE_LIST_OF(IndirectReference);

int der_decode_IndirectReference(FILE *, IndirectReference *, int);
/* only free's the contents, not the type itself */
void free_IndirectReference(IndirectReference *);

/*
 * GenericObjectReference
 */
typedef struct GenericObjectReference
{
	unsigned int choice;
	union {
		ObjectReference direct_reference;	/* choice == 1 */
#define GenericObjectReference_direct_reference 1
		IndirectReference indirect_reference;	/* choice == 2 */
#define GenericObjectReference_indirect_reference 2
	} u;
} GenericObjectReference;

DEFINE_LIST_OF(GenericObjectReference);

int der_decode_GenericObjectReference(FILE *, GenericObjectReference *, int);
/* only free's the contents, not the type itself */
void free_GenericObjectReference(GenericObjectReference *);

/*
 * GenericInteger
 */
typedef struct GenericInteger
{
	unsigned int choice;
	union {
		int integer;	/* choice == 1 */
#define GenericInteger_integer 1
		IndirectReference indirect_reference;	/* choice == 2 */
#define GenericInteger_indirect_reference 2
	} u;
} GenericInteger;

DEFINE_LIST_OF(GenericInteger);

int der_decode_GenericInteger(FILE *, GenericInteger *, int);
/* only free's the contents, not the type itself */
void free_GenericInteger(GenericInteger *);

/*
 * Add
 */
typedef struct Add
{
	GenericObjectReference target;
	GenericInteger value;
} Add;

DEFINE_LIST_OF(Add);

int der_decode_Add(FILE *, Add *, int);
/* only free's the contents, not the type itself */
void free_Add(Add *);

/*
 * AddItem
 */
typedef struct AddItem
{
	GenericObjectReference target;
	GenericInteger item_index;
	GenericObjectReference visible_reference;
} AddItem;

DEFINE_LIST_OF(AddItem);

int der_decode_AddItem(FILE *, AddItem *, int);
/* only free's the contents, not the type itself */
void free_AddItem(AddItem *);

/*
 * GenericOctetString
 */
typedef struct GenericOctetString
{
	unsigned int choice;
	union {
		OctetString octetstring;	/* choice == 1 */
#define GenericOctetString_octetstring 1
		IndirectReference indirect_reference;	/* choice == 2 */
#define GenericOctetString_indirect_reference 2
	} u;
} GenericOctetString;

DEFINE_LIST_OF(GenericOctetString);

int der_decode_GenericOctetString(FILE *, GenericOctetString *, int);
/* only free's the contents, not the type itself */
void free_GenericOctetString(GenericOctetString *);

/*
 * Append
 */
typedef struct Append
{
	GenericObjectReference target;
	GenericOctetString append_value;
} Append;

DEFINE_LIST_OF(Append);

int der_decode_Append(FILE *, Append *, int);
/* only free's the contents, not the type itself */
void free_Append(Append *);

/*
 * GenericBoolean
 */
typedef struct GenericBoolean
{
	unsigned int choice;
	union {
		bool boolean;	/* choice == 1 */
#define GenericBoolean_boolean 1
		IndirectReference indirect_reference;	/* choice == 2 */
#define GenericBoolean_indirect_reference 2
	} u;
} GenericBoolean;

DEFINE_LIST_OF(GenericBoolean);

int der_decode_GenericBoolean(FILE *, GenericBoolean *, int);
/* only free's the contents, not the type itself */
void free_GenericBoolean(GenericBoolean *);

/*
 * GenericContentReference
 */
typedef struct GenericContentReference
{
	unsigned int choice;
	union {
		ContentReference content_reference;	/* choice == 1 */
#define GenericContentReference_content_reference 1
		IndirectReference indirect_reference;	/* choice == 2 */
#define GenericContentReference_indirect_reference 2
	} u;
} GenericContentReference;

DEFINE_LIST_OF(GenericContentReference);

int der_decode_GenericContentReference(FILE *, GenericContentReference *, int);
/* only free's the contents, not the type itself */
void free_GenericContentReference(GenericContentReference *);

/*
 * Parameter
 */
typedef struct Parameter
{
	unsigned int choice;
	union {
		GenericBoolean new_generic_boolean;	/* choice == 1 */
#define Parameter_new_generic_boolean 1
		GenericInteger new_generic_integer;	/* choice == 2 */
#define Parameter_new_generic_integer 2
		GenericOctetString new_generic_octetstring;	/* choice == 3 */
#define Parameter_new_generic_octetstring 3
		GenericObjectReference new_generic_object_reference;	/* choice == 4 */
#define Parameter_new_generic_object_reference 4
		GenericContentReference new_generic_content_reference;	/* choice == 5 */
#define Parameter_new_generic_content_reference 5
	} u;
} Parameter;

DEFINE_LIST_OF(Parameter);

int der_decode_Parameter(FILE *, Parameter *, int);
/* only free's the contents, not the type itself */
void free_Parameter(Parameter *);

/*
 * Call
 */
typedef struct Call
{
	GenericObjectReference target;
	ObjectReference call_succeeded;
	LIST_OF(Parameter) *parameters;	/* OPTIONAL */
} Call;

DEFINE_LIST_OF(Call);

int der_decode_Call(FILE *, Call *, int);
/* only free's the contents, not the type itself */
void free_Call(Call *);

/*
 * CallActionSlot
 */
typedef struct CallActionSlot
{
	GenericObjectReference target;
	GenericInteger index;
} CallActionSlot;

DEFINE_LIST_OF(CallActionSlot);

int der_decode_CallActionSlot(FILE *, CallActionSlot *, int);
/* only free's the contents, not the type itself */
void free_CallActionSlot(CallActionSlot *);

/*
 * Clone
 */
typedef struct Clone
{
	GenericObjectReference target;
	ObjectReference clone_ref_var;
} Clone;

DEFINE_LIST_OF(Clone);

int der_decode_Clone(FILE *, Clone *, int);
/* only free's the contents, not the type itself */
void free_Clone(Clone *);

/*
 * CloseConnection
 */
typedef struct CloseConnection
{
	GenericObjectReference target;
	GenericInteger connection_tag;
} CloseConnection;

DEFINE_LIST_OF(CloseConnection);

int der_decode_CloseConnection(FILE *, CloseConnection *, int);
/* only free's the contents, not the type itself */
void free_CloseConnection(CloseConnection *);

/*
 * DelItem
 */
typedef struct DelItem
{
	GenericObjectReference target;
	GenericObjectReference visible_reference;
} DelItem;

DEFINE_LIST_OF(DelItem);

int der_decode_DelItem(FILE *, DelItem *, int);
/* only free's the contents, not the type itself */
void free_DelItem(DelItem *);

/*
 * DeselectItem
 */
typedef struct DeselectItem
{
	GenericObjectReference target;
	GenericInteger item_index;
} DeselectItem;

DEFINE_LIST_OF(DeselectItem);

int der_decode_DeselectItem(FILE *, DeselectItem *, int);
/* only free's the contents, not the type itself */
void free_DeselectItem(DeselectItem *);

/*
 * Divide
 */
typedef struct Divide
{
	GenericObjectReference target;
	GenericInteger value;
} Divide;

DEFINE_LIST_OF(Divide);

int der_decode_Divide(FILE *, Divide *, int);
/* only free's the contents, not the type itself */
void free_Divide(Divide *);

/*
 * DrawArc
 */
typedef struct DrawArc
{
	GenericObjectReference target;
	GenericInteger x;
	GenericInteger y;
	GenericInteger ellipse_width;
	GenericInteger ellipse_height;
	GenericInteger start_angle;
	GenericInteger arc_angle;
} DrawArc;

DEFINE_LIST_OF(DrawArc);

int der_decode_DrawArc(FILE *, DrawArc *, int);
/* only free's the contents, not the type itself */
void free_DrawArc(DrawArc *);

/*
 * DrawLine
 */
typedef struct DrawLine
{
	GenericObjectReference target;
	GenericInteger x1;
	GenericInteger y1;
	GenericInteger x2;
	GenericInteger y2;
} DrawLine;

DEFINE_LIST_OF(DrawLine);

int der_decode_DrawLine(FILE *, DrawLine *, int);
/* only free's the contents, not the type itself */
void free_DrawLine(DrawLine *);

/*
 * DrawOval
 */
typedef struct DrawOval
{
	GenericObjectReference target;
	GenericInteger x;
	GenericInteger y;
	GenericInteger ellipse_width;
	GenericInteger ellipse_height;
} DrawOval;

DEFINE_LIST_OF(DrawOval);

int der_decode_DrawOval(FILE *, DrawOval *, int);
/* only free's the contents, not the type itself */
void free_DrawOval(DrawOval *);

/*
 * Point
 */
typedef struct Point
{
	GenericInteger x;
	GenericInteger y;
} Point;

DEFINE_LIST_OF(Point);

int der_decode_Point(FILE *, Point *, int);
/* only free's the contents, not the type itself */
void free_Point(Point *);

/*
 * DrawPolygon
 */
typedef struct DrawPolygon
{
	GenericObjectReference target;
	LIST_OF(Point) *pointlist;
} DrawPolygon;

DEFINE_LIST_OF(DrawPolygon);

int der_decode_DrawPolygon(FILE *, DrawPolygon *, int);
/* only free's the contents, not the type itself */
void free_DrawPolygon(DrawPolygon *);

/*
 * DrawPolyline
 */
typedef struct DrawPolyline
{
	GenericObjectReference target;
	LIST_OF(Point) *pointlist;
} DrawPolyline;

DEFINE_LIST_OF(DrawPolyline);

int der_decode_DrawPolyline(FILE *, DrawPolyline *, int);
/* only free's the contents, not the type itself */
void free_DrawPolyline(DrawPolyline *);

/*
 * DrawRectangle
 */
typedef struct DrawRectangle
{
	GenericObjectReference target;
	GenericInteger x1;
	GenericInteger y1;
	GenericInteger x2;
	GenericInteger y2;
} DrawRectangle;

DEFINE_LIST_OF(DrawRectangle);

int der_decode_DrawRectangle(FILE *, DrawRectangle *, int);
/* only free's the contents, not the type itself */
void free_DrawRectangle(DrawRectangle *);

/*
 * DrawSector
 */
typedef struct DrawSector
{
	GenericObjectReference target;
	GenericInteger x;
	GenericInteger y;
	GenericInteger ellipse_width;
	GenericInteger ellipse_height;
	GenericInteger start_angle;
	GenericInteger arc_angle;
} DrawSector;

DEFINE_LIST_OF(DrawSector);

int der_decode_DrawSector(FILE *, DrawSector *, int);
/* only free's the contents, not the type itself */
void free_DrawSector(DrawSector *);

/*
 * Fork
 */
typedef struct Fork
{
	GenericObjectReference target;
	ObjectReference fork_succeeded;
	LIST_OF(Parameter) *parameters;	/* OPTIONAL */
} Fork;

DEFINE_LIST_OF(Fork);

int der_decode_Fork(FILE *, Fork *, int);
/* only free's the contents, not the type itself */
void free_Fork(Fork *);

/*
 * GetAvailabilityStatus
 */
typedef struct GetAvailabilityStatus
{
	GenericObjectReference target;
	ObjectReference availability_status_var;
} GetAvailabilityStatus;

DEFINE_LIST_OF(GetAvailabilityStatus);

int der_decode_GetAvailabilityStatus(FILE *, GetAvailabilityStatus *, int);
/* only free's the contents, not the type itself */
void free_GetAvailabilityStatus(GetAvailabilityStatus *);

/*
 * GetBoxSize
 */
typedef struct GetBoxSize
{
	GenericObjectReference target;
	ObjectReference x_box_size_var;
	ObjectReference y_box_size_var;
} GetBoxSize;

DEFINE_LIST_OF(GetBoxSize);

int der_decode_GetBoxSize(FILE *, GetBoxSize *, int);
/* only free's the contents, not the type itself */
void free_GetBoxSize(GetBoxSize *);

/*
 * GetCellItem
 */
typedef struct GetCellItem
{
	GenericObjectReference target;
	GenericInteger cell_index;
	ObjectReference item_ref_var;
} GetCellItem;

DEFINE_LIST_OF(GetCellItem);

int der_decode_GetCellItem(FILE *, GetCellItem *, int);
/* only free's the contents, not the type itself */
void free_GetCellItem(GetCellItem *);

/*
 * GetCursorPosition
 */
typedef struct GetCursorPosition
{
	GenericObjectReference target;
	ObjectReference x_out;
	ObjectReference y_out;
} GetCursorPosition;

DEFINE_LIST_OF(GetCursorPosition);

int der_decode_GetCursorPosition(FILE *, GetCursorPosition *, int);
/* only free's the contents, not the type itself */
void free_GetCursorPosition(GetCursorPosition *);

/*
 * GetEngineSupport
 */
typedef struct GetEngineSupport
{
	GenericObjectReference target;
	GenericOctetString feature;
	ObjectReference answer;
} GetEngineSupport;

DEFINE_LIST_OF(GetEngineSupport);

int der_decode_GetEngineSupport(FILE *, GetEngineSupport *, int);
/* only free's the contents, not the type itself */
void free_GetEngineSupport(GetEngineSupport *);

/*
 * GetEntryPoint
 */
typedef struct GetEntryPoint
{
	GenericObjectReference target;
	ObjectReference entry_point_var;
} GetEntryPoint;

DEFINE_LIST_OF(GetEntryPoint);

int der_decode_GetEntryPoint(FILE *, GetEntryPoint *, int);
/* only free's the contents, not the type itself */
void free_GetEntryPoint(GetEntryPoint *);

/*
 * GetFillColour
 */
typedef struct GetFillColour
{
	GenericObjectReference target;
	ObjectReference fill_colour_var;
} GetFillColour;

DEFINE_LIST_OF(GetFillColour);

int der_decode_GetFillColour(FILE *, GetFillColour *, int);
/* only free's the contents, not the type itself */
void free_GetFillColour(GetFillColour *);

/*
 * GetFirstItem
 */
typedef struct GetFirstItem
{
	GenericObjectReference target;
	ObjectReference first_item_var;
} GetFirstItem;

DEFINE_LIST_OF(GetFirstItem);

int der_decode_GetFirstItem(FILE *, GetFirstItem *, int);
/* only free's the contents, not the type itself */
void free_GetFirstItem(GetFirstItem *);

/*
 * GetHighlightStatus
 */
typedef struct GetHighlightStatus
{
	GenericObjectReference target;
	ObjectReference highlight_status_var;
} GetHighlightStatus;

DEFINE_LIST_OF(GetHighlightStatus);

int der_decode_GetHighlightStatus(FILE *, GetHighlightStatus *, int);
/* only free's the contents, not the type itself */
void free_GetHighlightStatus(GetHighlightStatus *);

/*
 * GetInteractionStatus
 */
typedef struct GetInteractionStatus
{
	GenericObjectReference target;
	ObjectReference interaction_status_var;
} GetInteractionStatus;

DEFINE_LIST_OF(GetInteractionStatus);

int der_decode_GetInteractionStatus(FILE *, GetInteractionStatus *, int);
/* only free's the contents, not the type itself */
void free_GetInteractionStatus(GetInteractionStatus *);

/*
 * GetItemStatus
 */
typedef struct GetItemStatus
{
	GenericObjectReference target;
	GenericInteger item_index;
	ObjectReference item_status_var;
} GetItemStatus;

DEFINE_LIST_OF(GetItemStatus);

int der_decode_GetItemStatus(FILE *, GetItemStatus *, int);
/* only free's the contents, not the type itself */
void free_GetItemStatus(GetItemStatus *);

/*
 * GetLabel
 */
typedef struct GetLabel
{
	GenericObjectReference target;
	ObjectReference label_var;
} GetLabel;

DEFINE_LIST_OF(GetLabel);

int der_decode_GetLabel(FILE *, GetLabel *, int);
/* only free's the contents, not the type itself */
void free_GetLabel(GetLabel *);

/*
 * GetLastAnchorFired
 */
typedef struct GetLastAnchorFired
{
	GenericObjectReference target;
	ObjectReference last_anchor_fired_var;
} GetLastAnchorFired;

DEFINE_LIST_OF(GetLastAnchorFired);

int der_decode_GetLastAnchorFired(FILE *, GetLastAnchorFired *, int);
/* only free's the contents, not the type itself */
void free_GetLastAnchorFired(GetLastAnchorFired *);

/*
 * GetLineColour
 */
typedef struct GetLineColour
{
	GenericObjectReference target;
	ObjectReference line_colour_var;
} GetLineColour;

DEFINE_LIST_OF(GetLineColour);

int der_decode_GetLineColour(FILE *, GetLineColour *, int);
/* only free's the contents, not the type itself */
void free_GetLineColour(GetLineColour *);

/*
 * GetLineStyle
 */
typedef struct GetLineStyle
{
	GenericObjectReference target;
	ObjectReference line_style_var;
} GetLineStyle;

DEFINE_LIST_OF(GetLineStyle);

int der_decode_GetLineStyle(FILE *, GetLineStyle *, int);
/* only free's the contents, not the type itself */
void free_GetLineStyle(GetLineStyle *);

/*
 * GetLineWidth
 */
typedef struct GetLineWidth
{
	GenericObjectReference target;
	ObjectReference line_width_var;
} GetLineWidth;

DEFINE_LIST_OF(GetLineWidth);

int der_decode_GetLineWidth(FILE *, GetLineWidth *, int);
/* only free's the contents, not the type itself */
void free_GetLineWidth(GetLineWidth *);

/*
 * GetListItem
 */
typedef struct GetListItem
{
	GenericObjectReference target;
	GenericInteger item_index;
	ObjectReference item_ref_var;
} GetListItem;

DEFINE_LIST_OF(GetListItem);

int der_decode_GetListItem(FILE *, GetListItem *, int);
/* only free's the contents, not the type itself */
void free_GetListItem(GetListItem *);

/*
 * GetListSize
 */
typedef struct GetListSize
{
	GenericObjectReference target;
	ObjectReference size_var;
} GetListSize;

DEFINE_LIST_OF(GetListSize);

int der_decode_GetListSize(FILE *, GetListSize *, int);
/* only free's the contents, not the type itself */
void free_GetListSize(GetListSize *);

/*
 * GetOverwriteMode
 */
typedef struct GetOverwriteMode
{
	GenericObjectReference target;
	ObjectReference overwrite_mode_var;
} GetOverwriteMode;

DEFINE_LIST_OF(GetOverwriteMode);

int der_decode_GetOverwriteMode(FILE *, GetOverwriteMode *, int);
/* only free's the contents, not the type itself */
void free_GetOverwriteMode(GetOverwriteMode *);

/*
 * GetPortion
 */
typedef struct GetPortion
{
	GenericObjectReference target;
	ObjectReference portion_var;
} GetPortion;

DEFINE_LIST_OF(GetPortion);

int der_decode_GetPortion(FILE *, GetPortion *, int);
/* only free's the contents, not the type itself */
void free_GetPortion(GetPortion *);

/*
 * GetPosition
 */
typedef struct GetPosition
{
	GenericObjectReference target;
	ObjectReference x_position_var;
	ObjectReference y_position_var;
} GetPosition;

DEFINE_LIST_OF(GetPosition);

int der_decode_GetPosition(FILE *, GetPosition *, int);
/* only free's the contents, not the type itself */
void free_GetPosition(GetPosition *);

/*
 * GetRunningStatus
 */
typedef struct GetRunningStatus
{
	GenericObjectReference target;
	ObjectReference running_status_var;
} GetRunningStatus;

DEFINE_LIST_OF(GetRunningStatus);

int der_decode_GetRunningStatus(FILE *, GetRunningStatus *, int);
/* only free's the contents, not the type itself */
void free_GetRunningStatus(GetRunningStatus *);

/*
 * GetSelectionStatus
 */
typedef struct GetSelectionStatus
{
	GenericObjectReference target;
	ObjectReference selection_status_var;
} GetSelectionStatus;

DEFINE_LIST_OF(GetSelectionStatus);

int der_decode_GetSelectionStatus(FILE *, GetSelectionStatus *, int);
/* only free's the contents, not the type itself */
void free_GetSelectionStatus(GetSelectionStatus *);

/*
 * GetSliderValue
 */
typedef struct GetSliderValue
{
	GenericObjectReference target;
	ObjectReference slider_value_var;
} GetSliderValue;

DEFINE_LIST_OF(GetSliderValue);

int der_decode_GetSliderValue(FILE *, GetSliderValue *, int);
/* only free's the contents, not the type itself */
void free_GetSliderValue(GetSliderValue *);

/*
 * GetTextContent
 */
typedef struct GetTextContent
{
	GenericObjectReference target;
	ObjectReference text_content_var;
} GetTextContent;

DEFINE_LIST_OF(GetTextContent);

int der_decode_GetTextContent(FILE *, GetTextContent *, int);
/* only free's the contents, not the type itself */
void free_GetTextContent(GetTextContent *);

/*
 * GetTextData
 */
typedef struct GetTextData
{
	GenericObjectReference target;
	ObjectReference text_data_var;
} GetTextData;

DEFINE_LIST_OF(GetTextData);

int der_decode_GetTextData(FILE *, GetTextData *, int);
/* only free's the contents, not the type itself */
void free_GetTextData(GetTextData *);

/*
 * GetTokenPosition
 */
typedef struct GetTokenPosition
{
	GenericObjectReference target;
	ObjectReference token_position_var;
} GetTokenPosition;

DEFINE_LIST_OF(GetTokenPosition);

int der_decode_GetTokenPosition(FILE *, GetTokenPosition *, int);
/* only free's the contents, not the type itself */
void free_GetTokenPosition(GetTokenPosition *);

/*
 * GetVolume
 */
typedef struct GetVolume
{
	GenericObjectReference target;
	ObjectReference volume_var;
} GetVolume;

DEFINE_LIST_OF(GetVolume);

int der_decode_GetVolume(FILE *, GetVolume *, int);
/* only free's the contents, not the type itself */
void free_GetVolume(GetVolume *);

/*
 * Modulo
 */
typedef struct Modulo
{
	GenericObjectReference target;
	GenericInteger value;
} Modulo;

DEFINE_LIST_OF(Modulo);

int der_decode_Modulo(FILE *, Modulo *, int);
/* only free's the contents, not the type itself */
void free_Modulo(Modulo *);

/*
 * Move
 */
typedef struct Move
{
	GenericObjectReference target;
	GenericInteger movement_identifier;
} Move;

DEFINE_LIST_OF(Move);

int der_decode_Move(FILE *, Move *, int);
/* only free's the contents, not the type itself */
void free_Move(Move *);

/*
 * MoveTo
 */
typedef struct MoveTo
{
	GenericObjectReference target;
	GenericInteger index;
} MoveTo;

DEFINE_LIST_OF(MoveTo);

int der_decode_MoveTo(FILE *, MoveTo *, int);
/* only free's the contents, not the type itself */
void free_MoveTo(MoveTo *);

/*
 * Multiply
 */
typedef struct Multiply
{
	GenericObjectReference target;
	GenericInteger value;
} Multiply;

DEFINE_LIST_OF(Multiply);

int der_decode_Multiply(FILE *, Multiply *, int);
/* only free's the contents, not the type itself */
void free_Multiply(Multiply *);

/*
 * OpenConnection
 */
typedef struct OpenConnection
{
	GenericObjectReference target;
	ObjectReference open_succeeded;
	GenericOctetString protocol;
	GenericOctetString address;
	GenericInteger connection_tag;
} OpenConnection;

DEFINE_LIST_OF(OpenConnection);

int der_decode_OpenConnection(FILE *, OpenConnection *, int);
/* only free's the contents, not the type itself */
void free_OpenConnection(OpenConnection *);

/*
 * PutBefore
 */
typedef struct PutBefore
{
	GenericObjectReference target;
	GenericObjectReference reference_visible;
} PutBefore;

DEFINE_LIST_OF(PutBefore);

int der_decode_PutBefore(FILE *, PutBefore *, int);
/* only free's the contents, not the type itself */
void free_PutBefore(PutBefore *);

/*
 * PutBehind
 */
typedef struct PutBehind
{
	GenericObjectReference target;
	GenericObjectReference reference_visible;
} PutBehind;

DEFINE_LIST_OF(PutBehind);

int der_decode_PutBehind(FILE *, PutBehind *, int);
/* only free's the contents, not the type itself */
void free_PutBehind(PutBehind *);

/*
 * ReadPersistent
 */
typedef struct ReadPersistent
{
	GenericObjectReference target;
	ObjectReference read_succeeded;
	LIST_OF(ObjectReference) *out_variables;
	GenericOctetString in_file_name;
} ReadPersistent;

DEFINE_LIST_OF(ReadPersistent);

int der_decode_ReadPersistent(FILE *, ReadPersistent *, int);
/* only free's the contents, not the type itself */
void free_ReadPersistent(ReadPersistent *);

/*
 * ScaleBitmap
 */
typedef struct ScaleBitmap
{
	GenericObjectReference target;
	GenericInteger x_scale;
	GenericInteger y_scale;
} ScaleBitmap;

DEFINE_LIST_OF(ScaleBitmap);

int der_decode_ScaleBitmap(FILE *, ScaleBitmap *, int);
/* only free's the contents, not the type itself */
void free_ScaleBitmap(ScaleBitmap *);

/*
 * ScaleVideo
 */
typedef struct ScaleVideo
{
	GenericObjectReference target;
	GenericInteger x_scale;
	GenericInteger y_scale;
} ScaleVideo;

DEFINE_LIST_OF(ScaleVideo);

int der_decode_ScaleVideo(FILE *, ScaleVideo *, int);
/* only free's the contents, not the type itself */
void free_ScaleVideo(ScaleVideo *);

/*
 * ScrollItems
 */
typedef struct ScrollItems
{
	GenericObjectReference target;
	GenericInteger items_to_scroll;
} ScrollItems;

DEFINE_LIST_OF(ScrollItems);

int der_decode_ScrollItems(FILE *, ScrollItems *, int);
/* only free's the contents, not the type itself */
void free_ScrollItems(ScrollItems *);

/*
 * SelectItem
 */
typedef struct SelectItem
{
	GenericObjectReference target;
	GenericInteger item_index;
} SelectItem;

DEFINE_LIST_OF(SelectItem);

int der_decode_SelectItem(FILE *, SelectItem *, int);
/* only free's the contents, not the type itself */
void free_SelectItem(SelectItem *);

/*
 * EventType
 */
typedef enum EventType
{
	EventType_is_available = 1,
	EventType_content_available = 2,
	EventType_is_deleted = 3,
	EventType_is_running = 4,
	EventType_is_stopped = 5,
	EventType_user_input = 6,
	EventType_anchor_fired = 7,
	EventType_timer_fired = 8,
	EventType_asynch_stopped = 9,
	EventType_interaction_completed = 10,
	EventType_token_moved_from = 11,
	EventType_token_moved_to = 12,
	EventType_stream_event = 13,
	EventType_stream_playing = 14,
	EventType_stream_stopped = 15,
	EventType_counter_trigger = 16,
	EventType_highlight_on = 17,
	EventType_highlight_off = 18,
	EventType_cursor_enter = 19,
	EventType_cursor_leave = 20,
	EventType_is_selected = 21,
	EventType_is_deselected = 22,
	EventType_test_event = 23,
	EventType_first_item_presented = 24,
	EventType_last_item_presented = 25,
	EventType_head_items = 26,
	EventType_tail_items = 27,
	EventType_item_selected = 28,
	EventType_item_deselected = 29,
	EventType_entry_field_full = 30,
	EventType_engine_event = 31,
	EventType_focus_moved = 32,
	EventType_slider_value_changed = 33,
} EventType;

DEFINE_LIST_OF(EventType);

int der_decode_EventType(FILE *, EventType *, int);
/* only free's the contents, not the type itself */
void free_EventType(EventType *);

/*
 * EmulatedEventData
 */
typedef struct EmulatedEventData
{
	unsigned int choice;
	union {
		GenericBoolean new_generic_boolean;	/* choice == 1 */
#define EmulatedEventData_new_generic_boolean 1
		GenericInteger new_generic_integer;	/* choice == 2 */
#define EmulatedEventData_new_generic_integer 2
		GenericOctetString new_generic_octet_string;	/* choice == 3 */
#define EmulatedEventData_new_generic_octet_string 3
	} u;
} EmulatedEventData;

DEFINE_LIST_OF(EmulatedEventData);

int der_decode_EmulatedEventData(FILE *, EmulatedEventData *, int);
/* only free's the contents, not the type itself */
void free_EmulatedEventData(EmulatedEventData *);

/*
 * SendEvent
 */
typedef struct SendEvent
{
	GenericObjectReference target;
	GenericObjectReference emulated_event_source;
	EventType emulated_event_type;
	bool have_emulated_event_data;	/* OPTIONAL */
	EmulatedEventData emulated_event_data;
} SendEvent;

DEFINE_LIST_OF(SendEvent);

int der_decode_SendEvent(FILE *, SendEvent *, int);
/* only free's the contents, not the type itself */
void free_SendEvent(SendEvent *);

/*
 * SetBoxSize
 */
typedef struct SetBoxSize
{
	GenericObjectReference target;
	GenericInteger x_new_box_size;
	GenericInteger y_new_box_size;
} SetBoxSize;

DEFINE_LIST_OF(SetBoxSize);

int der_decode_SetBoxSize(FILE *, SetBoxSize *, int);
/* only free's the contents, not the type itself */
void free_SetBoxSize(SetBoxSize *);

/*
 * SetCachePriority
 */
typedef struct SetCachePriority
{
	GenericObjectReference target;
	GenericInteger new_cache_priority;
} SetCachePriority;

DEFINE_LIST_OF(SetCachePriority);

int der_decode_SetCachePriority(FILE *, SetCachePriority *, int);
/* only free's the contents, not the type itself */
void free_SetCachePriority(SetCachePriority *);

/*
 * SetCounterEndPosition
 */
typedef struct SetCounterEndPosition
{
	GenericObjectReference target;
	GenericInteger new_counter_end_position;
} SetCounterEndPosition;

DEFINE_LIST_OF(SetCounterEndPosition);

int der_decode_SetCounterEndPosition(FILE *, SetCounterEndPosition *, int);
/* only free's the contents, not the type itself */
void free_SetCounterEndPosition(SetCounterEndPosition *);

/*
 * SetCounterPosition
 */
typedef struct SetCounterPosition
{
	GenericObjectReference target;
	GenericInteger new_counter_position;
} SetCounterPosition;

DEFINE_LIST_OF(SetCounterPosition);

int der_decode_SetCounterPosition(FILE *, SetCounterPosition *, int);
/* only free's the contents, not the type itself */
void free_SetCounterPosition(SetCounterPosition *);

/*
 * SetCounterTrigger
 */
typedef struct SetCounterTrigger
{
	GenericObjectReference target;
	GenericInteger trigger_identifier;
	bool have_new_counter_value;	/* OPTIONAL */
	GenericInteger new_counter_value;
} SetCounterTrigger;

DEFINE_LIST_OF(SetCounterTrigger);

int der_decode_SetCounterTrigger(FILE *, SetCounterTrigger *, int);
/* only free's the contents, not the type itself */
void free_SetCounterTrigger(SetCounterTrigger *);

/*
 * SetCursorPosition
 */
typedef struct SetCursorPosition
{
	GenericObjectReference target;
	GenericInteger x_cursor;
	GenericInteger y_cursor;
} SetCursorPosition;

DEFINE_LIST_OF(SetCursorPosition);

int der_decode_SetCursorPosition(FILE *, SetCursorPosition *, int);
/* only free's the contents, not the type itself */
void free_SetCursorPosition(SetCursorPosition *);

/*
 * SetCursorShape
 */
typedef struct SetCursorShape
{
	GenericObjectReference target;
	bool have_new_cursor_shape;	/* OPTIONAL */
	GenericObjectReference new_cursor_shape;
} SetCursorShape;

DEFINE_LIST_OF(SetCursorShape);

int der_decode_SetCursorShape(FILE *, SetCursorShape *, int);
/* only free's the contents, not the type itself */
void free_SetCursorShape(SetCursorShape *);

/*
 * NewContentSize
 */
typedef struct NewContentSize
{
	unsigned int choice;
	union {
		GenericInteger content_size;	/* choice == 1 */
#define NewContentSize_content_size 1
		Null null;	/* choice == 2 */
#define NewContentSize_null 2
	} u;
} NewContentSize;

DEFINE_LIST_OF(NewContentSize);

int der_decode_NewContentSize(FILE *, NewContentSize *, int);
/* only free's the contents, not the type itself */
void free_NewContentSize(NewContentSize *);

/*
 * NewReferencedContent
 */
typedef struct NewReferencedContent
{
	GenericContentReference generic_content_reference;
	NewContentSize new_content_size;
	bool have_new_content_cache_priority;	/* OPTIONAL */
	GenericInteger new_content_cache_priority;
} NewReferencedContent;

DEFINE_LIST_OF(NewReferencedContent);

int der_decode_NewReferencedContent(FILE *, NewReferencedContent *, int);
/* only free's the contents, not the type itself */
void free_NewReferencedContent(NewReferencedContent *);

/*
 * NewContent
 */
typedef struct NewContent
{
	unsigned int choice;
	union {
		GenericOctetString new_included_content;	/* choice == 1 */
#define NewContent_new_included_content 1
		NewReferencedContent new_referenced_content;	/* choice == 2 */
#define NewContent_new_referenced_content 2
	} u;
} NewContent;

DEFINE_LIST_OF(NewContent);

int der_decode_NewContent(FILE *, NewContent *, int);
/* only free's the contents, not the type itself */
void free_NewContent(NewContent *);

/*
 * SetData
 */
typedef struct SetData
{
	GenericObjectReference target;
	NewContent new_content;
} SetData;

DEFINE_LIST_OF(SetData);

int der_decode_SetData(FILE *, SetData *, int);
/* only free's the contents, not the type itself */
void free_SetData(SetData *);

/*
 * SetEntryPoint
 */
typedef struct SetEntryPoint
{
	GenericObjectReference target;
	GenericInteger new_entry_point;
} SetEntryPoint;

DEFINE_LIST_OF(SetEntryPoint);

int der_decode_SetEntryPoint(FILE *, SetEntryPoint *, int);
/* only free's the contents, not the type itself */
void free_SetEntryPoint(SetEntryPoint *);

/*
 * NewColour
 */
typedef struct NewColour
{
	unsigned int choice;
	union {
		GenericInteger new_colour_index;	/* choice == 1 */
#define NewColour_new_colour_index 1
		GenericOctetString new_absolute_colour;	/* choice == 2 */
#define NewColour_new_absolute_colour 2
	} u;
} NewColour;

DEFINE_LIST_OF(NewColour);

int der_decode_NewColour(FILE *, NewColour *, int);
/* only free's the contents, not the type itself */
void free_NewColour(NewColour *);

/*
 * SetFillColour
 */
typedef struct SetFillColour
{
	GenericObjectReference target;
	bool have_new_fill_colour;	/* OPTIONAL */
	NewColour new_fill_colour;
} SetFillColour;

DEFINE_LIST_OF(SetFillColour);

int der_decode_SetFillColour(FILE *, SetFillColour *, int);
/* only free's the contents, not the type itself */
void free_SetFillColour(SetFillColour *);

/*
 * SetFirstItem
 */
typedef struct SetFirstItem
{
	GenericObjectReference target;
	GenericInteger new_first_item;
} SetFirstItem;

DEFINE_LIST_OF(SetFirstItem);

int der_decode_SetFirstItem(FILE *, SetFirstItem *, int);
/* only free's the contents, not the type itself */
void free_SetFirstItem(SetFirstItem *);

/*
 * NewFont
 */
typedef struct NewFont
{
	unsigned int choice;
	union {
		GenericOctetString new_font_name;	/* choice == 1 */
#define NewFont_new_font_name 1
		GenericObjectReference new_font_reference;	/* choice == 2 */
#define NewFont_new_font_reference 2
	} u;
} NewFont;

DEFINE_LIST_OF(NewFont);

int der_decode_NewFont(FILE *, NewFont *, int);
/* only free's the contents, not the type itself */
void free_NewFont(NewFont *);

/*
 * SetFontRef
 */
typedef struct SetFontRef
{
	GenericObjectReference target;
	NewFont new_font;
} SetFontRef;

DEFINE_LIST_OF(SetFontRef);

int der_decode_SetFontRef(FILE *, SetFontRef *, int);
/* only free's the contents, not the type itself */
void free_SetFontRef(SetFontRef *);

/*
 * SetHighlightStatus
 */
typedef struct SetHighlightStatus
{
	GenericObjectReference target;
	GenericBoolean new_highlight_status;
} SetHighlightStatus;

DEFINE_LIST_OF(SetHighlightStatus);

int der_decode_SetHighlightStatus(FILE *, SetHighlightStatus *, int);
/* only free's the contents, not the type itself */
void free_SetHighlightStatus(SetHighlightStatus *);

/*
 * SetInteractionStatus
 */
typedef struct SetInteractionStatus
{
	GenericObjectReference target;
	GenericBoolean new_interaction_status;
} SetInteractionStatus;

DEFINE_LIST_OF(SetInteractionStatus);

int der_decode_SetInteractionStatus(FILE *, SetInteractionStatus *, int);
/* only free's the contents, not the type itself */
void free_SetInteractionStatus(SetInteractionStatus *);

/*
 * SetLabel
 */
typedef struct SetLabel
{
	GenericObjectReference target;
	GenericOctetString new_label;
} SetLabel;

DEFINE_LIST_OF(SetLabel);

int der_decode_SetLabel(FILE *, SetLabel *, int);
/* only free's the contents, not the type itself */
void free_SetLabel(SetLabel *);

/*
 * SetLineColour
 */
typedef struct SetLineColour
{
	GenericObjectReference target;
	NewColour new_line_colour;
} SetLineColour;

DEFINE_LIST_OF(SetLineColour);

int der_decode_SetLineColour(FILE *, SetLineColour *, int);
/* only free's the contents, not the type itself */
void free_SetLineColour(SetLineColour *);

/*
 * SetLineStyle
 */
typedef struct SetLineStyle
{
	GenericObjectReference target;
	GenericInteger new_line_style;
} SetLineStyle;

DEFINE_LIST_OF(SetLineStyle);

int der_decode_SetLineStyle(FILE *, SetLineStyle *, int);
/* only free's the contents, not the type itself */
void free_SetLineStyle(SetLineStyle *);

/*
 * SetLineWidth
 */
typedef struct SetLineWidth
{
	GenericObjectReference target;
	GenericInteger new_line_width;
} SetLineWidth;

DEFINE_LIST_OF(SetLineWidth);

int der_decode_SetLineWidth(FILE *, SetLineWidth *, int);
/* only free's the contents, not the type itself */
void free_SetLineWidth(SetLineWidth *);

/*
 * SetOverwriteMode
 */
typedef struct SetOverwriteMode
{
	GenericObjectReference target;
	GenericBoolean new_overwrite_mode;
} SetOverwriteMode;

DEFINE_LIST_OF(SetOverwriteMode);

int der_decode_SetOverwriteMode(FILE *, SetOverwriteMode *, int);
/* only free's the contents, not the type itself */
void free_SetOverwriteMode(SetOverwriteMode *);

/*
 * SetPaletteRef
 */
typedef struct SetPaletteRef
{
	GenericObjectReference target;
	GenericObjectReference new_palette_ref;
} SetPaletteRef;

DEFINE_LIST_OF(SetPaletteRef);

int der_decode_SetPaletteRef(FILE *, SetPaletteRef *, int);
/* only free's the contents, not the type itself */
void free_SetPaletteRef(SetPaletteRef *);

/*
 * SetPortion
 */
typedef struct SetPortion
{
	GenericObjectReference target;
	GenericInteger new_portion;
} SetPortion;

DEFINE_LIST_OF(SetPortion);

int der_decode_SetPortion(FILE *, SetPortion *, int);
/* only free's the contents, not the type itself */
void free_SetPortion(SetPortion *);

/*
 * SetPosition
 */
typedef struct SetPosition
{
	GenericObjectReference target;
	GenericInteger new_x_position;
	GenericInteger new_y_position;
} SetPosition;

DEFINE_LIST_OF(SetPosition);

int der_decode_SetPosition(FILE *, SetPosition *, int);
/* only free's the contents, not the type itself */
void free_SetPosition(SetPosition *);

/*
 * SetSliderValue
 */
typedef struct SetSliderValue
{
	GenericObjectReference target;
	GenericInteger new_slider_value;
} SetSliderValue;

DEFINE_LIST_OF(SetSliderValue);

int der_decode_SetSliderValue(FILE *, SetSliderValue *, int);
/* only free's the contents, not the type itself */
void free_SetSliderValue(SetSliderValue *);

/*
 * Rational
 */
typedef struct Rational
{
	GenericInteger numerator;
	bool have_denominator;	/* OPTIONAL */
	GenericInteger denominator;
} Rational;

DEFINE_LIST_OF(Rational);

int der_decode_Rational(FILE *, Rational *, int);
/* only free's the contents, not the type itself */
void free_Rational(Rational *);

/*
 * SetSpeed
 */
typedef struct SetSpeed
{
	GenericObjectReference target;
	Rational new_speed;
} SetSpeed;

DEFINE_LIST_OF(SetSpeed);

int der_decode_SetSpeed(FILE *, SetSpeed *, int);
/* only free's the contents, not the type itself */
void free_SetSpeed(SetSpeed *);

/*
 * NewTimer
 */
typedef struct NewTimer
{
	GenericInteger timer_value;
	bool have_absolute_time;	/* OPTIONAL */
	GenericBoolean absolute_time;
} NewTimer;

DEFINE_LIST_OF(NewTimer);

int der_decode_NewTimer(FILE *, NewTimer *, int);
/* only free's the contents, not the type itself */
void free_NewTimer(NewTimer *);

/*
 * SetTimer
 */
typedef struct SetTimer
{
	GenericObjectReference target;
	GenericInteger timer_id;
	bool have_new_timer;	/* OPTIONAL */
	NewTimer new_timer;
} SetTimer;

DEFINE_LIST_OF(SetTimer);

int der_decode_SetTimer(FILE *, SetTimer *, int);
/* only free's the contents, not the type itself */
void free_SetTimer(SetTimer *);

/*
 * SetTransparency
 */
typedef struct SetTransparency
{
	GenericObjectReference target;
	GenericInteger new_transparency;
} SetTransparency;

DEFINE_LIST_OF(SetTransparency);

int der_decode_SetTransparency(FILE *, SetTransparency *, int);
/* only free's the contents, not the type itself */
void free_SetTransparency(SetTransparency *);

/*
 * NewVariableValue
 */
typedef struct NewVariableValue
{
	unsigned int choice;
	union {
		GenericBoolean new_generic_boolean;	/* choice == 1 */
#define NewVariableValue_new_generic_boolean 1
		GenericInteger new_generic_integer;	/* choice == 2 */
#define NewVariableValue_new_generic_integer 2
		GenericOctetString new_generic_octet_string;	/* choice == 3 */
#define NewVariableValue_new_generic_octet_string 3
		GenericObjectReference new_generic_object_reference;	/* choice == 4 */
#define NewVariableValue_new_generic_object_reference 4
		GenericContentReference new_generic_content_reference;	/* choice == 5 */
#define NewVariableValue_new_generic_content_reference 5
	} u;
} NewVariableValue;

DEFINE_LIST_OF(NewVariableValue);

int der_decode_NewVariableValue(FILE *, NewVariableValue *, int);
/* only free's the contents, not the type itself */
void free_NewVariableValue(NewVariableValue *);

/*
 * SetVariable
 */
typedef struct SetVariable
{
	GenericObjectReference target;
	NewVariableValue new_variable_value;
} SetVariable;

DEFINE_LIST_OF(SetVariable);

int der_decode_SetVariable(FILE *, SetVariable *, int);
/* only free's the contents, not the type itself */
void free_SetVariable(SetVariable *);

/*
 * SetVolume
 */
typedef struct SetVolume
{
	GenericObjectReference target;
	GenericInteger new_volume;
} SetVolume;

DEFINE_LIST_OF(SetVolume);

int der_decode_SetVolume(FILE *, SetVolume *, int);
/* only free's the contents, not the type itself */
void free_SetVolume(SetVolume *);

/*
 * Step
 */
typedef struct Step
{
	GenericObjectReference target;
	GenericInteger nb_of_steps;
} Step;

DEFINE_LIST_OF(Step);

int der_decode_Step(FILE *, Step *, int);
/* only free's the contents, not the type itself */
void free_Step(Step *);

/*
 * StorePersistent
 */
typedef struct StorePersistent
{
	GenericObjectReference target;
	ObjectReference store_succeeded;
	LIST_OF(ObjectReference) *in_variables;
	GenericOctetString out_file_name;
} StorePersistent;

DEFINE_LIST_OF(StorePersistent);

int der_decode_StorePersistent(FILE *, StorePersistent *, int);
/* only free's the contents, not the type itself */
void free_StorePersistent(StorePersistent *);

/*
 * Subtract
 */
typedef struct Subtract
{
	GenericObjectReference target;
	GenericInteger value;
} Subtract;

DEFINE_LIST_OF(Subtract);

int der_decode_Subtract(FILE *, Subtract *, int);
/* only free's the contents, not the type itself */
void free_Subtract(Subtract *);

/*
 * ComparisonValue
 */
typedef struct ComparisonValue
{
	unsigned int choice;
	union {
		GenericBoolean new_generic_boolean;	/* choice == 1 */
#define ComparisonValue_new_generic_boolean 1
		GenericInteger new_generic_integer;	/* choice == 2 */
#define ComparisonValue_new_generic_integer 2
		GenericOctetString new_generic_octetstring;	/* choice == 3 */
#define ComparisonValue_new_generic_octetstring 3
		GenericObjectReference new_generic_object_reference;	/* choice == 4 */
#define ComparisonValue_new_generic_object_reference 4
		GenericContentReference new_generic_content_reference;	/* choice == 5 */
#define ComparisonValue_new_generic_content_reference 5
	} u;
} ComparisonValue;

DEFINE_LIST_OF(ComparisonValue);

int der_decode_ComparisonValue(FILE *, ComparisonValue *, int);
/* only free's the contents, not the type itself */
void free_ComparisonValue(ComparisonValue *);

/*
 * TestVariable
 */
typedef struct TestVariable
{
	GenericObjectReference target;
	GenericInteger operator;
	ComparisonValue comparison_value;
} TestVariable;

DEFINE_LIST_OF(TestVariable);

int der_decode_TestVariable(FILE *, TestVariable *, int);
/* only free's the contents, not the type itself */
void free_TestVariable(TestVariable *);

/*
 * ToggleItem
 */
typedef struct ToggleItem
{
	GenericObjectReference target;
	GenericInteger item_index;
} ToggleItem;

DEFINE_LIST_OF(ToggleItem);

int der_decode_ToggleItem(FILE *, ToggleItem *, int);
/* only free's the contents, not the type itself */
void free_ToggleItem(ToggleItem *);

/*
 * ConnectionTagOrNull
 */
typedef struct ConnectionTagOrNull
{
	unsigned int choice;
	union {
		GenericInteger connection_tag;	/* choice == 1 */
#define ConnectionTagOrNull_connection_tag 1
		Null null;	/* choice == 2 */
#define ConnectionTagOrNull_null 2
	} u;
} ConnectionTagOrNull;

DEFINE_LIST_OF(ConnectionTagOrNull);

int der_decode_ConnectionTagOrNull(FILE *, ConnectionTagOrNull *, int);
/* only free's the contents, not the type itself */
void free_ConnectionTagOrNull(ConnectionTagOrNull *);

/*
 * TransitionTo
 */
typedef struct TransitionTo
{
	GenericObjectReference target;
	ConnectionTagOrNull connection_tag_or_null;
	bool have_transition_effect;	/* OPTIONAL */
	GenericInteger transition_effect;
} TransitionTo;

DEFINE_LIST_OF(TransitionTo);

int der_decode_TransitionTo(FILE *, TransitionTo *, int);
/* only free's the contents, not the type itself */
void free_TransitionTo(TransitionTo *);

/*
 * SetBackgroundColour
 */
typedef struct SetBackgroundColour
{
	GenericObjectReference target;
	NewColour new_background_colour;
} SetBackgroundColour;

DEFINE_LIST_OF(SetBackgroundColour);

int der_decode_SetBackgroundColour(FILE *, SetBackgroundColour *, int);
/* only free's the contents, not the type itself */
void free_SetBackgroundColour(SetBackgroundColour *);

/*
 * SetCellPosition
 */
typedef struct SetCellPosition
{
	GenericObjectReference target;
	GenericInteger index;
	GenericInteger new_x_position;
	GenericInteger new_y_position;
} SetCellPosition;

DEFINE_LIST_OF(SetCellPosition);

int der_decode_SetCellPosition(FILE *, SetCellPosition *, int);
/* only free's the contents, not the type itself */
void free_SetCellPosition(SetCellPosition *);

/*
 * SetInputRegister
 */
typedef struct SetInputRegister
{
	GenericObjectReference target;
	GenericInteger new_input_register;
} SetInputRegister;

DEFINE_LIST_OF(SetInputRegister);

int der_decode_SetInputRegister(FILE *, SetInputRegister *, int);
/* only free's the contents, not the type itself */
void free_SetInputRegister(SetInputRegister *);

/*
 * SetTextColour
 */
typedef struct SetTextColour
{
	GenericObjectReference target;
	NewColour new_text_colour;
} SetTextColour;

DEFINE_LIST_OF(SetTextColour);

int der_decode_SetTextColour(FILE *, SetTextColour *, int);
/* only free's the contents, not the type itself */
void free_SetTextColour(SetTextColour *);

/*
 * SetFontAttributes
 */
typedef struct SetFontAttributes
{
	GenericObjectReference target;
	GenericOctetString new_font_attribute;
} SetFontAttributes;

DEFINE_LIST_OF(SetFontAttributes);

int der_decode_SetFontAttributes(FILE *, SetFontAttributes *, int);
/* only free's the contents, not the type itself */
void free_SetFontAttributes(SetFontAttributes *);

/*
 * SetVideoDecodeOffset
 */
typedef struct SetVideoDecodeOffset
{
	GenericObjectReference target;
	GenericInteger new_x_offset;
	GenericInteger new_y_offset;
} SetVideoDecodeOffset;

DEFINE_LIST_OF(SetVideoDecodeOffset);

int der_decode_SetVideoDecodeOffset(FILE *, SetVideoDecodeOffset *, int);
/* only free's the contents, not the type itself */
void free_SetVideoDecodeOffset(SetVideoDecodeOffset *);

/*
 * GetVideoDecodeOffset
 */
typedef struct GetVideoDecodeOffset
{
	GenericObjectReference target;
	ObjectReference x_offset_var;
	ObjectReference y_offset_var;
} GetVideoDecodeOffset;

DEFINE_LIST_OF(GetVideoDecodeOffset);

int der_decode_GetVideoDecodeOffset(FILE *, GetVideoDecodeOffset *, int);
/* only free's the contents, not the type itself */
void free_GetVideoDecodeOffset(GetVideoDecodeOffset *);

/*
 * GetFocusPosition
 */
typedef struct GetFocusPosition
{
	GenericObjectReference target;
	ObjectReference focus_position_var;
} GetFocusPosition;

DEFINE_LIST_OF(GetFocusPosition);

int der_decode_GetFocusPosition(FILE *, GetFocusPosition *, int);
/* only free's the contents, not the type itself */
void free_GetFocusPosition(GetFocusPosition *);

/*
 * SetFocusPosition
 */
typedef struct SetFocusPosition
{
	GenericObjectReference target;
	GenericInteger new_focus_position;
} SetFocusPosition;

DEFINE_LIST_OF(SetFocusPosition);

int der_decode_SetFocusPosition(FILE *, SetFocusPosition *, int);
/* only free's the contents, not the type itself */
void free_SetFocusPosition(SetFocusPosition *);

/*
 * SetBitmapDecodeOffset
 */
typedef struct SetBitmapDecodeOffset
{
	GenericObjectReference target;
	GenericInteger new_x_offset;
	GenericInteger new_y_offset;
} SetBitmapDecodeOffset;

DEFINE_LIST_OF(SetBitmapDecodeOffset);

int der_decode_SetBitmapDecodeOffset(FILE *, SetBitmapDecodeOffset *, int);
/* only free's the contents, not the type itself */
void free_SetBitmapDecodeOffset(SetBitmapDecodeOffset *);

/*
 * GetBitmapDecodeOffset
 */
typedef struct GetBitmapDecodeOffset
{
	GenericObjectReference target;
	ObjectReference x_offset_var;
	ObjectReference y_offset_var;
} GetBitmapDecodeOffset;

DEFINE_LIST_OF(GetBitmapDecodeOffset);

int der_decode_GetBitmapDecodeOffset(FILE *, GetBitmapDecodeOffset *, int);
/* only free's the contents, not the type itself */
void free_GetBitmapDecodeOffset(GetBitmapDecodeOffset *);

/*
 * SetSliderParameters
 */
typedef struct SetSliderParameters
{
	GenericObjectReference target;
	GenericInteger new_min_value;
	GenericInteger new_max_value;
	GenericInteger new_step_size;
} SetSliderParameters;

DEFINE_LIST_OF(SetSliderParameters);

int der_decode_SetSliderParameters(FILE *, SetSliderParameters *, int);
/* only free's the contents, not the type itself */
void free_SetSliderParameters(SetSliderParameters *);

/*
 * SetInputMask
 */
typedef struct SetInputMask
{
	GenericObjectReference target;
	GenericOctetString new_input_mask;
} SetInputMask;

DEFINE_LIST_OF(SetInputMask);

int der_decode_SetInputMask(FILE *, SetInputMask *, int);
/* only free's the contents, not the type itself */
void free_SetInputMask(SetInputMask *);

/*
 * ElementaryAction
 */
typedef struct ElementaryAction
{
	unsigned int choice;
	union {
		GenericObjectReference activate;	/* choice == 1 */
#define ElementaryAction_activate 1
		Add add;	/* choice == 2 */
#define ElementaryAction_add 2
		AddItem add_item;	/* choice == 3 */
#define ElementaryAction_add_item 3
		Append append;	/* choice == 4 */
#define ElementaryAction_append 4
		GenericObjectReference bring_to_front;	/* choice == 5 */
#define ElementaryAction_bring_to_front 5
		Call call;	/* choice == 6 */
#define ElementaryAction_call 6
		CallActionSlot call_action_slot;	/* choice == 7 */
#define ElementaryAction_call_action_slot 7
		GenericObjectReference clear;	/* choice == 8 */
#define ElementaryAction_clear 8
		Clone clone;	/* choice == 9 */
#define ElementaryAction_clone 9
		CloseConnection close_connection;	/* choice == 10 */
#define ElementaryAction_close_connection 10
		GenericObjectReference deactivate;	/* choice == 11 */
#define ElementaryAction_deactivate 11
		DelItem del_item;	/* choice == 12 */
#define ElementaryAction_del_item 12
		GenericObjectReference deselect;	/* choice == 13 */
#define ElementaryAction_deselect 13
		DeselectItem deselect_item;	/* choice == 14 */
#define ElementaryAction_deselect_item 14
		Divide divide;	/* choice == 15 */
#define ElementaryAction_divide 15
		DrawArc draw_arc;	/* choice == 16 */
#define ElementaryAction_draw_arc 16
		DrawLine draw_line;	/* choice == 17 */
#define ElementaryAction_draw_line 17
		DrawOval draw_oval;	/* choice == 18 */
#define ElementaryAction_draw_oval 18
		DrawPolygon draw_polygon;	/* choice == 19 */
#define ElementaryAction_draw_polygon 19
		DrawPolyline draw_polyline;	/* choice == 20 */
#define ElementaryAction_draw_polyline 20
		DrawRectangle draw_rectangle;	/* choice == 21 */
#define ElementaryAction_draw_rectangle 21
		DrawSector draw_sector;	/* choice == 22 */
#define ElementaryAction_draw_sector 22
		Fork fork;	/* choice == 23 */
#define ElementaryAction_fork 23
		GetAvailabilityStatus get_availability_status;	/* choice == 24 */
#define ElementaryAction_get_availability_status 24
		GetBoxSize get_box_size;	/* choice == 25 */
#define ElementaryAction_get_box_size 25
		GetCellItem get_cell_item;	/* choice == 26 */
#define ElementaryAction_get_cell_item 26
		GetCursorPosition get_cursor_position;	/* choice == 27 */
#define ElementaryAction_get_cursor_position 27
		GetEngineSupport get_engine_support;	/* choice == 28 */
#define ElementaryAction_get_engine_support 28
		GetEntryPoint get_entry_point;	/* choice == 29 */
#define ElementaryAction_get_entry_point 29
		GetFillColour get_fill_colour;	/* choice == 30 */
#define ElementaryAction_get_fill_colour 30
		GetFirstItem get_first_item;	/* choice == 31 */
#define ElementaryAction_get_first_item 31
		GetHighlightStatus get_highlight_status;	/* choice == 32 */
#define ElementaryAction_get_highlight_status 32
		GetInteractionStatus get_interaction_status;	/* choice == 33 */
#define ElementaryAction_get_interaction_status 33
		GetItemStatus get_item_status;	/* choice == 34 */
#define ElementaryAction_get_item_status 34
		GetLabel get_label;	/* choice == 35 */
#define ElementaryAction_get_label 35
		GetLastAnchorFired get_last_anchor_fired;	/* choice == 36 */
#define ElementaryAction_get_last_anchor_fired 36
		GetLineColour get_line_colour;	/* choice == 37 */
#define ElementaryAction_get_line_colour 37
		GetLineStyle get_line_style;	/* choice == 38 */
#define ElementaryAction_get_line_style 38
		GetLineWidth get_line_width;	/* choice == 39 */
#define ElementaryAction_get_line_width 39
		GetListItem get_list_item;	/* choice == 40 */
#define ElementaryAction_get_list_item 40
		GetListSize get_list_size;	/* choice == 41 */
#define ElementaryAction_get_list_size 41
		GetOverwriteMode get_overwrite_mode;	/* choice == 42 */
#define ElementaryAction_get_overwrite_mode 42
		GetPortion get_portion;	/* choice == 43 */
#define ElementaryAction_get_portion 43
		GetPosition get_position;	/* choice == 44 */
#define ElementaryAction_get_position 44
		GetRunningStatus get_running_status;	/* choice == 45 */
#define ElementaryAction_get_running_status 45
		GetSelectionStatus get_selection_status;	/* choice == 46 */
#define ElementaryAction_get_selection_status 46
		GetSliderValue get_slider_value;	/* choice == 47 */
#define ElementaryAction_get_slider_value 47
		GetTextContent get_text_content;	/* choice == 48 */
#define ElementaryAction_get_text_content 48
		GetTextData get_text_data;	/* choice == 49 */
#define ElementaryAction_get_text_data 49
		GetTokenPosition get_token_position;	/* choice == 50 */
#define ElementaryAction_get_token_position 50
		GetVolume get_volume;	/* choice == 51 */
#define ElementaryAction_get_volume 51
		GenericObjectReference launch;	/* choice == 52 */
#define ElementaryAction_launch 52
		GenericObjectReference lock_screen;	/* choice == 53 */
#define ElementaryAction_lock_screen 53
		Modulo modulo;	/* choice == 54 */
#define ElementaryAction_modulo 54
		Move move;	/* choice == 55 */
#define ElementaryAction_move 55
		MoveTo move_to;	/* choice == 56 */
#define ElementaryAction_move_to 56
		Multiply multiply;	/* choice == 57 */
#define ElementaryAction_multiply 57
		OpenConnection open_connection;	/* choice == 58 */
#define ElementaryAction_open_connection 58
		GenericObjectReference preload;	/* choice == 59 */
#define ElementaryAction_preload 59
		PutBefore put_before;	/* choice == 60 */
#define ElementaryAction_put_before 60
		PutBehind put_behind;	/* choice == 61 */
#define ElementaryAction_put_behind 61
		GenericObjectReference quit;	/* choice == 62 */
#define ElementaryAction_quit 62
		ReadPersistent read_persistent;	/* choice == 63 */
#define ElementaryAction_read_persistent 63
		GenericObjectReference run;	/* choice == 64 */
#define ElementaryAction_run 64
		ScaleBitmap scale_bitmap;	/* choice == 65 */
#define ElementaryAction_scale_bitmap 65
		ScaleVideo scale_video;	/* choice == 66 */
#define ElementaryAction_scale_video 66
		ScrollItems scroll_items;	/* choice == 67 */
#define ElementaryAction_scroll_items 67
		GenericObjectReference select;	/* choice == 68 */
#define ElementaryAction_select 68
		SelectItem select_item;	/* choice == 69 */
#define ElementaryAction_select_item 69
		SendEvent send_event;	/* choice == 70 */
#define ElementaryAction_send_event 70
		GenericObjectReference send_to_back;	/* choice == 71 */
#define ElementaryAction_send_to_back 71
		SetBoxSize set_box_size;	/* choice == 72 */
#define ElementaryAction_set_box_size 72
		SetCachePriority set_cache_priority;	/* choice == 73 */
#define ElementaryAction_set_cache_priority 73
		SetCounterEndPosition set_counter_end_position;	/* choice == 74 */
#define ElementaryAction_set_counter_end_position 74
		SetCounterPosition set_counter_position;	/* choice == 75 */
#define ElementaryAction_set_counter_position 75
		SetCounterTrigger set_counter_trigger;	/* choice == 76 */
#define ElementaryAction_set_counter_trigger 76
		SetCursorPosition set_cursor_position;	/* choice == 77 */
#define ElementaryAction_set_cursor_position 77
		SetCursorShape set_cursor_shape;	/* choice == 78 */
#define ElementaryAction_set_cursor_shape 78
		SetData set_data;	/* choice == 79 */
#define ElementaryAction_set_data 79
		SetEntryPoint set_entry_point;	/* choice == 80 */
#define ElementaryAction_set_entry_point 80
		SetFillColour set_fill_colour;	/* choice == 81 */
#define ElementaryAction_set_fill_colour 81
		SetFirstItem set_first_item;	/* choice == 82 */
#define ElementaryAction_set_first_item 82
		SetFontRef set_font_ref;	/* choice == 83 */
#define ElementaryAction_set_font_ref 83
		SetHighlightStatus set_highlight_status;	/* choice == 84 */
#define ElementaryAction_set_highlight_status 84
		SetInteractionStatus set_interaction_status;	/* choice == 85 */
#define ElementaryAction_set_interaction_status 85
		SetLabel set_label;	/* choice == 86 */
#define ElementaryAction_set_label 86
		SetLineColour set_line_colour;	/* choice == 87 */
#define ElementaryAction_set_line_colour 87
		SetLineStyle set_line_style;	/* choice == 88 */
#define ElementaryAction_set_line_style 88
		SetLineWidth set_line_width;	/* choice == 89 */
#define ElementaryAction_set_line_width 89
		SetOverwriteMode set_overwrite_mode;	/* choice == 90 */
#define ElementaryAction_set_overwrite_mode 90
		SetPaletteRef set_palette_ref;	/* choice == 91 */
#define ElementaryAction_set_palette_ref 91
		SetPortion set_portion;	/* choice == 92 */
#define ElementaryAction_set_portion 92
		SetPosition set_position;	/* choice == 93 */
#define ElementaryAction_set_position 93
		SetSliderValue set_slider_value;	/* choice == 94 */
#define ElementaryAction_set_slider_value 94
		SetSpeed set_speed;	/* choice == 95 */
#define ElementaryAction_set_speed 95
		SetTimer set_timer;	/* choice == 96 */
#define ElementaryAction_set_timer 96
		SetTransparency set_transparency;	/* choice == 97 */
#define ElementaryAction_set_transparency 97
		SetVariable set_variable;	/* choice == 98 */
#define ElementaryAction_set_variable 98
		SetVolume set_volume;	/* choice == 99 */
#define ElementaryAction_set_volume 99
		GenericObjectReference spawn;	/* choice == 100 */
#define ElementaryAction_spawn 100
		Step step;	/* choice == 101 */
#define ElementaryAction_step 101
		GenericObjectReference stop;	/* choice == 102 */
#define ElementaryAction_stop 102
		StorePersistent store_persistent;	/* choice == 103 */
#define ElementaryAction_store_persistent 103
		Subtract subtract;	/* choice == 104 */
#define ElementaryAction_subtract 104
		TestVariable test_variable;	/* choice == 105 */
#define ElementaryAction_test_variable 105
		GenericObjectReference toggle;	/* choice == 106 */
#define ElementaryAction_toggle 106
		ToggleItem toggle_item;	/* choice == 107 */
#define ElementaryAction_toggle_item 107
		TransitionTo transition_to;	/* choice == 108 */
#define ElementaryAction_transition_to 108
		GenericObjectReference unload;	/* choice == 109 */
#define ElementaryAction_unload 109
		GenericObjectReference unlock_screen;	/* choice == 110 */
#define ElementaryAction_unlock_screen 110
		SetBackgroundColour set_background_colour;	/* choice == 111 */
#define ElementaryAction_set_background_colour 111
		SetCellPosition set_cell_position;	/* choice == 112 */
#define ElementaryAction_set_cell_position 112
		SetInputRegister set_input_register;	/* choice == 113 */
#define ElementaryAction_set_input_register 113
		SetTextColour set_text_colour;	/* choice == 114 */
#define ElementaryAction_set_text_colour 114
		SetFontAttributes set_font_attributes;	/* choice == 115 */
#define ElementaryAction_set_font_attributes 115
		SetVideoDecodeOffset set_video_decode_offset;	/* choice == 116 */
#define ElementaryAction_set_video_decode_offset 116
		GetVideoDecodeOffset get_video_decode_offset;	/* choice == 117 */
#define ElementaryAction_get_video_decode_offset 117
		GetFocusPosition get_focus_position;	/* choice == 118 */
#define ElementaryAction_get_focus_position 118
		SetFocusPosition set_focus_position;	/* choice == 119 */
#define ElementaryAction_set_focus_position 119
		SetBitmapDecodeOffset set_bitmap_decode_offset;	/* choice == 120 */
#define ElementaryAction_set_bitmap_decode_offset 120
		GetBitmapDecodeOffset get_bitmap_decode_offset;	/* choice == 121 */
#define ElementaryAction_get_bitmap_decode_offset 121
		SetSliderParameters set_slider_parameters;	/* choice == 122 */
#define ElementaryAction_set_slider_parameters 122
		SetInputMask set_input_mask;	/* choice == 123 */
#define ElementaryAction_set_input_mask 123
	} u;
} ElementaryAction;

DEFINE_LIST_OF(ElementaryAction);

int der_decode_ElementaryAction(FILE *, ElementaryAction *, int);
/* only free's the contents, not the type itself */
void free_ElementaryAction(ElementaryAction *);

/*
 * ActionClass
 */
typedef LIST_OF(ElementaryAction) *ActionClass;

DEFINE_LIST_OF(ActionClass);

int der_decode_ActionClass(FILE *, ActionClass *, int);
/* only free's the contents, not the type itself */
void free_ActionClass(ActionClass *);

/*
 * ProgramClass
 */
typedef struct
{
	/* we need to know if it was forked or not */
	bool forked;
} ProgramClassInstanceVars;

typedef struct ProgramClass
{
	RootClass rootClass;
	bool initially_active;	/* DEFAULT false */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OctetString name;
	bool initially_available;	/* DEFAULT true */
	/* instance variables */
	ProgramClassInstanceVars inst;
} ProgramClass;

DEFINE_LIST_OF(ProgramClass);

int der_decode_ProgramClass(FILE *, ProgramClass *, int);
/* only free's the contents, not the type itself */
void free_ProgramClass(ProgramClass *);

/*
 * ResidentProgramClass
 */
typedef ProgramClass ResidentProgramClass;

DEFINE_LIST_OF(ResidentProgramClass);

int der_decode_ResidentProgramClass(FILE *, ResidentProgramClass *, int);
/* only free's the contents, not the type itself */
void free_ResidentProgramClass(ResidentProgramClass *);

/*
 * RemoteProgramClass
 */
typedef struct RemoteProgramClass
{
	RootClass rootClass;
	bool initially_active;	/* DEFAULT false */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OctetString name;
	bool initially_available;	/* DEFAULT true */
	bool have_program_connection_tag;	/* OPTIONAL */
	int program_connection_tag;
} RemoteProgramClass;

DEFINE_LIST_OF(RemoteProgramClass);

int der_decode_RemoteProgramClass(FILE *, RemoteProgramClass *, int);
/* only free's the contents, not the type itself */
void free_RemoteProgramClass(RemoteProgramClass *);

/*
 * InterchangedProgramClass
 */
typedef ProgramClass InterchangedProgramClass;

DEFINE_LIST_OF(InterchangedProgramClass);

int der_decode_InterchangedProgramClass(FILE *, InterchangedProgramClass *, int);
/* only free's the contents, not the type itself */
void free_InterchangedProgramClass(InterchangedProgramClass *);

/*
 * PaletteClass
 */
typedef IngredientClass PaletteClass;

DEFINE_LIST_OF(PaletteClass);

int der_decode_PaletteClass(FILE *, PaletteClass *, int);
/* only free's the contents, not the type itself */
void free_PaletteClass(PaletteClass *);

/*
 * FontClass
 */
typedef IngredientClass FontClass;

DEFINE_LIST_OF(FontClass);

int der_decode_FontClass(FILE *, FontClass *, int);
/* only free's the contents, not the type itself */
void free_FontClass(FontClass *);

/*
 * CursorShapeClass
 */
typedef IngredientClass CursorShapeClass;

DEFINE_LIST_OF(CursorShapeClass);

int der_decode_CursorShapeClass(FILE *, CursorShapeClass *, int);
/* only free's the contents, not the type itself */
void free_CursorShapeClass(CursorShapeClass *);

/*
 * OriginalValue
 */
typedef struct OriginalValue
{
	unsigned int choice;
	union {
		bool boolean;	/* choice == 1 */
#define OriginalValue_boolean 1
		int integer;	/* choice == 2 */
#define OriginalValue_integer 2
		OctetString octetstring;	/* choice == 3 */
#define OriginalValue_octetstring 3
		ObjectReference object_reference;	/* choice == 4 */
#define OriginalValue_object_reference 4
		ContentReference content_reference;	/* choice == 5 */
#define OriginalValue_content_reference 5
	} u;
} OriginalValue;

DEFINE_LIST_OF(OriginalValue);

int der_decode_OriginalValue(FILE *, OriginalValue *, int);
/* only free's the contents, not the type itself */
void free_OriginalValue(OriginalValue *);

/*
 * VariableClass
 */
typedef struct
{
	OriginalValue Value;
} VariableClassInstanceVars;

typedef struct VariableClass
{
	RootClass rootClass;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OriginalValue original_value;
	/* instance variables */
	VariableClassInstanceVars inst;
} VariableClass;

DEFINE_LIST_OF(VariableClass);

int der_decode_VariableClass(FILE *, VariableClass *, int);
/* only free's the contents, not the type itself */
void free_VariableClass(VariableClass *);

/*
 * BooleanVariableClass
 */
typedef VariableClass BooleanVariableClass;

DEFINE_LIST_OF(BooleanVariableClass);

int der_decode_BooleanVariableClass(FILE *, BooleanVariableClass *, int);
/* only free's the contents, not the type itself */
void free_BooleanVariableClass(BooleanVariableClass *);

/*
 * IntegerVariableClass
 */
typedef VariableClass IntegerVariableClass;

DEFINE_LIST_OF(IntegerVariableClass);

int der_decode_IntegerVariableClass(FILE *, IntegerVariableClass *, int);
/* only free's the contents, not the type itself */
void free_IntegerVariableClass(IntegerVariableClass *);

/*
 * OctetStringVariableClass
 */
typedef VariableClass OctetStringVariableClass;

DEFINE_LIST_OF(OctetStringVariableClass);

int der_decode_OctetStringVariableClass(FILE *, OctetStringVariableClass *, int);
/* only free's the contents, not the type itself */
void free_OctetStringVariableClass(OctetStringVariableClass *);

/*
 * ObjectRefVariableClass
 */
typedef VariableClass ObjectRefVariableClass;

DEFINE_LIST_OF(ObjectRefVariableClass);

int der_decode_ObjectRefVariableClass(FILE *, ObjectRefVariableClass *, int);
/* only free's the contents, not the type itself */
void free_ObjectRefVariableClass(ObjectRefVariableClass *);

/*
 * ContentRefVariableClass
 */
typedef VariableClass ContentRefVariableClass;

DEFINE_LIST_OF(ContentRefVariableClass);

int der_decode_ContentRefVariableClass(FILE *, ContentRefVariableClass *, int);
/* only free's the contents, not the type itself */
void free_ContentRefVariableClass(ContentRefVariableClass *);

/*
 * EventData
 */
typedef struct EventData
{
	unsigned int choice;
	union {
		bool boolean;	/* choice == 1 */
#define EventData_boolean 1
		int integer;	/* choice == 2 */
#define EventData_integer 2
		OctetString octetstring;	/* choice == 3 */
#define EventData_octetstring 3
	} u;
} EventData;

DEFINE_LIST_OF(EventData);

int der_decode_EventData(FILE *, EventData *, int);
/* only free's the contents, not the type itself */
void free_EventData(EventData *);

/*
 * LinkCondition
 */
typedef struct LinkCondition
{
	ObjectReference event_source;
	EventType event_type;
	bool have_event_data;	/* OPTIONAL */
	EventData event_data;
} LinkCondition;

DEFINE_LIST_OF(LinkCondition);

int der_decode_LinkCondition(FILE *, LinkCondition *, int);
/* only free's the contents, not the type itself */
void free_LinkCondition(LinkCondition *);

/*
 * LinkClass
 */
typedef struct LinkClass
{
	RootClass rootClass;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	LinkCondition link_condition;
	ActionClass link_effect;
} LinkClass;

DEFINE_LIST_OF(LinkClass);

int der_decode_LinkClass(FILE *, LinkClass *, int);
/* only free's the contents, not the type itself */
void free_LinkClass(LinkClass *);

/*
 * AudioClass
 */
typedef struct
{
	int Volume;
	/* we add a link to the StreamClass it is a part of */
	struct StreamClass *owner;
} AudioClassInstanceVars;

typedef struct AudioClass
{
	RootClass rootClass;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	int component_tag;
	int original_volume;	/* DEFAULT 0 */
	/* instance variables */
	AudioClassInstanceVars inst;
} AudioClass;

DEFINE_LIST_OF(AudioClass);

int der_decode_AudioClass(FILE *, AudioClass *, int);
/* only free's the contents, not the type itself */
void free_AudioClass(AudioClass *);

/*
 * OriginalBoxSize
 */
typedef struct OriginalBoxSize
{
	unsigned int x_length;
	unsigned int y_length;
} OriginalBoxSize;

DEFINE_LIST_OF(OriginalBoxSize);

int der_decode_OriginalBoxSize(FILE *, OriginalBoxSize *, int);
/* only free's the contents, not the type itself */
void free_OriginalBoxSize(OriginalBoxSize *);

/*
 * XYPosition
 */
typedef struct XYPosition
{
	int x_position;
	int y_position;
} XYPosition;

DEFINE_LIST_OF(XYPosition);

int der_decode_XYPosition(FILE *, XYPosition *, int);
/* only free's the contents, not the type itself */
void free_XYPosition(XYPosition *);

/*
 * Termination
 */
typedef enum Termination
{
	Termination_freeze = 1,
	Termination_disappear = 2,
} Termination;

DEFINE_LIST_OF(Termination);

int der_decode_Termination(FILE *, Termination *, int);
/* only free's the contents, not the type itself */
void free_Termination(Termination *);

/*
 * VideoClass
 */
typedef struct
{
	/* inherited from VisibleClass */
	OriginalBoxSize BoxSize;
	XYPosition Position;
	bool have_PaletteRef;		/* OPTIONAL */
	ObjectReference PaletteRef;
	/* VideoClass */
	/* UK MHEG Profile adds this */
	XYPosition VideoDecodeOffset;
	/* we add a link to the StreamClass it is a part of */
	struct StreamClass *owner;
#if !defined(WIN32)
	/* we add a lock for the size/position */
	pthread_mutex_t bbox_lock;
	/* and the scaled size */
	pthread_mutex_t scaled_lock;
#endif
	bool scaled;
	unsigned int scaled_width;
	unsigned int scaled_height;
	/* this gets set if the MHEGStreamPlayer fails to open the video stream */
	bool no_video;
} VideoClassInstanceVars;

typedef struct VideoClass
{
	RootClass rootClass;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OriginalBoxSize original_box_size;
	XYPosition original_position;	/* DEFAULT {x-position 0, y-position 0} */
	bool have_original_palette_ref;	/* OPTIONAL */
	ObjectReference original_palette_ref;
	int component_tag;
	Termination termination;	/* DEFAULT disappear */
	/* instance variables */
	VideoClassInstanceVars inst;
} VideoClass;

DEFINE_LIST_OF(VideoClass);

int der_decode_VideoClass(FILE *, VideoClass *, int);
/* only free's the contents, not the type itself */
void free_VideoClass(VideoClass *);

/*
 * RTGraphicsClass
 */
typedef struct
{
	/* not implemented */
	/* we add a link to the StreamClass it is a part of */
	struct StreamClass *owner;
} RTGraphicsClassInstanceVars;

typedef struct RTGraphicsClass
{
	RootClass rootClass;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OriginalBoxSize original_box_size;
	XYPosition original_position;	/* DEFAULT {x-position 0, y-position 0} */
	bool have_original_palette_ref;	/* OPTIONAL */
	ObjectReference original_palette_ref;
	int component_tag;
	Termination termination;	/* DEFAULT disappear */
	/* instance variables */
	RTGraphicsClassInstanceVars inst;
} RTGraphicsClass;

DEFINE_LIST_OF(RTGraphicsClass);

int der_decode_RTGraphicsClass(FILE *, RTGraphicsClass *, int);
/* only free's the contents, not the type itself */
void free_RTGraphicsClass(RTGraphicsClass *);

/*
 * StreamComponent
 */
typedef struct StreamComponent
{
	unsigned int choice;
	union {
		AudioClass audio;	/* choice == 1 */
#define StreamComponent_audio 1
		VideoClass video;	/* choice == 2 */
#define StreamComponent_video 2
		RTGraphicsClass rtgraphics;	/* choice == 3 */
#define StreamComponent_rtgraphics 3
	} u;
} StreamComponent;

DEFINE_LIST_OF(StreamComponent);

int der_decode_StreamComponent(FILE *, StreamComponent *, int);
/* only free's the contents, not the type itself */
void free_StreamComponent(StreamComponent *);

/*
 * Storage
 */
typedef enum Storage
{
	Storage_memory = 1,
	Storage_stream = 2,
} Storage;

DEFINE_LIST_OF(Storage);

int der_decode_Storage(FILE *, Storage *, int);
/* only free's the contents, not the type itself */
void free_Storage(Storage *);

/*
 * StreamClass
 */
#include "MHEGStreamPlayer.h"

typedef struct
{
	int numerator;
	bool have_denominator;	/* OPTIONAL */
	int demoninator;
} StreamSpeed;

typedef struct
{
	int id;
	int position;
} CounterTrigger;

DEFINE_LIST_OF(CounterTrigger);

typedef struct
{
	StreamSpeed Speed;
	int CounterPosition;
	int CounterEndPosition;
	LIST_OF(CounterTrigger) *CounterTriggers;
	/* we add this */
	MHEGStreamPlayer *player;
} StreamClassInstanceVars;

typedef struct StreamClass
{
	RootClass rootClass;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	LIST_OF(StreamComponent) *multiplex;	/* OPTIONAL */
	Storage storage;	/* DEFAULT stream */
	int looping;	/* DEFAULT 1 */
#define looping_infinity 0
	/* instance variables */
	StreamClassInstanceVars inst;
} StreamClass;

DEFINE_LIST_OF(StreamClass);

int der_decode_StreamClass(FILE *, StreamClass *, int);
/* only free's the contents, not the type itself */
void free_StreamClass(StreamClass *);

/*
 * BitmapClass
 */
#include "MHEGBitmap.h"

typedef struct
{
	/* inherited from VisibleClass */
	OriginalBoxSize BoxSize;
	XYPosition Position;
	bool have_PaletteRef;		/* OPTIONAL */
	ObjectReference PaletteRef;
	/* BitmapClass */
	unsigned int Transparency;
	/* UK MHEG Profile adds this extra variable */
	XYPosition BitmapDecodeOffset;
	/* and the scaled size */ /* hmkim : added. */
	bool scaled;
	unsigned int scaled_width;
	unsigned int scaled_height;
	/* we add the actual bitmap data */
	OctetString BitmapData;
	/* MHEGDisplay's internal format */
	MHEGBitmap *Bitmap;
} BitmapClassInstanceVars;

typedef struct BitmapClass
{
	RootClass rootClass;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OriginalBoxSize original_box_size;
	XYPosition original_position;	/* DEFAULT {x-position 0, y-position 0} */
	bool have_original_palette_ref;	/* OPTIONAL */
	ObjectReference original_palette_ref;
	bool tiling;	/* DEFAULT false */
	unsigned int original_transparency;	/* DEFAULT 0 */
	/* instance variables */
	BitmapClassInstanceVars inst;
} BitmapClass;

DEFINE_LIST_OF(BitmapClass);

int der_decode_BitmapClass(FILE *, BitmapClass *, int);
/* only free's the contents, not the type itself */
void free_BitmapClass(BitmapClass *);

/*
 * Colour
 */
typedef struct Colour
{
	unsigned int choice;
	union {
		int colour_index;	/* choice == 1 */
#define Colour_colour_index 1
		OctetString absolute_colour;	/* choice == 2 */
#define Colour_absolute_colour 2
	} u;
} Colour;

DEFINE_LIST_OF(Colour);

int der_decode_Colour(FILE *, Colour *, int);
/* only free's the contents, not the type itself */
void free_Colour(Colour *);

/*
 * LineArtClass
 */
#include "MHEGColour.h"
#include "MHEGCanvas.h"

typedef struct
{
	/* inherited from VisibleClass */
	OriginalBoxSize BoxSize;
	XYPosition Position;
	bool have_PaletteRef;		/* OPTIONAL */
	ObjectReference PaletteRef;
	/* LineArtClass */
	int LineWidth;
	int LineStyle;
#define LineStyle_solid		original_line_style_solid
#define LineStyle_dashed	original_line_style_dashed
#define LineStyle_dotted	original_line_style_dotted
	MHEGColour RefLineColour;
	MHEGColour RefFillColour;
	/*
	 * OriginalRefLine/FillColour are optional but have defaults defined in the spec
	 * store them here so we don't have to keep checking if they were specified or not
	 */
	MHEGColour OriginalRefLineColour;
	MHEGColour OriginalRefFillColour;
	/* only used by DynamicLineArtClass */
	MHEGCanvas *canvas;
} LineArtClassInstanceVars;

typedef struct LineArtClass
{
	RootClass rootClass;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OriginalBoxSize original_box_size;
	XYPosition original_position;	/* DEFAULT {x-position 0, y-position 0} */
	bool have_original_palette_ref;	/* OPTIONAL */
	ObjectReference original_palette_ref;
	bool have_bordered_bounding_box;	/* OPTIONAL */
	bool bordered_bounding_box;
	int original_line_width;	/* DEFAULT 1 */
	int original_line_style;	/* DEFAULT solid */
#define original_line_style_solid 1
#define original_line_style_dashed 2
#define original_line_style_dotted 3
	bool have_original_ref_line_colour;	/* OPTIONAL */
	Colour original_ref_line_colour;
	bool have_original_ref_fill_colour;	/* OPTIONAL */
	Colour original_ref_fill_colour;
	/* instance variables */
	LineArtClassInstanceVars inst;
} LineArtClass;

DEFINE_LIST_OF(LineArtClass);

int der_decode_LineArtClass(FILE *, LineArtClass *, int);
/* only free's the contents, not the type itself */
void free_LineArtClass(LineArtClass *);

/*
 * DynamicLineArtClass
 */
typedef LineArtClass DynamicLineArtClass;

DEFINE_LIST_OF(DynamicLineArtClass);

int der_decode_DynamicLineArtClass(FILE *, DynamicLineArtClass *, int);
/* only free's the contents, not the type itself */
void free_DynamicLineArtClass(DynamicLineArtClass *);

/*
 * RectangleClass
 */
typedef LineArtClass RectangleClass;

DEFINE_LIST_OF(RectangleClass);

int der_decode_RectangleClass(FILE *, RectangleClass *, int);
/* only free's the contents, not the type itself */
void free_RectangleClass(RectangleClass *);

/*
 * ButtonClass
 */
typedef struct ButtonClass
{
	RootClass rootClass;
	bool have_button_ref_colour;	/* OPTIONAL */
	Colour button_ref_colour;
	bool have_highlight_ref_colour;	/* OPTIONAL */
	Colour highlight_ref_colour;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OriginalBoxSize original_box_size;
	XYPosition original_position;	/* DEFAULT {x-position 0, y-position 0} */
	bool have_original_palette_ref;	/* OPTIONAL */
	ObjectReference original_palette_ref;
	bool engine_resp;	/* DEFAULT true */
} ButtonClass;

DEFINE_LIST_OF(ButtonClass);

int der_decode_ButtonClass(FILE *, ButtonClass *, int);
/* only free's the contents, not the type itself */
void free_ButtonClass(ButtonClass *);

/*
 * HotspotClass
 */
typedef ButtonClass HotspotClass;

DEFINE_LIST_OF(HotspotClass);

int der_decode_HotspotClass(FILE *, HotspotClass *, int);
/* only free's the contents, not the type itself */
void free_HotspotClass(HotspotClass *);

/*
 * ButtonStyle
 */
typedef enum ButtonStyle
{
	ButtonStyle_pushbutton = 1,
	ButtonStyle_radiobutton = 2,
	ButtonStyle_checkbox = 3,
} ButtonStyle;

DEFINE_LIST_OF(ButtonStyle);

int der_decode_ButtonStyle(FILE *, ButtonStyle *, int);
/* only free's the contents, not the type itself */
void free_ButtonStyle(ButtonStyle *);

/*
 * SwitchButtonClass
 */
typedef struct SwitchButtonClass
{
	RootClass rootClass;
	bool have_character_set;	/* OPTIONAL */
	int character_set;
	bool have_button_ref_colour;	/* OPTIONAL */
	Colour button_ref_colour;
	bool have_highlight_ref_colour;	/* OPTIONAL */
	Colour highlight_ref_colour;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OriginalBoxSize original_box_size;
	XYPosition original_position;	/* DEFAULT {x-position 0, y-position 0} */
	bool have_original_palette_ref;	/* OPTIONAL */
	ObjectReference original_palette_ref;
	bool engine_resp;	/* DEFAULT true */
	bool have_original_label;	/* OPTIONAL */
	OctetString original_label;
	ButtonStyle button_style;
} SwitchButtonClass;

DEFINE_LIST_OF(SwitchButtonClass);

int der_decode_SwitchButtonClass(FILE *, SwitchButtonClass *, int);
/* only free's the contents, not the type itself */
void free_SwitchButtonClass(SwitchButtonClass *);

/*
 * PushButtonClass
 */
typedef struct PushButtonClass
{
	RootClass rootClass;
	bool have_character_set;	/* OPTIONAL */
	int character_set;
	bool have_button_ref_colour;	/* OPTIONAL */
	Colour button_ref_colour;
	bool have_highlight_ref_colour;	/* OPTIONAL */
	Colour highlight_ref_colour;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OriginalBoxSize original_box_size;
	XYPosition original_position;	/* DEFAULT {x-position 0, y-position 0} */
	bool have_original_palette_ref;	/* OPTIONAL */
	ObjectReference original_palette_ref;
	bool engine_resp;	/* DEFAULT true */
	bool have_original_label;	/* OPTIONAL */
	OctetString original_label;
} PushButtonClass;

DEFINE_LIST_OF(PushButtonClass);

int der_decode_PushButtonClass(FILE *, PushButtonClass *, int);
/* only free's the contents, not the type itself */
void free_PushButtonClass(PushButtonClass *);

/*
 * FontBody
 */
typedef struct FontBody
{
	unsigned int choice;
	union {
		ObjectReference indirect_font;	/* choice == 1 */
#define FontBody_indirect_font 1
		OctetString direct_font;	/* choice == 2 */
#define FontBody_direct_font 2
	} u;
} FontBody;

DEFINE_LIST_OF(FontBody);

int der_decode_FontBody(FILE *, FontBody *, int);
/* only free's the contents, not the type itself */
void free_FontBody(FontBody *);

/*
 * Justification
 */
typedef enum Justification
{
	Justification_start = 1,
	Justification_end = 2,
	Justification_centre = 3,
	Justification_justified = 4,
} Justification;

DEFINE_LIST_OF(Justification);

int der_decode_Justification(FILE *, Justification *, int);
/* only free's the contents, not the type itself */
void free_Justification(Justification *);

/*
 * LineOrientation
 */
typedef enum LineOrientation
{
	LineOrientation_vertical = 1,
	LineOrientation_horizontal = 2,
} LineOrientation;

DEFINE_LIST_OF(LineOrientation);

int der_decode_LineOrientation(FILE *, LineOrientation *, int);
/* only free's the contents, not the type itself */
void free_LineOrientation(LineOrientation *);

/*
 * StartCorner
 */
typedef enum StartCorner
{
	StartCorner_upper_left = 1,
	StartCorner_upper_right = 2,
	StartCorner_lower_left = 3,
	StartCorner_lower_right = 4,
} StartCorner;

DEFINE_LIST_OF(StartCorner);

int der_decode_StartCorner(FILE *, StartCorner *, int);
/* only free's the contents, not the type itself */
void free_StartCorner(StartCorner *);

/*
 * TextClass
 */
#include "MHEGFont.h"

typedef struct
{
	/* inherited from VisibleClass */
	OriginalBoxSize BoxSize;
	XYPosition Position;
	bool have_PaletteRef;		/* OPTIONAL */
	ObjectReference PaletteRef;
	/* TextClass */
	OctetString TextData;
	MHEGFont Font;
	/* UK MHEG Profile adds these */
	MHEGColour TextColour;
	MHEGColour BackgroundColour;
// part of MHEGFont
//	MHEGFontAttr FontAttributes;
	/* we add this */
	LIST_OF(MHEGTextElement) *element;
} TextClassInstanceVars;

typedef struct TextClass
{
	RootClass rootClass;
	bool have_character_set;	/* OPTIONAL */
	int character_set;
	bool have_background_colour;	/* OPTIONAL */
	Colour background_colour;
	bool have_text_colour;	/* OPTIONAL */
	Colour text_colour;
	bool have_font_attributes;	/* OPTIONAL */
	OctetString font_attributes;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OriginalBoxSize original_box_size;
	XYPosition original_position;	/* DEFAULT {x-position 0, y-position 0} */
	bool have_original_palette_ref;	/* OPTIONAL */
	ObjectReference original_palette_ref;
	bool have_original_font;	/* OPTIONAL */
	FontBody original_font;
	Justification horizontal_justification;	/* DEFAULT start */
	Justification vertical_justification;	/* DEFAULT start */
	LineOrientation line_orientation;	/* DEFAULT horizontal */
	StartCorner start_corner;	/* DEFAULT upper-left */
	bool text_wrapping;	/* DEFAULT false */
	/* instance variables */
	TextClassInstanceVars inst;
} TextClass;

DEFINE_LIST_OF(TextClass);

int der_decode_TextClass(FILE *, TextClass *, int);
/* only free's the contents, not the type itself */
void free_TextClass(TextClass *);

/*
 * InputType
 */
typedef enum InputType
{
	InputType_alpha = 1,
	InputType_numeric = 2,
	InputType_any = 3,
	InputType_listed = 4,
} InputType;

DEFINE_LIST_OF(InputType);

int der_decode_InputType(FILE *, InputType *, int);
/* only free's the contents, not the type itself */
void free_InputType(InputType *);

/*
 * EntryFieldClass
 */
typedef struct
{
	/* inherited from VisibleClass */
	OriginalBoxSize BoxSize;
	XYPosition Position;
	bool have_PaletteRef;		/* OPTIONAL */
	ObjectReference PaletteRef;
	/* inherited from InteractibleClass */
	bool HighlightStatus;
	bool InteractionStatus;
	/* inherited from TextClass */
	OctetString TextData;
	MHEGFont Font;
	/* UK MHEG Profile adds these */
	MHEGColour TextColour;
	MHEGColour BackgroundColour;
	MHEGColour HighlightRefColour; /* hmkim : added. */
// part of MHEGFont
//	MHEGFontAttr FontAttributes;
	/* we add this */
	LIST_OF(MHEGTextElement) *element;
	/* EntryFieldClass */
	int EntryPoint; /* hmkim : modified (unsigned int -> int) */
	bool OverwriteMode;
} EntryFieldClassInstanceVars;

typedef struct EntryFieldClass
{
	RootClass rootClass;
	bool have_character_set;	/* OPTIONAL */
	int character_set;
	bool have_background_colour;	/* OPTIONAL */
	Colour background_colour;
	bool have_text_colour;	/* OPTIONAL */
	Colour text_colour;
	bool have_font_attributes;	/* OPTIONAL */
	OctetString font_attributes;
	bool have_highlight_ref_colour;	/* OPTIONAL */
	Colour highlight_ref_colour;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OriginalBoxSize original_box_size;
	XYPosition original_position;	/* DEFAULT {x-position 0, y-position 0} */
	bool have_original_palette_ref;	/* OPTIONAL */
	ObjectReference original_palette_ref;
	bool have_original_font;	/* OPTIONAL */
	FontBody original_font;
	Justification horizontal_justification;	/* DEFAULT start */
	Justification vertical_justification;	/* DEFAULT start */
	LineOrientation line_orientation;	/* DEFAULT horizontal */
	StartCorner start_corner;	/* DEFAULT upper-left */
	bool text_wrapping;	/* DEFAULT false */
	bool engine_resp;	/* DEFAULT true */
	InputType input_type;	/* DEFAULT any */
	bool have_char_list;	/* OPTIONAL */
	OctetString char_list;
	bool obscured_input;	/* DEFAULT false */
	int max_length;	/* DEFAULT 0 */
	/* instance variables */
	EntryFieldClassInstanceVars inst;
} EntryFieldClass;

DEFINE_LIST_OF(EntryFieldClass);

int der_decode_EntryFieldClass(FILE *, EntryFieldClass *, int);
/* only free's the contents, not the type itself */
void free_EntryFieldClass(EntryFieldClass *);

/*
 * HyperTextClass
 */
typedef struct
{
	/* inherited from VisibleClass */
	OriginalBoxSize BoxSize;
	XYPosition Position;
	bool have_PaletteRef;		/* OPTIONAL */
	ObjectReference PaletteRef;
	/* inherited from InteractibleClass */
	bool HighlightStatus;
	bool InteractionStatus;
	/* inherited from TextClass */
	OctetString TextData;
	MHEGFont Font;
	/* UK MHEG Profile adds these */
	MHEGColour TextColour;
	MHEGColour BackgroundColour;
	MHEGColour HighlightRefColour; /* hmkim : added. */
// part of MHEGFont
//	MHEGFontAttr FontAttributes;
	/* we add this */
	LIST_OF(MHEGTextElement) *element;
	/* HyperTextClass */
	OctetString LastAnchorFired;
	/* UK MHEG Profile adds this */
	unsigned int FocusPosition;
} HyperTextClassInstanceVars;

typedef struct HyperTextClass
{
	RootClass rootClass;
	bool have_character_set;	/* OPTIONAL */
	int character_set;
	bool have_background_colour;	/* OPTIONAL */
	Colour background_colour;
	bool have_text_colour;	/* OPTIONAL */
	Colour text_colour;
	bool have_font_attributes;	/* OPTIONAL */
	OctetString font_attributes;
	bool have_highlight_ref_colour;	/* OPTIONAL */
	Colour highlight_ref_colour;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OriginalBoxSize original_box_size;
	XYPosition original_position;	/* DEFAULT {x-position 0, y-position 0} */
	bool have_original_palette_ref;	/* OPTIONAL */
	ObjectReference original_palette_ref;
	bool have_original_font;	/* OPTIONAL */
	FontBody original_font;
	Justification horizontal_justification;	/* DEFAULT start */
	Justification vertical_justification;	/* DEFAULT start */
	LineOrientation line_orientation;	/* DEFAULT horizontal */
	StartCorner start_corner;	/* DEFAULT upper-left */
	bool text_wrapping;	/* DEFAULT false */
	bool engine_resp;	/* DEFAULT true */
	/* instance variables */
	HyperTextClassInstanceVars inst;
} HyperTextClass;

DEFINE_LIST_OF(HyperTextClass);

int der_decode_HyperTextClass(FILE *, HyperTextClass *, int);
/* only free's the contents, not the type itself */
void free_HyperTextClass(HyperTextClass *);

/*
 * Orientation
 */
typedef enum Orientation
{
	Orientation_left = 1,
	Orientation_right = 2,
	Orientation_up = 3,
	Orientation_down = 4,
} Orientation;

DEFINE_LIST_OF(Orientation);

int der_decode_Orientation(FILE *, Orientation *, int);
/* only free's the contents, not the type itself */
void free_Orientation(Orientation *);

/*
 * SliderStyle
 */
typedef enum SliderStyle
{
	SliderStyle_normal = 1,
	SliderStyle_thermometer = 2,
	SliderStyle_proportional = 3,
} SliderStyle;

DEFINE_LIST_OF(SliderStyle);

int der_decode_SliderStyle(FILE *, SliderStyle *, int);
/* only free's the contents, not the type itself */
void free_SliderStyle(SliderStyle *);

/*
 * SliderClass
 */
typedef struct
{
	/* inherited from VisibleClass */
	OriginalBoxSize BoxSize;
	XYPosition Position;
	bool have_PaletteRef;		/* OPTIONAL */
	ObjectReference PaletteRef;
	/* inherited from InteractibleClass */
	bool HighlightStatus;
	bool InteractionStatus;
	/* UK MHEG Profile adds these */ /* hmkim : added. */
	MHEGColour HighlightRefColour;
	MHEGColour SliderRefColour;
	/* SliderClass */
	int SliderValue;
	int Portion;
	/* UK MHEG Profile adds these */
	int MinValue;
	int MaxValue;
	int StepSize;
} SliderClassInstanceVars;

typedef struct SliderClass
{
	RootClass rootClass;
	bool have_highlight_ref_colour;	/* OPTIONAL */
	Colour highlight_ref_colour;
	bool have_slider_ref_colour;	/* OPTIONAL */
	Colour slider_ref_colour;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OriginalBoxSize original_box_size;
	XYPosition original_position;	/* DEFAULT {x-position 0, y-position 0} */
	bool have_original_palette_ref;	/* OPTIONAL */
	ObjectReference original_palette_ref;
	bool engine_resp;	/* DEFAULT true */
	Orientation orientation;
	int max_value;
	int min_value;	/* DEFAULT 1 */
	bool have_initial_value;	/* OPTIONAL */
	int initial_value;
	bool have_initial_portion;	/* OPTIONAL */
	int initial_portion;
	int step_size;	/* DEFAULT 1 */
	SliderStyle slider_style;	/* DEFAULT normal */
	/* instance variables */
	SliderClassInstanceVars inst;
} SliderClass;

DEFINE_LIST_OF(SliderClass);

int der_decode_SliderClass(FILE *, SliderClass *, int);
/* only free's the contents, not the type itself */
void free_SliderClass(SliderClass *);

/*
 * Movement
 */
typedef LIST_OF(int) *Movement;

DEFINE_LIST_OF(Movement);

int der_decode_Movement(FILE *, Movement *, int);
/* only free's the contents, not the type itself */
void free_Movement(Movement *);

/*
 * ActionSlot
 */
typedef struct ActionSlot
{
	unsigned int choice;
	union {
		Null null;	/* choice == 1 */
#define ActionSlot_null 1
		ActionClass action_class;	/* choice == 2 */
#define ActionSlot_action_class 2
	} u;
} ActionSlot;

DEFINE_LIST_OF(ActionSlot);

int der_decode_ActionSlot(FILE *, ActionSlot *, int);
/* only free's the contents, not the type itself */
void free_ActionSlot(ActionSlot *);

/*
 * TokenGroupItem
 */
typedef struct TokenGroupItem
{
	ObjectReference a_visible;
	LIST_OF(ActionSlot) *action_slots;	/* OPTIONAL */
} TokenGroupItem;

DEFINE_LIST_OF(TokenGroupItem);

int der_decode_TokenGroupItem(FILE *, TokenGroupItem *, int);
/* only free's the contents, not the type itself */
void free_TokenGroupItem(TokenGroupItem *);

/*
 * TokenGroupClass
 */
typedef struct
{
	/* inherited from TokenManagerClass */
	unsigned int TokenPosition;
} TokenGroupClassInstanceVars;

typedef struct TokenGroupClass
{
	RootClass rootClass;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	LIST_OF(Movement) *movement_table;	/* OPTIONAL */
	LIST_OF(TokenGroupItem) *token_group_items;	/* OPTIONAL */
	LIST_OF(ActionSlot) *no_token_action_slots;	/* OPTIONAL */
	/* instance variables */
	TokenGroupClassInstanceVars inst;
} TokenGroupClass;

DEFINE_LIST_OF(TokenGroupClass);

int der_decode_TokenGroupClass(FILE *, TokenGroupClass *, int);
/* only free's the contents, not the type itself */
void free_TokenGroupClass(TokenGroupClass *);

/*
 * ListGroupClass
 */
typedef struct
{
	#if 0 // org
	TokenGroupItem item;
	#else // hmkim : modified.
	ObjectReference a_visible;
	#endif
	bool ItemSelectionStatus;
} ListGroupItem;

DEFINE_LIST_OF(ListGroupItem);

typedef struct
{
	/* inherited from TokenManagerClass */
	unsigned int TokenPosition;
	/* ListGroupClass */
	LIST_OF(ListGroupItem) *ItemList;
	unsigned int NumOfItems; /* hmkim : added. */
	unsigned int FirstItem; /* hmkim : modified (int -> unsigned int) */
	unsigned int WindowSize; /* hmkim : added. */
	/* UK MHEG Profile adds this extra variable */
	LIST_OF(XYPosition) *Positions;
} ListGroupClassInstanceVars;

typedef struct ListGroupClass
{
	RootClass rootClass;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	LIST_OF(Movement) *movement_table;	/* OPTIONAL */
	LIST_OF(TokenGroupItem) *token_group_items;	/* OPTIONAL */
	LIST_OF(ActionSlot) *no_token_action_slots;	/* OPTIONAL */
	LIST_OF(XYPosition) *positions;
	bool wrap_around;	/* DEFAULT false */
	bool multiple_selection;	/* DEFAULT false */
	/* instance variables */
	ListGroupClassInstanceVars inst;
} ListGroupClass;

DEFINE_LIST_OF(ListGroupClass);

int der_decode_ListGroupClass(FILE *, ListGroupClass *, int);
/* only free's the contents, not the type itself */
void free_ListGroupClass(ListGroupClass *);

/*
 * GroupItem
 */
typedef struct GroupItem
{
	unsigned int choice;
	union {
		ResidentProgramClass resident_program;	/* choice == 1 */
#define GroupItem_resident_program 1
		RemoteProgramClass remote_program;	/* choice == 2 */
#define GroupItem_remote_program 2
		InterchangedProgramClass interchanged_program;	/* choice == 3 */
#define GroupItem_interchanged_program 3
		PaletteClass palette;	/* choice == 4 */
#define GroupItem_palette 4
		FontClass font;	/* choice == 5 */
#define GroupItem_font 5
		CursorShapeClass cursor_shape;	/* choice == 6 */
#define GroupItem_cursor_shape 6
		BooleanVariableClass boolean_variable;	/* choice == 7 */
#define GroupItem_boolean_variable 7
		IntegerVariableClass integer_variable;	/* choice == 8 */
#define GroupItem_integer_variable 8
		OctetStringVariableClass octet_string_variable;	/* choice == 9 */
#define GroupItem_octet_string_variable 9
		ObjectRefVariableClass object_ref_variable;	/* choice == 10 */
#define GroupItem_object_ref_variable 10
		ContentRefVariableClass content_ref_variable;	/* choice == 11 */
#define GroupItem_content_ref_variable 11
		LinkClass link;	/* choice == 12 */
#define GroupItem_link 12
		StreamClass stream;	/* choice == 13 */
#define GroupItem_stream 13
		BitmapClass bitmap;	/* choice == 14 */
#define GroupItem_bitmap 14
		LineArtClass line_art;	/* choice == 15 */
#define GroupItem_line_art 15
		DynamicLineArtClass dynamic_line_art;	/* choice == 16 */
#define GroupItem_dynamic_line_art 16
		RectangleClass rectangle;	/* choice == 17 */
#define GroupItem_rectangle 17
		HotspotClass hotspot;	/* choice == 18 */
#define GroupItem_hotspot 18
		SwitchButtonClass switch_button;	/* choice == 19 */
#define GroupItem_switch_button 19
		PushButtonClass push_button;	/* choice == 20 */
#define GroupItem_push_button 20
		TextClass text;	/* choice == 21 */
#define GroupItem_text 21
		EntryFieldClass entry_field;	/* choice == 22 */
#define GroupItem_entry_field 22
		HyperTextClass hyper_text;	/* choice == 23 */
#define GroupItem_hyper_text 23
		SliderClass slider;	/* choice == 24 */
#define GroupItem_slider 24
		TokenGroupClass token_group;	/* choice == 25 */
#define GroupItem_token_group 25
		ListGroupClass list_group;	/* choice == 26 */
#define GroupItem_list_group 26
	} u;
} GroupItem;

DEFINE_LIST_OF(GroupItem);

int der_decode_GroupItem(FILE *, GroupItem *, int);
/* only free's the contents, not the type itself */
void free_GroupItem(GroupItem *);

/*
 * DefaultAttribute
 */
typedef struct DefaultAttribute
{
	unsigned int choice;
	union {
		int character_set;	/* choice == 1 */
#define DefaultAttribute_character_set 1
		Colour background_colour;	/* choice == 2 */
#define DefaultAttribute_background_colour 2
		int text_content_hook;	/* choice == 3 */
#define DefaultAttribute_text_content_hook 3
		Colour text_colour;	/* choice == 4 */
#define DefaultAttribute_text_colour 4
		FontBody font;	/* choice == 5 */
#define DefaultAttribute_font 5
		OctetString font_attributes;	/* choice == 6 */
#define DefaultAttribute_font_attributes 6
		int interchanged_program_content_hook;	/* choice == 7 */
#define DefaultAttribute_interchanged_program_content_hook 7
		int stream_content_hook;	/* choice == 8 */
#define DefaultAttribute_stream_content_hook 8
		int bitmap_content_hook;	/* choice == 9 */
#define DefaultAttribute_bitmap_content_hook 9
		int line_art_content_hook;	/* choice == 10 */
#define DefaultAttribute_line_art_content_hook 10
		Colour button_ref_colour;	/* choice == 11 */
#define DefaultAttribute_button_ref_colour 11
		Colour highlight_ref_colour;	/* choice == 12 */
#define DefaultAttribute_highlight_ref_colour 12
		Colour slider_ref_colour;	/* choice == 13 */
#define DefaultAttribute_slider_ref_colour 13
	} u;
} DefaultAttribute;

DEFINE_LIST_OF(DefaultAttribute);

int der_decode_DefaultAttribute(FILE *, DefaultAttribute *, int);
/* only free's the contents, not the type itself */
void free_DefaultAttribute(DefaultAttribute *);

/*
 * ApplicationClass
 */
#include "MHEGTimer.h"

/* so we can do LIST_OF(RootClass *) */
typedef RootClass *RootClassPtr;
DEFINE_LIST_OF(RootClassPtr);

/*
 * UK MHEG Profile moves Timers out of the SceneClass into the GroupClass
 * so now both ApplicationClass and SceneClass get Timers
 */
typedef struct
{
	int id;
	int position;
	bool absolute_time;
	/* we add this */
	MHEGTimer mheg_id;
} Timer;

DEFINE_LIST_OF(Timer);

typedef struct
{
	/* inherited from GroupClass */
	unsigned int GroupCachePriority;
	LIST_OF(Timer) *Timers;
	/* we add these */
	LIST_OF(MHEGTimer) *removed_timers;
	struct timeval start_time;
	/* ApplicationClass */
	unsigned int LockCount;
	LIST_OF(RootClassPtr) *DisplayStack;	/* tail is on top */
	/* we add where to start searching for unused object numbers for clones */
	unsigned int next_clone;
} ApplicationClassInstanceVars;

typedef struct ApplicationClass
{
	RootClass rootClass;
	bool have_standard_identifier;	/* OPTIONAL */
	StandardIdentifier standard_identifier;
	bool have_standard_version;	/* OPTIONAL */
	unsigned int standard_version;
	bool have_object_information;	/* OPTIONAL */
	OctetString object_information;
	bool have_on_start_up;	/* OPTIONAL */
	ActionClass on_start_up;
	bool have_on_close_down;	/* OPTIONAL */
	ActionClass on_close_down;
	unsigned int original_group_cache_priority;	/* DEFAULT 127 */
	LIST_OF(GroupItem) *items;	/* OPTIONAL */
	bool have_on_spawn_close_down;	/* OPTIONAL */
	ActionClass on_spawn_close_down;
	bool have_on_restart;	/* OPTIONAL */
	ActionClass on_restart;
	LIST_OF(DefaultAttribute) *default_attributes;	/* OPTIONAL */
	/* instance variables */
	ApplicationClassInstanceVars inst;
} ApplicationClass;

DEFINE_LIST_OF(ApplicationClass);

int der_decode_ApplicationClass(FILE *, ApplicationClass *, int);
/* only free's the contents, not the type itself */
void free_ApplicationClass(ApplicationClass *);

/*
 * SceneCoordinateSystem
 */
typedef struct SceneCoordinateSystem
{
	int x_scene;
	int y_scene;
} SceneCoordinateSystem;

DEFINE_LIST_OF(SceneCoordinateSystem);

int der_decode_SceneCoordinateSystem(FILE *, SceneCoordinateSystem *, int);
/* only free's the contents, not the type itself */
void free_SceneCoordinateSystem(SceneCoordinateSystem *);

/*
 * AspectRatio
 */
typedef struct AspectRatio
{
	int width;
	int height;
} AspectRatio;

DEFINE_LIST_OF(AspectRatio);

int der_decode_AspectRatio(FILE *, AspectRatio *, int);
/* only free's the contents, not the type itself */
void free_AspectRatio(AspectRatio *);

/*
 * NextScene
 */
typedef struct NextScene
{
	OctetString scene_ref;
	unsigned int scene_weight;
} NextScene;

DEFINE_LIST_OF(NextScene);

int der_decode_NextScene(FILE *, NextScene *, int);
/* only free's the contents, not the type itself */
void free_NextScene(NextScene *);

/*
 * SceneClass
 */
typedef struct
{
	/* inherited from GroupClass */
	unsigned int GroupCachePriority;
	LIST_OF(Timer) *Timers;
	/* we add these */
	LIST_OF(MHEGTimer) *removed_timers;
	struct timeval start_time;
	/* we add where to start searching for unused object numbers for clones */
	unsigned int next_clone;
} SceneClassInstanceVars;

typedef struct SceneClass
{
	RootClass rootClass;
	bool have_standard_identifier;	/* OPTIONAL */
	StandardIdentifier standard_identifier;
	bool have_standard_version;	/* OPTIONAL */
	unsigned int standard_version;
	bool have_object_information;	/* OPTIONAL */
	OctetString object_information;
	bool have_on_start_up;	/* OPTIONAL */
	ActionClass on_start_up;
	bool have_on_close_down;	/* OPTIONAL */
	ActionClass on_close_down;
	unsigned int original_group_cache_priority;	/* DEFAULT 127 */
	LIST_OF(GroupItem) *items;	/* OPTIONAL */
	int input_event_register;
	SceneCoordinateSystem scene_coordinate_system;
	bool have_aspect_ratio;	/* OPTIONAL */
	AspectRatio aspect_ratio;
	bool moving_cursor;	/* DEFAULT false */
	LIST_OF(NextScene) *next_scenes;	/* OPTIONAL */
	bool have_input_event_mask;	/* OPTIONAL */
	OctetString input_event_mask;
	/* instance variables */
	SceneClassInstanceVars inst;
} SceneClass;

DEFINE_LIST_OF(SceneClass);

int der_decode_SceneClass(FILE *, SceneClass *, int);
/* only free's the contents, not the type itself */
void free_SceneClass(SceneClass *);

/*
 * InterchangedObject
 */
typedef struct InterchangedObject
{
	unsigned int choice;
	union {
		ApplicationClass application;	/* choice == 1 */
#define InterchangedObject_application 1
		SceneClass scene;	/* choice == 2 */
#define InterchangedObject_scene 2
	} u;
} InterchangedObject;

DEFINE_LIST_OF(InterchangedObject);

int der_decode_InterchangedObject(FILE *, InterchangedObject *, int);
/* only free's the contents, not the type itself */
void free_InterchangedObject(InterchangedObject *);

/*
 * GroupClass
 */
typedef struct GroupClass
{
	RootClass rootClass;
	bool have_standard_identifier;	/* OPTIONAL */
	StandardIdentifier standard_identifier;
	bool have_standard_version;	/* OPTIONAL */
	unsigned int standard_version;
	bool have_object_information;	/* OPTIONAL */
	OctetString object_information;
	bool have_on_start_up;	/* OPTIONAL */
	ActionClass on_start_up;
	bool have_on_close_down;	/* OPTIONAL */
	ActionClass on_close_down;
	unsigned int original_group_cache_priority;	/* DEFAULT 127 */
	LIST_OF(GroupItem) *items;	/* OPTIONAL */
} GroupClass;

DEFINE_LIST_OF(GroupClass);

int der_decode_GroupClass(FILE *, GroupClass *, int);
/* only free's the contents, not the type itself */
void free_GroupClass(GroupClass *);

/*
 * TokenManagerClass
 */
typedef struct TokenManagerClass
{
	LIST_OF(Movement) *movement_table;	/* OPTIONAL */
} TokenManagerClass;

DEFINE_LIST_OF(TokenManagerClass);

int der_decode_TokenManagerClass(FILE *, TokenManagerClass *, int);
/* only free's the contents, not the type itself */
void free_TokenManagerClass(TokenManagerClass *);

/*
 * VisibleClass
 */
typedef struct VisibleClass
{
	RootClass rootClass;
	bool initially_active;	/* DEFAULT true */
	bool have_content_hook;	/* OPTIONAL */
	int content_hook;
	bool have_original_content;	/* OPTIONAL */
	ContentBody original_content;
	bool have_shared;	/* OPTIONAL */
	bool shared;
	OriginalBoxSize original_box_size;
	XYPosition original_position;	/* DEFAULT {x-position 0, y-position 0} */
	bool have_original_palette_ref;	/* OPTIONAL */
	ObjectReference original_palette_ref;
} VisibleClass;

DEFINE_LIST_OF(VisibleClass);

int der_decode_VisibleClass(FILE *, VisibleClass *, int);
/* only free's the contents, not the type itself */
void free_VisibleClass(VisibleClass *);

/*
 * InteractibleClass
 */
typedef struct InteractibleClass
{
	bool have_highlight_ref_colour;	/* OPTIONAL */
	Colour highlight_ref_colour;
	bool engine_resp;	/* DEFAULT true */
} InteractibleClass;

DEFINE_LIST_OF(InteractibleClass);

int der_decode_InteractibleClass(FILE *, InteractibleClass *, int);
/* only free's the contents, not the type itself */
void free_InteractibleClass(InteractibleClass *);

#endif	/* __ISO13522_MHEG_5_H__ */

