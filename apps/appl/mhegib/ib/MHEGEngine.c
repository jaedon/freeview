/*
 * MHEGEngine.c
 */

#if !defined(WIN32)
#include <unistd.h>
#endif
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#if !defined(WIN32)
#include <stdbool.h>
#endif
#include <string.h>
#include <limits.h>
#include <errno.h>
#if !defined(WIN32)
#include <sys/time.h>
#endif
#include <png.h>
#include <ondk.h>
#include <hlib.h>
#include 	<directfb.h>

#include "MHEGEngine.h"
#include "RootClass.h"
#include "LinkClass.h"
#include "EventType.h"
#include "ElementaryAction.h"
#include "Reference.h"
#include "Generic.h"
#include "GroupItem.h"
#include "ApplicationClass.h"
#include "SceneClass.h"
#include "VisibleClass.h"
#include "ResidentProgramClass.h"
#include "SliderClass.h"
#include "EntryFieldClass.h"
#include "HyperTextClass.h"
#include "si.h"
#include "clone.h"
#include "utils.h"

#include "adaptation.h"

////////////////////////////////////////////////////////////////////////////////////////////////////

#define ___MHEGIB_DEF___

/* default time to poll for missing content before generating a ContentRefError (seconds) */
#define MISSING_CONTENT_TIMEOUT			30

/* EngineEvent EventTag values */
/* 0 and 1 are reserved */
#define EngineEvent_GroupIDRefError		2
#define EngineEvent_ContentRefError		3
#define EngineEvent_TextKeyFunction		4
/* 5 is reserved */
#define EngineEvent_VideoPrefChanged	6 /* CI+ MHEG Profile 에선 필요치 않다 */
#define EngineEvent_PauseResume			7
/* 8 is reserved */
#define EngineEvent_NetworkBootInfo		9 /* CI+ MHEG Profile 에선 필요치 않다 */
/* 10-15 are reserved */
#define EngineEvent_CancelKeyFunction	16
/* 17-99 are reserved */
#define EngineEvent_RedKeyFunction		100
#define EngineEvent_GreenKeyFunction	101
#define EngineEvent_YellowKeyFunction	102
#define EngineEvent_BlueKeyFunction		103
/* from the NZ profile */
#define EngineEvent_EPGKeyFunction		300
/* all other values are reserved */

#define CI_AMMI_APP_DOMAIN_ID	"CIMHEGP1"	/* (0x43494d4845475031) */ /* CI Application Domain ("CIEngineProfile1") Identifier */
#define UK_AMMI_APP_DOMAIN_ID	"UKMHEGP1"	/* (0x554B4D4845475031) */ /* UK Application Domain ("UK Profile 1 MHEG-5") Identifier */

/* a list of files we are waiting for, and the objects that want them */
typedef struct
{
	RootClass *obj;
	MHEGFileObject file; // hmkim : modified. org is OctetString file;
	time_t requested;	/* when we first asked for the file (used to timeout requests) */
	time_t received; // hmkim : added (메모리 관리 정책에 사용하기 위한 용도로 추가함)
} MissingContent;

typedef MissingContent ReceivedContent;

DEFINE_LIST_OF(MissingContent);
DEFINE_LIST_OF(ReceivedContent);

/*
 * asynchronous events list
 * these are events generated by objects while processing an action
 * async events are processed when the action has finished
 * rather than at the time they are generated (like synchronous events)
 */
typedef struct
{
	ExternalReference src;
	EventType type;
	EventData *data;
} MHEGAsyncEvent;

DEFINE_LIST_OF(MHEGAsyncEvent);

/* a list of actions that need performing */
typedef struct
{
	ExternalReference *ref; // hmkim : org is OctetString *group_id;		/* group identifier of the object that caused this action */
	ElementaryAction *action;	/* the action */
} MHEGAction;

DEFINE_LIST_OF(MHEGAction);

/* a list of active links */
typedef LinkClass *LinkClassPtr;

DEFINE_LIST_OF(LinkClassPtr);

/* cmd line options */
typedef struct
{
	MHEGBackendMode backend_mode;
	char *srg_loc;		/* service gateway location: directory for local; host[:port] for remote */
	MHEGFileObject init_obj;
	int network_id;		/* Network ID for local backends, used to resolve MHEG_REC_SVC_DEF (<0 => leave it blank) */
#if 0 // hmkim : commented out (StreamPlayer : CI+ MHEG Profile 에선 불필요. UK MHEG Profile 을 위해서는 추가 작업 필요함!)
	char *audio_dev;	/* ALSA audio device name */
	char *vo_method;	/* MHEGVideoOutputMethod name (NULL for default) */
#endif
	bool av_disabled;	/* true => audio and video output totally disabled */
} MHEGEngineOptions;

/* status for MHEG internal browser */
typedef enum
{
	MHEGEngine_Not_Initialized = 0,
	MHEGEngine_Initialized = 1,
	MHEGEngine_Running = 2, // MHEG engine 에 메시지를 날릴 수 있는 유일한 상태다!
	MHEGEngine_Paused = 3,
	MHEGEngine_Finished = 0
} MHEGEngineStatus;

/* engine state */
typedef struct
{
	MHEGEngineStatus status;
	MHEGDisplay display;				/* make porting easier */
#if 0 // hmkim : commented out (StreamPlayer : CI+ MHEG Profile 에선 불필요. UK MHEG Profile 을 위해서는 추가 작업 필요함!)
	char *audio_dev;				/* audio device name */
	MHEGVideoOutputMethod *vo_method;		/* video output method (resolved from name given in MHEGEngineOptions) */
#endif
	bool av_disabled;				/* true => video and audio output totally disabled */
	MHEGBackend backend;				/* local or remote access to DSMCC carousel and MPEG streams */
	MHEGApp active_app;				/* application we are currently running */
	QuitReason quit_reason;				/* do we need to stop the current app */
	OctetString quit_data;				/* new app to Launch or Spawn, or channel to Retune to */
	OctetString *der_object;			/* DER object we are currently decoding */
	LIST_OF(RootClassPtr) *objects;			/* all currently loaded MHEG objects */
	LIST_OF(MissingContent) *missing_content;	/* files we are waiting for */ /* missing content list 에 대한 접근은 MHEGEngine_enterCriticalMissingContent ~ MHEGEngine_leaveCriticalMissingContent 로 보호되어야 한다! */
	LIST_OF(ReceivedContent) *temp_content;		/* 수신된 missing content 는 missing content list 로부터 임시로 이곳으로 옮겨지고, */
	LIST_OF(ReceivedContent) *received_content;	/* 최종적으로 이곳이나 */
	LIST_OF(ReceivedContent) *received_bitmap;	/* 이곳으로 옮겨진다. BitmapClass 데이터인 경우엔 크기가 크므로 별도의 메모리 관리를 위해 따로 관리한다. */
	LIST_OF(LinkClassPtr) *active_links;		/* currently active LinkClass objects */
	LIST_OF(MHEGAsyncEvent) *async_eventq;		/* asynchronous events that need processing */
	LIST_OF(MHEGAction) *main_actionq;		/* UK MHEG Profile event processing method */
	LIST_OF(MHEGAction) *temp_actionq;		/* UK MHEG Profile event processing method */
	LIST_OF(PersistentData) *persistent;		/* persistent files */
} MHEGEngine;

/*
 * rather than passing a ptr to this to every function we write
 * let's be naughty and make it global (to this file)
 */
static MHEGEngine engine = {MHEGEngine_Not_Initialized, };

/* message queue id for MHEG internal browser */
static unsigned long s_ulMhegIbMainMsgQId = 0;
static unsigned long s_ulMhegIbRunningMsgQId = 0;

/* task id for MHEG internal browser */
static unsigned long s_ulMhegIbTaskId = 0;

/* semaphore for missing content list */
unsigned long g_ulMhegIbMissingContentSemId = 0;

/* main message types for MHEG internal browser */
typedef enum
{
	MHEGIB_MAIN_MSG_AMMI_REQ_START,
	MHEGIB_MAIN_MSG_AMMI_REQ_START_ACK,
	// TODO : DSM ...
	MHEGIB_MAIN_MSG_MAX
} MHEGIB_MAIN_MSG_TYPE;

/* main message body for MHEG internal browser */
typedef struct
{
	MHEGIB_MAIN_MSG_TYPE	enMsgType;
} MHEGIB_MAIN_MSG;

/* running message types for MHEG internal browser (IB 내부용) */
typedef enum
{
	MHEGIB_RUN_MSG_MISSING_CONTENT_RECEIVED = 1,
	MHEGIB_RUN_MSG_ASYNC_EVENT_GENERATED,
	MHEGIB_RUN_MSG_QUIT_EVENT_GENERATED,
	MHEGIB_RUN_MSG_KEY_DOWN,
	MHEGIB_RUN_MSG_MAX
} MHEGIB_RUN_MSG_TYPE;

/* running message body for MHEG internal browser */
typedef struct
{
	HINT32	lMessage; /* MHEGIB_RUN_MSG_TYPE */
	HINT32	lparam1;
	HINT32	lparam2;
	HINT32	lparam3;
} MHEGIB_RUN_MSG;

/* context for CI Application MMI */
typedef struct
{
	unsigned short			usSessionId;
	unsigned char 			ucInitialObjectName[256]; // PATH_MAX
	unsigned long			ulInitialObjectDataLen;
	unsigned char * 		pucInitialObjectData;
} MHEGIB_AMMI_CONTEXT;

static MHEGIB_AMMI_CONTEXT s_stMhegIbAmmiContext;

////////////////////////////////////////////////////////////////////////////////////////////////////

#define ___MHEGIB_PROTOTYPES___

static bool MHEGEngine_keyPressed(unsigned int, bool);
static void MHEGEngine_processMHEGEvents(void);
static void MHEGEngine_processNextAsyncEvent(void);

static HERROR local_MHEGIB_SendMessage(HINT32 lMessage, HINT32 lParam1, HINT32 lParam2, HINT32 lParam3);

////////////////////////////////////////////////////////////////////////////////////////////////////

#define ___MHEGIB_FUNCTIONS___

static LIST_TYPE(MissingContent) *
new_MissingContentListItem(RootClass *obj, OctetString *file)
{
	LIST_TYPE(MissingContent) *missing;
	struct timeval now;

	missing = safe_mallocz(sizeof(LIST_TYPE(MissingContent)));

	missing->item.obj = obj;

	/* copy the filename */
	#if 0 // org
	OctetString_dup(&missing->item.file.name, file);
	#else // hmkim : modified (missing content 파일명은 absolute file name 으로 저장하도록 한다)
	{
		if (MHEGEngine_isNotAbsoluteFilename(file))
		{
			char *absolute = MHEGEngine_absoluteFilename(file);
			OctetString tmp;
			if(absolute)
			{
				tmp.size = strlen(absolute)/*+1*/;
				tmp.data = safe_malloc(tmp.size);
				if(tmp.data!=NULL)
				{
					VK_memcpy(tmp.data, absolute, tmp.size);
					OctetString_dup(&missing->item.file.name, &tmp);
					safe_free(tmp.data);
				}
			}
		}
		else
		{
			OctetString_dup(&missing->item.file.name, file);
		}
	}
	#endif

	/* current time */
	gettimeofday(&now, NULL);
	missing->item.requested = now.tv_sec;

	return missing;
}

static void
free_MissingContentListItem(LIST_TYPE(MissingContent) *missing)
{
	verbose("MissingContent: '%.*s' free (%s)", missing->item.file.name.size, missing->item.file.name.data, MHEGEngine_RTTI_name(missing->item.obj->inst.rtti));

	/* assert */
	if (missing->item.file.content.size || missing->item.file.content.data)
	{
		error("MissingContent: '%.*s' has data (%d)", missing->item.file.name.size, missing->item.file.name.data, missing->item.file.content.size); // 이런 에러가 난다면 뭔가 코딩 오류이겠지... 디버깅 필요!!
	}

	/* free the filename we copied */
	safe_free(missing->item.file.name.data);

	safe_free(missing->item.file.content.data); // 사실상 이건 불필요하지만 만약을 위해 넣어둔다.

	safe_free(missing);

	return;
}

static void
free_ReceivedContentListItem(LIST_TYPE(ReceivedContent) *received)
{
	verbose("ReceivedContent: '%.*s' free", received->item.file.name.size, received->item.file.name.data); /* 새로운 Scene 이 로드되면 obj 가 가리키는 메모리는 더이상 유효하지 않으므로 찍지 않는다. */

	/* assert */
	if (received->item.file.content.size == 0 || received->item.file.content.data == NULL)
	{
		error("ReceivedContent: '%.*s' has no data (%d)", received->item.file.name.size, received->item.file.name.data, received->item.file.content.size); // 이런 에러가 난다면 뭔가 코딩 오류이겠지... 디버깅 필요!!
	}

	/* free the filename we copied */
	safe_free(received->item.file.name.data);

	safe_free(received->item.file.content.data);

	safe_free(received);

	return;
}

static LIST_TYPE(PersistentData) *
new_PersistentDataListItem(OctetString *filename)
{
	LIST_TYPE(PersistentData) *p;

	p = safe_mallocz(sizeof(LIST_TYPE(PersistentData)));

	OctetString_dup(&p->item.filename, filename);

	p->item.data = NULL;

	return p;
}

static void
free_PersistentDataListItem(LIST_TYPE(PersistentData) *p)
{
	safe_free(p->item.filename.data);

	LIST_FREE_ITEMS(&p->item.data, OriginalValue, free_OriginalValue, safe_free);

	safe_free(p);

	return;
}

static LIST_TYPE(MHEGAsyncEvent) *
new_MHEGAsyncEventListItem(ExternalReference *src, EventType type, EventData *data)
{
	LIST_TYPE(MHEGAsyncEvent) *event;

	event = safe_mallocz(sizeof(LIST_TYPE(MHEGAsyncEvent)));

	/* take a copy of the source in case it disappears before we process the event */
	ExternalReference_dup(&event->item.src, src);

	/* remember the type */
	event->item.type = type;

	/* take a copy of the data in case it disappears before we process the event */
	if(data != NULL)
	{
		event->item.data = safe_malloc(sizeof(EventData));
		EventData_dup(event->item.data, data);
	}
	else
	{
		event->item.data = NULL;
	}

	return event;
}

static void
free_MHEGAsyncEventListItem(LIST_TYPE(MHEGAsyncEvent) *event)
{
	/* free the source */
	safe_free(event->item.src.group_identifier.data);

	/* free any event data */
	if(event->item.data != NULL)
	{
		free_EventData(event->item.data);
		safe_free(event->item.data);
	}

	safe_free(event);

	return;
}

/*
 * the group ID and action must remain valid until we execute the action
 */

static LIST_TYPE(MHEGAction) *
new_MHEGActionListItem(ExternalReference *ref, ElementaryAction *action) // hmkim : org is new_MHEGActionListItem(OctetString *group_id, ElementaryAction *action)
{
	LIST_TYPE(MHEGAction) *item;

	item = safe_malloc(sizeof(LIST_TYPE(MHEGAction)));

	item->item.ref = ref; // hmkim : org is item->item.group_id = group_id;
	item->item.action = action;

	return item;
}

static void
free_MHEGActionListItem(LIST_TYPE(MHEGAction) *item)
{
	safe_free(item);

	return;
}

bool
MHEGEngine_started(void) /* 외부에서 엔진을 구동하기 전에 엔진이 구동된 상태인지를 판단하기 위한 용도 */
{
	return (engine.status) ? true : false;
}

bool
MHEGEngine_running(void) /* 외부에서 엔진에 메시지를 전달하기 전에 엔진이 메시지 수신 가능한 상태인지를 판단하기 위한 용도 */
{
	return (engine.status == MHEGEngine_Running) ? true : false;
}

static int
MHEGEngine_init(MHEGEngineOptions *opts)
{
	VK_memset(&engine, 0x00, sizeof(MHEGEngine));

	if (MHEGDisplay_init(&engine.display))
		return -1;

	// create ib proc
	MHEGIB_CreateAppl();

#if 0 // hmkim : commented out (StreamPlayer : CI+ MHEG Profile 에선 불필요. UK MHEG Profile 을 위해서는 추가 작업 필요함!)
	if (opts->av_disabled)
	{
		engine.audio_dev = NULL;
		engine.vo_method = NULL;
	}
	else
	{
		engine.audio_dev = safe_strdup(opts->audio_dev);
		engine.vo_method = MHEGVideoOutputMethod_fromString(opts->vo_method);
	}
#endif

	engine.av_disabled = opts->av_disabled;

	if (MHEGBackend_init(&engine.backend, opts->backend_mode, opts->srg_loc, &opts->init_obj, opts->network_id))
		return -1;

	if (MHEGApp_init(&engine.active_app))
		return -1;

	engine.status = MHEGEngine_Initialized;

	return 0;
}

static int
MHEGEngine_run(void)
{
	#if 1 // hmkim : added for ApplicationStacking.
	/* UK MHEG Profile (D-BOOK 5.0) : To support application stacking receivers shall implement an application identifier stack capable of holding references to 5 applications. */
	/* TODO : 임시 구현. 제대로 된 구현을 하려면 타입이 OctetString 이 아니라 ApplicationClass 이어야 하고 MHEGApp_loadApplication() 을 재수행할 필요가 없어야 한다! */
	#define NUM_APP_STACK 10
	static OctetString app_stack[NUM_APP_STACK] = {{0, NULL}, };
	static bool app_spawned[NUM_APP_STACK] = {false,};
	static unsigned int app_stacking = 0;
	#endif

	OctetString boot_obj;
	ApplicationClass *app;
	SceneClass *scene;
	bool block;

	MHEGIB_RUN_MSG stRunMsg;

	unsigned int i;

	#if 0 // hmkim : commented out.
	bool found;
	struct timeval start;
	struct timeval now;
	/* search order for the app to boot in the Service Gateway dir */
	char *boot_order[] = { "~//a", "~//startup", "~//startup_vod", NULL };
	#endif

	engine.quit_reason = QuitReason_DontQuit;

	do
	{
		/* clear the display (if you want a splash screen, do it here) */
		MHEGDisplay_clearScreen(&engine.display);

		#if 0 // org
		/* search for the boot object for timeout seconds */
		found = false;
		gettimeofday(&start, NULL);
		do
		{
			for(i=0; !found && boot_order[i] != NULL; i++)
			{
				boot_obj.size = strlen(boot_order[i]);
				boot_obj.data = (unsigned char *) boot_order[i];
				found = MHEGEngine_checkContentRef(&boot_obj);
			}
			gettimeofday(&now, NULL);
		}
		while(!found && now.tv_sec <= (start.tv_sec + engine.timeout));
		if(!found)
		{
			error("Unable to find boot object in service gateway");
			return -1;
		}
		#else // hmkim : modified.
		boot_obj.size = engine.backend.init_obj.name.size;
		boot_obj.data = engine.backend.init_obj.name.data;
		#endif

		do
		{
			/* boot it */
			verbose("Booting '%.*s' (AppStacking = %d)", boot_obj.size, boot_obj.data, app_stacking);

			/* load the app */
			if((engine.quit_reason == QuitReason_Launch || engine.quit_reason == QuitReason_Spawn)	/* 현재 구현에서 정상적인 플로우 */
				|| ((app = MHEGApp_loadApplication(&engine.active_app, &boot_obj)) == NULL))		/* 이런 경우엔 원인 분석 필요함! */
			{
				#if 1 // hmkim : added (Scene 에서 Application 을 Launch or Spawn 하는 상황에 대한 임시 구현).
				char *ext_fn;
				int ext_fn_len;

				ext_fn = MHEGEngine_externalFilename(&boot_obj);
				ext_fn_len = strlen(ext_fn);

				if(ext_fn_len > 5 // 뒤에 최소 1자 이상의 이름이 있는지 체크하기 위해 >= 가 아니라 > 로 확인한다.
					&& strncmp((char *) ext_fn, MHEG_SRG_LOC_CI, 5) == 0)
				{
					VK_memset(s_stMhegIbAmmiContext.ucInitialObjectName, 0, 256); // PATH_MAX
					VK_memcpy(s_stMhegIbAmmiContext.ucInitialObjectName, ext_fn, ext_fn_len);

					//ycgo_Hx_Print
					HxLOG_Print("MHEGEngine run\n");
					if (s_stMhegIbAmmiContext.usSessionId == 0 || MHEGIB_FileRequst(s_stMhegIbAmmiContext.usSessionId, eMhegIb_Ad_ReqType_File, ext_fn, ext_fn_len))
					{
						error("CI_RequestFileorData (%d, %s) failed", s_stMhegIbAmmiContext.usSessionId, ext_fn);
					}
				}
				else if(ext_fn_len > 6 // 뒤에 최소 1자 이상의 이름이 있는지 체크하기 위해 >= 가 아니라 > 로 확인한다.
					&& strncmp((char *) ext_fn, MHEG_SRG_LOC_DSM, 6) == 0)
				{
					verbose_todo("%s; DSM:", __FUNCTION__);
				}
				else
				{
					error("'%.*s' can't be requested", boot_obj.size, boot_obj.data);
				}
				#endif

				return -1;
			}

			#if 1 // hmkim : added for ApplicationStacking.
			if (app_stacking == 0)
			{
				for (i = 0; i < NUM_APP_STACK; i++)
				{
					free_OctetString(&app_stack[i]);
					app_spawned[i] = false;
				}
				OctetString_copy(&app_stack[0], &boot_obj);
				app_stacking = 1;
			}
			#endif

			/* main loop start : set status */
			verbose("Main loop start '%.*s'", boot_obj.size, boot_obj.data);
			engine.status = MHEGEngine_Running; // this should be done before ApplicationClass_Preparation() and ApplicationClass_Activation()
			engine.quit_reason = QuitReason_DontQuit;

			/* start it up */
			ApplicationClass_Preparation(app);
			ApplicationClass_Activation(app);

			while(engine.quit_reason == QuitReason_DontQuit)
			{
				if (VK_MSG_Receive(s_ulMhegIbRunningMsgQId, &stRunMsg, sizeof(MHEGIB_RUN_MSG)) != VK_OK)
				{
					error("VK_MSG_Receive() failed");
					continue;
				}

				switch (stRunMsg.lMessage)
				{
					case MHEGIB_RUN_MSG_MISSING_CONTENT_RECEIVED:
						verbose_misc("ReceiveMessage: MissingContent");
						/* poll for files we are waiting for */
						MHEGEngine_pollMissingContent(true);
						break;

					case MHEGIB_RUN_MSG_ASYNC_EVENT_GENERATED:
						verbose_misc("ReceiveMessage: AsyncEvent (%d %s)", stRunMsg.lparam1, EventType_name(stRunMsg.lparam2));
						/* process any async events */
						MHEGEngine_processMHEGEvents();
						break;

					case MHEGIB_RUN_MSG_QUIT_EVENT_GENERATED:
						verbose_misc("ReceiveMessage: QuitEvent (%d)", stRunMsg.lparam1);
						break;

					case MHEGIB_RUN_MSG_KEY_DOWN:
						verbose_misc("ReceiveMessage: Key (%d)", stRunMsg.lparam1);
						/*
						 * if we are polling for missing content,
						 * or if we need to quit the current app
						 * don't block waiting for the next GUI event
						 */
						block = (engine.missing_content == NULL && engine.quit_reason == QuitReason_DontQuit);
						/* process any GUI events */
						if (MHEGEngine_keyPressed(stRunMsg.lparam1, block))
							engine.quit_reason = QuitReason_QuitByGUI;
						break;

					default:
						error("Invalid Message (%d)", stRunMsg.lMessage);
						break;
				}
			}

			/* main loop end : set status */
			engine.status = MHEGEngine_Paused;
			verbose("Main loop end '%.*s'", boot_obj.size, boot_obj.data);

			/* clear message queue */
			if (VK_MSG_Clear(s_ulMhegIbRunningMsgQId) != VK_OK)
				error("VK_MSG_Clear() failed");

			/* do Destruction of Application and Scene */
			if((scene = MHEGEngine_getActiveScene()) != NULL)
			{
				verbose("Deactivation and Destruction on %s", ExternalReference_name(&scene->rootClass.inst.ref));
				SceneClass_Deactivation(scene);
				SceneClass_Destruction(scene);
			}
			ApplicationClass_Deactivation(app);
			ApplicationClass_Destruction(app);

			/* clean up */
			#ifdef DEBUG_ENGINE
			MHEGEngine_print();
			#endif
			MHEGApp_fini(&engine.active_app);
			LIST_FREE(&engine.objects, RootClassPtr, safe_free);
			LIST_FREE(&engine.missing_content, MissingContent, free_MissingContentListItem);
			LIST_FREE(&engine.temp_content, ReceivedContent, free_ReceivedContentListItem);
			LIST_FREE(&engine.received_content, ReceivedContent, free_ReceivedContentListItem);
			LIST_FREE(&engine.received_bitmap, ReceivedContent, free_ReceivedContentListItem);
			LIST_FREE(&engine.active_links, LinkClassPtr, safe_free);
			LIST_FREE(&engine.async_eventq, MHEGAsyncEvent, free_MHEGAsyncEventListItem);
			LIST_FREE(&engine.main_actionq, MHEGAction, free_MHEGActionListItem);
			LIST_FREE(&engine.temp_actionq, MHEGAction, free_MHEGActionListItem);

			/* do we need to run a new app */
			switch(engine.quit_reason)
			{
			case QuitReason_Launch:
				verbose("Launch '%.*s' (AppStacking = %d)", engine.quit_data.size, engine.quit_data.data, app_stacking);
				boot_obj.size = engine.quit_data.size;
				boot_obj.data = engine.quit_data.data;
				#if 1 // hmkim : added for ApplicationStacking.
				{
					for (i = 0; i < NUM_APP_STACK; i++)
					{
						if (app_spawned[i])
						{
							free_OctetString(&app_stack[i]);
							app_spawned[i] = false;
							app_stacking--;
						}
					}
				}
				if (app_stacking < NUM_APP_STACK)
				{
					OctetString_copy(&app_stack[app_stacking], &boot_obj);
					app_spawned[app_stacking] = false;
					app_stacking++;
				}
				else // if (app_stacking == NUM_APP_STACK)
				{
					for (i = 0; i < NUM_APP_STACK - 1; i++)
						OctetString_copy(&app_stack[i], &app_stack[i+1]);
					OctetString_copy(&app_stack[i], &boot_obj);
					app_spawned[i] = false;
				}
				#endif
				break;

			case QuitReason_Spawn:
				verbose("Spawn '%.*s' (AppStacking = %d)", engine.quit_data.size, engine.quit_data.data, app_stacking);
				verbose_todo("%s; Spawn '%.*s'; doing Launch instead", __FUNCTION__, engine.quit_data.size, engine.quit_data.data); /* need to run on_restart and on_spawn_close_down Actions at some point */
				boot_obj.size = engine.quit_data.size;
				boot_obj.data = engine.quit_data.data;
				#if 1 // hmkim : added for ApplicationStacking.
				if (app_stacking < NUM_APP_STACK)
				{
					OctetString_copy(&app_stack[app_stacking], &boot_obj);
					app_spawned[app_stacking] = true;
					app_stacking++;
				}
				else // if (app_stacking == NUM_APP_STACK)
				{
					for (i = 0; i < NUM_APP_STACK - 1; i++)
						OctetString_copy(&app_stack[i], &app_stack[i+1]);
					OctetString_copy(&app_stack[i], &boot_obj);
					app_spawned[i] = true;
				}
				#endif
				break;

			case QuitReason_Retune:
				verbose("Retune to '%.*s'", engine.quit_data.size, engine.quit_data.data);
				MHEGEngine_retune(&engine.quit_data);
				break;

			default:
				#if 0 // org
				verbose("Quit (%d)", engine.quit_reason);
				/* nothing to do */
				#else // hmkim : modified for ApplicationStacking.
				verbose("Quit (QuitReason = %d, AppStacking = %d)", engine.quit_reason, app_stacking);
				if (engine.quit_reason == QuitReason_QuitByApp && app_stacking > 1)
				{
					app_stacking--;
					free_OctetString(&app_stack[app_stacking]);
					app_spawned[app_stacking] = false;
					boot_obj.size = app_stack[app_stacking-1].size;
					boot_obj.data = app_stack[app_stacking-1].data;
					engine.quit_reason = QuitReason_Launch; // or QuitReason_Spawn
				}
				else
				{
					for (i = 0; i < NUM_APP_STACK; i++)
					{
						free_OctetString(&app_stack[i]);
						app_spawned[i] = false;
					}
					app_stacking = 0;
				}
				#endif
				break;
			}
		}
		while(engine.quit_reason == QuitReason_Launch || engine.quit_reason == QuitReason_Spawn);
	}
	while(engine.quit_reason == QuitReason_Retune);

	return 0;
}

static int
MHEGEngine_fini(void)
{
	// destroy ib proc
	MHEGIB_DestroyAppl();

	MHEGDisplay_fini(&engine.display);

#if 0 // hmkim : commented out (StreamPlayer : CI+ MHEG Profile 에선 불필요. UK MHEG Profile 을 위해서는 추가 작업 필요함!)
	safe_free(engine.audio_dev);
#endif

	LIST_FREE(&engine.persistent, PersistentData, free_PersistentDataListItem);

	si_free();

	MHEGBackend_fini(&engine.backend);

	free_OctetString(&engine.quit_data);

	engine.status = MHEGEngine_Finished;

	return 0;
}

MHEGDisplay *
MHEGEngine_getDisplay(void)
{
	return &engine.display;
}

#if 0 // hmkim : commented out (StreamPlayer : CI+ MHEG Profile 에선 불필요. UK MHEG Profile 을 위해서는 추가 작업 필요함!)

char *
MHEGEngine_getAudioOutputDevice(void)
{
	return engine.audio_dev;
}

MHEGVideoOutputMethod *
MHEGEngine_getVideoOutputMethod(void)
{
	return engine.vo_method;
}

#endif

bool
MHEGEngine_avDisabled(void)
{
	return engine.av_disabled;
}

/*
 * according to the ISO MHEG spec this should be part of the SceneClass
 * but we need info about the current app etc too
 */

void
MHEGEngine_TransitionTo(TransitionTo *to, OctetString *caller_gid)
{
	ObjectReference *ref;
	char *absolute;
	OctetString scene_id;
	SceneClass *current_scene;
	ApplicationClass *current_app;
	OctetString *app_gid;
	LIST_TYPE(MHEGAsyncEvent) *ev, *next_ev;
	LIST_TYPE(MHEGAction) *act, *next_act;
	LIST_TYPE(GroupItem) *gi;
	LIST_TYPE(GroupItem) *gi_tail;

	/* check we can find an ExternalReference for the new scene */
	if(((ref = GenericObjectReference_getObjectReference(&to->target, caller_gid)) == NULL)
	|| ref->choice != ObjectReference_external_reference)
	{
		if(ref != NULL)
			error("TransitionTo: unable to transition to an internal reference");
		return;
	}

	/* get the absolute group ID of the new scene */
	absolute = MHEGEngine_absoluteFilename(&ref->u.external_reference.group_identifier);
	/* copy it */
	if(absolute == NULL)
	{
		error("absolute is Null.");
		return;
	}

	scene_id.size = strlen(absolute)/*+1*/;

	scene_id.data = safe_malloc(scene_id.size);
	if(scene_id.data == NULL)
	{
		error("scene_id.data is Null.");
		return;
	}
	VK_memcpy(scene_id.data, absolute, scene_id.size);

	/* check target is not the current scene */
	current_scene = MHEGEngine_getActiveScene();
	if(current_scene == NULL
	|| OctetString_cmp(&current_scene->rootClass.inst.ref.group_identifier, &scene_id) != 0)
	{
		verbose("TransitionTo: %s", ExternalReference_name(&ref->u.external_reference));
		/* UK MHEG Profile says we don't need to support transition effects */
		/* (remember that 'to' will get destroyed when we free the action queues, so use it now if you need it) */
		if(to->have_transition_effect)
			error("TransitionEffect not supported in UK MHEG Profile");
		/* get the active app */
		if ((current_app = MHEGEngine_getActiveApplication()) == NULL)
		{
			error("Can't find ApplicationClass");
			safe_free(scene_id.data);
			return;
		}
		/* check the new scene is available */
		if(!MHEGEngine_checkContentRef(&scene_id))
		{
//			EventData event_tag;
			verbose("Unable to open '%.*s'", scene_id.size, scene_id.data); // 해당 Scene 클래스 오브젝트를 받지 않았으면 당연히 찍히는 것으로 error 대신 verbose 로 출력한다.
			#if 1 // hmkim : added.
			MHEGEngine_enterCriticalMissingContent;
			if (current_scene) // 최초 시점에서는 당연히 active scene 이 없기 때문에 이 경우 else 가 동작한다. 따라서 이 경우 runtime type info 는 Application 클래스가 될 것이다.
				MHEGEngine_addMissingContent(&current_scene->rootClass, &scene_id);
			else
				MHEGEngine_addMissingContent(&current_app->rootClass, &scene_id);
			MHEGEngine_leaveCriticalMissingContent;
			#endif
			#if 0 // hmkim : commented out. see MHEGEngine_pollMissingContent().
			/* generate a GroupIDRefError EngineEvent */
			event_tag.choice = EventData_integer;
			event_tag.u.integer = EngineEvent_GroupIDRefError;
			MHEGEngine_generateAsyncEvent(&current_app->rootClass.inst.ref, EventType_engine_event, &event_tag);
			#endif
			/* clean up */
			safe_free(scene_id.data);
			return;
		}
		/*
		 * do Deactivation of all Ingredients in the current app that are not shared
		 * in the reverse order they appear in the items list
		 */
		gi = current_app->items;
		/* get the tail of the list */
		gi_tail = (current_app->items != NULL) ? current_app->items->prev : NULL;
		while(gi)
		{
			/* only do Deactivation if it is not shared */
			if(!GroupItem_isShared(&gi->item))
				GroupItem_Deactivation(&gi->item);
			/* have we reached the head */
			gi = (gi->prev != gi_tail) ? gi->prev : NULL;
		}
		/* do Deactivation and Destruction on the current scene */
		if(current_scene != NULL)
		{
			verbose("Deactivation and Destruction on %s", ExternalReference_name(&current_scene->rootClass.inst.ref));
			SceneClass_Deactivation(current_scene);
			SceneClass_Destruction(current_scene);
		}
		/*
		 * now the old scene is destroyed,
		 * remove its events from the Async event queue and its pending actions
		 * keep events and actions associated with the app
		 */
		app_gid = &current_app->rootClass.inst.ref.group_identifier;
		/* async event queue */
		ev = engine.async_eventq;
		while(ev)
		{
			next_ev = ev->next;
			if(OctetString_cmp(&ev->item.src.group_identifier, app_gid) != 0)
			{
				LIST_REMOVE(&engine.async_eventq, ev);
				free_MHEGAsyncEventListItem(ev);
			}
			ev = next_ev;
		}
		/* main action queue */
		act = engine.main_actionq;
		while(act)
		{
			next_act = act->next;
			if(OctetString_cmp(&act->item.ref->group_identifier, app_gid) != 0) // hmkim : org is if(OctetString_cmp(act->item.group_id, app_gid) != 0)
			{
				LIST_REMOVE(&engine.main_actionq, act);
				free_MHEGActionListItem(act);
			}
			act = next_act;
		}
		/* temp action queue */
		act = engine.temp_actionq;
		while(act)
		{
			next_act = act->next;
			if(OctetString_cmp(&act->item.ref->group_identifier, app_gid) != 0) // hmkim : org is if(OctetString_cmp(act->item.group_id, app_gid) != 0)
			{
				LIST_REMOVE(&engine.temp_actionq, act);
				free_MHEGActionListItem(act);
			}
			act = next_act;
		}
		/* load the new scene (also free's the old one if we have one) */
		if((current_scene = MHEGApp_loadScene(&engine.active_app, &scene_id)) != NULL)
		{
			/* do Preparation and Activation */
			SceneClass_Preparation(current_scene);
			SceneClass_Activation(current_scene);
		}
	}

	/* clean up */
	safe_free(scene_id.data);

	return;
}


void
MHEGEngine_quit(QuitReason reason, OctetString *data)
{
	/*
	 * tell the main loop we want to quit the current app
	 * can't just Launch the new app here cuz we may be in the middle of processing a sequence of ElementaryActions
	 * the rest of the sequence would be free'd if we destroyed the current app here
	 */
	engine.quit_reason = reason;

	/* copy not dup, in case we get called more than once */
	OctetString_copy(&engine.quit_data, data);

	/* empty the Async event queue and any pending actions */
	LIST_FREE(&engine.async_eventq, MHEGAsyncEvent, free_MHEGAsyncEventListItem);
	LIST_FREE(&engine.main_actionq, MHEGAction, free_MHEGActionListItem);
	LIST_FREE(&engine.temp_actionq, MHEGAction, free_MHEGActionListItem);

	local_MHEGIB_SendMessage(MHEGIB_RUN_MSG_QUIT_EVENT_GENERATED, reason, 0, 0);

	return;
}

void
MHEGEngine_quitByChannelChange(void)
{
	if (engine.status == MHEGEngine_Running)
	{
		MHEGEngine_quit(QuitReason_QuitByChannelChange, NULL);
	}
}

void
MHEGEngine_quitByGui(void)
{
	if (engine.status == MHEGEngine_Running)
	{
		MHEGEngine_quit(QuitReason_QuitByGUI, NULL);
	}
}

/*
 * it is a fatal error if no app is loaded
 */

ApplicationClass *
MHEGEngine_getActiveApplication(void)
{
	/* assert */
	if(engine.active_app.app == NULL
	|| engine.active_app.app->choice != InterchangedObject_application)
	{
		fatal("Can't find ApplicationClass");
		return NULL;
	}

	return &engine.active_app.app->u.application;
}

/*
 * returns NULL if no scene is loaded
 */

SceneClass *
MHEGEngine_getActiveScene(void)
{
	if(engine.active_app.scene == NULL)
		return NULL;

	/* assert */
	if(engine.active_app.scene->choice != InterchangedObject_scene)
	{
		fatal("Can't find SceneClass");
		return NULL;
	}

	return &engine.active_app.scene->u.scene;
}

/*
 * adds the given object to the top of the DisplayStack for the active application
 * (if it is not already in the DisplayStack)
 * adds the ptr, so the data must remain valid until it is removed from the DisplayStack
 * Visible 클래스들, 즉, Bitmap, LineArt, Rectangle, DynamicLineArt, Text, Video, RTGraphics, Slider, EntryField, HyperText, Hotspot, PushButton, SwitchButton 클래스들을 대상으로 한다.
 */

void
MHEGEngine_addVisibleObject(RootClass *obj)
{
	ApplicationClass *app = MHEGEngine_getActiveApplication();
	LIST_TYPE(RootClassPtr) *vis;

	/* assert */
	if (app == NULL)
	{
		error("Can't find ApplicationClass");
		return;
	}

	/* check it is not already on the DisplayStack */
	vis = app->inst.DisplayStack;
	while(vis)
	{
		if(vis->item == obj)
			return;
		vis = vis->next;
	}

	vis = safe_malloc(sizeof(LIST_TYPE(RootClassPtr)));
	vis->item = obj;
	LIST_APPEND(&app->inst.DisplayStack, vis);

	return;
}

/*
 * removes the given object from the DisplayStack for the active application
 * Visible 클래스들, 즉, Bitmap, LineArt, Rectangle, DynamicLineArt, Text, Video, RTGraphics, Slider, EntryField, HyperText, Hotspot, PushButton, SwitchButton 클래스들을 대상으로 한다.
 */

void
MHEGEngine_removeVisibleObject(RootClass *obj)
{
	ApplicationClass *app = MHEGEngine_getActiveApplication();
	LIST_TYPE(RootClassPtr) *vis;

	/* assert */
	if (app == NULL)
	{
		error("Can't find ApplicationClass");
		return;
	}

	/* find it */
	vis = app->inst.DisplayStack;
	while(vis)
	{
		if(vis->item == obj)
		{
			LIST_REMOVE(&app->inst.DisplayStack, vis);
			safe_free(vis);
			return;
		}
		vis = vis->next;
	}

	error("Object not found on DisplayStack: %s", ExternalReference_name(&obj->inst.ref));

	return;
}

/*
 * doesn't redraw the screen
 * the end of the DisplayStack list is the top of the screen
 */

void
MHEGEngine_bringToFront(RootClass *obj)
{
	ApplicationClass *app = MHEGEngine_getActiveApplication();
	LIST_TYPE(RootClassPtr) *vis;

	/* assert */
	if (app == NULL)
	{
		error("Can't find ApplicationClass");
		return;
	}

	/* find it on the DisplayStack */
	vis = app->inst.DisplayStack;
	while(vis && vis->item != obj)
		vis = vis->next;

	/* if it is not already at the top (ie at the tail of the list) */
	if(vis && vis->next)
	{
		LIST_REMOVE(&app->inst.DisplayStack, vis);
		LIST_APPEND(&app->inst.DisplayStack, vis);
	}

	return;
}

/*
 * doesn't redraw the screen
 * the head of the DisplayStack list is the bottom of the screen
 */

void
MHEGEngine_sendToBack(RootClass *obj)
{
	ApplicationClass *app = MHEGEngine_getActiveApplication();
	LIST_TYPE(RootClassPtr) *vis;

	/* assert */
	if (app == NULL)
	{
		error("Can't find ApplicationClass");
		return;
	}

	/* find it on the DisplayStack */
	vis = app->inst.DisplayStack;
	while(vis && vis->item != obj)
		vis = vis->next;

	/* if it is not already at the bottom (ie at the head of the list) */
	if(vis && vis != app->inst.DisplayStack)
	{
		LIST_REMOVE(&app->inst.DisplayStack, vis);
		LIST_PREPEND(&app->inst.DisplayStack, vis);
	}

	return;
}

/*
 * doesn't redraw the screen
 * the head of the DisplayStack list is the bottom of the screen
 */

void
MHEGEngine_putBefore(RootClass *target, RootClass *ref)
{
	ApplicationClass *app = MHEGEngine_getActiveApplication();
	LIST_TYPE(RootClassPtr) *target_item, *ref_item;

	/* assert */
	if (app == NULL)
	{
		error("Can't find ApplicationClass");
		return;
	}

	/* find target on the DisplayStack */
	target_item = app->inst.DisplayStack;
	while(target_item && target_item->item != target)
		target_item = target_item->next;
	if(target_item == NULL)
	{
		error("PutBefore: %s is not on the DisplayStack", ExternalReference_name(&target->inst.ref));
		return;
	}

	/* find ref on the DisplayStack */
	ref_item = app->inst.DisplayStack;
	while(ref_item && ref_item->item != ref)
		ref_item = ref_item->next;
	if(ref_item == NULL)
	{
		error("PutBefore: %s is not on the DisplayStack", ExternalReference_name(&ref->inst.ref));
		return;
	}

	/* remove target from the list */
	LIST_REMOVE(&app->inst.DisplayStack, target_item);

	/* insert target after ref in the list */
	LIST_INSERT_AFTER(&app->inst.DisplayStack, target_item, ref_item);

	return;
}

/*
 * doesn't redraw the screen
 * the head of the DisplayStack list is the bottom of the screen
 */

void
MHEGEngine_putBehind(RootClass *target, RootClass *ref)
{
	ApplicationClass *app = MHEGEngine_getActiveApplication();
	LIST_TYPE(RootClassPtr) *target_item, *ref_item;

	/* assert */
	if (app == NULL)
	{
		error("Can't find ApplicationClass");
		return;
	}

	/* find target on the DisplayStack */
	target_item = app->inst.DisplayStack;
	while(target_item && target_item->item != target)
		target_item = target_item->next;
	if(target_item == NULL)
	{
		error("PutBefore: %s is not on the DisplayStack", ExternalReference_name(&target->inst.ref));
		return;
	}

	/* find ref on the DisplayStack */
	ref_item = app->inst.DisplayStack;
	while(ref_item && ref_item->item != ref)
		ref_item = ref_item->next;
	if(ref_item == NULL)
	{
		error("PutBefore: %s is not on the DisplayStack", ExternalReference_name(&ref->inst.ref));
		return;
	}

	/* remove target from the list */
	LIST_REMOVE(&app->inst.DisplayStack, target_item);

	/* insert target before ref in the list */
	LIST_INSERT_BEFORE(&app->inst.DisplayStack, target_item, ref_item);

	return;
}

/*
 * redraw all the objects on the DisplayStack in the given area, that have RunningStatus of true
 * area should be given in MHEG coords, ie in the range  0-MHEG_XRES, 0-MHEG_YRES
 */

void
MHEGEngine_redrawArea(XYPosition *pos, OriginalBoxSize *box)
{
	ApplicationClass *app = MHEGEngine_getActiveApplication();
	LIST_TYPE(RootClassPtr) *stack;
	RootClass *obj;
//	MHEGColour black;

	/* assert */
	if (app == NULL)
	{
		error("Can't find ApplicationClass");
		return;
	}

	/* only redraw if the display is not locked */
	if(app->inst.LockCount > 0)
		return;

	/* any undrawn on background is black */
#if 0 // org
	MHEGColour_black(&black);
	MHEGDisplay_fillRectangle(&engine.display, pos, box, &black);
#else // 위처럼 배경을 검은색으로 그려서 video를 가리는 것이 옳은가..?
	MHEGDisplay_fillTransparentRectangle(&engine.display, pos, box);
#endif

	/* get the display stack from the current ApplicationClass */
	stack = app->inst.DisplayStack;

	/* start at the bottom and redraw each object inside the area */
	while(stack)
	{
		obj = stack->item;
		/* only draw active objects (should all be derived from VisibleClass) */
		if(obj->inst.RunningStatus)
			VisibleClass_render(obj, &engine.display, pos, box);
		stack = stack->next;
	}

	/* use the new objects we have just drawn */
	MHEGDisplay_useOverlay(&engine.display);

	/* refresh the screen */
	MHEGDisplay_refresh(&engine.display, pos, box);

	return;
}

/*
 * adds a ptr to the given LinkClass to the active links list
 * the ptr to the LinkClass data must remain valid until it is removed with MHEGEngine_removeActiveLink()
 */

void
MHEGEngine_addActiveLink(LinkClass *link)
{
	LIST_TYPE(LinkClassPtr) *list;

	list = safe_malloc(sizeof(LIST_TYPE(LinkClassPtr)));
	list->item = link;

	LIST_APPEND(&engine.active_links, list);

	return;
}

void
MHEGEngine_removeActiveLink(LinkClass *link)
{
	LIST_TYPE(LinkClassPtr) *list = engine.active_links;

	while(list)
	{
		if(list->item == link)
		{
			LIST_REMOVE(&engine.active_links, list);
			safe_free(list);
			return;
		}
		list = list->next;
	}

	error("Active link not found: %s", ExternalReference_name(&link->rootClass.inst.ref));

	return;
}

/*
 * key should be one of the MHEGKey_xxx constants
 */

/* UK MHEG Profile (D-BOOK 5.0) :

   Section 19 MHEG-5 Authoring Rules & Guidelines

   MHEG-5 application 이 "selected" 되어 "entered" 되기 전까지는
   The application shall only use input event register 3
   The application shall ensure that the InteractionStatus of all Interactibles shall be False ... 이다.

   Section 13.13.6 Interactibles

   A restriction on the receiver implementation of interaction methods for any Interactible
   is that the Text, Red, Green, Yellow and Blue key functions shall not be used.
   Further, even when the InteractionStatus is true,
   the EngineEvents corresponding to all key functions shall still be generated
   even if UserInput events are not - as described above.

   Section 13.6 User input

   Register 3 group : Cancel, Text, 컬러키 (Red, Green, Yellow, Blue) -> always available to a running MHEG-5 application.
   Register 4 group : 숫자키 -> sometimes available to a running MHEG-5 application.
   Register 5 group : Select, 방향키 (Up, Down, Left, Right) -> sometimes available to a running MHEG-5 application.
   Receiver   group : Power, Subtitle, Wide, Info, Guide, Prog+/-, Vol+/-, Mute -> never available to a running MHEG-5 application.
*/

static bool
MHEGEngine_isKeyAvailableForInteracting(unsigned int key)
{
	if (key == MHEGKey_Text || key == MHEGKey_Red || key == MHEGKey_Green || key == MHEGKey_Yellow || key == MHEGKey_Blue)
		return false;

	return true;
}

static bool
MHEGEngine_isKeyAvailableForUserInput(unsigned int key, int input_event_register)
{
	// Register 3 group
	if (key == MHEGKey_Cancel || key == MHEGKey_Text || key == MHEGKey_Red || key == MHEGKey_Green || key == MHEGKey_Yellow || key == MHEGKey_Blue)
		return true;

	// Register 4 group
	if ((MHEGKey_0 <= key && key <= MHEGKey_9) && input_event_register == 4)
		return true;

	// Register 5 group
	if ((key == MHEGKey_Select || (MHEGKey_Up <= key && key <= MHEGKey_Right)) && (input_event_register == 4 || input_event_register == 5))
		return true;

	return false;
}

static bool
MHEGEngine_checkKeyForEntryField(EntryFieldClass *entry_field, unsigned int key, int input_event_register)
{
	/*--- check input parameters ---*/

	if (entry_field == NULL)
		return false; // key not consumed

	if (key == MHEGKey_Cancel)
		;
	else if ((key == MHEGKey_Select || key == MHEGKey_Left) && (input_event_register == 4 || input_event_register == 5))
		;
	else if ((MHEGKey_0 <= key && key <= MHEGKey_9) && input_event_register == 4)
		;
	else
		return false; // key not consumed

	return true; // key consumed
}

static bool
MHEGEngine_checkKeyForHyperText(HyperTextClass *hyper_text, unsigned int key, int input_event_register)
{
	unsigned int FocusPosition;

	verbose_todo("%s not yet implemented", __FUNCTION__); // HyperText required in UK MHEG Profile but not required to support in CI+ MHEG Profile

	/*--- check input parameters ---*/

	if (hyper_text == NULL)
		return false; // key not consumed

	if (key == MHEGKey_Cancel)
		;
	else if ((key == MHEGKey_Select || (MHEGKey_Up <= key && key <= MHEGKey_Right)) && (input_event_register == 4 || input_event_register == 5))
		;
	else
		return false; // key not consumed

	/*--- init values ---*/

	FocusPosition = hyper_text->inst.FocusPosition;

	/*--- check values with UK MHEG Profile (D-BOOK 5.0) and ISO/IEC 13522-5 ---*/

	if (FocusPosition == 0)
	{
		return false; // key not consumed
	}

	return true; // key consumed
}

static bool
MHEGEngine_checkKeyForSlider(SliderClass *slider, unsigned int key, int input_event_register)
{
	if (slider == NULL)
		return false; // key not consumed

	if (key == MHEGKey_Cancel)
		;
	else if ((key == MHEGKey_Select || (MHEGKey_Up <= key && key <= MHEGKey_Right)) && (input_event_register == 4 || input_event_register == 5))
		;
	else
		return false; // key not consumed

	return true; // key consumed
}


static bool
MHEGEngine_keyHandlerForEntryField(EntryFieldClass *entry_field, unsigned int key, int input_event_register)
{
	OctetString TextData;
	int EntryPoint;

	XYPosition pos = {0, 0};
	OriginalBoxSize box = {MHEG_XRES, MHEG_YRES};

	int i;

	/*--- check input parameters ---*/

	if (entry_field == NULL)
		return false; // key not consumed

	if (key == MHEGKey_Cancel)
		;
	else if ((key == MHEGKey_Select || key == MHEGKey_Left) && (input_event_register == 4 || input_event_register == 5))
		;
	else if ((MHEGKey_0 <= key && key <= MHEGKey_9) && input_event_register == 4)
		;
	else
		return false; // key not consumed

	/*--- init values ---*/

	OctetString_dup(&TextData, &entry_field->inst.TextData);
	EntryPoint = entry_field->inst.EntryPoint;

	/*--- check values with UK MHEG Profile (D-BOOK 5.0) and ISO/IEC 13522-5 ---*/

	if (EntryPoint < 0)
	{
		error("EntryPoint is wrong (%d)", EntryPoint);
		EntryPoint = 0;
	}
	else if (EntryPoint > TextData.size)
	{
		error("EntryPoint is wrong (%d > %d)", EntryPoint, TextData.size);
		EntryPoint = TextData.size;
	}

	/*--- do process for input key ---*/

	/* Cancel terminates interaction and also sets the TextData attribute to an empty string. */
	if (key == MHEGKey_Cancel)
	{
		/* set InteractionStatus to false and generate the event, InteractionCompleted */
		entry_field->inst.InteractionStatus = false;
		MHEGEngine_generateAsyncEvent(&entry_field->rootClass.inst.ref, EventType_interaction_completed, NULL);

		/* free TextData */
		free_OctetString(&entry_field->inst.TextData);
		LIST_FREE(&entry_field->inst.element, MHEGTextElement, safe_free);
	}
	/* Select simply terminates interaction. */
	else if (key == MHEGKey_Select)
	{
		/* set InteractionStatus to false and generate the event, InteractionCompleted */
		entry_field->inst.InteractionStatus = false;
		MHEGEngine_generateAsyncEvent(&entry_field->rootClass.inst.ref, EventType_interaction_completed, NULL);
	}
	/* Left results in the character to the left of the insertion point (if any) being deleted regardless of the state of OverwriteMode. */
	else if (key == MHEGKey_Left)
	{
		if (EntryPoint > 0) // EntryPoint 가 시작점에 위치한 경우의 left 키는 처리하지 않음.
		{
			/* set EntryPoint */
			entry_field->inst.EntryPoint = EntryPoint - 1;

			/* set TextData */
			free_OctetString(&entry_field->inst.TextData);
			LIST_FREE(&entry_field->inst.element, MHEGTextElement, safe_free);
			entry_field->inst.TextData.size = TextData.size - 1;
			if (entry_field->inst.TextData.size)
			{
				entry_field->inst.TextData.data = safe_malloc(entry_field->inst.TextData.size);
				for (i = 0; i < EntryPoint - 1; i++)
					entry_field->inst.TextData.data[i] = TextData.data[i];
				for (; i < entry_field->inst.TextData.size; i++)
					entry_field->inst.TextData.data[i] = TextData.data[i+1];
			}

			/* redraw : 이 시점엔 EntryField 오브젝트가 top 에 위치할 것으로 가정해도 무방할 듯 하므로 MHEGEngine_redrawArea() 호출하여 Visible 오브젝트들을 전부 그리는 대신 EntryField 오브젝트만 그려도 될 것이다. */
			EntryFieldClass_render(entry_field, &engine.display, &pos, &box);
			MHEGDisplay_useOverlay(&engine.display);
			MHEGDisplay_refresh(&engine.display, &pos, &box);
		}
	}
	else // if (MHEGKey_0 <= key && key <= MHEGKey_9)
	{
		if (TextData.size < entry_field->max_length) // 입력되어 있는 텍스트 길이가 EntryField 에 입력 가능한 길이보다 작을 때만 처리함. 만약 이번 입력으로 EntryField 가 꽉 차게 되면 interaction 은 종료될 것임.
		{
			/* set EntryPoint */
			entry_field->inst.EntryPoint = EntryPoint + 1;

			/* set TextData */
			free_OctetString(&entry_field->inst.TextData);
			LIST_FREE(&entry_field->inst.element, MHEGTextElement, safe_free);
			if (entry_field->inst.OverwriteMode)
			{
				entry_field->inst.TextData.size = MAX(TextData.size, EntryPoint + 1);
				entry_field->inst.TextData.data = safe_malloc(entry_field->inst.TextData.size);
				VK_memcpy(entry_field->inst.TextData.data, TextData.data, TextData.size);
				entry_field->inst.TextData.data[EntryPoint] = key - MHEGKey_0 + 0x30;
			}
			else
			{
				entry_field->inst.TextData.size = TextData.size + 1;
				entry_field->inst.TextData.data = safe_malloc(entry_field->inst.TextData.size);
				for (i = 0; i < EntryPoint; i++)
					entry_field->inst.TextData.data[i] = TextData.data[i];
				for (; i < TextData.size; i++)
					entry_field->inst.TextData.data[i+1] = TextData.data[i];
				entry_field->inst.TextData.data[EntryPoint] = key - MHEGKey_0 + 0x30;
			}

			if (entry_field->max_length > 0 && entry_field->inst.TextData.size == entry_field->max_length)
			{
				/* set InteractionStatus to false and generate the event, InteractionCompleted */
				entry_field->inst.InteractionStatus = false;
				MHEGEngine_generateAsyncEvent(&entry_field->rootClass.inst.ref, EventType_interaction_completed, NULL);

				/* generate the event, EntryFieldFull */
				MHEGEngine_generateAsyncEvent(&entry_field->rootClass.inst.ref, EventType_entry_field_full, NULL);
			}
			else
			{
				/* redraw : 이 시점엔 EntryField 오브젝트가 top 에 위치할 것으로 가정해도 무방할 듯 하므로 MHEGEngine_redrawArea() 호출하여 Visible 오브젝트들을 전부 그리는 대신 EntryField 오브젝트만 그려도 될 것이다. */
				EntryFieldClass_render(entry_field, &engine.display, &pos, &box);
				MHEGDisplay_useOverlay(&engine.display);
				MHEGDisplay_refresh(&engine.display, &pos, &box);
			}
		}
	}

	/*--- free the allocated memories ---*/

	free_OctetString(&TextData);

	return true; // key consumed
}

static bool
MHEGEngine_keyHandlerForHyperText(HyperTextClass *hyper_text, unsigned int key, int input_event_register)
{
	unsigned int N, FocusPosition;
	EventData event_tag;

	verbose_todo("%s not yet implemented", __FUNCTION__); // HyperText required in UK MHEG Profile but not required to support in CI+ MHEG Profile

	/*--- check input parameters ---*/

	if (hyper_text == NULL)
		return false; // key not consumed

	if (key == MHEGKey_Cancel)
		;
	else if ((key == MHEGKey_Select || (MHEGKey_Up <= key && key <= MHEGKey_Right)) && (input_event_register == 4 || input_event_register == 5))
		;
	else
		return false; // key not consumed

	/*--- init values ---*/

	FocusPosition = hyper_text->inst.FocusPosition;

	/*--- check values with UK MHEG Profile (D-BOOK 5.0) and ISO/IEC 13522-5 ---*/

	N = 0; // TODO : calculate N !

	if (FocusPosition == 0)
	{
		error("FocusPosition is 0");
		return false; // key not consumed
	}
	if (FocusPosition > N)
	{
		error("FocusPosition is wrong (%d > %d)", FocusPosition, N);
		FocusPosition = N;
	}

	/*--- do process for input key ---*/

	/* Interaction with the HyperText object shall be terminated if the user activates the "Cancel" user interface function */
	if (key == MHEGKey_Cancel)
	{
		/* set InteractionStatus to false and generate the event, InteractionCompleted */
		hyper_text->inst.InteractionStatus = false;
		MHEGEngine_generateAsyncEvent(&hyper_text->rootClass.inst.ref, EventType_interaction_completed, NULL);
	}
	/* Anchors shall be fired by the user activating the "Select" user interface function */
	else if (key == MHEGKey_Select)
	{
		/* set LastAnchorFired */
		free_OctetString(&hyper_text->inst.LastAnchorFired);
		// TODO : FocusPosition 위치의 anchor 를 구해서 LastAnchorFired 를 셋팅하라.

		/* generate the event, AnchorFired */
		event_tag.choice = EventData_octetstring;
		event_tag.u.octetstring.size = hyper_text->inst.LastAnchorFired.size;
		event_tag.u.octetstring.data = hyper_text->inst.LastAnchorFired.data;
		MHEGEngine_generateAsyncEvent(&hyper_text->rootClass.inst.ref, EventType_anchor_fired, &event_tag);
	}
	/* The "up" or "left" user interface functions will move the focus to the previous anchor */
	else if (key == MHEGKey_Up || key == MHEGKey_Left)
	{
		if (FocusPosition == 1) // top event : anchor_wrapping_flag 가 false 인 경우. <TODO> anchor_wrapping_flag 가 true 인 경우엔 bottom 으로 wrap 해라.
		{
			/* generate the event, AnchorFired with MHEG_REC_HTEXT_TOP */
			event_tag.choice = EventData_octetstring;
			event_tag.u.octetstring.size = strlen(MHEG_REC_HTEXT_TOP);
			event_tag.u.octetstring.data = (unsigned char *)MHEG_REC_HTEXT_TOP;
			MHEGEngine_generateAsyncEvent(&hyper_text->rootClass.inst.ref, EventType_anchor_fired, &event_tag);
		}
		else
		{
			/* set FocusPosition */
			FocusPosition--;
			hyper_text->inst.FocusPosition = FocusPosition;

			/* generate the event, FocusMoved */
			event_tag.choice = EventData_integer;
			event_tag.u.integer = FocusPosition;
			MHEGEngine_generateAsyncEvent(&hyper_text->rootClass.inst.ref, EventType_focus_moved, &event_tag);
		}
	}
	/* The "down" or "right" user interface functions will move the focus to the next anchor */
	else // if (key == MHEGKey_Down || key == MHEGKey_Right)
	{
		if (FocusPosition == N) // bottom event : anchor_wrapping_flag 가 false 인 경우. <TODO> anchor_wrapping_flag 가 true 인 경우엔 top 으로 wrap 해라.
		{
			/* generate the event, AnchorFired with MHEG_REC_HTEXT_BOT */
			event_tag.choice = EventData_octetstring;
			event_tag.u.octetstring.size = strlen(MHEG_REC_HTEXT_BOT);
			event_tag.u.octetstring.data = (unsigned char *)MHEG_REC_HTEXT_BOT;
			MHEGEngine_generateAsyncEvent(&hyper_text->rootClass.inst.ref, EventType_anchor_fired, &event_tag);
		}
		else
		{
			/* set FocusPosition */
			FocusPosition++;
			hyper_text->inst.FocusPosition = FocusPosition;

			/* generate the event, FocusMoved */
			event_tag.choice = EventData_integer;
			event_tag.u.integer = FocusPosition;
			MHEGEngine_generateAsyncEvent(&hyper_text->rootClass.inst.ref, EventType_focus_moved, &event_tag);
		}
	}

	/*--- free the allocated memories ---*/

	// there are no allocated memories. so nothing to do here...

	return true; // key consumed
}

static bool
MHEGEngine_keyHandlerForSlider(SliderClass *slider, unsigned int key, int input_event_register)
{
	Orientation orientation;
	int SliderValue;
	int Portion;
	int MinValue;
	int MaxValue;
	int StepSize;
	EventData event_tag;

	/*--- check input parameters ---*/

	if (slider == NULL)
		return false; // key not consumed

	if (key == MHEGKey_Cancel)
		;
	else if ((key == MHEGKey_Select || (MHEGKey_Up <= key && key <= MHEGKey_Right)) && (input_event_register == 4 || input_event_register == 5))
		;
	else
		return false; // key not consumed

	/*--- init values ---*/

	orientation = slider->orientation;
	SliderValue = slider->inst.SliderValue;
	Portion = slider->slider_style == SliderStyle_proportional ? slider->inst.Portion : 0;
	MinValue = slider->inst.MinValue;
	MaxValue = slider->inst.MaxValue;
	StepSize = slider->inst.StepSize;

	/*--- check values with UK MHEG Profile (D-BOOK 5.0) and ISO/IEC 13522-5 ---*/

	if (SliderValue < MinValue || SliderValue > MaxValue - Portion)
	{
		error("SliderValue is wrong (%d not within [MinValue %d, MaxValue %d - Portion %d]", SliderValue, MinValue, MaxValue, Portion);
		SliderValue = MinValue;
	}

	/*--- do process for input key ---*/

	/* Interaction with the Slider object shall be terminated if the user activates either the "Select" or "Cancel" user interface function. */
	if (key == MHEGKey_Cancel || key == MHEGKey_Select)
	{
		/* set InteractionStatus to false and generate the event, InteractionCompleted */
		slider->inst.InteractionStatus = false;
		MHEGEngine_generateAsyncEvent(&slider->rootClass.inst.ref, EventType_interaction_completed, NULL);
	}
	/* UK MHEG Profile (D-BOOK 5.0) 에서는 Orientation 에 따라 up/down/left/right 동작이 각각 기술되어 있지만 여기서는 HyperText 의 경우처럼 up & left, down & right 를 묶어 같이 처리한다.
	   또한, 변경된 SliderValue 가 [MinValue, MaxValue - Portion] range 를 벗어나는 경우에 대한 처리가 언급되어 있지 않은데 여기서는 단순히 경계값인 경우 처리하지 않는 것으로 한다. */
	else // if (MHEGKey_Up <= key && key <= MHEGKey_Right)
	{
		if (orientation == Orientation_left || orientation == Orientation_up)
		{
			if (key == MHEGKey_Left || key == MHEGKey_Up)
				SliderValue += StepSize;
			else
				SliderValue -= StepSize;
		}
		else // if (orientation == Orientation_right || orientation == Orientation_down)
		{
			if (key == MHEGKey_Right || key == MHEGKey_Down)
				SliderValue += StepSize;
			else
				SliderValue -= StepSize;
		}

		if (MinValue <= SliderValue && SliderValue <= MaxValue - Portion)
		{
			/* set SliderValue */
			slider->inst.SliderValue = SliderValue;

			/* generate the event, SliderValueChanged */
			event_tag.choice = EventData_integer;
			event_tag.u.integer = SliderValue;
			MHEGEngine_generateAsyncEvent(&slider->rootClass.inst.ref, EventType_slider_value_changed, &event_tag);
		}
	}

	/*--- free the allocated memories ---*/

	// there are no allocated memories. so nothing to do here...

	return true; // key consumed
}

/* MHEGDisplay_processEvents() 처리를 여기서 바로 한다.
 * process the next GUI event
 * if block is false and no events are pending, return immediately
 * if block is true and no events are pending, wait for the next event
 * returns true if the GUI wants us to quit
 */

static bool
MHEGEngine_keyPressed(unsigned int key, bool block)
{
	ApplicationClass *app = MHEGEngine_getActiveApplication(); /* source of EngineEvent events */
	SceneClass *scene = MHEGEngine_getActiveScene(); /* source of UserInput events */
	EventData data; /* event data */
	bool key_consumed = false;

	/* assert */
	if (app == NULL)
	{
		error("Can't find ApplicationClass");
		return false;
	}

	data.choice = EventData_integer;

	/*--- EngineEvent ---*/

	/* do we need an EngineEvent for this key */
	if (key == MHEGKey_Cancel)
	{
		data.u.integer = EngineEvent_CancelKeyFunction;
		MHEGEngine_generateAsyncEvent(&app->rootClass.inst.ref, EventType_engine_event, &data);
	}
	else
	{
		if (scene != NULL) // hmkim : modified. TEXT, colour 키들은 active scene object 가 있는 경우에만 유효하다. EPG 키에 대해서는 스펙에 명시되어 있지 않으나 TEXT 키에 준할 것으로 생각된다.
		{
			// and if scene->input_event_register is 3, 4 or 5... -> 1, 2 의 경우엔 DAVIC 사양이기 때문에 아래 키들은 항시 적용되므로 여기서는 굳이 체크할 필요 없음.

			if (key == MHEGKey_Text)
			{
				data.u.integer = EngineEvent_TextKeyFunction;
				MHEGEngine_generateAsyncEvent(&app->rootClass.inst.ref, EventType_engine_event, &data);
			}
			else if (key == MHEGKey_EPG) // NZ profile
			{
				data.u.integer = EngineEvent_EPGKeyFunction;
				MHEGEngine_generateAsyncEvent(&app->rootClass.inst.ref, EventType_engine_event, &data);
			}
			else if (key == MHEGKey_Red)
			{
				data.u.integer = EngineEvent_RedKeyFunction;
				MHEGEngine_generateAsyncEvent(&app->rootClass.inst.ref, EventType_engine_event, &data);
			}
			else if (key == MHEGKey_Green)
			{
				data.u.integer = EngineEvent_GreenKeyFunction;
				MHEGEngine_generateAsyncEvent(&app->rootClass.inst.ref, EventType_engine_event, &data);
			}
			else if (key == MHEGKey_Yellow)
			{
				data.u.integer = EngineEvent_YellowKeyFunction;
				MHEGEngine_generateAsyncEvent(&app->rootClass.inst.ref, EventType_engine_event, &data);
			}
			else if (key == MHEGKey_Blue)
			{
				data.u.integer = EngineEvent_BlueKeyFunction;
				MHEGEngine_generateAsyncEvent(&app->rootClass.inst.ref, EventType_engine_event, &data);
			}
		}
	}

	/*--- UserInput ---*/

#if 0 // org

	/* generate the UserInput event */
	if(scene != NULL)
	{
		data.u.integer = key;
		MHEGEngine_generateAsyncEvent(&scene->rootClass.inst.ref, EventType_user_input, &data);
	}

#else // hmkim : modified.

	/* 활성화된 Interactible 클래스가 존재하고 그것의 InteractionStatus 가 true 인 경우 (interacting),
	   UserInput 이벤트를 generate 하는 대신 아래의 각 Interaction 처리 루틴을 수행하도록 해야 한다.
	   또한, At any time, at most one lnteractible shall have its InteractionStatus set to True... 이다.
	   한편, UK / CI+ MHEG Profile 에서 필요치 않는 Button 클래스들,
	   즉, Hotspot, PushButton, SwitchButton 클래스들은 구현하지 않는다 (Not required features = SHALL NOT be implemented). */

	if (scene != NULL)
	{
		if (MHEGEngine_isKeyAvailableForInteracting(key))
		{
			LIST_TYPE(GroupItem) *gi;
			EntryFieldClass *entry_field = NULL;
			HyperTextClass *hyper_text = NULL;
			SliderClass *slider = NULL;

			gi = scene->items;
			while(gi)
			{
				if (gi->item.choice == GroupItem_entry_field
					&& gi->item.u.entry_field.rootClass.inst.AvailabilityStatus
					&& gi->item.u.entry_field.rootClass.inst.RunningStatus
					&& gi->item.u.entry_field.inst.InteractionStatus)
				{
					entry_field = &gi->item.u.entry_field;
					break;
				}
				else if (gi->item.choice == GroupItem_hyper_text
					&& gi->item.u.hyper_text.rootClass.inst.AvailabilityStatus
					&& gi->item.u.hyper_text.rootClass.inst.RunningStatus
					&& gi->item.u.hyper_text.inst.InteractionStatus)
				{
					hyper_text = &gi->item.u.hyper_text;
					break;
				}
				else if (gi->item.choice == GroupItem_slider
					&& gi->item.u.slider.rootClass.inst.AvailabilityStatus
					&& gi->item.u.slider.rootClass.inst.RunningStatus
					&& gi->item.u.slider.inst.InteractionStatus)
				{
					slider = &gi->item.u.slider;
					break;
				}
				gi = gi->next;
			}

			if (entry_field)
			{
				key_consumed = MHEGEngine_keyHandlerForEntryField(entry_field, key, scene->input_event_register);
			}
			else if (hyper_text)
			{
				key_consumed = MHEGEngine_keyHandlerForHyperText(hyper_text, key, scene->input_event_register);
			}
			else if (slider)
			{
				key_consumed = MHEGEngine_keyHandlerForSlider(slider, key, scene->input_event_register);
			}
		}

		if (!key_consumed && MHEGEngine_isKeyAvailableForUserInput(key, scene->input_event_register))
		{
			data.u.integer = key;
			MHEGEngine_generateAsyncEvent(&scene->rootClass.inst.ref, EventType_user_input, &data);
		}
	}

#endif

	return false;
}

static bool
MHEGEngine_checkKeyConsumed(unsigned int key)
{
	ApplicationClass *app = MHEGEngine_getActiveApplication(); /* source of EngineEvent events */
	SceneClass *scene = MHEGEngine_getActiveScene(); /* source of UserInput events */
	EventData data; /* event data */
	bool key_consumed = false;

	/* assert */
	if (app == NULL)
	{
		error("Can't find ApplicationClass");
		return false;
	}

	data.choice = EventData_integer;

	/*--- EngineEvent ---*/

	/* do we need an EngineEvent for this key */
	if (key == MHEGKey_Cancel)
	{
		return true;
	}
	else
	{
		if (scene != NULL) // hmkim : modified. TEXT, colour 키들은 active scene object 가 있는 경우에만 유효하다. EPG 키에 대해서는 스펙에 명시되어 있지 않으나 TEXT 키에 준할 것으로 생각된다.
		{
			// and if scene->input_event_register is 3, 4 or 5... -> 1, 2 의 경우엔 DAVIC 사양이기 때문에 아래 키들은 항시 적용되므로 여기서는 굳이 체크할 필요 없음.

			if (key == MHEGKey_Text)
			{
				key_consumed = true;
			}
			else if (key == MHEGKey_EPG) // NZ profile
			{
				key_consumed = true;
			}
			else if (key == MHEGKey_Red)
			{
				key_consumed = true;
			}
			else if (key == MHEGKey_Green)
			{
				key_consumed = true;
			}
			else if (key == MHEGKey_Yellow)
			{
				key_consumed = true;
			}
			else if (key == MHEGKey_Blue)
			{
				key_consumed = true;
			}

			if(key_consumed == true)
			{
				return true;
			}
		}
	}

	/*--- UserInput ---*/

#if 0 // org

	/* generate the UserInput event */
	if(scene != NULL)
	{
		data.u.integer = key;
		MHEGEngine_generateAsyncEvent(&scene->rootClass.inst.ref, EventType_user_input, &data);
	}

#else // hmkim : modified.

	/* 활성화된 Interactible 클래스가 존재하고 그것의 InteractionStatus 가 true 인 경우 (interacting),
	   UserInput 이벤트를 generate 하는 대신 아래의 각 Interaction 처리 루틴을 수행하도록 해야 한다.
	   또한, At any time, at most one lnteractible shall have its InteractionStatus set to True... 이다.
	   한편, UK / CI+ MHEG Profile 에서 필요치 않는 Button 클래스들,
	   즉, Hotspot, PushButton, SwitchButton 클래스들은 구현하지 않는다 (Not required features = SHALL NOT be implemented). */

	key_consumed = false;

	if (scene != NULL)
	{
		if (MHEGEngine_isKeyAvailableForInteracting(key))
		{
			LIST_TYPE(GroupItem) *gi;
			EntryFieldClass *entry_field = NULL;
			HyperTextClass *hyper_text = NULL;
			SliderClass *slider = NULL;

			gi = scene->items;
			while(gi)
			{
				if (gi->item.choice == GroupItem_entry_field
					&& gi->item.u.entry_field.rootClass.inst.AvailabilityStatus
					&& gi->item.u.entry_field.rootClass.inst.RunningStatus
					&& gi->item.u.entry_field.inst.InteractionStatus)
				{
					entry_field = &gi->item.u.entry_field;
					break;
				}
				else if (gi->item.choice == GroupItem_hyper_text
					&& gi->item.u.hyper_text.rootClass.inst.AvailabilityStatus
					&& gi->item.u.hyper_text.rootClass.inst.RunningStatus
					&& gi->item.u.hyper_text.inst.InteractionStatus)
				{
					hyper_text = &gi->item.u.hyper_text;
					break;
				}
				else if (gi->item.choice == GroupItem_slider
					&& gi->item.u.slider.rootClass.inst.AvailabilityStatus
					&& gi->item.u.slider.rootClass.inst.RunningStatus
					&& gi->item.u.slider.inst.InteractionStatus)
				{
					slider = &gi->item.u.slider;
					break;
				}
				gi = gi->next;
			}

			HxLOG_Error("entry_field [%d], hyper_text [%d], slider [%d], key [%d], register [%d]\n", entry_field, hyper_text, slider, key, scene->input_event_register);

			if (entry_field)
			{
				key_consumed = MHEGEngine_checkKeyForEntryField(entry_field, key, scene->input_event_register);
			}
			else if (hyper_text)
			{
				key_consumed = MHEGEngine_checkKeyForHyperText(hyper_text, key, scene->input_event_register);
			}
			else if (slider)
			{
				key_consumed = MHEGEngine_checkKeyForSlider(slider, key, scene->input_event_register);
			}
		}

		if ((key_consumed == true) || (!key_consumed && MHEGEngine_isKeyAvailableForUserInput(key, scene->input_event_register)))
		{
			return true;
		}
	}

#endif

	return false;
}

/*
 * returns NULL if the file does not exist and create is false
 * if create is true and the file does not exist, a new (empty one) is created
 */

PersistentData *
MHEGEngine_findPersistentData(OctetString *filename, bool create)
{
	LIST_TYPE(PersistentData) *p = engine.persistent;

	while(p)
	{
		if(OctetString_cmp(&p->item.filename, filename) == 0)
			return &p->item;
		p = p->next;
	}

	/* not found, create it */
	if(create)
	{
		/* add it to the list */
		p = new_PersistentDataListItem(filename);
		LIST_APPEND(&engine.persistent, p);
	}

	return (p != NULL) ? &p->item : NULL;
}

/*
 * the event is processed immediately
 * if any of the active links match the event, add the link actions to the temp_actionq
 * the src should be a fully qualified reference (ie include the group identifier)
 * data (if not NULL) is used immediately, so doesn't need to remain valid after this call
 */

void
#if (EVT_VERBOSE < 1)
MHEGEngine_generateEvent(ExternalReference *src, EventType type, EventData *data)
#else
MHEGEngine_generateEvent_(ExternalReference *src, EventType type, EventData *data, char *caller, int line)
#endif
{
	LIST_TYPE(LinkClassPtr) *link;
	LIST_TYPE(ElementaryAction) *link_action;
	LIST_TYPE(MHEGAction) *temp_action;
	ExternalReference *ref; // hmkim : org is OctetString *gid;

	#if (EVT_VERBOSE < 1)
	verbose_event("Event: %s; %s", ExternalReference_name(src), EventType_name(type));
	#else
	verbose_event("Event: %s; %s - from %s() %d", ExternalReference_name(src), EventType_name(type), caller, line);
	#endif

	/* see if any of the active links match this event */
	link = engine.active_links;
	while(link)
	{
		/* if it matches, add the actions to the temp action queue */
		if(LinkClass_conditionMet(link->item, src, type, data))
		{
			/* add a ptr to each ElementaryAction to temp_actionq */
			link_action = link->item->link_effect;
			while(link_action)
			{
				/* remember the group id of the link that caused the action */
				ref = &link->item->rootClass.inst.ref; // hmkim : org is gid = &link->item->rootClass.inst.ref.group_identifier;
				temp_action = new_MHEGActionListItem(ref, &link_action->item); // hmkim : org is temp_action = new_MHEGActionListItem(gid, &link_action->item);
				LIST_APPEND(&engine.temp_actionq, temp_action);
				link_action = link_action->next;
			}
		}
		link = link->next;
	}

	return;
}

/*
 * the event is added to the async_eventq
 * it will be processed (ie matched against active links) when MHEGEngine_processNextAsyncEvent() is called
 * the src should be a fully qualified reference (ie include the group identifier)
 * makes a copy of src and data so they don't need to stay valid after this call
 */

void
#if (EVT_VERBOSE < 1)
MHEGEngine_generateAsyncEvent(ExternalReference *src, EventType type, EventData *data)
#else
MHEGEngine_generateAsyncEvent_(ExternalReference *src, EventType type, EventData *data, char *caller, int line)
#endif
{
	LIST_TYPE(MHEGAsyncEvent) *event;

	#if (EVT_VERBOSE < 1)
	verbose_event("AsyncEvent: %s; %s", ExternalReference_name(src), EventType_name(type));
	#else
	if(data)
	{
		switch(data->choice)
		{
		case EventData_boolean:
			verbose_event("AsyncEvent: %s; %s; boolean = %d - from %s() %d", ExternalReference_name(src), EventType_name(type), data->u.boolean, caller, line);
			break;

		case EventData_integer:
			verbose_event("AsyncEvent: %s; %s; integer = %d - from %s() %d", ExternalReference_name(src), EventType_name(type), data->u.integer, caller, line);
			break;

		case EventData_octetstring:
			verbose_event("AsyncEvent: %s; %s; string = %.*s - from %s() %d", ExternalReference_name(src), EventType_name(type), data->u.octetstring.size, data->u.octetstring.data, caller, line);
			break;
		}
	}
	else
	{
		verbose_event("AsyncEvent: %s; %s; no data - from %s() %d", ExternalReference_name(src), EventType_name(type), caller, line);
	}
	#endif

	event = new_MHEGAsyncEventListItem(src, type, data);

	if (engine.async_eventq == NULL)
		local_MHEGIB_SendMessage(MHEGIB_RUN_MSG_ASYNC_EVENT_GENERATED, src->object_number, type, 0);

	LIST_APPEND(&engine.async_eventq, event); // 여기서 append 된 event 는 이후 MHEGEngine_processMHEGEvents() -> MHEGEngine_processNextAsyncEvent() 에서 처리될 것이다.

	return;
}

/*
 * process all outstanding (async) events
 */

static void
MHEGEngine_processMHEGEvents(void)
{
	/* assert */
	if(engine.main_actionq != NULL)
	{
		fatal("Outstanding actions on the main action queue");
		return;
	}

	if (engine.async_eventq == NULL)
	{
		return;
	}

	/* process the next asynchronous event (if there is one) */
	while(engine.async_eventq)
	{
		/* adds any resulting actions to temp_actionq */
		MHEGEngine_processNextAsyncEvent();
		/* process MHEG event queue as described in UK MHEG Profile (D-BOOK 5.0) : section 13.13.3 and 13.13.4 */
		engine.main_actionq = engine.temp_actionq;
		engine.temp_actionq = NULL;
		while(engine.main_actionq)
		{
			/* execute the action - adds any resulting actions to temp_actionq */
			verbose("MHEGEngine_processMHEGEvents: %s, ElementaryAction (%s) calling...",
				ExternalReference_name(engine.main_actionq->item.ref), ElementaryAction_name(engine.main_actionq->item.action));
			ElementaryAction_execute(engine.main_actionq->item.action, engine.main_actionq->item.ref); // hmkim : org is ElementaryAction_execute(engine.main_actionq->item.action, engine.main_actionq->item.group_id);
			/* remove the action we just executed from the main_actionq */
			LIST_FREE_HEAD(&engine.main_actionq, MHEGAction, free_MHEGActionListItem);
			/* prepend any temp_actionq actions it generated to the main_actionq */
			LIST_CONCAT(&engine.temp_actionq, MHEGAction, engine.main_actionq);
			engine.main_actionq = engine.temp_actionq;
			engine.temp_actionq = NULL;
		}
	}

	/* redraw all the visible objects */
	/* ElementaryAction_execute() 에 의해 수행되는 모든 클래스 액션들은 만약 redraw 가 필요한 경우가 있다면 이 코드로 모두 커버가 된다.
	   따라서 각 클래스 액션에서 redraw 를 호출할 필요가 없다. */
	{
		XYPosition pos = {0, 0};
		OriginalBoxSize box = {MHEG_XRES, MHEG_YRES};

		MHEGEngine_redrawArea(&pos, &box);
	}

	return;
}

/*
 * match the head event in the async_eventq against the active links
 * if any active links fire, add the actions to the temp_actionq
 */

static void
MHEGEngine_processNextAsyncEvent(void)
{
	MHEGAsyncEvent *event;

	if(engine.async_eventq)
	{
//		verbose_event("Processing next asynchronous event");
		event = &engine.async_eventq->item;
		/* match it against any active links */
		MHEGEngine_generateEvent(&event->src, event->type, event->data);
		/* remove the event we just processed */
		LIST_FREE_HEAD(&engine.async_eventq, MHEGAsyncEvent, free_MHEGAsyncEventListItem);
	}

	return;
}

/*
 * add a ptr to each ElementaryAction to temp_actionq
 */

void
MHEGEngine_addToTempActionQ(ActionClass *action, ExternalReference *ref) // hmkim : org is MHEGEngine_addToTempActionQ(ActionClass *action, OctetString *caller_gid)
{
	LIST_TYPE(ElementaryAction) *list = *action;
	LIST_TYPE(MHEGAction) *temp_action;

	/* add a ptr to each ElementaryAction to temp_actionq */
	while(list)
	{
		/* remember the group id of the object that caused the action */
		temp_action = new_MHEGActionListItem(ref, &list->item); // hmkim : org is temp_action = new_MHEGActionListItem(caller_gid, &list->item);
		LIST_APPEND(&engine.temp_actionq, temp_action);
		list = list->next;
	}

	return;
}

/*
 * sets the group identifier that will be used in MHEGEngine_resolveDERObjectReference()
 * should be an absolute group ID, ie start with ~//
 */

void
MHEGEngine_setDERObject(OctetString *gid)
{
	#if 0 // hmkim : commented out (caller 쪽에서 체크한다)
	/* assert */
	if(MHEGEngine_isNotAbsoluteFilename(gid))
	{
		fatal("Group ID '%.*s' is not absolute", gid->size, gid->data);
		return;
	}
	#endif

	engine.der_object = gid;

	return;
}

/*
 * converts the ObjectReference into an ExternalReference
 * gives it the group identifier that was set with MHEGEngine_setDERObject()
 * this should only be called during DER decoding, all other times use MHEGEngine_findObjectReference()
 */

void
MHEGEngine_resolveDERObjectReference(ObjectReference *ref, ExternalReference *out)
{
	/* always give it the absolute group ID set with MHEGEngine_setDERObject() */
	OctetString_dup(&out->group_identifier, engine.der_object);

	/* find the object number */
	switch(ref->choice)
	{
	case ObjectReference_internal_reference:
		out->object_number = ref->u.internal_reference;
		break;

	case ObjectReference_external_reference:
		out->object_number = ref->u.external_reference.object_number;
		break;

	default:
		fatal("Unknown ObjectReference type: %d", ref->choice);
		break;
	}

	return;
}

/*
 * stores the ptr, so it must remain valid until MHEGEngine_removeObjectReference() is called
 */

void
MHEGEngine_addObjectReference(RootClass *obj)
{
	LIST_TYPE(RootClassPtr) *list = safe_malloc(sizeof(LIST_TYPE(RootClassPtr)));

	list->item = obj;

	LIST_APPEND(&engine.objects, list);

	return;
}

void
MHEGEngine_removeObjectReference(RootClass *obj)
{
	LIST_TYPE(RootClassPtr) *list = engine.objects;

	while(list)
	{
		if(list->item == obj)
		{
			LIST_REMOVE(&engine.objects, list);
			safe_free(list);
			return;
		}
		list = list->next;
	}

	/* assert */
	fatal("ObjectReference not found: %s", ExternalReference_name(&obj->inst.ref));

	/* not reached */
	return;
}

/*
 * if the ObjectReference does not contain a group id of its own, the caller_gid will be used
 * returns NULL if the object has not been added with MHEGEngine_addObjectReference()
 */

RootClass *
#if (ENG_VERBOSE < 1)
MHEGEngine_findObjectReference(ObjectReference *ref, OctetString *caller_gid)
#else
MHEGEngine_findObjectReference_(ObjectReference *ref, OctetString *caller_gid, char *caller, int line)
#endif
{
	LIST_TYPE(RootClassPtr) *list = engine.objects;
	OctetString *gid = NULL;	/* keep the compiler happy */
	unsigned int num = 0;		/* keep the compiler happy */
	char *fullname;
	OctetString absolute;
	RootClass *obj;

	/* find the group id we need */
	switch(ref->choice)
	{
	case ObjectReference_internal_reference:
		gid = caller_gid;
		num = ref->u.internal_reference;
		break;

	case ObjectReference_external_reference:
		gid = &ref->u.external_reference.group_identifier;
		num = ref->u.external_reference.object_number;
		break;

	default:
		#if (ENG_VERBOSE < 1)
		fatal("Unknown ObjectReference type: %d", ref->choice);
		#else
		fatal("Unknown ObjectReference type: %d - from %s() %d", ref->choice, caller, line);
		#endif
		return NULL;
	}

	/* get the absolute group ID */
	fullname = MHEGEngine_absoluteFilename(gid);
	absolute.size = strlen(fullname);
	absolute.data = (unsigned char *) fullname;
	gid = &absolute;

	while(list)
	{
		obj = list->item;
		if(OctetString_cmp(gid, &obj->inst.ref.group_identifier) == 0
		&& num == obj->inst.ref.object_number)
		{
			return list->item;
		}
		list = list->next;
	}

	#if (ENG_VERBOSE < 1)
	verbose("ObjectReference not found: %.*s %u", gid->size, gid->data, num);
	#else
	verbose("ObjectReference not found: %.*s %u - from %s() %d", gid->size, gid->data, num, caller, line);
	#endif

	return NULL;
}

/*
 * returns either the active Scene or the active Application
 * returns NULL if the given group ID does not match either
 * group ID should be absolute (ie start with ~//)
 */

RootClass *
MHEGEngine_findGroupObject(OctetString *gid)
{
	ApplicationClass *app;
	SceneClass *scene;

#if 0 // org

	/* assert */
	if(MHEGEngine_isNotAbsoluteFilename(gid))
	{
		fatal("Group ID '%.*s' is not absolute", gid->size, gid->data);
		return NULL;
	}

	/* is it the app */
	if((app = MHEGEngine_getActiveApplication()) == NULL)
	{
		error("Can't find ApplicationClass");
		return NULL;
	}
	if(OctetString_cmp(&app->rootClass.inst.ref.group_identifier, gid) == 0)
		return &app->rootClass;

	/* is it the scene */
	if((scene = MHEGEngine_getActiveScene()) == NULL)
	{
		error("Can't find SceneClass");
		return NULL;
	}
	if(OctetString_cmp(&scene->rootClass.inst.ref.group_identifier, gid) == 0)
		return &scene->rootClass;

#else // hmkim : modified.

	char *absolute = MHEGEngine_absoluteFilename(gid);

	/* is it the app */
	if((app = MHEGEngine_getActiveApplication()) == NULL)
	{
		error("Can't find ApplicationClass");
		return NULL;
	}
	if(OctetString_strcmp(&app->rootClass.inst.ref.group_identifier, absolute) == 0)
		return &app->rootClass;

	/* is it the scene */
	if((scene = MHEGEngine_getActiveScene()) == NULL)
	{
		error("Can't find SceneClass");
		return NULL;
	}
	if(OctetString_strcmp(&scene->rootClass.inst.ref.group_identifier, absolute) == 0)
		return &scene->rootClass;

#endif

	return NULL;
}

/*
 * returns an object number which is not used in the given GroupClass
 * group should be either an ApplicationClass or a SceneClass object
 * returns 0 if group is NULL or there are no free object numbers left (very unlikely)
 */

unsigned int
MHEGEngine_getUnusedObjectNumber(RootClass *group)
{
	LIST_TYPE(GroupItem) *items, *gi;
	unsigned int next_clone;
	bool unused;
	RootClass *r;

	if(group == NULL)
		return 0;

	/* get a ptr to the list of GroupItems */
	if(group->inst.rtti == RTTI_ApplicationClass)
	{
		items = ((ApplicationClass *) group)->items;
		next_clone = ((ApplicationClass *) group)->inst.next_clone;
	}
	else if(group->inst.rtti == RTTI_SceneClass)
	{
		items = ((SceneClass *) group)->items;
		next_clone = ((SceneClass *) group)->inst.next_clone;
	}
	else
	{
		return 0;
	}

	/* find the next unused object number starting at next_clone */
	unused = false;
	while(!unused)
	{
		next_clone ++;
		/* stop infinite loops */
		if(next_clone == 0)
			return 0;
		/* do any of the existing objects use this number */
		unused = true;
		gi = items;
		while(unused && gi)
		{
			if((r = GroupItem_rootClass(&gi->item)) != NULL)
				unused = (r->inst.ref.object_number != next_clone);
			gi = gi->next;
		}
	}

	/* save the object number search point for next time */
	if(group->inst.rtti == RTTI_ApplicationClass)
		((ApplicationClass *) group)->inst.next_clone = next_clone;
	else
		((SceneClass *) group)->inst.next_clone = next_clone;

	return next_clone;
}

/*
 * add the given file to the missing_content list
 * removes any previous missing content entry for this object
 * sets the objects need_content flag to true
 * the event loop polls for all the files in the missing_content list
 * when a file appears, the associated objects' contentAvailable() method is called
 * and a ContentAvailable event is generated
 * takes a copy of the file OctetString so it doesn't need to remain valid
 */

void
MHEGEngine_addMissingContent(RootClass *obj, OctetString *file)
{
	LIST_TYPE(MissingContent) *missing;

#if 1 // hmkim : added (이미 missing content list 에 추가된 것이라면... 정상적이라면 이런 경우는 없을 것 같으나 만일을 위해 추가해 둠)
{
	LIST_TYPE(MissingContent) *list = engine.missing_content;
	char *absolute = MHEGEngine_absoluteFilename(file);

	while (list)
	{
		if (OctetString_strcmp(&list->item.file.name, absolute) == 0)
		{
			error("MissingContent: '%.*s' exist (%s)", list->item.file.name.size, list->item.file.name.data, MHEGEngine_RTTI_name(list->item.obj->inst.rtti));
			return;
		}
		list = list->next;
	}
}
#endif

	/* does it have an existing entry */
	if(obj->inst.need_content)
		MHEGEngine_removeMissingContent(obj); // TODO : 이거 제거할 게 아니라 그냥 리턴하는게 좋지 않나? 확인 필요...

	/* so RootClass_Preparation wont generate a ContentAvailable event */
	obj->inst.need_content = true;

	/* add it to the list */
	missing = new_MissingContentListItem(obj, file);
	verbose("MissingContent: [%d] '%.*s' add (%s)", missing->item.file.name.size, missing->item.file.name.size, missing->item.file.name.data, MHEGEngine_RTTI_name(missing->item.obj->inst.rtti));
	LIST_APPEND(&engine.missing_content, missing);

#if 1 // hmkim : added.
{
	char *ext_fn;
	int ext_fn_len;

	ext_fn = MHEGEngine_externalFilename(file);
	ext_fn_len = strlen(ext_fn);

	if(ext_fn_len > 5 // 뒤에 최소 1자 이상의 이름이 있는지 체크하기 위해 >= 가 아니라 > 로 확인한다.
		&& strncmp((char *) ext_fn, MHEG_SRG_LOC_CI, 5) == 0)
	{
		//ycgo_Hx_Print
		HxLOG_Print("MHEGEngine_addMissingContent[%d][%s]\n", ext_fn_len, ext_fn);
		if (s_stMhegIbAmmiContext.usSessionId == 0 || MHEGIB_FileRequst(s_stMhegIbAmmiContext.usSessionId, eMhegIb_Ad_ReqType_File, ext_fn, ext_fn_len))
		{
			error("MHEGIB_FileRequst (%d, %s) failed", s_stMhegIbAmmiContext.usSessionId, ext_fn);
		}
	}
	else if(ext_fn_len > 6 // 뒤에 최소 1자 이상의 이름이 있는지 체크하기 위해 >= 가 아니라 > 로 확인한다.
		&& strncmp((char *) ext_fn, MHEG_SRG_LOC_DSM, 6) == 0)
	{
		verbose_todo("%s; DSM:", __FUNCTION__);
	}
	else
	{
		error("MissingContent: '%.*s' can't be requested", file->size, file->data);

		missing->item.obj->inst.need_content = false;
		LIST_REMOVE(&engine.missing_content, missing);
		free_MissingContentListItem(missing);
	}
}
#endif

	return;
}

void
MHEGEngine_removeMissingContent(RootClass *obj)
{
	LIST_TYPE(MissingContent) *list = engine.missing_content;

	/* just to avoid any confusion */
	obj->inst.need_content = false;

	while(list)
	{
		if(list->item.obj == obj)
		{
			verbose("MissingContent: '%.*s' remove (%s)", list->item.file.name.size, list->item.file.name.data, MHEGEngine_RTTI_name(list->item.obj->inst.rtti));
			LIST_REMOVE(&engine.missing_content, list);
			free_MissingContentListItem(list);
			return;
		}
		list = list->next;
	}

	/* assert */
	fatal("MissingContent Object not found: %s", ExternalReference_name(&obj->inst.ref));

	/* not reached */
	return;
}

void
MHEGEngine_pollMissingContent(bool do_post_action)
{
	LIST_TYPE(MissingContent) *missing, *next_missing;
	LIST_TYPE(ReceivedContent) *received, *next_received;
	struct timeval now;
	SceneClass *current_scene = MHEGEngine_getActiveScene();
	ApplicationClass *current_app = MHEGEngine_getActiveApplication();
	OctetString *app_gid;
	LIST_TYPE(MHEGAsyncEvent) *ev, *next_ev;
	LIST_TYPE(MHEGAction) *act, *next_act;
	LIST_TYPE(GroupItem) *gi;
	LIST_TYPE(GroupItem) *gi_tail;

	/* assert */
	if (current_app == NULL)
	{
		error("Can't find ApplicationClass");
		return;
	}

	MHEGEngine_enterCriticalMissingContent;
	missing = engine.missing_content;
	while(missing)
	{
		/* assert */
		if (missing->item.obj == NULL)
		{
			error("Can't find RootClass");
			missing = missing->next;
			continue;
		}

		if(missing->item.file.content.size && missing->item.file.content.data)
		{
			verbose("MissingContent: '%.*s' received (%s)", missing->item.file.name.size, missing->item.file.name.data, MHEGEngine_RTTI_name(missing->item.obj->inst.rtti));

			/* move it from the missing content list to the temporal content list */
			next_missing = missing->next;
			LIST_MOVE(&engine.missing_content, &engine.temp_content, missing);
			missing = next_missing;
		}
		else
		{
			/* has it timed out */
			gettimeofday(&now, NULL);
			/* <= means timeout=0 generates a ContentRefError immediately */
			if(missing->item.requested + MISSING_CONTENT_TIMEOUT <= now.tv_sec || missing->item.received == -1)
			{
				EventData event_tag;

				verbose("MissingContent: '%.*s' timeout (%s)", missing->item.file.name.size, missing->item.file.name.data, MHEGEngine_RTTI_name(missing->item.obj->inst.rtti));

				#if 0 // org
				/* generate a ContentRefError EngineEvent */
				event_tag.choice = EventData_integer;
				event_tag.u.integer = EngineEvent_ContentRefError;
				MHEGEngine_generateAsyncEvent(&current_app->rootClass.inst.ref, EventType_engine_event, &event_tag);
				#else // hmkim : modified.
				if(missing->item.obj->inst.rtti == RTTI_ApplicationClass || missing->item.obj->inst.rtti == RTTI_SceneClass)
				{
					/* generate a GroupIDRefError EngineEvent */
					event_tag.choice = EventData_integer;
					event_tag.u.integer = EngineEvent_GroupIDRefError;
					MHEGEngine_generateAsyncEvent(&current_app->rootClass.inst.ref, EventType_engine_event, &event_tag);
				}
				else
				{
					/* generate a ContentRefError EngineEvent */
					event_tag.choice = EventData_integer;
					event_tag.u.integer = EngineEvent_ContentRefError;
					MHEGEngine_generateAsyncEvent(&current_app->rootClass.inst.ref, EventType_engine_event, &event_tag);
				}
				#endif

				/* clear the need_content flag */
				missing->item.obj->inst.need_content = false;

				/* remove it from the list */
				next_missing = missing->next;
				LIST_REMOVE(&engine.missing_content, missing);
				free_MissingContentListItem(missing);
				missing = next_missing;
			}
			else
			{
				missing = missing->next;
			}
		}
	}
	MHEGEngine_leaveCriticalMissingContent;

	received = engine.temp_content;
	while(received)
	{
		/* assert */
		if (received->item.obj == NULL)
		{
			error("Can't find RootClass");
			received = received->next;
			continue;
		}

		verbose("MissingContent: '%.*s' processing (%s)", received->item.file.name.size, received->item.file.name.data, MHEGEngine_RTTI_name(received->item.obj->inst.rtti));

		/* move it from the temporal content list to the received content list or received bitmap list */
		next_received = received->next;
		if (received->item.obj->inst.rtti == RTTI_BitmapClass)
			LIST_MOVE(&engine.temp_content, &engine.received_bitmap, received);
		else
			LIST_MOVE(&engine.temp_content, &engine.received_content, received);

		if (do_post_action)
		{
			if(received->item.obj->inst.rtti == RTTI_ApplicationClass || received->item.obj->inst.rtti == RTTI_SceneClass) // TODO : Application 클래스 처리...
			{
				/* see MHEGEngine_TransitionTo() */

				/*
				 * do Deactivation of all Ingredients in the current app that are not shared
				 * in the reverse order they appear in the items list
				 */
				gi = current_app->items;
				/* get the tail of the list */
				gi_tail = (current_app->items != NULL) ? current_app->items->prev : NULL;
				while(gi)
				{
					/* only do Deactivation if it is not shared */
					if(!GroupItem_isShared(&gi->item))
						GroupItem_Deactivation(&gi->item);
					/* have we reached the head */
					gi = (gi->prev != gi_tail) ? gi->prev : NULL;
				}
				/* do Deactivation and Destruction on the current scene */
				if(current_scene != NULL)
				{
					verbose("Deactivation and Destruction on %s", ExternalReference_name(&current_scene->rootClass.inst.ref));
					SceneClass_Deactivation(current_scene);
					SceneClass_Destruction(current_scene);
				}
				/*
				 * now the old scene is destroyed,
				 * remove its events from the Async event queue and its pending actions
				 * keep events and actions associated with the app
				 */
				app_gid = &current_app->rootClass.inst.ref.group_identifier;
				/* async event queue */
				ev = engine.async_eventq;
				while(ev)
				{
					next_ev = ev->next;
					if(OctetString_cmp(&ev->item.src.group_identifier, app_gid) != 0)
					{
						LIST_REMOVE(&engine.async_eventq, ev);
						free_MHEGAsyncEventListItem(ev);
					}
					ev = next_ev;
				}
				/* main action queue */
				act = engine.main_actionq;
				while(act)
				{
					next_act = act->next;
					if(OctetString_cmp(&act->item.ref->group_identifier, app_gid) != 0)
					{
						LIST_REMOVE(&engine.main_actionq, act);
						free_MHEGActionListItem(act);
					}
					act = next_act;
				}
				/* temp action queue */
				act = engine.temp_actionq;
				while(act)
				{
					next_act = act->next;
					if(OctetString_cmp(&act->item.ref->group_identifier, app_gid) != 0)
					{
						LIST_REMOVE(&engine.temp_actionq, act);
						free_MHEGActionListItem(act);
					}
					act = next_act;
				}
				/* load the new scene (also free's the old one if we have one) */
				if((current_scene = MHEGApp_loadScene(&engine.active_app, &received->item.file.name)) != NULL)
				{
					/* do Preparation and Activation */
					SceneClass_Preparation(current_scene);
					SceneClass_Activation(current_scene);
				}
			}
			else
			{
				RootClass_contentAvailable(received->item.obj, &received->item.file.name);
			}
		}

		received = next_received;
	}

	if (engine.temp_content)
	{
		error("Temporal content list not empty"); // 이런 에러가 난다면 뭔가 코딩 오류이겠지... 디버깅 필요!!
		LIST_FREE(&engine.temp_content, ReceivedContent, free_ReceivedContentListItem);
	}

	return;
}

MHEGFileObject *
MHEGEngine_getReceivedContent(char *name)
{
	LIST_TYPE(ReceivedContent) *list = engine.received_content;

	while (list)
	{
		verbose("MissingContent: name in list(%d)(%s) name(%d)(%s)", list->item.file.name.size, list->item.file.name.data, strlen(name), name);
		if (OctetString_strcmp(&list->item.file.name, name) == 0)
		{
			return &list->item.file;
		}
		list = list->next;
	}

	return NULL;
}

MHEGFileObject *
MHEGEngine_getReceivedBitmap(char *name)
{
	LIST_TYPE(ReceivedContent) *list = engine.received_bitmap;

	while (list)
	{
		if (OctetString_strcmp(&list->item.file.name, name) == 0)
		{
			return &list->item.file;
		}
		list = list->next;
	}

	return NULL;
}

/*
 * returns true if the file exists on the carousel
 */

bool
MHEGEngine_checkContentRef(ContentReference *name)
{
	/* just in case */
	if(name == NULL || name->size == 0 || name->data == NULL)
	{
		error("No filename given");
		return false;
	}

	if(engine.backend.fns->checkContentRef)
	{
		return (*(engine.backend.fns->checkContentRef))(&engine.backend, name);
	}
	else
	{
		error("No function given");
		return false;
	}
}

/*
 * file contents are stored in out (out->data will need to be free'd)
 * returns false if it can't load the file (out will be {0,NULL})
 * out should be uninitialised before calling this
 */

bool
MHEGEngine_loadFile(OctetString *name, OctetString *out)
{
	/* in case it fails */
	out->size = 0;
	out->data = NULL;

	/* just in case */
	if(name == NULL || name->size == 0 || name->data == NULL)
	{
		error("No filename given");
		return false;
	}

	if(engine.backend.fns->loadFile)
	{
		return (*(engine.backend.fns->loadFile))(&engine.backend, name, out);
	}
	else
	{
		error("No function given");
		return false;
	}
}

/*
 * returns a read-only FILE handle for the given carousel file
 * returns NULL on error
 */

FILE *
MHEGEngine_openFile(OctetString *name)
{
	/* just in case */
	if(name == NULL || name->size == 0 || name->data == NULL)
	{
		error("No filename given");
		return NULL;
	}

	if(engine.backend.fns->openFile)
	{
		return (*(engine.backend.fns->openFile))(&engine.backend, name);
	}
	else
	{
		error("No function given");
		return NULL;
	}
}

/*
 * return a read-only FILE handle for an MPEG Transport Stream
 * the TS will contain an audio stream (if have_audio is true) and a video stream (if have_video is true)
 * the *audio_tag and *video_tag numbers refer to Component/Association Tag values from the DVB PMT
 * if *audio_tag or *video_tag is -1, the default audio and/or video stream for the current Service ID is used
 * updates *audio_tag and/or *video_tag to the actual PIDs in the Transport Stream
 * returns NULL on error
 */

MHEGStream *
MHEGEngine_openStream(int service_id, bool have_audio, int *audio_tag, int *audio_type, bool have_video, int *video_tag, int *video_type)
{
	if(engine.backend.fns->openStream)
	{
		return (*(engine.backend.fns->openStream))(&engine.backend,
							   service_id,
							   have_audio, audio_tag, audio_type,
							   have_video, video_tag, video_type);
	}
	else
	{
		error("No function given");
		return NULL;
	}
}

void
MHEGEngine_closeStream(MHEGStream *stream)
{
	if(engine.backend.fns->closeStream)
	{
		return (*(engine.backend.fns->closeStream))(&engine.backend, stream);
	}
	else
	{
		error("No function given");
	}
}

/*
 * retune the backend to the given service
 * service should be in the form MHEG_DVB_SERVICE - "dvb://<network_id>..<service_id>", eg "dvb://233a..4C80"
 */

void
MHEGEngine_retune(OctetString *service)
{
	if(engine.backend.fns->retune)
	{
		return (*(engine.backend.fns->retune))(&engine.backend, service);
	}
	else
	{
		error("No function given");
	}
}

/*
 * return a read-only MHEG_DVB_SERVICE format value for MHEG_REC_SVC_DEF
 */

const OctetString *
MHEGEngine_getRecSvcDef(void)
{
	/* ask the backend */
	if(engine.backend.fns->getServiceURL)
	{
		return (*(engine.backend.fns->getServiceURL))(&engine.backend, 1, NULL);
	}
	else
	{
		fatal("No function given");
		return NULL;
	}
}

/*
 * return a read-only MHEG_DVB_SERVICE format value for MHEG_REC_SVC_CUR
 */

const OctetString *
MHEGEngine_getRecSvcCur(void)
{
	/* TODO */
	// need to keep track of this ourselves
	// initially svc/cur = svc/def
	// only changes if SetData called on StreamClass
	// retune => reset to svc/cur = svc/def again?
	// verbose_todo("%s; returning %s instead", __FUNCTION__, MHEG_REC_SVC_DEF);
	if(engine.backend.fns->getServiceURL)
	{
		return (*(engine.backend.fns->getServiceURL))(&engine.backend, 2, NULL);
	}
	else
	{
		fatal("No function given");
		return NULL;
	}
}

/*
 * return a read-only MHEG_DVB_SERVICE format value for MHEG_REC_SVC_LCN
 */

const OctetString *
MHEGEngine_getRecSvcLcn(OctetString *ref)
{
	/* ask the backend */
	if(engine.backend.fns->getServiceURL)
	{
		return (*(engine.backend.fns->getServiceURL))(&engine.backend, 3, ref);
	}
	else
	{
		fatal("No function given");
		return NULL;
	}
}

/*
 * return true if the engine is able to receive the given service
 * service should be in the form MHEG_DVB_SERVICE - "dvb://<network_id>..<service_id>", eg "dvb://233a..4C80"
 */

bool
MHEGEngine_isServiceAvailable(OctetString *service)
{
	/* ask the backend */
	if(engine.backend.fns->isServiceAvailable)
	{
		return (*(engine.backend.fns->isServiceAvailable))(&engine.backend, service);
	}
	else
	{
		error("No function given");
		return false;
	}
}

/*
 * returns the absolute group ID, ie it always starts with "~//"
 * returns a ptr to static string that will be overwritten by the next call to this routine
 * section 8.3.2 of the UK MHEG Profile says the filename prefixes are:
 * // for the root
 * / for the path to the current active app
 */

static char _active_app_path[PATH_MAX];

static char *
active_app_path(void)
{
	ApplicationClass *app = MHEGEngine_getActiveApplication();
	OctetString *gid;
	char *slash;

	/* assert */
	if (app == NULL)
	{
		error("Can't find ApplicationClass");
		return NULL;
	}

	gid = &app->rootClass.inst.ref.group_identifier;

	/* assert */
	if(gid->size < 3 || strncmp((char *) gid->data, "~//", 3) != 0)
	{
		fatal("Invalid group ID '%.*s'", gid->size, gid->data);
		return NULL;
	}

	snprintf(_active_app_path, sizeof(_active_app_path), "%.*s", gid->size, gid->data);

	/* chop off the trailing '/filename' */
	slash = strrchr(_active_app_path, '/');
	/* assert above means it will never be NULL */
	*slash = '\0';

	verbose_file("active_app_path: '%.*s' -> %s", gid->size, gid->data, _active_app_path);

	return _active_app_path;
}

bool
MHEGEngine_isNotAbsoluteFilename(OctetString *name)
{
	if(name->size < 3 || strncmp((char *) name->data, "~//", 3) != 0)
		return true;
	else
		return false;
}

static char _absolute[PATH_MAX];

char *
MHEGEngine_absoluteFilename(OctetString *name)
{
	unsigned int size;
	unsigned char *data;

	/* CI: at the start is equivalent to ~ */
	if(name->size > 2 && strncmp((char *) name->data, MHEG_SRG_SRC_CI, 3) == 0)
	{
//		verbose_todo("%s; absoluteFilename '%.*s'", __FUNCTION__, name->size, name->data);
		#if 1 // hmkim : added.
		size = name->size - 3;
		data = &name->data[3];
		#endif
	}
	/* DSM: at the start is equivalent to ~ */
	else if(name->size > 3 && strncmp((char *) name->data, MHEG_SRG_SRC_DSM, 4) == 0)
	{
		size = name->size - 4;
		data = &name->data[4];
	}
	else
	{
		size = name->size;
		data = name->data;
	}

	/* does it already start with a ~// */
	if(size > 2 && strncmp((char *) data, "~//", 3) == 0)
		snprintf(_absolute, sizeof(_absolute), "%.*s", size, data);
	/* starting with // is the same as starting with ~// */
	else if(size > 1 && strncmp((char *) data, "//", 2) == 0)
		snprintf(_absolute, sizeof(_absolute), "~%.*s", size, data);
	/* starting with ~/ means prepend the path to the current active app */
	else if(size > 1 && strncmp((char *) data, "~/", 2) == 0)
		snprintf(_absolute, sizeof(_absolute), "%s%.*s", active_app_path(), size - 1, &data[1]);
	/* starting with / is the same as starting with ~/ */
	else if(size > 0 && data[0] == '/')
		snprintf(_absolute, sizeof(_absolute), "%s%.*s", active_app_path(), size, data);
	/* no / at the start, UK Profile doesn't say what to do, so prepend the path to the current active app */
	else if(size > 0)
				snprintf(_absolute, sizeof(_absolute), "%s/%.*s", active_app_path(), size, data);
	/* no name at all */
	else
		snprintf(_absolute, sizeof(_absolute), "%s/", active_app_path());

	verbose_file("absolute file name: '%.*s' -> %s", name->size, name->data, _absolute);

	return _absolute;
}

/*
 * returns a filename that can be loaded from the file system
 * ie ~// at the start of the absolute name is replaced with base_dir
 * returns a ptr to a static string that will be overwritten by the next call to this routine
 */

static char _external[PATH_MAX];

char *
MHEGEngine_externalFilename(OctetString *name)
{
	char *absolute;

	/* convert it to an absolute group id, ie with a "~//" at the start */
	absolute = MHEGEngine_absoluteFilename(name);

	/* construct the filename */
	snprintf(_external, sizeof(_external), "%s%s", engine.backend.base_dir, &absolute[3]); // hmkim : absolute[2] -> absolute[3]

	verbose_file("external file name: '%s'", _external);

	return _external;
}

/*
 * if have_hook is true, hook should be either MHEG_ContentHook_Bitmap_MPEG or MHEG_ContentHook_Bitmap_PNG
 * if have_hook is false, default hook is MHEG_ContentHook_Bitmap_PNG
 * Channel 4 sometimes has the wrong content hook, so if the data has a PNG signature treat it as PNG
 */

MHEGBitmap *
MHEGEngine_newBitmap(OctetString *data, bool have_hook, int hook)
{
	MHEGBitmap *bitmap = NULL;

	if(have_hook == false
	|| (have_hook == true && hook == MHEG_ContentHook_Bitmap_PNG)
	|| (data->size >= 8 && png_check_sig(data->data, 8)))
		bitmap = MHEGDisplay_newPNGBitmap(&engine.display, data);
	else if(have_hook == true && hook == MHEG_ContentHook_Bitmap_MPEG)
		bitmap = MHEGDisplay_newMPEGBitmap(&engine.display, data);
	else
		error("Unknown BitmapClass content hook: %d,%d", have_hook, hook);

	return bitmap;
}

void
MHEGEngine_freeBitmap(MHEGBitmap *bitmap)
{
	MHEGDisplay_freeBitmap(&engine.display, bitmap);

	return;
}

char *
MHEGEngine_RTTI_name(RunTimeTypeInfo rtti)
{
	switch(rtti)
	{
	case RTTI_Unknown :
		return "Unknown";

	case RTTI_ApplicationClass :
		return "Application";

	case RTTI_SceneClass :
		return "Scene";

	case RTTI_LinkClass :
		return "Link";

	case RTTI_ResidentProgramClass :
		return "ResidentProgram";

	case RTTI_RemoteProgramClass :
		return "RemoteProgram";

	case RTTI_InterchangedProgramClass :
		return "InterchangedProgram";

	case RTTI_PaletteClass :
		return "Palette";

	case RTTI_FontClass :
		return "Font";

	case RTTI_CursorShapeClass :
		return "CursorShape";

	case RTTI_VariableClass :
		return "Variable";

	case RTTI_TokenGroupClass :
		return "TokenGroup";

	case RTTI_ListGroupClass :
		return "ListGroup";

	case RTTI_BitmapClass :
		return "Bitmap";

	case RTTI_LineArtClass :
		return "LineArt";

	case RTTI_RectangleClass :
		return "Rectangle";

	case RTTI_DynamicLineArtClass :
		return "DynamicLineArt";

	case RTTI_TextClass :
		return "Text";

	case RTTI_StreamClass :
		return "Stream";

	case RTTI_AudioClass :
		return "Audio";

	case RTTI_VideoClass :
		return "Video";

	case RTTI_RTGraphicsClass :
		return "RTGraphics";

	case RTTI_SliderClass :
		return "Slider";

	case RTTI_EntryFieldClass :
		return "EntryField";

	case RTTI_HyperTextClass :
		return "HyperText";

	case RTTI_HotspotClass :
		return "Hotspot";

	case RTTI_PushButtonClass :
		return "PushButton";

	case RTTI_SwitchButtonClass :
		return "SwitchButton";

	default:
		error("Unknown runtime type: %d", rtti);
		return NULL;
	}
}

#ifdef DEBUG_ENGINE

void
MHEGEngine_print(void)
{
	ApplicationClass *app;
	SceneClass *scene;

	LIST_TYPE(RootClassPtr) *r_ptr;
	LIST_TYPE(MissingContent) *missing_content;
	LIST_TYPE(ReceivedContent) *received_content;
	LIST_TYPE(LinkClassPtr) *l_ptr;
	LIST_TYPE(MHEGAsyncEvent) *async_eventq;
	LIST_TYPE(MHEGAction) *actionq;
	LIST_TYPE(PersistentData) *persistent;

	LIST_TYPE(GroupItem) *gi;
	LIST_TYPE(DefaultAttribute) *da;
	LIST_TYPE(Timer) *timer;
	LIST_TYPE(MHEGTimer) *mt;
	LIST_TYPE(NextScene) *ns;
	LIST_TYPE(ElementaryAction) *ea;

	int sum;

	if (!(g_MhegIbDbgFlag & MHEG_IB_DBG_MASK_MAIN))
		return;

	HLIB_CMD_Printf("\n- Engine Data Info (EngineStatus = %d on profile 0x%x) -\n\n", engine.status, MHEGIB_GetProfile());

	HLIB_CMD_Printf("* Active Application Info\n");
	app = engine.active_app.app ? MHEGEngine_getActiveApplication() : NULL;
	if (app)
	{
		HLIB_CMD_Printf("\tRootClass :\n");
//		VK_Print("\t\tObjectReference = %s (%s)\n", ObjectReference_name(&app->rootClass.ObjectReference), MHEGEngine_RTTI_name(app->rootClass.inst.rtti)); // RTTI_ApplicationClass
		HLIB_CMD_Printf("\t\tExternalReference = %s (%s)\n", ExternalReference_name(&app->rootClass.inst.ref), MHEGEngine_RTTI_name(app->rootClass.inst.rtti)); // RTTI_ApplicationClass
		HLIB_CMD_Printf("\t\t%s, %s, %s\n",
			app->rootClass.inst.need_content ? "content need" : "content ok",
			app->rootClass.inst.AvailabilityStatus ? "available" : "not available",
			app->rootClass.inst.RunningStatus ? "running" : "not running");

		HLIB_CMD_Printf("\titems :\n");
		gi = app->items;
		while (gi)
		{
			GroupItem_print(&gi->item);
			gi = gi->next;
		}

		HLIB_CMD_Printf("\tdefault_attributes :\n");
		da = app->default_attributes;
		while (da)
		{
			HLIB_CMD_Printf("\t\tdata found (%d)\n", da->item.choice);
			da = da->next;
		}

		HLIB_CMD_Printf("\tTimers :\n");
		timer = app->inst.Timers;
		while (timer)
		{
			HLIB_CMD_Printf("\t\tdata found (%d:%d)\n", timer->item.id, (int)timer->item.mheg_id);
			timer = timer->next;
		}

		HLIB_CMD_Printf("\tremoved_timers :\n");
		mt = app->inst.removed_timers;
		while (mt)
		{
			HLIB_CMD_Printf("\t\tdata found (%d)\n", (int)mt->item);
			mt = mt->next;
		}

		HLIB_CMD_Printf("\tLockCount = %d\n", app->inst.LockCount);

		HLIB_CMD_Printf("\tDisplayStack :\n");
		r_ptr = app->inst.DisplayStack;
		while (r_ptr)
		{
//			VK_Print("\t\tObjectReference = %s (%s)\n", ObjectReference_name(&r_ptr->item->ObjectReference), MHEGEngine_RTTI_name(r_ptr->item->inst.rtti));
			HLIB_CMD_Printf("\t\tExternalReference = %s (%s)\n", ExternalReference_name(&r_ptr->item->inst.ref), MHEGEngine_RTTI_name(r_ptr->item->inst.rtti));
			r_ptr = r_ptr->next;
		}
	}

	HLIB_CMD_Printf("* Active Scene Info\n");
	scene = MHEGEngine_getActiveScene();
	if (scene)
	{
		HLIB_CMD_Printf("\tRootClass :\n");
//		VK_Print("\t\tObjectReference = %s (%s)\n", ObjectReference_name(&scene->rootClass.ObjectReference), MHEGEngine_RTTI_name(scene->rootClass.inst.rtti)); // RTTI_SceneClass
		HLIB_CMD_Printf("\t\tExternalReference = %s (%s)\n", ExternalReference_name(&scene->rootClass.inst.ref), MHEGEngine_RTTI_name(scene->rootClass.inst.rtti)); // RTTI_SceneClass
		HLIB_CMD_Printf("\t\t%s, %s, %s\n",
			scene->rootClass.inst.need_content ? "content need" : "content ok",
			scene->rootClass.inst.AvailabilityStatus ? "available" : "not available",
			scene->rootClass.inst.RunningStatus ? "running" : "not running");

		HLIB_CMD_Printf("\titems :\n");
		gi = scene->items;
		while (gi)
		{
			GroupItem_print(&gi->item);
			gi = gi->next;
		}

		HLIB_CMD_Printf("\tinput_event_register : %d\n", scene->input_event_register);

		HLIB_CMD_Printf("\tnext_scenes :\n");
		ns = scene->next_scenes;
		while (ns)
		{
			HLIB_CMD_Printf("\t\tdata found (%.*s)\n", ns->item.scene_ref.size, ns->item.scene_ref.data);
			ns = ns->next;
		}

		HLIB_CMD_Printf("\tTimers :\n");
		timer = scene->inst.Timers;
		while (timer)
		{
			HLIB_CMD_Printf("\t\tdata found (%d:%d)\n", timer->item.id, (int)timer->item.mheg_id);
			timer = timer->next;
		}

		HLIB_CMD_Printf("\tremoved_timers :\n");
		mt = scene->inst.removed_timers;
		while (mt)
		{
			HLIB_CMD_Printf("\t\tdata found (%d)\n", (int)mt->item);
			mt = mt->next;
		}
	}

	HLIB_CMD_Printf("* Objects Info\n");
	r_ptr = engine.objects;
	if (r_ptr)
	{
//		VK_Print("\tObjectReference = %s (%s)\n", ObjectReference_name(&r_ptr->item->ObjectReference), MHEGEngine_RTTI_name(r_ptr->item->inst.rtti));
		HLIB_CMD_Printf("\tExternalReference = %s (%s)\n", ExternalReference_name(&r_ptr->item->inst.ref), MHEGEngine_RTTI_name(r_ptr->item->inst.rtti));
		r_ptr = r_ptr->next;
	}

	HLIB_CMD_Printf("* Missing Contents Info\n");
	MHEGEngine_enterCriticalMissingContent;
	missing_content = engine.missing_content;
	while (missing_content)
	{
		HLIB_CMD_Printf("\tfile : %.*s\n", missing_content->item.file.name.size, missing_content->item.file.name.data);
		HLIB_CMD_Printf("\t\trequested = %s", ctime(&missing_content->item.requested));
		if (missing_content->item.file.content.size || missing_content->item.file.content.data)
			HLIB_CMD_Printf("\t\thas data (%d) !!!\n", missing_content->item.file.content.size);
		if (missing_content->item.obj)
		{
//			VK_Print("\t\tObjectReference = %s (%s)\n", ObjectReference_name(&missing_content->item.obj->ObjectReference), MHEGEngine_RTTI_name(missing_content->item.obj->inst.rtti));
			HLIB_CMD_Printf("\t\tExternalReference = %s (%s)\n", ExternalReference_name(&missing_content->item.obj->inst.ref), MHEGEngine_RTTI_name(missing_content->item.obj->inst.rtti));
			HLIB_CMD_Printf("\t\t%s, %s, %s\n",
				missing_content->item.obj->inst.need_content ? "content need" : "content ok",
				missing_content->item.obj->inst.AvailabilityStatus ? "available" : "not available",
				missing_content->item.obj->inst.RunningStatus ? "running" : "not running");
		}
		missing_content = missing_content->next;
	}
	MHEGEngine_leaveCriticalMissingContent;

	HLIB_CMD_Printf("* Temp Contents Info\n");
	received_content = engine.temp_content;
	while (received_content)
	{
		HLIB_CMD_Printf("\tfile : %.*s (%d bytes)\n", received_content->item.file.name.size, received_content->item.file.name.data, received_content->item.file.content.size);
		HLIB_CMD_Printf("\t\trequested = %s", ctime(&received_content->item.requested));
		HLIB_CMD_Printf("\t\treceived  = %s", ctime(&received_content->item.received));
		if (received_content->item.file.content.size == 0 || received_content->item.file.content.data == NULL)
			HLIB_CMD_Printf("\t\thas no data (%d) !!!\n", received_content->item.file.content.size);
		if (received_content->item.obj)
		{
//			VK_Print("\t\tObjectReference = %s (%s)\n", ObjectReference_name(&received_content->item.obj->ObjectReference), MHEGEngine_RTTI_name(received_content->item.obj->inst.rtti));
			HLIB_CMD_Printf("\t\tExternalReference = %s (%s)\n", ExternalReference_name(&received_content->item.obj->inst.ref), MHEGEngine_RTTI_name(received_content->item.obj->inst.rtti));
			HLIB_CMD_Printf("\t\t%s, %s, %s\n",
				received_content->item.obj->inst.need_content ? "content need" : "content ok",
				received_content->item.obj->inst.AvailabilityStatus ? "available" : "not available",
				received_content->item.obj->inst.RunningStatus ? "running" : "not running");
		}
		received_content = received_content->next;
	}

	HLIB_CMD_Printf("* Received Contents Info\n");
	received_content = engine.received_content;
	sum = 0;
	while (received_content)
	{
		HLIB_CMD_Printf("\tfile : %.*s (%d bytes)\n", received_content->item.file.name.size, received_content->item.file.name.data, received_content->item.file.content.size);
		HLIB_CMD_Printf("\t\trequested = %s", ctime(&received_content->item.requested));
		HLIB_CMD_Printf("\t\treceived  = %s", ctime(&received_content->item.received));
		if (received_content->item.file.content.size == 0 || received_content->item.file.content.data == NULL)
			HLIB_CMD_Printf("\t\thas no data (%d) !!!\n", received_content->item.file.content.size);
		sum += received_content->item.file.content.size;
		// 새로운 Scene 이 로드되면 obj 가 가리키는 메모리는 더이상 유효하지 않으므로 obj 정보는 찍지 않는다.
		received_content = received_content->next;
	}
	HLIB_CMD_Printf("\t-> total %d bytes\n", sum);

	HLIB_CMD_Printf("* Received Bitmap Info\n");
	received_content = engine.received_bitmap;
	sum = 0;
	while (received_content)
	{
		HLIB_CMD_Printf("\tfile : %.*s (%d bytes)\n", received_content->item.file.name.size, received_content->item.file.name.data, received_content->item.file.content.size);
		HLIB_CMD_Printf("\t\trequested = %s", ctime(&received_content->item.requested));
		HLIB_CMD_Printf("\t\treceived  = %s", ctime(&received_content->item.received));
		if (received_content->item.file.content.size == 0 || received_content->item.file.content.data == NULL)
			HLIB_CMD_Printf("\t\thas no data (%d) !!!\n", received_content->item.file.content.size);
		sum += received_content->item.file.content.size;
		// 새로운 Scene 이 로드되면 obj 가 가리키는 메모리는 더이상 유효하지 않으므로 obj 정보는 찍지 않는다.
		received_content = received_content->next;
	}
	HLIB_CMD_Printf("\t-> total %d bytes\n", sum);

	HLIB_CMD_Printf("* Active Links Info\n");
	l_ptr = engine.active_links;
	while (l_ptr)
	{
		HLIB_CMD_Printf("\tRootClass :\n");
//		VK_Print("\t\tObjectReference = %s (%s)\n", ObjectReference_name(&l_ptr->item->rootClass.ObjectReference), MHEGEngine_RTTI_name(l_ptr->item->rootClass.inst.rtti)); // RTTI_LinkClass
		HLIB_CMD_Printf("\t\tExternalReference = %s (%s)\n", ExternalReference_name(&l_ptr->item->rootClass.inst.ref), MHEGEngine_RTTI_name(l_ptr->item->rootClass.inst.rtti)); // RTTI_LinkClass
		HLIB_CMD_Printf("\t\t%s, %s, %s\n",
			l_ptr->item->rootClass.inst.need_content ? "content need" : "content ok",
			l_ptr->item->rootClass.inst.AvailabilityStatus ? "available" : "not available",
			l_ptr->item->rootClass.inst.RunningStatus ? "running" : "not running");
		HLIB_CMD_Printf("\t\tLinkCondition :\n");
		HLIB_CMD_Printf("\t\t\tObjectReference (event src) = %s\n", ObjectReference_name(&l_ptr->item->link_condition.event_source));
		HLIB_CMD_Printf("\t\t\tEventType = %s\n", EventType_name(l_ptr->item->link_condition.event_type));
		ea = l_ptr->item->link_effect;
		while (ea)
		{
			HLIB_CMD_Printf("\t\t\tlink effect = %s\n", ElementaryAction_name(&ea->item));
			ea = ea->next;
		}
		l_ptr = l_ptr->next;
	}

	HLIB_CMD_Printf("* Async Events Info\n");
	async_eventq = engine.async_eventq;
	while (async_eventq)
	{
		HLIB_CMD_Printf("\tsrc = %s (%s)\n", ExternalReference_name(&async_eventq->item.src), EventType_name(async_eventq->item.type));
		async_eventq = async_eventq->next;
	}

	HLIB_CMD_Printf("* Main Actions Info\n");
	actionq = engine.main_actionq;
	if (actionq)
	{
		HLIB_CMD_Printf("\tdata found\n");
	}

	HLIB_CMD_Printf("* Temp Actions Info\n");
	actionq = engine.temp_actionq;
	if (actionq)
	{
		HLIB_CMD_Printf("\tdata found\n");
	}

	HLIB_CMD_Printf("* Persistent Files Info\n");
	persistent = engine.persistent;
	if (persistent)
	{
		HLIB_CMD_Printf("\tdata found\n");
	}

#ifdef DEBUG_MALLOC
	safe_print_malloc_count();
#endif
#ifdef DEBUG_MALLOC_LIST
	safe_print_malloc_list();
#endif

	HLIB_CMD_Printf("\n- End -\n\n");
}

#else

void
MHEGEngine_print(void)
{
	/* nothing */
}

#endif

////////////////////////////////////////////////////////////////////////////////////////////////////

#define ___MHEGIB_MSG_KEY___

static HERROR local_MHEGIB_SendMessage(HINT32 lMessage, HINT32 lParam1, HINT32 lParam2, HINT32 lParam3)
{
	MHEGIB_RUN_MSG	stRunMsg;

	if (engine.status != MHEGEngine_Running)
	{
		verbose_misc("SendMessage: %d, params: %d %d %d, but MHEG engine not running (%d)", lMessage, lParam1, lParam2, lParam3, engine.status);
		return ERR_FAIL;
	}

	VK_memset(&stRunMsg, 0x00, sizeof(MHEGIB_RUN_MSG));
	stRunMsg.lMessage = lMessage; /* MHEGIB_RUN_MSG_TYPE */
	stRunMsg.lparam1 = lParam1;
	stRunMsg.lparam2 = lParam2;
	stRunMsg.lparam3 = lParam3;

	if (VK_MSG_SendTimeout(s_ulMhegIbRunningMsgQId, &stRunMsg, sizeof(MHEGIB_RUN_MSG), 0) != VK_OK)
	{
		error("VK_MSG_Send() failed");
		return ERR_FAIL;
	}

	return ERR_OK;
}

HERROR MHEGIB_SendKey(HINT32 lMessage, HINT32 lParam1, HINT32 lParam2, HINT32 lParam3)
{
	HERROR				hError = ERR_OK;
	HUINT32				ulConvertedKeycode = 0;
	bool				bConsumed;

	if (engine.status != MHEGEngine_Running)
	{
		verbose_misc("SendKey: %d, params: %d %d %d, but MHEG engine not running (%d)", lMessage, lParam1, lParam2, lParam3, engine.status);
		return ERR_FAIL;
	}

	/* UK MHEG Profile (D-BOOK 5.0) :
	   Register 3 group : Cancel, Text, 컬러키 (Red, Green, Yellow, Blue) -> always available to a running MHEG-5 application.
	   Register 4 group : 숫자키 -> sometimes available to a running MHEG-5 application.
	   Register 5 group : Select, 방향키 (Up, Down, Left, Right) -> sometimes available to a running MHEG-5 application.
	   Receiver   group : Power, Subtitle, Wide, Info, Guide, Prog+/-, Vol+/-, Mute -> never available to a running MHEG-5 application.

	   단, 키 그룹에 대한 핸들링은 여기서 하지 않고 MHEGEngine_keyPressed() 에서 처리한다. */

	switch (lParam1)
	{
		/* arrow */
		case KEY_ARROWUP:		ulConvertedKeycode = MHEGKey_Up;		break;
		case KEY_ARROWDOWN:		ulConvertedKeycode = MHEGKey_Down;	break;
		case KEY_ARROWLEFT:		ulConvertedKeycode = MHEGKey_Left;	break;
		case KEY_ARROWRIGHT:	ulConvertedKeycode = MHEGKey_Right;	break;

		/* numeric */
		case KEY_0:				ulConvertedKeycode = MHEGKey_0;		break;
		case KEY_1:				ulConvertedKeycode = MHEGKey_1;		break;
		case KEY_2:				ulConvertedKeycode = MHEGKey_2;		break;
		case KEY_3:				ulConvertedKeycode = MHEGKey_3;		break;
		case KEY_4:				ulConvertedKeycode = MHEGKey_4;		break;
		case KEY_5:				ulConvertedKeycode = MHEGKey_5;		break;
		case KEY_6:				ulConvertedKeycode = MHEGKey_6;		break;
		case KEY_7:				ulConvertedKeycode = MHEGKey_7;		break;
		case KEY_8:				ulConvertedKeycode = MHEGKey_8;		break;
		case KEY_9:				ulConvertedKeycode = MHEGKey_9;		break;

		/* select */
		case KEY_OK:			ulConvertedKeycode = MHEGKey_Select;	break;

		/* cancel */
		#ifndef CONFIG_OP_CANALREADY // UK MHEG profile 에선 채널 전환을 제외하고는 특정 키에 의한 자체 종료에 대해 언급되어 있지 않은데 만약 필요하다면 아래와 같이 사용할 수 있겠다 (CONFIG_OP_CANALREADY 의 경우)
		case KEY_LAST:
		case KEY_BACK:			/* fall through */
		case KEY_EXIT:			ulConvertedKeycode = MHEGKey_Cancel;	break;
		#else
		case KEY_LAST:
		case KEY_BACK:			ulConvertedKeycode = MHEGKey_Cancel;	break;
		case KEY_EXIT:			MHEGEngine_quit(QuitReason_QuitByConsole, NULL); hError = ERR_FAIL; return ERR_OK; break;
		#endif

		/* help (info) */
		#if 0 // UK MHEG profile 에선 사용되지 않으므로 막아둔다.
		case KEY_INFO:			ulConvertedKeycode = MHEGKey_Help;		break;
		#endif

		/* color key */
		case KEY_RED:			ulConvertedKeycode = MHEGKey_Red;		break;
		case KEY_GREEN:			ulConvertedKeycode = MHEGKey_Green;		break;
		case KEY_YELLOW:		ulConvertedKeycode = MHEGKey_Yellow;	break;
		case KEY_BLUE:			ulConvertedKeycode = MHEGKey_Blue;		break;

		/* text */
		case KEY_TEXT:			ulConvertedKeycode = MHEGKey_Text;		break;

		/* guide */
		case KEY_GUIDE:			if (MHEGIB_GetProfile() & MHEGIB_Profile_NZ) ulConvertedKeycode = MHEGKey_EPG; else hError = ERR_FAIL; break; // NZ profile

		/* channel change */
		case KEY_CH_PLUS:		/* fall through */
		case KEY_CH_MINUS:		/*MHEGEngine_quit(QuitReason_QuitByChannelChange, NULL);*/ hError = ERR_FAIL; break;

		default:
			verbose_misc("SendKey: Invalid Keycode (0x%X)", lParam1);
			hError = ERR_FAIL;
			break;
	}

	if (hError != ERR_FAIL)
	{
		bConsumed = MHEGEngine_checkKeyConsumed(ulConvertedKeycode);

		hError = local_MHEGIB_SendMessage(MHEGIB_RUN_MSG_KEY_DOWN, ulConvertedKeycode, lParam2, lParam3);

		if((bConsumed == true) && (hError == ERR_OK))
		{
			hError = ERR_OK;
		}
		else
		{
			hError = ERR_FAIL;
		}
	}

	return hError;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

#define ___MHEGIB_AMMI___

/* ---------------------------------------------------------------------------------------
   Local : Callback functions between MHEG internal browser and CI layer (Application MMI)
   --------------------------------------------------------------------------------------- */

static int local_MHEGIB_CiAppMmi_cb_req_start(uCiAmmiContent_t * puContent) // CI_AMMI_MSG_REQ_START 에 대한 처리
{
	sCiAmmiTypeReqStart_t * pReqStart = (sCiAmmiTypeReqStart_t *)puContent; // NULL 체크 필요 없음 (CI AMMI stack 에서 보장)
	MHEGIB_MAIN_MSG stMainMsg;
	HBOOL bStartCondition = MHEGIB_CheckEngineStartCondition();

	verbose_ammi("cb_req_start: SessionId = %d, AppDomainId = [%d][%.*s], InitialObject = [%d][%.*s], EngineStatus = %d (%d)",
		pReqStart->usSessionId,
		pReqStart->ucAppDomainIdLen, pReqStart->ucAppDomainIdLen, pReqStart->pucAppDomainId,
		pReqStart->ucInitialObjectLen, pReqStart->ucInitialObjectLen, pReqStart->pucInitialObject,
		engine.status, bStartCondition);

	/* CI+ MHEG Profile (CI+ spec) : 12.6.1.1 Launching and Terminating the CI Plus Application - The CI Plus Application cannot be presented when subtitles or RTGraphics are enabled. */
	/* HAMA에서 전달하는 eHSIG_ShowSubtitle/eHSIG_ShowTeletext을 참고하여 처리하면 될 듯 함.*/
	if (MHEGIB_CheckEngineStartCondition() != TRUE)
	{
		return (int)eCiAmmiRequestStartAckCode_API_BUSY;
	}

	/* CI+ MHEG Profile (CI+ spec) : 12.6.2 Interaction with DVB Common Interface Module */
	/* in case of CI+ : <applicationDomainIndentifier>[;<option1>;<option2>;…;<option#>], <applicationDomainIndentifier> = CI_AMMI_APP_DOMAIN_ID */
	if ((pReqStart->ucAppDomainIdLen == strlen(CI_AMMI_APP_DOMAIN_ID)) && (VK_memcmp(pReqStart->pucAppDomainId, CI_AMMI_APP_DOMAIN_ID, pReqStart->ucAppDomainIdLen) == 0))
	{
		// maybe nothing to do here
	}
	else if ((pReqStart->ucAppDomainIdLen > strlen(CI_AMMI_APP_DOMAIN_ID)) && (VK_memcmp(pReqStart->pucAppDomainId, CI_AMMI_APP_DOMAIN_ID, strlen(CI_AMMI_APP_DOMAIN_ID)) == 0))
	{
		// TODO : there are option values. parse it and ...
	}
	else if ((pReqStart->ucAppDomainIdLen == strlen(UK_AMMI_APP_DOMAIN_ID)) && (VK_memcmp(pReqStart->pucAppDomainId, UK_AMMI_APP_DOMAIN_ID, pReqStart->ucAppDomainIdLen) == 0))
	{
		// maybe nothing to do here
	}
	else
	{
		return (int)eCiAmmiRequestStartAckCode_WRONG_API;
	}

	/* UK MHEG Profile (D-BOOK 5.0) : 16.11.3.2 RequestStart - Initial object

		1. If InitialObjectLength is 0 and an MHEG-5 application is currently running
		   then the application is NOT killed and the CI file system is mounted and becomes available to the application.
		2. If InitialObjectLength is 0 and no MHEG-5 application is currently running
		   then the CI file system is mounted and the receiver continues looking for a broadcast auto-boot application.
		3. If the InitialObjectLength > 0
		   then the RequestStart message specifies a new application object that is to be run,
		   any currently running application is killed to make way for the application specified by RequestStart.
	*/

	if (pReqStart->ucInitialObjectLen == 0)
	{
		if (engine.status == MHEGEngine_Running)
		{
			verbose_todo("CI file system is mounted and becomes available to the application.");
		}
		else
		{
			verbose_todo("continues looking for a broadcast auto-boot application.");
		}

		return (int)eCiAmmiRequestStartAckCode_OK;
	}

	if (engine.status == MHEGEngine_Running)
	{
		MHEGEngine_quit(QuitReason_QuitByCI, NULL);
	}

	/* init context for CI Application MMI : 새로운 CI Application MMI 세션의 시작 */
	VK_memset(&s_stMhegIbAmmiContext, 0x00, sizeof(MHEGIB_AMMI_CONTEXT));
	s_stMhegIbAmmiContext.usSessionId = pReqStart->usSessionId;
	VK_memcpy(s_stMhegIbAmmiContext.ucInitialObjectName, pReqStart->pucInitialObject, pReqStart->ucInitialObjectLen);

	stMainMsg.enMsgType = MHEGIB_MAIN_MSG_AMMI_REQ_START;

	if (VK_MSG_SendTimeout(s_ulMhegIbMainMsgQId, &stMainMsg, sizeof(MHEGIB_MAIN_MSG), 0) != VK_OK)
	{
		error("VK_MSG_Send() failed");
		return (int)eCiAmmiRequestStartAckCode_API_BUSY;
	}

	return (int)eCiAmmiRequestStartAckCode_OK;
}

static int local_MHEGIB_CiAppMmi_cb_file_ack(uCiAmmiContent_t * puContent) // CI_AMMI_MSG_FILE_ACK 에 대한 처리
{
	sCiAmmiTypeFileAck_t * pFileAck = (sCiAmmiTypeFileAck_t *)puContent; // NULL 체크 필요 없음 (CI AMMI stack 에서 보장)
	MHEGIB_MAIN_MSG stMainMsg;

	verbose_ammi("cb_file_ack: SessionId = %d, %s %s", pFileAck->usSessionId, pFileAck->enReqType == 0/*eMhegIb_ReqType_File*/ ? "File" : "Data", pFileAck->ucFileOK ? "OK" : "NG");

	if (s_stMhegIbAmmiContext.usSessionId != pFileAck->usSessionId)
	{
		error("Wrong SessionId (%d != %d)", s_stMhegIbAmmiContext.usSessionId, pFileAck->usSessionId);
		return -1; // 이 경우 리턴값은 don't care
	}

	if (pFileAck->enReqType == 0/*eMhegIb_ReqType_File*/)
	{
		unsigned char ucFileNameLen;
		unsigned char *pucFileName;

		unsigned long ulFileDataLen;
		unsigned char *pucFileData;

		ucFileNameLen = pFileAck->pucBytes[0];
		pucFileName = ucFileNameLen ? &pFileAck->pucBytes[1] : NULL;

		ulFileDataLen = ((unsigned long)pFileAck->pucBytes[1+ucFileNameLen] << 24) & 0xff000000;
		ulFileDataLen |= (((unsigned long)pFileAck->pucBytes[2+ucFileNameLen] << 16) & 0x00ff0000);
		ulFileDataLen |= (((unsigned long)pFileAck->pucBytes[3+ucFileNameLen] << 8) & 0x0000ff00);
		ulFileDataLen |= ((unsigned long)pFileAck->pucBytes[4+ucFileNameLen] & 0x000000ff);
		pucFileData = ulFileDataLen ? &pFileAck->pucBytes[5+ucFileNameLen] : NULL;

		if(pucFileData == NULL || pucFileName == NULL)
		{
			error("pucFileData is Null, OR pucFileName is Null.");
			return -1;
		}

		// 위 값들의 무결성 체크 필요 없음 (CI AMMI stack 에서 보장)

		verbose_ammi("cb_file_ack: FileName = [%d][%.*s], FileData = [%ld]", ucFileNameLen, ucFileNameLen, pucFileName, ulFileDataLen);
		verbose_ammi("cb_file_ack: init Object name = [%d][%s]", strlen(s_stMhegIbAmmiContext.ucInitialObjectName), s_stMhegIbAmmiContext.ucInitialObjectName);

		if ((ucFileNameLen == strlen(s_stMhegIbAmmiContext.ucInitialObjectName)) && (VK_memcmp(pucFileName, s_stMhegIbAmmiContext.ucInitialObjectName, ucFileNameLen) == 0))
		{
			if (engine.status)
			{
				error("MHEG engine already running (%d)", engine.status);
				return -1; // 이 경우 리턴값은 don't care
			}

			if (!pFileAck->ucFileOK)
			{
				error("InitialObject is not available");
				return -1; // 이 경우 리턴값은 don't care
			}

			s_stMhegIbAmmiContext.ulInitialObjectDataLen = ulFileDataLen;
			s_stMhegIbAmmiContext.pucInitialObjectData = safe_malloc(ulFileDataLen); // free : MHEGBackend_fini() or local_MHEGIB_main() on error
			VK_memcpy(s_stMhegIbAmmiContext.pucInitialObjectData, pucFileData, ulFileDataLen);

			stMainMsg.enMsgType = MHEGIB_MAIN_MSG_AMMI_REQ_START_ACK;

			if (VK_MSG_SendTimeout(s_ulMhegIbMainMsgQId, &stMainMsg, sizeof(MHEGIB_MAIN_MSG), 0) != VK_OK)
			{
				error("VK_MSG_Send() failed");
				safe_free(s_stMhegIbAmmiContext.pucInitialObjectData);
				s_stMhegIbAmmiContext.ulInitialObjectDataLen = 0;
				return -1; // 이 경우 리턴값은 don't care
			}
		}
		else
		{
			LIST_TYPE(MissingContent) *missing;
			struct timeval now;
			bool not_found = true;

			if (engine.status != MHEGEngine_Running)
			{
				error("MHEG engine not running (%d)", engine.status);
				return -1; // 이 경우 리턴값은 don't care
			}

			MHEGEngine_enterCriticalMissingContent;
			missing = engine.missing_content;
			while (missing && not_found)
			{
				// missing content 파일명은 absolute file name 으로 저장한다.
				// 예로, ack 받은 파일명은 "CI://live.mhg" (13 bytes) 이고 missing content 명은 "~//live.mhg" (11 bytes) 이다.
				// 또한, ack 받은 파일명은 "CI://png/logo_CIPSK.png" (23 bytes) 이고 missing content 명은 "/png/logo_CIPSK.png" (19 bytes) -> "~//png/logo_CIPSK.png" (21 bytes) 이다.
				verbose_ammi("cb_file_ack: FileName = [%d][%s], [%d][%s]", ucFileNameLen, &pucFileName[0], missing->item.file.name.size + 2, &missing->item.file.name.data[0]);

				if ((ucFileNameLen == missing->item.file.name.size + 2) && (VK_memcmp(&pucFileName[3], &missing->item.file.name.data[1], ucFileNameLen - 3) == 0))
				{
					if (pFileAck->ucFileOK && ulFileDataLen)
					{
						verbose_ammi("cb_file_ack: missing content received");
						missing->item.file.content.size = ulFileDataLen;
						missing->item.file.content.data = safe_malloc(ulFileDataLen); // free : free_ReceivedContentListItem()
						VK_memcpy32(missing->item.file.content.data, pucFileData, ulFileDataLen);
						gettimeofday(&now, NULL);
						missing->item.received = now.tv_sec;

						#if 0
						#define DEBUG_MHEG_IB_PACKET_DUMP_FILE	"MhegIb_packet.dat"
						{
							static FILE *packetFile = NULL;

							if (packetFile == NULL)
								packetFile = fopen(DEBUG_MHEG_IB_PACKET_DUMP_FILE, "wb");

							fwrite(pucFileData, ulFileDataLen, 1, packetFile);
							fflush(packetFile);
							fclose(packetFile); packetFile = NULL;
						}
						#endif
					}
					else
					{
						verbose_ammi("cb_file_ack: missing content received but file data is not available");
						missing->item.received = -1;
					}
					not_found = false;
				}
				missing = missing->next;
			}
			MHEGEngine_leaveCriticalMissingContent;

			if (not_found)
			{
				error("requested file '%.*s' not found on missing content list", ucFileNameLen, pucFileName); // 이런 에러가 난다면 뭔가 코딩 오류이겠지... 디버깅 필요!!
			}
			else
			{
				local_MHEGIB_SendMessage(MHEGIB_RUN_MSG_MISSING_CONTENT_RECEIVED, 0, 0, 0);
			}
		}
	}
	else // CI_AMMI_REQUEST_TYPE_DATA
	{
		verbose_ammi("cb_file_ack: DataByte = [%ld]", pFileAck->ulBytesLen);

		if (engine.status != MHEGEngine_Running)
		{
			error("MHEG engine not running (%d)", engine.status);
			return -1; // 이 경우 리턴값은 don't care
		}

		prog_CI_ReceiveMessage(pFileAck->ulBytesLen, pFileAck->pucBytes); // Data NG 인 경우엔 ulBytesLen = 0, pucBytes = NULL... 이 경우도 prog_CI_ReceiveMessage() 내에서 핸들링함.
	}

	return 0; // 이 경우 리턴값은 don't care
}

static int local_MHEGIB_CiAppMmi_cb_req_app_abort(uCiAmmiContent_t * puContent) // CI_AMMI_MSG_REQ_APP_ABORT 에 대한 처리
{
	sCiAmmiTypeReqAppAbort_t * pReqAppAbort = (sCiAmmiTypeReqAppAbort_t *)puContent; // NULL 체크 필요 없음 (CI AMMI stack 에서 보장)

	verbose_ammi("cb_req_app_abort: SessionId = %d, AbortReqCode = 0x%x, EngineStatus = %d", pReqAppAbort->usSessionId, pReqAppAbort->enAbortReqCode, engine.status);

	if (s_stMhegIbAmmiContext.usSessionId != pReqAppAbort->usSessionId)
	{
		error("Wrong SessionId (%d != %d)", s_stMhegIbAmmiContext.usSessionId, pReqAppAbort->usSessionId);
		return -1; // 이 경우 리턴값은 don't care
	}

	if (engine.status == MHEGEngine_Running)
	{
		MHEGEngine_quit(QuitReason_QuitByCI, NULL);
	}

	/* init context for CI Application MMI : MHEGEngine_fini() 후에 request app abort to ci_ammi stack 하지 않기 위함이다 */
	VK_memset(&s_stMhegIbAmmiContext, 0x00, sizeof(MHEGIB_AMMI_CONTEXT));

	// 캠으로의 ack 는 CI AMMI stack 에서 바로 처리하기 때문에 여기서 추가적으로 할 일은 없을 듯...

	return 0; // 이 경우 리턴값은 don't care
}

static int local_MHEGIB_CiAppMmi_cb_app_abort_ack(uCiAmmiContent_t * puContent) // CI_AMMI_MSG_APP_ABORT_ACK 에 대한 처리
{
	sCiAmmiTypeAppAbortAck_t * pAppAbortAck = (sCiAmmiTypeAppAbortAck_t *)puContent; // NULL 체크 필요 없음 (CI AMMI stack 에서 보장)

	verbose_ammi("cb_app_abort_ack: SessionId = %d, EngineStatus = %d", pAppAbortAck->usSessionId, engine.status);

	if (s_stMhegIbAmmiContext.usSessionId != pAppAbortAck->usSessionId)
	{
		error("Wrong SessionId (%d != %d)", s_stMhegIbAmmiContext.usSessionId, pAppAbortAck->usSessionId);
		return -1; // 이 경우 리턴값은 don't care
	}

	// 여기서 추가적으로 할 일은 없을 듯...

	return 0; // 이 경우 리턴값은 don't care
}

HERROR MHEGIB_CiAppMmi_SendData(eCiAmmiMsgType_t enMsgType, uCiAmmiContent_t *puContent)
{
	int ret = 0;

	switch(enMsgType)
	{
		case eCiAmmiMsgType_reqStart :
			verbose_ammi("cb_main: eCiAmmiMsgType_reqStart received");
			ret = local_MHEGIB_CiAppMmi_cb_req_start(puContent);
			if(ret == eCiAmmiRequestStartAckCode_API_BUSY)
			{
				//1 To Do someting
			}
			else if (ret == eCiAmmiRequestStartAckCode_WRONG_API)
			{
				//1 To Do someting
			}
			else
			{
				//1 To Do someting
			}
			break;

		case eCiAmmiMsgType_FileAck :
			verbose_ammi("cb_main: eCiAmmiMsgType_FileAck received");
			ret = local_MHEGIB_CiAppMmi_cb_file_ack(puContent);
			break;

		case eCiAmmiMsgType_ReqAppAbort :
			verbose_ammi("cb_main: eCiAmmiMsgType_ReqAppAbort received");
			ret = local_MHEGIB_CiAppMmi_cb_req_app_abort(puContent);
			break;

		case eCiAmmiMsgType_AppAbortAck :
			verbose_ammi("cb_main: eCiAmmiMsgType_AppAbortAck received");
			ret = local_MHEGIB_CiAppMmi_cb_app_abort_ack(puContent);
			break;

		case eCiAmmiMsgType_MAX :
		default:
			error("Invalid message received (%d)", enMsgType);
			break;
	}

	return ret;
}

unsigned short
MHEGIB_CiAppMmi_getSessionId(void)
{
	return s_stMhegIbAmmiContext.usSessionId;
}

#ifdef CONFIG_DEBUG
void MHEGIB_CiAppMmi_test(unsigned char *name)
{
	MHEGIB_MAIN_MSG stMainMsg;

	VK_memset(&s_stMhegIbAmmiContext, 0x00, sizeof(MHEGIB_AMMI_CONTEXT));
	VK_memcpy(s_stMhegIbAmmiContext.ucInitialObjectName, name, strlen(name));

	stMainMsg.enMsgType = MHEGIB_MAIN_MSG_AMMI_REQ_START_ACK;

	if (VK_MSG_SendTimeout(s_ulMhegIbMainMsgQId, &stMainMsg, sizeof(MHEGIB_MAIN_MSG), 0) != VK_OK)
	{
		error("VK_MSG_Send() failed");
	}
}
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////

#define ___MHEGIB_INIT_MAIN___

/* ------------------------------------
   Main entry for MHEG internal browser
   ------------------------------------ */

static void
local_MHEGIB_main(void)
{
	MHEGIB_MAIN_MSG stMainMsg;
	MHEGFileObject stInitObj;
	MHEGEngineOptions opts;
	unsigned char name[256]; // PATH_MAX
	int rc;

	/* we assume &struct == &struct.first_item, not sure if C guarantees it */
	ApplicationClass app;
	if(&app != (ApplicationClass *) &app.rootClass)
	{
		fatal("Needs to be compiled with a compiler that makes &struct == &struct.first_item");
		return;
	}
	/* let's be really paranoid */
	if(NULL != 0)
	{
		fatal("Needs to be compiled with a libc that makes NULL == 0");
		return;
	}

	/* init context for CI Application MMI : 최초 초기화 (MHEGIB_Init()은 재진입 가능한 함수로 구현되었기 때문에 여기서 초기화한다) */
	VK_memset(&s_stMhegIbAmmiContext, 0x00, sizeof(MHEGIB_AMMI_CONTEXT));

	while(1)
	{
		if (VK_MSG_Receive(s_ulMhegIbMainMsgQId, &stMainMsg, sizeof(MHEGIB_MAIN_MSG)) != VK_OK)
		{
			error("VK_MSG_Receive() failed");
			continue;
		}

		switch (stMainMsg.enMsgType)
		{
			case MHEGIB_MAIN_MSG_AMMI_REQ_START :
				verbose_ammi("task: MHEGIB_MAIN_MSG_AMMI_REQ_START received");

				//ycgo_Hx_Print
				HxLOG_Print("local_MHEGIB_main\n");
				if (MHEGIB_FileRequst(s_stMhegIbAmmiContext.usSessionId, eMhegIb_Ad_ReqType_File, s_stMhegIbAmmiContext.ucInitialObjectName, strlen(s_stMhegIbAmmiContext.ucInitialObjectName)))
				{
					error("MHEGIB_FileRequst (%d, %s) failed", s_stMhegIbAmmiContext.usSessionId, s_stMhegIbAmmiContext.ucInitialObjectName);
				}
				continue;

			case MHEGIB_MAIN_MSG_AMMI_REQ_START_ACK :
				verbose_ammi("task: MHEGIB_MAIN_MSG_AMMI_REQ_START_ACK received");
				stInitObj.name.size = strlen(s_stMhegIbAmmiContext.ucInitialObjectName);
				stInitObj.name.data = s_stMhegIbAmmiContext.ucInitialObjectName;
				stInitObj.content.size = s_stMhegIbAmmiContext.ulInitialObjectDataLen;
				stInitObj.content.data = s_stMhegIbAmmiContext.pucInitialObjectData;

				#define DEBUG_MHEG_ENGINE_IB_PACKET_DUMP_FILE	"/tmp/MhegIbEngine_packet.dat"
				#if 0
				{
					static FILE	*packetFile = NULL;

					if (packetFile == NULL)
						packetFile = fopen(DEBUG_MHEG_ENGINE_IB_PACKET_DUMP_FILE, "wb");

					fwrite(s_stMhegIbAmmiContext.pucInitialObjectData, s_stMhegIbAmmiContext.ulInitialObjectDataLen, 1, packetFile);
					fflush(packetFile);
				}
				#endif

				break;

			// TODO : DSM ...

			default :
				error("Invalid message received (%d)", stMainMsg.enMsgType);
				continue;
		}

		/* UK MHEG Profile (D-BOOK 5.0) : 16.2.2 Launching and terminating MHEG-5 applications & CI+ MHEG Profile (CI+ spec) : 12.6 CI Application Life Cycle 참고할 것 */

		/* default options */
		VK_memset(&opts, 0x00, sizeof(MHEGEngineOptions));
		opts.backend_mode = 0;		/* not the default, but needed so you can do eg "-r services/4165" */
		opts.srg_loc = DEFAULT_BACKEND;
#if 0 // hmkim : commented out (StreamPlayer : CI+ MHEG Profile 에선 불필요. UK MHEG Profile 을 위해서는 추가 작업 필요함!)
		opts.audio_dev = DEFAULT_ALSA_DEVICE;
		opts.vo_method = NULL;
#endif
		opts.av_disabled = true;	/* org is false */
		opts.network_id = -1;		/* => leave it blank */

		/* UK MHEG Profile (D-BOOK 5.0) : 17.4.4.2 Locating the initial object, 18.3.2.3 Structure of file references

			< Explicit Initial Object Identified >

			If the initial_object field identifies a File object, this shall be the initial object.
			If the initial_object field identifies a Directory object,
			the receiver shall use the default names "a" and "startup",
			in that order, to locate the initial Application object in this Directory object.

			< No Explicit Initial Object Identified >

			If no appropriate initial_object field can be identified...
			the receiver shall use the following default names
			to locate the initial Application object in the ServiceGateway object (in the following order):
			"DSM://a", "DSM://startup"

			< Structure of file references >

			1. Source, "DSM:" (0x44534D3A) = The service gateway of the "Current Carousel".
			2. Source, "~" (0x7E) = Shorthand for "DSM:"
			3. Source, "CI:" (0x43493A) = The root of the file system provided by a CI module
			   while application MMI session is open after a RequestStart has been sent by the module.
			4. Source, empty string "" = Shorthand for "Current Source". Resolves to "DSM:" or "CI:" as appropriate.
			5. Path Origin, "//" (0x2F2F) = Root directory of the specified source.
			6. Path Origin, "/" (0x2F) = Shorthand for the path from "//" to the active application.
			7. Path, "dir/" = A component of a path to a sub directory.
			8. Path, "../" = "Move back up on directory level"
			9. File Name, "file" = The name of the file.

			< Resolution of file references >

			1. Expand any short hand components
			   - an empty source expands to "DSM:" or "CI:"
			   - the path origin "/" expands to a path such as "//weather/today/"
			   - the source and path origin together might be "DSM://weather/today/"
			   So "/cloud" might become "DSM://weather/today/cloud"
			2. Allow each "../" component to consume the path component preceding it. So:
			   "/../tomorrow/app" might first become "DSM://weather/today/../tomorrow/app" before it collapses to "DSM://weather/tomorrow/app"
			... 생략 ...

			< Examples >

			If the fully resolved reference for the current application object is "DSM://dir1/foo" then:
			'//bar' resolves to 'DSM://bar'
			'/bar' resolves to 'DSM://dir1/bar'
			'~/bar' resolves to 'DSM://dir1/bar'
			'~/../bar' resolves to 'DSM://bar'
			'//../bar' is an invalid reference

			=> MHEGEngine_externalFilename(), MHEGEngine_absoluteFilename(), active_app_path() 함수들 참고할 것.
		*/

		if (stInitObj.content.size == 0 && stInitObj.content.data == NULL) // 이건 테스트 용도로만 사용된다.
		{
			if(stInitObj.name.size > 5 // 뒤에 최소 1자 이상의 이름이 있는지 체크하기 위해 >= 가 아니라 > 로 확인한다.
				&& strncmp((char *) stInitObj.name.data, MHEG_SRG_LOC_CI, 5) == 0)
			{
				opts.backend_mode = MHEGEngineBackendMode_Local;
#if defined(WIN32)
				opts.srg_loc = "./opt/CI/";
#else
				opts.srg_loc = "/opt/CI/";
#endif
				opts.init_obj.name.size = stInitObj.name.size - 2;
				name[0] = '~';
				strcpy(&name[1], &stInitObj.name.data[3]);
				opts.init_obj.name.data = name;
				opts.init_obj.content.size = 0;
				opts.init_obj.content.data = NULL;
			}
			else
			{
				error("'%.*s' needs initial object source like 'CI://'", stInitObj.name.size, stInitObj.name.data);
				safe_free(opts.init_obj.content.data);
				continue;
			}
		}
		else
		{
			/* assert */
			if (stInitObj.content.size == 0 || stInitObj.content.data == NULL)
			{
				error("Something wrong (%d, %p)", stInitObj.content.size, stInitObj.content.data);
				continue;
			}

			if(stInitObj.name.size > 5 // 뒤에 최소 1자 이상의 이름이 있는지 체크하기 위해 >= 가 아니라 > 로 확인한다.
				&& strncmp((char *) stInitObj.name.data, MHEG_SRG_LOC_CI, 5) == 0)
			{
				opts.backend_mode = MHEGEngineBackendMode_CI;
				opts.srg_loc = MHEG_SRG_LOC_CI;
				opts.init_obj.name.size = stInitObj.name.size - 2;
				name[0] = '~';
				strcpy(&name[1], &stInitObj.name.data[3]);
				opts.init_obj.name.data = name;
				opts.init_obj.content.size = stInitObj.content.size;
				opts.init_obj.content.data = stInitObj.content.data;
			}
			else if(stInitObj.name.size > 6 // 뒤에 최소 1자 이상의 이름이 있는지 체크하기 위해 >= 가 아니라 > 로 확인한다.
				&& strncmp((char *) stInitObj.name.data, MHEG_SRG_LOC_DSM, 6) == 0)
			{
				opts.backend_mode = MHEGEngineBackendMode_DSM;
				opts.srg_loc = MHEG_SRG_LOC_DSM;
				opts.init_obj.name.size = stInitObj.name.size - 3;
				name[0] = '~';
				strcpy(&name[1], &stInitObj.name.data[4]);
				opts.init_obj.name.data = name;
				opts.init_obj.content.size = stInitObj.content.size;
				opts.init_obj.content.data = stInitObj.content.data;
			}
			else
			{
				error("'%.*s' needs initial object source like 'CI://' or 'DSM://'", stInitObj.name.size, stInitObj.name.data);
				safe_free(opts.init_obj.content.data);
				continue;
			}
		}

		verbose("--- MHEG internal browser start ---");

		rc = MHEGEngine_init(&opts);

		if (!rc) rc = MHEGEngine_run();

		MHEGEngine_fini();

		/* request app abort to ci_ammi stack */
		if (!rc && s_stMhegIbAmmiContext.usSessionId)
		{
			if (MHEGIB_AppAbort(s_stMhegIbAmmiContext.usSessionId, eMhegIb_Ad_AbortReqCode_UseCancel))
			{
				error("CI_RequestAppAbort (%d) failed", s_stMhegIbAmmiContext.usSessionId);
			}
		}

		#ifdef DEBUG_ENGINE
		MHEGEngine_print();
		#endif

		verbose("--- MHEG internal browser end ---");
	}
}

/* ---------------------------------------------------
   Public : Init environment for MHEG internal browser
   --------------------------------------------------- */
#define MHEGIB_MSGQ_SIZE				128//OCTO_MSGQ_LEVEL03
#define MHEGIB_RCV_MSGQ_SIZE			512//OCTO_MSGQ_LEVEL05
#define MHEGIB_TASK_PRIORITY			40//VK_TASK_PRIORITY_MW_REF
#define MHEGIB_TASK_STACK_SIZE		0x00010000//SIZE_64K


HERROR
MHEGIB_Init(void) /* 재진입 가능한 함수다 */
{
	/* create message queue and task for MHEG internal browser */
	if (!s_ulMhegIbMainMsgQId)
	{
		if (VK_MSG_Create(MHEGIB_MSGQ_SIZE, sizeof(MHEGIB_MAIN_MSG), "qMhegIbMain", &s_ulMhegIbMainMsgQId, VK_SUSPENDTYPE_PRIORITY))
		{
			fatal("VK_MSG_Create() failed");
			return -1;
		}
	}
	if (!s_ulMhegIbRunningMsgQId)
	{
		if (VK_MSG_Create(MHEGIB_RCV_MSGQ_SIZE, sizeof(MHEGIB_RUN_MSG), "qMhegIbRunning", &s_ulMhegIbRunningMsgQId, VK_SUSPENDTYPE_PRIORITY))
		{
			fatal("VK_MSG_Create() failed");
			return -1;
		}
	}
	if (!s_ulMhegIbTaskId)
	{
		if (VK_TASK_Create((void*)local_MHEGIB_main, MHEGIB_TASK_PRIORITY, MHEGIB_TASK_STACK_SIZE, "tMhegIbMain", (void*)NULL, &s_ulMhegIbTaskId, 0))
		{
			fatal("VK_TASK_Create() failed");
			return -1;
		}
		if (VK_TASK_Start(s_ulMhegIbTaskId))
		{
			fatal("VK_TASK_Start() failed");
			return -1;
		}
	}

	/* create semaphore for missing content list */
	if (!g_ulMhegIbMissingContentSemId)
	{
		if (VK_SEM_Create(&g_ulMhegIbMissingContentSemId, "sMhegIbMissing", VK_SUSPENDTYPE_PRIORITY))
		{
			fatal("VK_SEM_Create() failed");
			return -1;
		}
	}

	/* register callback function for CI Application MMI */
	// ycgo
	//CI_RegisterAppMmiCallback(local_MHEGIB_CiAppMmi_cb_main);

	return 0;
}

MHEGIB_Profile MHEGIB_GetProfile(void)
{
	MHEGIB_Profile profile = MHEGIB_Profile_Unknown;

	// 설정된 configuration 에 따라 지원하는 profile 셋팅... 단, CI+ MHEG Profile 을 우선해야 하는 경우, 다른 profile 은 무시.

#if defined(CONFIG_MW_CI_PLUS) || defined(CONFIG_3RD_MHEG_CIPLUS_PROFILE1) /* CAS관련 Config가 Global config가 되기 전에 임시로 사용 */
	profile |= MHEGIB_Profile_CI;
#endif

#if defined(CONFIG_3RD_MHEG_UK_PROFILE1)
	profile |= MHEGIB_Profile_UK;
#endif

#if defined(CONFIG_3RD_MHEG_UKFEESAT_PROFILE)
	profile |= MHEGIB_Profile_UK_FSAT;
#endif

#if defined(CONFIG_3RD_MHEG_NZ_PROFILE1)
	profile |= MHEGIB_Profile_NZ;
#endif

#if defined(CONFIG_3RD_MHEG_HK_PROFILE1)
	profile |= MHEGIB_Profile_HK;
#endif

#if defined(CONFIG_MW_CI_PLUS) || defined(CONFIG_3RD_MHEG_CIPLUS_PROFILE1) /* CAS관련 Config가 Global config가 되기 전에 임시로 사용 */
	if (engine.backend.base_dir)
	{
		if (VK_memcmp(engine.backend.base_dir, MHEG_SRG_LOC_CI, 5) == 0)
			profile = MHEGIB_Profile_CI;
	}
#endif

	return profile;
}

/* End of file */
