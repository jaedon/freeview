
/*******************************************************************
	File Description
********************************************************************/
/**
	@file	  mw_ttxerrchk.c
	@brief    Teletext 관련 Error Protection codes

	Description:
	Module:

	Copyright (c) 2008 HUMAX Co., Ltd.			\n
	All rights reserved.						\n
*/

/*******************************************************************/
/********************      Header Files    *************************/
/*******************************************************************/
/** @brief global header file  */
//#include <octo_common.h>

/** @brief local header file  */
#include <ttx_errchk.h>
/*******************************************************************/
/********************      Static Variables     ********************/
/*******************************************************************/


/**
 *  ODD PARITY LOOKUP TABLE
 *
 *	텔레텍스트의 모든 데이터들은 bit order가 little endian이기 때문에 아래의
 * 	테이블에서는 홀수 패리티 검사와 함께 비트 오더를 big endian으로 바꿔준다.
 *
 *	The number '0xff' means parity error.
 */
static const HUINT8	s_aucOddParityTbl[256] =
{
	0xff,0x00,0x40,0xff,0x20,0xff,0xff,0x60,  0x10,0xff,0xff,0x50,0xff,0x30,0x70,0xff,
	0x08,0xff,0xff,0x48,0xff,0x28,0x68,0xff,  0xff,0x18,0x58,0xff,0x38,0xff,0xff,0x78,
	0x04,0xff,0xff,0x44,0xff,0x24,0x64,0xff,  0xff,0x14,0x54,0xff,0x34,0xff,0xff,0x74,
	0xff,0x0c,0x4c,0xff,0x2c,0xff,0xff,0x6c,  0x1c,0xff,0xff,0x5c,0xff,0x3c,0x7c,0xff,
	0x02,0xff,0xff,0x42,0xff,0x22,0x62,0xff,  0xff,0x12,0x52,0xff,0x32,0xff,0xff,0x72,
	0xff,0x0a,0x4a,0xff,0x2a,0xff,0xff,0x6a,  0x1a,0xff,0xff,0x5a,0xff,0x3a,0x7a,0xff,
	0xff,0x06,0x46,0xff,0x26,0xff,0xff,0x66,  0x16,0xff,0xff,0x56,0xff,0x36,0x76,0xff,
	0x0e,0xff,0xff,0x4e,0xff,0x2e,0x6e,0xff,  0xff,0x1e,0x5e,0xff,0x3e,0xff,0xff,0x7e,
	0x01,0xff,0xff,0x41,0xff,0x21,0x61,0xff,  0xff,0x11,0x51,0xff,0x31,0xff,0xff,0x71,
	0xff,0x09,0x49,0xff,0x29,0xff,0xff,0x69,  0x19,0xff,0xff,0x59,0xff,0x39,0x79,0xff,
	0xff,0x05,0x45,0xff,0x25,0xff,0xff,0x65,  0x15,0xff,0xff,0x55,0xff,0x35,0x75,0xff,
	0x0d,0xff,0xff,0x4d,0xff,0x2d,0x6d,0xff,  0xff,0x1d,0x5d,0xff,0x3d,0xff,0xff,0x7d,
	0xff,0x03,0x43,0xff,0x23,0xff,0xff,0x63,  0x13,0xff,0xff,0x53,0xff,0x33,0x73,0xff,
	0x0b,0xff,0xff,0x4b,0xff,0x2b,0x6b,0xff,  0xff,0x1b,0x5b,0xff,0x3b,0xff,0xff,0x7b,
	0x07,0xff,0xff,0x47,0xff,0x27,0x67,0xff,  0xff,0x17,0x57,0xff,0x37,0xff,0xff,0x77,
	0xff,0x0f,0x4f,0xff,0x2f,0xff,0xff,0x6f,  0x1f,0xff,0xff,0x5f,0xff,0x3f,0x7f,0xff
};


/**
 *  HAMMING 8/4 CODE LOOKUP TABLE
 *
 *	텔레텍스트의 모든 데이터들은 bit order가 little endian이기 때문에 아래의
 * 	테이블에서는 비트 오더를 big endian으로 바꿔준다.
 *
 *	The number '0xff' means reject data.
 */
static const HUINT8	s_aucHamming84Tbl[256] =
{
	0x01,0xff,0xff,0x08,0xff,0x0c,0x04,0xff,  0xff,0x08,0x08,0x08,0x06,0xff,0xff,0x08,
	0xff,0x0a,0x02,0xff,0x06,0xff,0xff,0x0f,  0x06,0xff,0xff,0x08,0x06,0x06,0x06,0xff,
	0xff,0x0a,0x04,0xff,0x04,0xff,0x04,0x04,  0x00,0xff,0xff,0x08,0xff,0x0d,0x04,0xff,
	0x0a,0x0a,0xff,0x0a,0xff,0x0a,0x04,0xff,  0xff,0x0a,0x03,0xff,0x06,0xff,0xff,0x0e,
	0x01,0x01,0x01,0xff,0x01,0xff,0xff,0x0f,  0x01,0xff,0xff,0x08,0xff,0x0d,0x05,0xff,
	0x01,0xff,0xff,0x0f,0xff,0x0f,0x0f,0x0f,  0xff,0x0b,0x03,0xff,0x06,0xff,0xff,0x0f,
	0x01,0xff,0xff,0x09,0xff,0x0d,0x04,0xff,  0xff,0x0d,0x03,0xff,0x0d,0x0d,0xff,0x0d,
	0xff,0x0a,0x03,0xff,0x07,0xff,0xff,0x0f,  0x03,0xff,0x03,0x03,0xff,0x0d,0x03,0xff,
	0xff,0x0c,0x02,0xff,0x0c,0x0c,0xff,0x0c,  0x00,0xff,0xff,0x08,0xff,0x0c,0x05,0xff,
	0x02,0xff,0x02,0x02,0xff,0x0c,0x02,0xff,  0xff,0x0b,0x02,0xff,0x06,0xff,0xff,0x0e,
	0x00,0xff,0xff,0x09,0xff,0x0c,0x04,0xff,  0x00,0x00,0x00,0xff,0x00,0xff,0xff,0x0e,
	0xff,0x0a,0x02,0xff,0x07,0xff,0xff,0x0e,  0x00,0xff,0xff,0x0e,0xff,0x0e,0x0e,0x0e,
	0x01,0xff,0xff,0x09,0xff,0x0c,0x05,0xff,  0xff,0x0b,0x05,0xff,0x05,0xff,0x05,0x05,
	0xff,0x0b,0x02,0xff,0x07,0xff,0xff,0x0f,  0x0b,0x0b,0xff,0x0b,0xff,0x0b,0x05,0xff,
	0xff,0x09,0x09,0x09,0x07,0xff,0xff,0x09,  0x00,0xff,0xff,0x09,0xff,0x0d,0x05,0xff,
	0x07,0xff,0xff,0x09,0x07,0x07,0x07,0xff,  0xff,0x0b,0x03,0xff,0x07,0xff,0xff,0x0e,
};


/**
 * 비트 오더를 반대로 변경하기 위한 테이블들
 */
static const HUINT8	s_aucHBitRevTbl[] =
{
	0x00,0x80,0x40,0xc0,0x20,0xa0,0x60,0xe0,  0x10,0x90,0x50,0xd0,0x30,0xb0,0x70,0xf0,
};

static const HUINT8	s_aucLBitRevTbl[] =
{
	0x00,0x08,0x04,0x0c,0x02,0x0a,0x06,0x0e,  0x01,0x09,0x05,0x0d,0x03,0x0b,0x07,0x0f,
};


/*******************************************************************/
/*************      Static Function Prototypes     *****************/
/*******************************************************************/

static	HUINT8	local_ttx_ParityChk	(const HUINT8 ucByte);

/*******************************************************************/
/********************      Functions       *************************/
/*******************************************************************/

HINT32	TTX_ERRCHK_OddParity	(HUINT8 *pucDest, const HUINT8 *pucSrc, HUINT32 ulLen)
{
	HINT32	err	= 0;

	if (pucDest == NULL || pucSrc == NULL || ulLen == 0)
	{
		return -1;
	}

	while (ulLen--)
	{
		*pucDest = s_aucOddParityTbl[*pucSrc++];
		if (*pucDest == eTTX_ERR_PARITY)
		{
			err++;
		}
		pucDest++;
	}

	return err;
}


HINT32	TTX_ERRCHK_Hamming84	(HUINT8 *pucDest, const HUINT8 *pucSrc, HUINT32 ulLen)
{
	HINT32	err = 0;

	if (pucDest == NULL || pucSrc == NULL || ulLen == 0)
	{
		return -1;
	}

	while (ulLen--)
	{
		*pucDest = s_aucHamming84Tbl[*pucSrc++];
		if (*pucDest == eTTX_ERR_HAMMING84)
		{
			err++;
		}
		pucDest++;
	}

	return err;
}


HINT32	TTX_ERRCHK_Hamming2418	(HUINT8 *pucDest, const HUINT8 *pucSrc, HUINT32 ulLen)
{
	HINT32	err	= 0;
	HUINT8	ucParityAtoE	= 0;
	HUINT8	ucParityF		= 0;

	if (pucDest == NULL || pucSrc == NULL || ulLen == 0)
	{
		return -1;
	}

	ulLen /= 3;

	while (ulLen--)
	{
		ucParityAtoE	= ((local_ttx_ParityChk(pucSrc[0] & 0xAA) ^ // A mask: 1010 1010
							local_ttx_ParityChk(pucSrc[1] & 0xAA) ^
							local_ttx_ParityChk(pucSrc[2] & 0xAA)) << 0)
						| ((local_ttx_ParityChk(pucSrc[0] & 0x66) ^ // B mask: 0110 0110
							local_ttx_ParityChk(pucSrc[1] & 0x66) ^
							local_ttx_ParityChk(pucSrc[2] & 0x66)) << 1)
						| ((local_ttx_ParityChk(pucSrc[0] & 0x1E) ^ // C mask: 0001 1110
							local_ttx_ParityChk(pucSrc[1] & 0x1E) ^
							local_ttx_ParityChk(pucSrc[2] & 0x1E)) << 2)
						|  (local_ttx_ParityChk((pucSrc[0] << 7) | (pucSrc[1] >> 1)) << 3)	// D
						|  (local_ttx_ParityChk((pucSrc[1] << 7) | (pucSrc[2] >> 1)) << 4);	// E

		ucParityF		=  	local_ttx_ParityChk(pucSrc[0]) ^ local_ttx_ParityChk(pucSrc[1])
							^ local_ttx_ParityChk(pucSrc[2]);

		// If A, B, C, D, E are not all correct and F is correct then DOUBLE ERROR
		if (ucParityAtoE != 0x1F && ucParityF)
		{
			err++;
			continue;
		}

		pucDest[0]	= pucSrc[0];
		pucDest[1]	= pucSrc[1];
		pucDest[2]	= pucSrc[2];

		// If A, B, C, D, E are not all correct
		if (ucParityAtoE != 0x1F)
		{
			ucParityAtoE = (~ucParityAtoE) & 0x1F;
			pucDest[(ucParityAtoE - 1) / 8] ^= (0x80 >> (ucParityAtoE % 8 - 1));
		}

		// To convert bit order to big endian
		TTX_ERRCHK_ReverseBit(pucDest, pucSrc, 3);
		pucDest[0]	= ((pucDest[0] >> 2) & 0x1) | ((pucDest[0] & 0x70) >> 3);
		pucDest[1]	= pucDest[1] & 0x7F;
		pucDest[2]	= pucDest[2] & 0x7F;

		pucDest	+= 3;
		pucSrc	+= 3;
	}

	return err;
}


HINT32	TTX_ERRCHK_ReverseBit	(HUINT8 *pucDest, const HUINT8 *pucSrc, HUINT32 ulLen)
{
	if (pucDest == NULL || pucSrc == NULL || ulLen == 0)
	{
		return -1;
	}

	while (ulLen--)
	{
		*pucDest++ = (s_aucHBitRevTbl[*pucSrc & 0x0F] | s_aucLBitRevTbl[*pucSrc >> 4]);
		pucSrc++;
	}

	return 0;
}


static HUINT8	local_ttx_ParityChk(const HUINT8 ucByte)
{
	return (s_aucOddParityTbl[ucByte] == eTTX_ERR_PARITY) ? 0x0 : 0x1;
}



/* end of file */


