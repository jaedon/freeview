/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */
#include "InstrumentationThread.h"

#include <nrdbase/Instrumentation.h>
#include <nrdbase/Log.h>
#include <nrdbase/PerformanceMarker.h>
#include <nrdbase/StringTokenizer.h>

#include <nrdnet/AseUrl.h>
#include <nrdnet/IAsyncHttpLib.h>

#include "NrdApplication.h"
#include "NrdLog.h"
#include "SystemData.h"
#include "SystemDataListener.h"


namespace netflix
{
namespace nrdlog
{


//=============================================================================

#ifdef INSTRUMENTATION_ENABLED

//-----------------------------------------------------------------------------
// Tracing behavior

#if 0
#define INTRACES(s) NTRACES(TRACE_INSTRUMENTATION, s)
#define INTRACING
#else
#define INTRACES(s) do{}while(0)
#endif

//-----------------------------------------------------------------------------
// Each message is tagged with this version. If we change the format of
// the events beyond backward-compatible additions, we should bump this up.

#define INSTRUMENTATION_PROTOCOL_VERSION 1

//-----------------------------------------------------------------------------
// These are the keys in streaming config parameters used for instrumentation


#define INSTRUMENTATION_ENABLED_CONFIG_KEY "instrumentation.enabled"
#define INSTRUMENTATION_ENABLED_CONFIG_DEFAULT "true"

#define INSTRUMENTATION_SWITCHED_ENABLED_CONFIG_KEY "instrumentation.switched.enabled"
#define INSTRUMENTATION_SWITCHED_ENABLED_CONFIG_DEFAULT "false"

#define INSTRUMENTATION_ONLY_EVENTS_CONFIG_KEY "instrumentation.only.events"
#define INSTRUMENTATION_ONLY_EVENTS_CONFIG_DEFAULT "*"

#define INSTRUMENTATION_STASH_OFF_SECONDS 20

//-----------------------------------------------------------------------------
// This decides whether switched events are on before we have received the
// corresponding configuration from the server.

static bool sINSTRUMENTATION_SWITCHED_EVENTS_INITIALLY_ON(true);

//-----------------------------------------------------------------------------
// With this one, you can decide that switched events are always on, regardless
// of what the server says

static bool sINSTRUMENTATION_SWITCHED_EVENTS_ALWAYS_ON(false);

//-----------------------------------------------------------------------------
// This is the number of ms that the thread waits between iterations, to
// throttle it. This has nothing to do with the frequency of events that
// can be generated by the application.

static llong sINSTRUMENTATION_THREAD_THROTTLE_MS(100);

//-----------------------------------------------------------------------------
// This is the maximum number of events the collector pulls from the queue
// in each iteration.

static llong sINSTRUMENTATION_THREAD_THROTTLE_EVENTS(100);

//-----------------------------------------------------------------------------
// These are the criteria for flushing the event buffer. Size in bytes, count
// and time in ms.

static llong sINSTRUMENTATION_BUFFER_MAX_SIZE ( 150 * 1024);
static llong sINSTRUMENTATION_BUFFER_MAX_COUNT(1500       );
static llong sINSTRUMENTATION_BUFFER_MAX_TIME (  45 * 1000);

//-----------------------------------------------------------------------------
// If false, will not send log messages either to the console or NCCP

static bool sINSTRUMENTATION_LOG_ENABLED(true);

// A URL to post events

static std::string sINSTRUMENTATION_POST_URL("");

// If set, streaming config parameters are ignored (for testing)

static bool sINSTRUMENTATION_IGNORE_CONFIG(false);

// Prints events in real time

static bool sINSTRUMENTATION_PRINT(false);

// Post events to NTS in their format

static bool sINSTRUMENTATION_NTS_POST(false);

// Stash events in memory so that JS can get them later

static bool sINSTRUMENTATION_STASH_ON(false);

// Stash is initially on

static bool sINSTRUMENTATION_STASH_INITIALLY_ON(true);

// List of event names to include

static std::string sINSTRUMENTATION_EVENT_NAMES("");

// Will cause the instrumentation thread to exit early

static bool sINSTRUMENTATION_THREAD_EXIT(false);

//=============================================================================
// Always returns a map variant.

static Variant mergeVariantMaps(const Variant & a, const Variant & b)
{
    if (!a.isStringMap() && ! b.isStringMap()) {
        // Neither is a map, so we return an empty variant map
        return Variant(std::map<std::string, Variant>());
    }

    if (!a.isStringMap()) {
        // A is not a map, but B is, so we return B
        return b;
    }

    if (!b.isStringMap()) {
        // B is not a map, but A is, so we return A
        return a;
    }

    // They're both maps, we merge

    Variant result(a);
    const Variant::StringMapIterator end = b.stringMapEnd();
    for (Variant::StringMapIterator it = b.stringMapBegin(); it != end; ++it) {
        result[ it->first ] = it->second;
    }
    return result;
}

//=============================================================================

class ConfigListener : public SystemDataListener
{
public:
    static shared_ptr<SystemDataListener> install() {
        shared_ptr<SystemDataListener> listener(new ConfigListener());
        nrdApp()->systemData()->addListener(listener);
        return listener;
    }

    virtual void datumChanged(SystemDataKey::Key key) {
        if (key == SystemDataKey::SYSTEM_FILE) {
            Log::info(TRACE_INSTRUMENTATION, "STREAMING CONFIGURATION PARAMETERS CHANGED");

            std::map< std::string, std::string> params(nrdApp()->serviceParameters("streaming"));

            if (params.find(INSTRUMENTATION_ENABLED_CONFIG_KEY) != params.end() ||
                params.find(INSTRUMENTATION_SWITCHED_ENABLED_CONFIG_KEY) != params.end() ||
                params.find(INSTRUMENTATION_ONLY_EVENTS_CONFIG_KEY) != params.end()) {
                instrumentation::config();
            } else {
                Log::info(TRACE_INSTRUMENTATION, " PARAMETERS DO NOT INCLUDE INSTRUMENTATION SETTINGS, IGNORING");
            }
        }
    }
};

//=============================================================================
// Thread that collects events and sends them

DECLARE_THREAD(INSTRUMENTATION_COLLECTOR);
DEFINE_THREAD(INSTRUMENTATION_COLLECTOR, Thread::minPriority, 0);

//=============================================================================

using namespace instrumentation;

class CollectorThread : public Thread
{
public:

    CollectorThread();

private:

    struct IntervalData {
        IntervalData(shared_ptr<Event> event)
            : event(event),
            started(event->mono),
            mark(event->mono)
        {}

        void restart(ullong mono) {
            started = mark = mono;
            counters.clear();
            tags.clear();
            marks.clear();
        }

        void count(const std::string & name, llong increment) {
            counters[ name ] += increment;
        }

        void addMark(const std::string name, ullong mono, const Variant & value) {
            // This can happen when a mark comes in after the interval was restarted
            // because the restart time is now-ish and could come after the mark
            // was inserted into the queue with an earlier mono.
            if (mono < mark && mark == started) {
                mono = mark;
            }
            marks[ name ].push_back(MarkData(mark - started, mono - mark, value));
            mark = mono;
        }

        typedef std::map< std::string, llong > CounterMap;
        struct MarkData {
            MarkData(ullong s, ullong d, const Variant &v) : started(s), duration(d), value(v) { }
            ullong started;
            ullong duration;
            Variant value;
        };
        typedef std::vector< MarkData > MarkList;
        typedef std::map< std::string, MarkList > MarkMap;

        shared_ptr<Event> event;
        ullong started;
        CounterMap counters;
        Variant tags;
        ullong mark;
        MarkMap marks;
    };

    struct BufferedEvent {
        BufferedEvent(Type _type, const std::string & _name, const std::string & _json)
            : type(_type), name(_name), json(_json)
        {}

        Type type;
        std::string name;
        std::string json;
    };

    typedef std::vector< BufferedEvent > Events;
    typedef std::map< std::string, IntervalData > IntervalMap;
    typedef std::set< std::string > StringSet;
    typedef std::map< std::string, std::string > StringMap;

    virtual void Run();

    void setConfiguration();
    void applyConfiguration(StringMap & params);
    void setEventNameFilter(const std::string & eventNames);
    void checkForSwitches();
    void updateQueueFilter();

    bool shouldDiscardEventType(Type type) const;
    bool shouldDiscardEventName(const std::string & name) const;
    bool shouldDiscardEvent(Type type, const std::string & name) const;
    bool filteringByName() const;

    void bufferEvent(shared_ptr<Event> event, const IntervalData * data = 0);
    std::string toJSON() const;
    bool send(bool force);
    void post(const std::string & json);

    typedef std::set< shared_ptr<Listener> > ListenerSet;

    shared_ptr<Queue> mQueue;

    Events mEvents;
    IntervalMap mIntervals;
    size_t mSize;
    Time mLastSent;
    unsigned mNextThreadNumber;
    bool mDisabled;
    bool mConfigReceived;
    std::string mESN;
    Stopwatch mStart;

    bool mInstrumentationOn;
    bool mSwitchedEventsOn;
    StringSet mOnlyEventNames;

    ListenerSet mListeners;

    Variant mStash;
};

//=============================================================================
// Collector thread

CollectorThread::CollectorThread()
    : Thread(& THREAD_INSTRUMENTATION_COLLECTOR),
      mQueue(getQueue()),
      mSize(0),
      mLastSent(Time::mono()),
      mNextThreadNumber(1),
      mDisabled(false),
      mConfigReceived(false),
      mInstrumentationOn(true),
      mSwitchedEventsOn(sINSTRUMENTATION_SWITCHED_EVENTS_INITIALLY_ON || sINSTRUMENTATION_SWITCHED_EVENTS_ALWAYS_ON)
{
    if (!mSwitchedEventsOn) {
        updateQueueFilter();
    }
    setEventNameFilter(sINSTRUMENTATION_EVENT_NAMES);
    Start();
}


void CollectorThread::Run()
{
    Log::info(TRACE_INSTRUMENTATION) << "INSTRUMENTATION THREAD STARTING";

    if (sINSTRUMENTATION_THREAD_EXIT)
    {
        mQueue->close(false);
        mQueue->clear();
        Log::info(TRACE_INSTRUMENTATION) << "INSTRUMENTATION COLLECTOR THREAD EXITING EARLY";
        return;
    }

    shared_ptr<SystemDataListener> listener = ConfigListener::install();

    mESN = nrdApp()->getSystem()->getEsn();

    // If it was explicitly turned on by a command line argument, we need
    // to turn off the initial switch - so that it will stay on.

    if (sINSTRUMENTATION_STASH_ON && sINSTRUMENTATION_STASH_INITIALLY_ON) {
        sINSTRUMENTATION_STASH_INITIALLY_ON = false;
    }

    Time stashOffTime(Time::mono() + Time::fromSeconds(INSTRUMENTATION_STASH_OFF_SECONDS));

    Time wakeupTime(0);
    Stopwatch waited;

    while (!mQueue->is_closed()) {
        PERFORMANCE_MARKER_SCOPED("instrumentation.loop");

        //---------------------------------------------------------------------
        // Throttle this thread if the iteration took less than our throttle time

        llong elapsed = static_cast<llong>(waited.elapsed());

        if (elapsed < sINSTRUMENTATION_THREAD_THROTTLE_MS) {
            const Time now = Time::mono();
            const Time throttleWakeUpTime = std::min(now + Time::fromMS(sINSTRUMENTATION_THREAD_THROTTLE_MS), wakeupTime);
            const ullong ms = (throttleWakeUpTime - now).ms();
            if (ms > 0) {
                INTRACES("TIME IS NOW " << now << " SLEEPING FOR " << ms << " ms");
                usleep(ms * MicroSecondsPerMillisecond);
            }
        }

        waited.restart();

        //---------------------------------------------------------------------
        // Flush buffered events

        send(false);

        //---------------------------------------------------------------------

        const Time timeNow(Time::mono());

        //---------------------------------------------------------------------
        // If no one turns it on explicitly within a certain amount of time,
        // we turn it off and clear it.

        if (sINSTRUMENTATION_STASH_INITIALLY_ON && timeNow >= stashOffTime) {
            Log::info(TRACE_INSTRUMENTATION) << "TURNING OFF STASH";
            sINSTRUMENTATION_STASH_INITIALLY_ON = false;
            mStash.clear();
            updateQueueFilter();
        }

        //---------------------------------------------------------------------
        // If we woke up because we reached our wake up time (as opposed to
        // because we popped some events) we have to calculate our next
        // wake up time. We have to look at repeating intervals.

        if (wakeupTime <= timeNow) {
            wakeupTime = mLastSent + Time::fromMS(sINSTRUMENTATION_BUFFER_MAX_TIME);

            if (!mIntervals.empty()) {
                INTRACES("TIME NOW IS " << timeNow << " SWEEPING INTERVALS");

                for (IntervalMap::iterator it = mIntervals.begin(); it != mIntervals.end(); ++it) {
                    IntervalData & data(it->second);

                    if (ullong reset = data.event->intervalReset) {
                        Time resetTime = Time(data.started + reset);

                        // This one is done
                        if (resetTime <= timeNow) {
                            // If the counters are not empty, or the interval has tags buffer an event
                            if (!data.counters.empty() || ! data.tags.empty()) {
                                INTRACES(" GENERATING AUTO EVENT FOR \"" << it->first << "\"");
                                bufferEvent(shared_ptr<Event>(Event::make(data.event->type, timeNow.ms(), data.event->name, Variant::null(), data.event->thread)), & it->second);
                            }
                            // Restart the interval
                            data.restart(resetTime.ms());

                            // Get the next time it should fire
                            resetTime += Time(reset);
                        }
                        wakeupTime = std::min(wakeupTime, resetTime);
                    }
                }
            }
        }

        //---------------------------------------------------------------------
        // See if we need to wake up a little earlier to turn off the stash

        if (sINSTRUMENTATION_STASH_INITIALLY_ON && wakeupTime > stashOffTime) {
            INTRACES("WAKING UP EARLIER TO TURN OFF STASH AT " << stashOffTime);
            wakeupTime = stashOffTime;
        }

        //---------------------------------------------------------------------
        // Wait for some events, making sure we don't wait forever (Time(0))

        const Time wait(wakeupTime - timeNow);

        if (wait.ms() == 0) {
            continue;
        }

        INTRACES("TIME NOW IS " << timeNow << " WAITING UNTIL " << wakeupTime << " (" << wait << " ms)");

        // Grab events from the queue

        Queue::List events = mQueue->pop_all(wait, std::max<llong>(mQueue->size() / 4, sINSTRUMENTATION_THREAD_THROTTLE_EVENTS));

        if (events.empty()) {
            continue;
        }

        waited.stop();

        //Log::warn(TRACE_INSTRUMENTATION) << "POPPED " << events.size() << "/" << mQueue->size();

        INTRACES("POPPED " << events.size() << ", LEFT " << mQueue->size());

        //---------------------------------------------------------------------
        // Now process each event

        for (Queue::List::const_iterator eit = events.begin(); eit != events.end(); ++eit) {
            PERFORMANCE_MARKER_START("instrumentation.loop.process");

            shared_ptr<Event> event(*eit);

            //INTRACES( "PROCESSING EVENT " << event.get() << "\"" << event->name << "\" " << "TYPE=" << event->type << " OP=" << event->intervalOp );

            switch (event->type) {
                // A flush event forces us to send whatever we have buffered
            case instrumentation::Flush:
                send(true);
                if (sINSTRUMENTATION_LOG_ENABLED) {
                    Log::Message(TRACE_INSTRUMENTATION, Log::Info, netflix::nrdlog::MessageType::flush).send();
                }
                break;

                // This event tells us that streaming configuration parameters have changed
            case instrumentation::Config:
                setConfiguration();
                break;

            case instrumentation::Enable:
                mDisabled = false;
                break;

            case instrumentation::Disable:
                mDisabled = true;
                mEvents.clear();
                break;

            case instrumentation::SwitchedOn:
                sINSTRUMENTATION_SWITCHED_EVENTS_ALWAYS_ON = true;
                mSwitchedEventsOn = true;
                updateQueueFilter();
                break;

            case instrumentation::SwitchedOff:
                mSwitchedEventsOn = false;
                updateQueueFilter();
                break;

            case instrumentation::StashOn:
                sINSTRUMENTATION_STASH_ON = true;
                sINSTRUMENTATION_STASH_INITIALLY_ON = false;
                INTRACES("STASH IS NOW ON");
                updateQueueFilter();
                break;

            case instrumentation::StashOff:
                sINSTRUMENTATION_STASH_ON = false;
                sINSTRUMENTATION_STASH_INITIALLY_ON = false;
                INTRACES("STASH IS NOW OFF");
                updateQueueFilter();
                break;

            case instrumentation::PopStash:
                // We transfer the contents of our stash into the event
                static_pointer_cast<PopStashEvent>(event)->swap(mStash);
                INTRACES("POPPED STASH");
                break;

            case instrumentation::AddListener:
                mListeners.insert(event->listener);
                INTRACES("ADDED LISTENER");
                break;

            case instrumentation::RemoveListener:
                mListeners.erase(event->listener);
                INTRACES("REMOVED LISTENER");
                break;


                // All other "normal" events
            case instrumentation::On:
            case instrumentation::Switched:
            case instrumentation::Test:
            case instrumentation::Debug:
                switch (event->intervalOp) {
                    // Really "normal" event
                case instrumentation::None:
                    bufferEvent(event);
                    break;

                case instrumentation::Start: {
                    std::pair< IntervalMap::iterator, bool > result = mIntervals.insert(std::make_pair(event->name, IntervalData(event)));
                    // If it was inserted
                    if (result.second) {
                        // Adjust our wakeup time if this is a repeating interval
                        if (event->intervalReset) {
                            wakeupTime = std::min(wakeupTime, event->mono + Time(event->intervalReset));
                        }
                    }
                }
                    break;

                case instrumentation::Count: {
                    IntervalMap::iterator it = mIntervals.find(event->name);
                    // If we find the interval by name, we increment its counter
                    if (it != mIntervals.end()) {
                        it->second.count(event->intervalCounter, event->intervalCountIncrement);
                    }
                }
                    break;

                case instrumentation::Tag: {
                    IntervalMap::iterator it = mIntervals.find(event->name);
                    // If we find the interval by name, we merge the event value
                    // with any existing tags
                    if (it != mIntervals.end()) {
                        it->second.tags = mergeVariantMaps(it->second.tags, event->value);
                    }
                }
                    break;

                case instrumentation::Mark: {
                    IntervalMap::iterator it = mIntervals.find(event->name);
                    // If we find it, we push the new mark into it
                    if (it != mIntervals.end()) {
                        it->second.addMark(event->intervalCounter, event->mono, event->value);
                    }
                }
                    break;

                case instrumentation::CountMark: {
                    IntervalMap::iterator it = mIntervals.find(event->name);
                    // If we find the interval by name, we increment its counter
                    if (it != mIntervals.end()) {
                        it->second.count(event->intervalCounter, 1);
                        it->second.addMark(event->intervalCounter, event->mono, event->value);
                    }
                }
                    break;

                case instrumentation::End:
                case instrumentation::Cancel: {
                    IntervalMap::iterator it = mIntervals.find(event->name);
                    // If it exists
                    if (it != mIntervals.end()) {
                        if (event->intervalOp == instrumentation::End) {
                            bool wanted = true;
                            // In auto-reset intervals, it is possible that there was an END event that was pushed
                            // before we did an auto-reset but processed after - in which case we will see
                            // a phantom interval event with negative duration
                            if (it->second.event->intervalReset && it->second.started > event->mono) {
                                Log::warn(TRACE_INSTRUMENTATION) << "END for '" << event->name << "' was processed at " << Time::monoMS() << " and pushed at " << event->mono
                                    << ". The interval was reset at " << it->second.started;
                                wanted = false;
                            }
                            // Buffer the event with the interval data
                            if (wanted) {
                                bufferEvent(shared_ptr<Event>(Event::make(it->second.event->type, event->mono, it->first, event->value, event->thread)), & it->second);
                            }
                        }
                        // Get rid of the interval data
                        mIntervals.erase(it);
                    }
                }
                    break;
                }
                break;
            }

            PERFORMANCE_MARKER_END();

            usleep(5);
        }
    }
}

void CollectorThread::setConfiguration()
{
    if (shared_ptr<SystemData> sysdata = nrdApp()->systemData()) {
        // This comes from streaming config

        StringMap params = nrdApp()->serviceParameters("streaming");

        // These come from NCCP response parameters

        bool nccpInstrumentationEnabled = sysdata->instrumentationEnabled();
        std::string nccpInstrumentationEvents = sysdata->instrumentationEvents();

        Log::info(TRACE_INSTRUMENTATION) << " NCCP : INSTRUMENTATION ENABLED = " << std::boolalpha << nccpInstrumentationEnabled;
        Log::info(TRACE_INSTRUMENTATION) << " NCCP : INSTRUMENTATION EVENTS = [" << nccpInstrumentationEvents << "]";

        params[ INSTRUMENTATION_ENABLED_CONFIG_KEY ] = (params[ INSTRUMENTATION_ENABLED_CONFIG_KEY ] != "false" && nccpInstrumentationEnabled) ? "true" : "false";

        if (!nccpInstrumentationEvents.empty()) {
            params[ INSTRUMENTATION_ONLY_EVENTS_CONFIG_KEY ] = nccpInstrumentationEvents;
        }

        applyConfiguration(params);
    }
}

void CollectorThread::setEventNameFilter(const std::string & eventNames)
{
    if (!eventNames.empty()) {
        if (eventNames == "*") {
            mOnlyEventNames.clear();
        } else {
            std::vector< std::string > names;
            StringTokenizer::tokenize(eventNames, names, ", ");
            mOnlyEventNames.clear();
            for (std::vector< std::string >::const_iterator it = names.begin(); it != names.end(); ++it) {
                if (!it->empty()) {
                    // If an event name starts with "#", it is actually a category
                    // For now, we only handle #switched here.

                    if (it->substr(0, 1) == "#") {
                        if (*it == "#switched") {
                            mSwitchedEventsOn = true;
                        }
                    } else {
                        mOnlyEventNames.insert(*it);
                    }
                }
            }
            updateQueueFilter();
        }
    }
}


void CollectorThread::applyConfiguration(StringMap & params)
{
    mConfigReceived = true;

    if (sINSTRUMENTATION_IGNORE_CONFIG) {
        Log::warn(TRACE_INSTRUMENTATION) << "IGNORING STREAMING CONFIG PARAMETERS";
        return;
    }

    bool oldVerbose = mInstrumentationOn && mSwitchedEventsOn;

    INTRACES("APPLYING CONFIGURATION PARAMETERS");

    mInstrumentationOn = params[ INSTRUMENTATION_ENABLED_CONFIG_KEY ] != "false";
    mSwitchedEventsOn = (sINSTRUMENTATION_SWITCHED_EVENTS_ALWAYS_ON || params[ INSTRUMENTATION_SWITCHED_ENABLED_CONFIG_KEY ] == "true");

    const std::string onlyEventNames(params[ INSTRUMENTATION_ONLY_EVENTS_CONFIG_KEY ]);
    setEventNameFilter(onlyEventNames);

    Log::info(TRACE_INSTRUMENTATION)
        << "UPDATING SWITCHES"
        << " : INSTRUMENTATION ON = " << std::boolalpha << mInstrumentationOn
        << " : SWITCHED EVENTS ON = " << std::boolalpha << mSwitchedEventsOn
        << " : ONLY EVENTS = " << (filteringByName() ? onlyEventNames : "<all>");

    updateQueueFilter();

    // See if "verbosity" changed. If so, tell listeners

    bool verbose = mInstrumentationOn && mSwitchedEventsOn;

    if (oldVerbose != verbose) {
        INTRACES("VERBOSE CHANGED TO " << std::boolalpha << verbose);

        if (!mListeners.empty()) {
            for (ListenerSet::iterator it = mListeners.begin(); it != mListeners.end(); ++ it) {
                (*it)->verboseChanged(verbose);
            }
        }
    }

    // Instrumentation is not on, we can clear everything.
    // We can also close the queue and let the thread go away.

    if (!mInstrumentationOn) {
        Log::info(TRACE_INSTRUMENTATION) << "INSTRUMENTATION IS OFF, THREAD EXITING";
        mEvents.clear();
        mIntervals.clear();
        mQueue->close(false);
        mQueue->clear();
        mStash.clear();
        return;
    }

    size_t count = 0;

    // Get rid of buffered events

    for (Events::iterator it = mEvents.begin(); it != mEvents.end();) {
        if (shouldDiscardEventType(it->type)) {
            //INTRACES(" DROPPING BUFFERED EVENT \"" << it->name << "\"");
            it = mEvents.erase(it);
            ++count;
        } else if (shouldDiscardEventName(it->name)) {
            //INTRACES(" DROPPING BUFFERED EVENT \"" << it->name << "\" (BY NAME)");
            it = mEvents.erase(it);
            ++count;
        } else {
            it++;
        }
    }

    if (count) {
        Log::info(TRACE_INSTRUMENTATION) << " DROPPED " << count << " EVENTS ";
    }
}

class SwitchedFilter : public AsyncQueue<Event>::Filter
{
public:
    virtual bool operator()(const shared_ptr<Event> &event) const
    {
        return (event->type != instrumentation::Switched);
    }
};

void CollectorThread::updateQueueFilter()
{
    shared_ptr<Queue::Filter> filter;
    if (!mSwitchedEventsOn && !(sINSTRUMENTATION_STASH_ON || sINSTRUMENTATION_STASH_INITIALLY_ON)) {
        filter.reset(new SwitchedFilter);
        Log::info(TRACE_INSTRUMENTATION) << ">> INSTALLED SWITCHED FILTER <<";
    } else {
        Log::info(TRACE_INSTRUMENTATION) << ">> CLEARED SWITCHED FILTER <<";
    }
    mQueue->set_filter(filter);
}

bool CollectorThread::shouldDiscardEventType(Type type) const
{
    return (!mInstrumentationOn) ||
        (type == instrumentation::Switched && ! mSwitchedEventsOn);
}

bool CollectorThread::filteringByName() const
{
    return ! mOnlyEventNames.empty();
}

bool CollectorThread::shouldDiscardEventName(const std::string & name) const
{
    return filteringByName() && mOnlyEventNames.find(name.substr(0, name.find('/'))) == mOnlyEventNames.end();
}

bool CollectorThread::shouldDiscardEvent(Type type, const std::string & name) const
{
    return shouldDiscardEventType(type) || shouldDiscardEventName(name);
}


void CollectorThread::bufferEvent(shared_ptr<Event> event, const CollectorThread::IntervalData * data)
{
    assert((!data) || (data && data->event->type == event->type));

    // The result is logged as an array, so order is important.
    // Do not change the order! Add to the end.
    //
    // 1 name [string]
    // 2 time [integer]
    // 3 category [integer] (0=ON, 1=SWITCHED, 2=TEST, 3=DEBUG)
    // 4 thread number [unsigned integer]
    // 5 value (payload) [object (which may be empty)]
    //
    // 6 elapsed time for intervals [integer, or not present]
    // 7 counters for intervals [object with unsigned integer values, empty object or not present ]
    // 8 marks for intervals [object with mark name keys and values. Value is an array of arrays,
    // each array has the start time and the duration. Or not present ]
    //
    // For example: { "foo" : [ [ 0, 5 ], [ 12, 40 ] ], "bar" : [ [ 5, 7] ] }
    //
    // This interval has two marks, "foo" and "bar". Foo had two slices, one starting
    // at 0 ms from the interval start time and lasting for 5 ms and another starting
    // at 12 ms and lasting for 40. Bar has one slice, starting at 5 ms and lasting for 7.
    //
    // If you add an element, you will need to make the "not present ones" above null.
    // AND - you should bump INSTRUMENTATION_PROTOCOL_VERSION above.

    Variant v;

    // 1 NAME
    v.push_back(event->name.substr(0, event->name.find('/')));

    // 2 TIME
    v.push_back(event->mono - Application::MONO_STARTED.ms());

    // 3 CATEGORY
    v.push_back(static_cast<int>(event->type));

    // 4 THREAD NUMBER
    v.push_back(event->thread);

    // 5 VALUE
    // The event may have up to 3 maps:
    // 1) from the interval start
    // 2) from interval tags
    // 3) from the event itself (either a plain event or an interval end event)
    // If there is interval data, we merge the tags with the start value
    // We then merge the end value with that
    Variant intervalValue(data ? mergeVariantMaps(data->event->value, data->tags) : Variant::null());
    v.push_back(mergeVariantMaps(intervalValue, event->value));

    if (data) {
        // 6 ELAPSED
        v.push_back(event->mono - data->started);

        if (!(data->counters.empty() && data->marks.empty())) {
            // 7 COUNTERS
            Variant counters(Variant::Type_StringMap);
            for (IntervalData::CounterMap::const_iterator it = data->counters.begin(); it != data->counters.end(); ++ it) {
                counters[ it->first ] = it->second;
            }
            v.push_back(counters);

            // 8 MARKS
            Variant marks(Variant::Type_StringMap);
            for (IntervalData::MarkMap::const_iterator it = data->marks.begin(); it != data->marks.end(); ++it) {
                if (!it->second.empty()) {
                    Variant times(Variant::Type_Array);
                    for (IntervalData::MarkList::const_iterator mit = it->second.begin(); mit != it->second.end(); ++mit) {
                        Variant result;
                        result.push_back(mit->started);
                        result.push_back(mit->duration);
                        if (!mit->value.isNull())
                            result.push_back(mit->value);
                        times.push_back(result);
                    }
                    marks[ it->first ] = times;
                }
            }

            if (!marks.empty()) {
                v.push_back(marks);
            }
        }
    }
    assert(v.isArray());

    // See if there are any listeners that may want this event
    if (!mListeners.empty()) {
        for (ListenerSet::iterator it = mListeners.begin(); it != mListeners.end(); ++ it) {
            (*it)->receive(v);
        }
    }

    // See if we want to stash it

    if (sINSTRUMENTATION_STASH_ON || sINSTRUMENTATION_STASH_INITIALLY_ON) {
        mStash.push_back(v);
    }

    // Now filter it out. I know, I know.

    if (mDisabled) {
        INTRACES(" DROPPING EVENT \"" << event->name << "\" BECAUSE WE ARE DISABLED");
        return;
    }

    if (shouldDiscardEventType(event->type)) {
        INTRACES(" DROPPING EVENT \"" << event->name << "\" BY TYPE");
        return;
    }

    if (shouldDiscardEventName(event->name)) {
        INTRACES(" DROPPING EVENT \"" << event->name << "\" BY NAME");
        return;
    }

    std::string json(v.toJSON());
    mEvents.push_back(BufferedEvent(event->type, event->name, json));
    mSize += json.size();

    if (0 == mEvents.size() % 100) {
        Log::info(TRACE_INSTRUMENTATION) << "BUFFERED " << mEvents.size() << " EVENTS (" << mSize << " BYTES)";

#ifdef INTRACING
        std::map<std::string, size_t> names;
        for (Events::const_iterator it = mEvents.begin(); it != mEvents.end(); ++it)
            ++names[it->name.substr(0, it->name.find('/'))];
        for (std::map<std::string, size_t>::const_iterator it = names.begin(); it != names.end(); ++it)
            INTRACES("   " << std::setw(6) << it->second << "  " << it->first);
#endif

    }

    if (sINSTRUMENTATION_PRINT) {
        Log::printf("%s\n", json.c_str());
    }
}

std::string CollectorThread::toJSON() const
{
    std::ostringstream stream;
    stream << "[";
    int i = 0;
    for (Events::const_iterator it = mEvents.begin(); it != mEvents.end(); ++it) {
        if (!shouldDiscardEvent(it->type, it->name)) {
            stream << (i ? ", " : "") << it->json;
            ++i;
        }
    }
    stream << "]";
    return stream.str();
}


bool CollectorThread::send(bool force)
{
    Time now(Time::mono());

    if (force) {
        INTRACES("SENDING BECAUSE IT WAS FORCED");
    } else if (mSize > static_cast<size_t>(sINSTRUMENTATION_BUFFER_MAX_SIZE)) {
        INTRACES("SENDING BECAUSE WE HAS EXCEEDED THE MAX SIZE : " << mSize << " > " << sINSTRUMENTATION_BUFFER_MAX_SIZE);
    } else if (mEvents.size() > static_cast<size_t>(sINSTRUMENTATION_BUFFER_MAX_COUNT)) {
        INTRACES("SENDING BECAUSE WE HAS EXCEEDED THE MAX COUNT : " << mEvents.size() << " > " << sINSTRUMENTATION_BUFFER_MAX_COUNT);
    } else if ((now - mLastSent).ms() >= static_cast<ullong>(sINSTRUMENTATION_BUFFER_MAX_TIME)) {
        INTRACES("SENDING BECAUSE WE HAS REACHED THE MAX TIME : " << (now - mLastSent).ms() << " ms >= " << sINSTRUMENTATION_BUFFER_MAX_TIME << " ms");
    } else {
        return false;
    }

    // We are about to send events...If we have not yet received the
    // configuration parameters, we set default values.
    //
    // For example, when the UI goes into the login dialog, it does not give us
    // any streaming config parameters, so we would send switched events for as
    // long as it is up.

    if (!mConfigReceived) {
        Log::info(TRACE_INSTRUMENTATION) << "HAS NOT RECEIVED CONFIG PARAMETERS - SETTING DEFAULTS";

        StringMap params;
        params[ INSTRUMENTATION_ENABLED_CONFIG_KEY ] = INSTRUMENTATION_ENABLED_CONFIG_DEFAULT;
        params[ INSTRUMENTATION_SWITCHED_ENABLED_CONFIG_KEY ] = INSTRUMENTATION_SWITCHED_ENABLED_CONFIG_DEFAULT;
        params[ INSTRUMENTATION_ONLY_EVENTS_CONFIG_KEY ] = INSTRUMENTATION_ONLY_EVENTS_CONFIG_DEFAULT;

        applyConfiguration(params);
    }

    mLastSent = now;
    mSize = 0;

    if (mEvents.empty()) {
        INTRACES(" NOTHING TO SEND");
        return false;
    }


    std::string json(toJSON());

    if (!sINSTRUMENTATION_LOG_ENABLED) {
        INTRACES(" NOT SENDING TO NCCP, LOG DISABLED");
    } else {
        INTRACES(" SENDING " << mEvents.size() << " EVENT(S) TO NCCP");

        Log::stream(TRACE_INSTRUMENTATION, Log::Info, nrdlog::MessageType::instrumentation)
            << Log::tag(nrdlog::CommonTags::version, INSTRUMENTATION_PROTOCOL_VERSION)
            << json
            << Log::flush;
    }

    if (!sINSTRUMENTATION_POST_URL.empty()) {
        post(json);
    }

    mEvents.clear();

    return true;
}

void CollectorThread::post(const std::string & json)
{

    AseUrl url(sINSTRUMENTATION_POST_URL);

    std::string body(json);

    if (sINSTRUMENTATION_NTS_POST) {
        Variant msg(Variant::Array(Variant::StringMap("clientTimeAsMillis", Time::serverTime().ms())
                                   ("logLevel", "info")
                                   ("context", "nrdp.instrumentation")
                                   ("message", json)));

        body = msg.toJSON();

        url = sINSTRUMENTATION_POST_URL + "/" + mESN;
    }

    INTRACES(" POSTING " << mEvents.size() << " EVENTS(S) TO " << url);

    do {
        IAsyncHttpClientPtr pAsyncHttpClient;

        int32_t retVal = constructAsyncHttpClient(pAsyncHttpClient, NULL, NULL, NULL, NULL);

        if (retVal == AS_NO_ERROR) {
            retVal = pAsyncHttpClient->init();

            if (retVal != AS_NO_ERROR) {
                pAsyncHttpClient.reset();
            }
        }

        if (!pAsyncHttpClient) {
            INTRACES("FAILED TO CREATE HTTP CLIENT");
            break;
        }

        IAsyncHttpConnectionPtr pHttpConnection;

        retVal = pAsyncHttpClient->openConnection(
            url.GetHost(),
            url.GetPortNumber(),
            AseTimeVal::ZERO,
            AseTimeVal::ZERO,
            0,
            NULL,
            false,
            pHttpConnection);

        if ((retVal != AS_NO_ERROR) && (retVal != AS_IN_PROGRESS)) {
            pAsyncHttpClient->deinit();
            INTRACES("FAILED TO OPEN CONNECTION");
            break;
        }

        IAsyncHttpRequestPtr pHttpRequest;
        std::vector<IAsyncHttpConnectionPtr> selectedConnections;
        Stopwatch sw;

        while (true) {
            if (pHttpRequest) {
                bool done = false;
                IAsyncHttpRequest::State state = pHttpRequest->getState();
                // INTRACES( "STATE IS NOW " << state );

                switch (state) {
                    //case IAsyncHttpRequest::RECEIVING_STATUS_STATE:
                case IAsyncHttpRequest::RECEIVING_HEADERS_STATE:
                case IAsyncHttpRequest::RECEIVING_BODY_STATE:
                case IAsyncHttpRequest::COMPLETED_STATE:
                    INTRACES("REQUEST SENT - STATUS IS " << pHttpRequest->getResponseCode());
                    done = true;
                    break;
                default:
                    break;
                }
                if (done) {
                    break;
                }
            }

            if (sw.elapsed() >= 5000) {
                INTRACES("TIMEOUT ELAPSED");
                break;
            }

            INTRACES("SELECTING...");

            retVal = pAsyncHttpClient->select(selectedConnections, AseTimeVal::fromMS(500));

            if ((retVal != AS_NO_ERROR) && (retVal != IAsyncHttpClient::SELECT_CONNECT)) {
                INTRACES("BAILING WITH " << retVal);
                break;
            }

            if (retVal == IAsyncHttpClient::SELECT_CONNECT) {
                assert(selectedConnections.size() == 1);
                assert(selectedConnections[0].get() == pHttpConnection.get());

                IAsyncHttpConnection::Event outstandingEvent = pHttpConnection->retrieveOutstandingEvent();

                if (outstandingEvent == IAsyncHttpConnection::STATE_CHANGE_EVENT) {
                    INTRACES("GOT STATE CHANGE " << pHttpConnection->getState());

                    if (pHttpConnection->getState() == IAsyncHttpConnection::IDLE_STATE) {
                        INTRACES("CONNECTION IS IDLE");

                        HttpHeaders headers;

                        headers[ "Content-Type" ] = "application/json";

                        retVal = pHttpConnection->issueRequest(
                            IAsyncHttpRequest::POST_METHOD,
                            IAsyncHttpRequest::HTTP_1_1,
                            url,
                            headers,
                            reinterpret_cast<unsigned char*>(const_cast<char*>(body.data())),
                            body.size(),
                            AseTimeVal::INFINITE,
                            IHttpRequestTraceListenerPtr(),
                            pHttpRequest);

                        if (retVal != AS_NO_ERROR) {
                            INTRACES("FAILED TO ISSUE REQUEST");
                            break;
                        }

                        INTRACES("REQUEST ISSUED");

                        sw.restart();
                    } else {
                        INTRACES("BAD STATE");
                        break;
                    }
                }
            }
        }

        if (pHttpConnection) {
            pAsyncHttpClient->closeConnection(pHttpConnection);
        }

        pAsyncHttpClient->deinit();
        pAsyncHttpClient.reset();

    } while (false);

}

#endif

//=============================================================================

InstrumentationThread * InstrumentationThread::sInstance;

void InstrumentationThread::start()
{
    assert(!sInstance);
    sInstance = new InstrumentationThread();
}

void InstrumentationThread::shutdown()
{
#ifdef INSTRUMENTATION_ENABLED
    getQueue()->close();
    getQueue()->clear();
#endif
    if (sInstance) {
        delete sInstance;
        sInstance = 0;
    }
}

InstrumentationThread::InstrumentationThread()
{
#ifdef INSTRUMENTATION_ENABLED
    mThread.reset(new CollectorThread());
#endif
}

InstrumentationThread::~InstrumentationThread()
{
#ifdef INSTRUMENTATION_ENABLED
    mThread->Wait();
    mThread.reset();
#endif
}

bool InstrumentationThread::switchedAlwaysOn()
{
#ifdef INSTRUMENTATION_ENABLED
    return sINSTRUMENTATION_SWITCHED_EVENTS_ALWAYS_ON;
#else
    return false;
#endif
}

ConfigurationOptions InstrumentationThread::defaultOptions()
{
    ConfigurationOptions options;

#ifdef INSTRUMENTATION_ENABLED
    options.push_back("Instrumentation Options");

    options.push_back(ConfigurationOption(0, "inst-switched-events-initially-on",
                                          &sINSTRUMENTATION_SWITCHED_EVENTS_INITIALLY_ON, "Whether switched events are on initially"));
    options.push_back(ConfigurationOption(0, "inst-switched-events-always-on",
                                          &sINSTRUMENTATION_SWITCHED_EVENTS_ALWAYS_ON, "Whether switched events are always on regardless of config parameters"));
    options.push_back(ConfigurationOption(0, "inst-thread-throttle-ms", ConfigurationOption::TIME_ARGUMENT,
                                          &sINSTRUMENTATION_THREAD_THROTTLE_MS, "Number of ms to wait before each iteration"));
    options.push_back(ConfigurationOption(0, "inst-thread-throttle-events", ConfigurationOption::INT_ARGUMENT,
                                          &sINSTRUMENTATION_THREAD_THROTTLE_EVENTS, "Maximum number of events to pop each iteration"));
    options.push_back(ConfigurationOption(0, "inst-max-buffer-size", ConfigurationOption::SIZE_ARGUMENT,
                                          &sINSTRUMENTATION_BUFFER_MAX_SIZE, "Max amount of bytes to buffer before flushing"));
    options.push_back(ConfigurationOption(0, "inst-max-buffer-count", ConfigurationOption::INT_ARGUMENT,
                                          &sINSTRUMENTATION_BUFFER_MAX_COUNT, "Max number of events to buffer before flushing"));
    options.push_back(ConfigurationOption(0, "inst-max-buffer-time", ConfigurationOption::SIZE_ARGUMENT,
                                          &sINSTRUMENTATION_BUFFER_MAX_TIME, "Amount of time to wait before flushing"));
    options.push_back(ConfigurationOption(0, "inst-log",
                                          &sINSTRUMENTATION_LOG_ENABLED, "If disabled, events will not be logged"));
    options.push_back(ConfigurationOption(0, "inst-post-url", ConfigurationOption::STRING_ARGUMENT,
                                          &sINSTRUMENTATION_POST_URL, "If this is set, events will be posted to the URL"));
    options.push_back(ConfigurationOption(0, "inst-ignore-config",
                                          &sINSTRUMENTATION_IGNORE_CONFIG, "If set, streaming config parameters will be ignored"));
    options.push_back(ConfigurationOption(0, "inst-print",
                                          &sINSTRUMENTATION_PRINT, "If set, events will be printed immediately"));
    options.push_back(ConfigurationOption(0, "inst-nts-post",
                                          &sINSTRUMENTATION_NTS_POST, "If set, events will be posted to NTS"));
    options.push_back(ConfigurationOption(0, "inst-stash",
                                          &sINSTRUMENTATION_STASH_ON, "If set, events will be stashed in memory for later retrieval from JS"));
    options.push_back(ConfigurationOption(0, "inst-event-names", ConfigurationOption::STRING_ARGUMENT,
                                          &sINSTRUMENTATION_EVENT_NAMES, "Comma separated list of event names to include, all others will be excluded"));
    options.push_back(ConfigurationOption(0, "inst-thread-exit",
                                          &sINSTRUMENTATION_THREAD_EXIT, "If set, the instrumentation thread will exit early"));

#endif
    return options;
}

}
} // netflix::nrdlog


