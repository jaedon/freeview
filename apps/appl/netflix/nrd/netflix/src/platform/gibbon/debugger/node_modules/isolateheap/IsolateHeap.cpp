#include "IsolateHeap.h"
/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

#include "Util.h"
#include <v8-profiler.h>
#include <list>
#include <stdlib.h>

using namespace v8;
using namespace node;

UniquePersistent<FunctionTemplate> IsolateHeap::constructor;
std::map<std::string, IsolateHeap::Data> IsolateHeap::serialized;
IsolateHeap* IsolateHeap::inst;

void IsolateHeap::init(Handle<Object> target)
{
    Isolate* isolate = Isolate::GetCurrent();
    HandleScope scope(isolate);

    Local<String> name = String::NewFromUtf8(isolate, "isolateheap");

    Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);
    tpl->InstanceTemplate()->SetInternalFieldCount(1);
    tpl->SetClassName(name);

    NODE_SET_PROTOTYPE_METHOD(tpl, "run", run);
    NODE_SET_PROTOTYPE_METHOD(tpl, "call", call);
    NODE_SET_PROTOTYPE_METHOD(tpl, "isRunning", isRunning);

    target->Set(name, tpl->GetFunction());

    constructor = UniquePersistent<FunctionTemplate>(isolate, tpl);
}

static Handle<Value> eval(const Handle<String>& source)
{
    Isolate* isolate = Isolate::GetCurrent();
    EscapableHandleScope scope(isolate);

    TryCatch tryCatch;
    Handle<Script> script = Script::Compile(source, String::NewFromUtf8(isolate, "<isolate>"));
    if (tryCatch.HasCaught()) {
        String::Utf8Value utfException(tryCatch.Exception());
        fprintf(stderr, "Exception compiling isolate script: '%s'\n", *utfException);
        fflush(stderr);
        return scope.Escape(tryCatch.Exception());
    }
    Local<Value> ret = script->Run();
    if (tryCatch.HasCaught()) {
        String::Utf8Value utfException(tryCatch.Exception());
        fprintf(stderr, "Exception running isolate script: '%s'\n", *utfException);
        fflush(stderr);
        return scope.Escape(tryCatch.Exception());
    }
    return scope.Escape(ret);
}

class IsolateThread
{
public:
    IsolateThread(uv_loop_t* loop, const std::string& script, const std::vector<std::string>& args);
    ~IsolateThread();

    void stop();
    void join();
    void call(const std::string& func, const std::string& arg);
    void callLater(const std::string& func);
    void notify(const std::string& fn);

private:
    static void run(uv_work_t* work);
    static void done(uv_work_t* work, int status);
    static void asyncCall(uv_async_t* handle);

    void run();

private:
    const std::string mScript;
    const std::vector<std::string> mArgs;

    struct {
        const char* str;
    } mAsyncData;

    UVMutex mMutex, mDoneMutex, mAsyncMutex;
    UVCondition mCondition, mDoneCondition, mAsyncCondition;
    uv_async_t mAsync;
    uv_work_t mWork;

    std::vector<std::string> mCalls;
    std::list<std::string> mLaters;
    bool mStopped, mJoined, mAsyncDone;
};

IsolateThread::IsolateThread(uv_loop_t* loop, const std::string& script, const std::vector<std::string>& args)
    : mScript(script), mArgs(args), mStopped(false), mJoined(false), mAsyncDone(false)
{
    mWork.data = this;
    mAsync.data = this;
    uv_queue_work(loop, &mWork, run, done);
    uv_async_init(loop, &mAsync, asyncCall);
}

IsolateThread::~IsolateThread()
{
}

void IsolateThread::run(uv_work_t* work)
{
    IsolateThread* thr = static_cast<IsolateThread*>(work->data);
    thr->run();
}

void IsolateThread::done(uv_work_t* work, int /*status*/)
{
    IsolateThread* thr = static_cast<IsolateThread*>(work->data);
    uv_close(reinterpret_cast<uv_handle_t*>(&thr->mAsync), 0);
}

// this happens in the main thread
void IsolateThread::asyncCall(uv_async_t* handle)
{
    IsolateThread* thr = static_cast<IsolateThread*>(handle->data);
    UVMutexLocker locker(thr->mAsyncMutex);
    IsolateHeap::instance()->notifyCallback(thr->mAsyncData.str);
    thr->mAsyncDone = true;
    thr->mAsyncCondition.signal();
}

void IsolateThread::call(const std::string& func, const std::string& arg)
{
    UVMutexLocker locker(mMutex);
    mCalls.push_back(func);
    mCalls.push_back(arg);
    mCondition.signal();
}

void IsolateThread::callLater(const std::string& func)
{
    mLaters.push_back(func);
}

void IsolateThread::notify(const std::string& fn)
{
    UVMutexLocker locker(mAsyncMutex);
    mAsyncDone = false;
    mAsyncData.str = fn.c_str();
    uv_async_send(&mAsync);
    while (!mAsyncDone) {
        mAsyncCondition.wait(mAsyncMutex);
    }
}

void IsolateThread::stop()
{
    UVMutexLocker locker(mMutex);
    mStopped = true;
    mCondition.signal();
}

void IsolateThread::join()
{
    UVMutexLocker locker(mDoneMutex);
    while (!mJoined) {
        mDoneCondition.wait(mDoneMutex);
    }
}

static inline Handle<Context> createContext(Isolate* isolate)
{
    EscapableHandleScope scope(isolate);
    // create a brand new jsc context
    Handle<ObjectTemplate> global = ObjectTemplate::New();
    global->Set(String::NewFromUtf8(isolate, "snapshot"), FunctionTemplate::New(isolate, IsolateHeap::snapshot));
    global->Set(String::NewFromUtf8(isolate, "serialize"), FunctionTemplate::New(isolate, IsolateHeap::serialize));
    global->Set(String::NewFromUtf8(isolate, "deserialize"), FunctionTemplate::New(isolate, IsolateHeap::deserialize));
    global->Set(String::NewFromUtf8(isolate, "callLater"), FunctionTemplate::New(isolate, IsolateHeap::callLater));
    global->Set(String::NewFromUtf8(isolate, "notify"), FunctionTemplate::New(isolate, IsolateHeap::notify));

    Handle<ObjectTemplate> console = ObjectTemplate::New();
    console->Set(String::NewFromUtf8(isolate, "log"), FunctionTemplate::New(isolate, IsolateHeap::consoleLog));
    console->Set(String::NewFromUtf8(isolate, "error"), FunctionTemplate::New(isolate, IsolateHeap::consoleError));
    global->Set(String::NewFromUtf8(isolate, "console"), console);

    Local<Context> ctx = Context::New(isolate, 0, global);
    return scope.Escape(ctx);
}

void IsolateThread::run()
{
    Isolate* isolate = Isolate::New();
    isolate->SetData(0, this);
    {
        Locker locker(isolate);
        {
            Isolate::Scope isolateScope(isolate);
            {
                HandleScope subScope(isolate);
                Handle<Context> ctx = createContext(isolate);
                Handle<Object> globalObject = ctx->Global();
                Context::Scope ctxScope(ctx);

                {
                    // Make an array of strings and set it on the global object
                    Handle<Array> array = Array::New(isolate, mArgs.size());
                    for (size_t i = 0; i < mArgs.size(); ++i) {
                        array->Set(i, String::NewFromUtf8(isolate, mArgs[i].c_str()));
                    }

                    if (array->Length() > 0)
                        globalObject->Set(String::NewFromUtf8(isolate, "data"), array);

                    // give the global object a name
                    globalObject->Set(String::NewFromUtf8(isolate, "global"), globalObject);

                    Handle<String> script = String::NewFromUtf8(isolate, mScript.c_str());
                    Handle<Value> val = eval(script);

                    // turn 'val' into JSON and back?
                    (void)val;
                }

                // lock, swap and call
                for (;;) {
                    std::vector<std::string> calls;
                    {
                        UVMutexLocker locker(mMutex);
                        if (mStopped)
                            break;
                        while (mCalls.empty()) {
                            mCondition.wait(mMutex);
                            if (mStopped)
                                break;
                        }
                        if (mStopped)
                            break;
                        std::swap(calls, mCalls);
                    }
                    assert(!calls.empty());
                    assert(!(calls.size() % 2));
                    std::vector<std::string>::const_iterator it = calls.begin();
                    while (it != calls.end()) {
                        {
                            HandleScope subsubScope(isolate);
                            Handle<String> func = String::NewFromUtf8(isolate, it->c_str());
                            ++it;
                            Handle<Value> arg = String::NewFromUtf8(isolate, it->c_str());
                            ++it;

                            // find the function
                            Handle<Value> f = globalObject->Get(func);
                            if (f.IsEmpty() || !f->IsFunction()) {
                                String::Utf8Value val(func);
                                fprintf(stderr, "Isolate(%p): %s is not a function\n", isolate, *val);
                                fflush(stderr);
                            }

                            Handle<Function> rf = Handle<Function>::Cast(f);
                            TryCatch tryCatch;
                            rf->Call(globalObject, 1, &arg);
                            if (tryCatch.HasCaught()) {
                                String::Utf8Value utfFunction(func);
                                String::Utf8Value utfException(tryCatch.Exception());
                                fprintf(stderr, "Isolate(%p): Exception calling function %s: '%s'\n", isolate, *utfFunction, *utfException);
                                fflush(stderr);
                            }
                        }

                        while (!mLaters.empty()) {
                            HandleScope subsubScope(isolate);

                            Handle<String> func = String::NewFromUtf8(isolate, mLaters.front().c_str());
                            mLaters.pop_front();

                            Handle<Value> f = globalObject->Get(func);
                            Handle<Function> rf = Handle<Function>::Cast(f);
                            TryCatch tryCatch;
                            rf->Call(globalObject, 0, 0);
                            if (tryCatch.HasCaught()) {
                                String::Utf8Value utfFunction(func);
                                String::Utf8Value utfException(tryCatch.Exception());
                                fprintf(stderr, "Isolate(%p): Exception calling function %s: '%s'\n", isolate, *utfFunction, *utfException);
                                fflush(stderr);
                            }
                        }
                    }
                }
            }
        }
    }
    isolate->Dispose();

    UVMutexLocker locker(mDoneMutex);
    mJoined = true;
    mDoneCondition.signal();
}

void IsolateHeap::run(const FunctionCallbackInfo<Value>& args)
{
    Isolate* isolate = args.GetIsolate();
    HandleScope scope(isolate);
    ReturnValue<Value> ret = args.GetReturnValue();

    IsolateHeap* obj = ObjectWrap::Unwrap<IsolateHeap>(args.This());
    if (args.Length() < 1) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.run takes a script argument"))));
        return;
    }
    if (args[0].IsEmpty() || !args[0]->IsString()) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.run first argument is not a string"))));
        return;
    }

    std::vector<std::string> runArgs;
    for (int i = 1; i < args.Length(); ++i) {
        if (args[i].IsEmpty() || !args[i]->IsString()) {
            ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.run only accepts string arguments"))));
            return;
        }
        String::Utf8Value val(args[i]);
        runArgs.push_back(*val);
    }

    Handle<String> script = Handle<String>::Cast(args[0]);
    String::Utf8Value utfScript(script);

    if (obj->thread) {
        fprintf(stderr, "stopping thread...\n");
        obj->thread->stop();
        obj->thread->join();
        delete obj->thread;
    }
    obj->thread = new IsolateThread(uv_default_loop(), *utfScript, runArgs);
}

void IsolateHeap::isRunning(const FunctionCallbackInfo<Value>& args)
{
    Isolate* isolate = args.GetIsolate();
    HandleScope scope(isolate);
    IsolateHeap* obj = ObjectWrap::Unwrap<IsolateHeap>(args.This());
    args.GetReturnValue().Set(obj->thread ? True(isolate) : False(isolate));
    //args.GetReturnValue().Set(True(isolate));
}

static void WeakCallback(const WeakCallbackData<Value, Persistent<Value, CopyablePersistentTraits<Value> > >& data)
{
    data.GetParameter()->Reset();
}

void IsolateHeap::notifyCallback(const std::string& fn)
{
    Isolate* isolate = Isolate::GetCurrent();
    HandleScope scope(isolate);

    Handle<Value> fnval = String::NewFromUtf8(isolate, fn.c_str());
    Local<Function> cb = Local<Function>::New(isolate, callback);
    cb->Call(isolate->GetCurrentContext()->Global(), 1, &fnval);
}

void IsolateHeap::notify(const FunctionCallbackInfo<Value>& args)
{
    Isolate* isolate = args.GetIsolate();
    HandleScope scope(isolate);
    ReturnValue<Value> ret = args.GetReturnValue();

    if (args.Length() != 1) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.notify takes a file name"))));
        return;
    }
    if (args[0].IsEmpty() || !args[0]->IsString()) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.notify takes a file name"))));
        return;
    }

    String::Utf8Value fn(args[0]);
    IsolateThread* thread = static_cast<IsolateThread*>(isolate->GetData(0));
    thread->notify(*fn);
}

void IsolateHeap::callLater(const FunctionCallbackInfo<Value>& args)
{
    Isolate* isolate = args.GetIsolate();
    HandleScope scope(isolate);
    ReturnValue<Value> ret = args.GetReturnValue();

    if (args.Length() != 1) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.callLater takes a function name"))));
        return;
    }
    if (args[0].IsEmpty() || !args[0]->IsString()) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.callLater takes a function name"))));
        return;
    }
    String::Utf8Value utfFunc(args[0]);

    IsolateThread* thread = static_cast<IsolateThread*>(isolate->GetData(0));
    thread->callLater(*utfFunc);
}

void IsolateHeap::serialize(const FunctionCallbackInfo<Value>& args)
{
    Isolate* isolate = args.GetIsolate();
    HandleScope scope(isolate);
    ReturnValue<Value> ret = args.GetReturnValue();

    if (args.Length() != 1) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.serialize takes an object of values"))));
        return;
    }
    if (args[0].IsEmpty() || !args[0]->IsObject()) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.serialize takes an object of values"))));
        return;
    }

    IsolateHeap::serialized.clear();

    Handle<String> idKey = String::NewFromUtf8(isolate, "id");
    Handle<String> objKey = String::NewFromUtf8(isolate, "obj");
    Handle<String> typeKey = String::NewFromUtf8(isolate, "type");
    Handle<String> nameKey = String::NewFromUtf8(isolate, "name");
    Handle<String> dataKey = String::NewFromUtf8(isolate, "data");
    Handle<String> objectKey = String::NewFromUtf8(isolate, "object");

    Handle<Object> obj = Handle<Object>::Cast(args[0]);
    Handle<Array> props = obj->GetOwnPropertyNames();
    for (size_t i = 0; i < props->Length(); ++i) {
        Handle<Value> val = obj->Get(props->Get(i));

        if (val.IsEmpty() || !val->IsObject()) {
            ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.serialize only takes objects"))));
            return;
        }
        // find the "obj" object
        Handle<Object> obj = Handle<Object>::Cast(val);
        Handle<Value> sub = obj->Get(objKey);
        if (val.IsEmpty() || val->IsUndefined()) {
            ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.serialize one argument doesn't have a obj property"))));
            return;
        }
        Handle<Value> dataVal = obj->Get(dataKey);
        if (dataVal.IsEmpty() || !dataVal->IsObject()) {
            ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.serialize one argument doesn't have a data property"))));
            return;
        }
        Handle<Object> dataObj = Handle<Object>::Cast(dataVal);
        Handle<Value> type = dataObj->Get(typeKey);
        if (val.IsEmpty()) {
            ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.serialize one argument doesn't have a type property"))));
            return;
        }
        Handle<Value> name = dataObj->Get(nameKey);

        String::Utf8Value utfKey(props->Get(i));
        Data& data = IsolateHeap::serialized[*utfKey];
        data.persistent.Reset(isolate, sub);
        data.persistent.SetWeak(&data.persistent, ::WeakCallback);
        String::Utf8Value utfType(type);
        data.type = *utfType;
        if (!name.IsEmpty() && name->IsString()) {
            String::Utf8Value utfName(name);
            data.name = *utfName;
        }
        Handle<Value> objectVal = dataObj->Get(objectKey);
        if (!objectVal.IsEmpty() && objectVal->IsObject()) {
            // iterate
            Handle<Object> object = Handle<Object>::Cast(objectVal);
            Handle<Array> props = object->GetOwnPropertyNames();
            for (size_t k = 0; k < props->Length(); ++k) {
                Handle<Value> key = props->Get(k);
                Handle<Value> val = object->Get(key);
                if (!val.IsEmpty() && val->IsObject()) {
                    Handle<Object> valObj = Handle<Object>::Cast(val);
                    Handle<Value> subType = valObj->Get(typeKey);
                    Handle<Value> subId = valObj->Get(idKey);

                    String::Utf8Value utfKey(key);
                    String::Utf8Value utfType(subType);
                    String::Utf8Value utfId(subId);
                    data.object[*utfKey] = std::make_pair(std::string(*utfType), std::string(*utfId));
                }
            }
        }
        //persistent.MarkIndependent();
    }
}

void IsolateHeap::deserialize(const FunctionCallbackInfo<Value>& args)
{
    Isolate* isolate = args.GetIsolate();
    HandleScope scope(isolate);

    Handle<String> idKey = String::NewFromUtf8(isolate, "id");
    Handle<String> objKey = String::NewFromUtf8(isolate, "obj");
    Handle<String> typeKey = String::NewFromUtf8(isolate, "type");
    Handle<String> nameKey = String::NewFromUtf8(isolate, "name");
    Handle<String> dataKey = String::NewFromUtf8(isolate, "data");
    Handle<String> objectKey = String::NewFromUtf8(isolate, "object");

    Handle<Object> ret = Object::New(isolate);
    std::map<std::string, Data>::const_iterator it = IsolateHeap::serialized.begin();
    const std::map<std::string, Data>::const_iterator end = IsolateHeap::serialized.end();
    while (it != end) {
        const Data& data = it->second;
        if (!data.persistent.IsEmpty()) {
            Local<Value> val = Local<Value>::New(isolate, data.persistent);
            if (!val.IsEmpty()) {
                Handle<Object> obj = Object::New(isolate);
                Handle<String> id = String::NewFromUtf8(isolate, it->first.c_str());
                obj->Set(objKey, val);
                Handle<Object> dataObj = Object::New(isolate);
                dataObj->Set(idKey, id);
                dataObj->Set(typeKey, String::NewFromUtf8(isolate, data.type.c_str()));
                if (!data.name.empty())
                    dataObj->Set(nameKey, String::NewFromUtf8(isolate, data.name.c_str()));

                if (!data.object.empty()) {
                    Handle<Object> object = Object::New(isolate);
                    std::map<std::string, std::pair<std::string, std::string> >::const_iterator it = data.object.begin();
                    while (it != data.object.end()) {
                        Handle<String> k = String::NewFromUtf8(isolate, it->first.c_str());
                        Handle<String> sk = String::NewFromUtf8(isolate, it->second.first.c_str());
                        Handle<String> sv = String::NewFromUtf8(isolate, it->second.second.c_str());
                        Handle<Object> subObject = Object::New(isolate);
                        subObject->Set(typeKey, sk);
                        subObject->Set(idKey, sv);
                        object->Set(k, subObject);
                        ++it;
                    }
                    dataObj->Set(objectKey, object);
                }

                obj->Set(dataKey, dataObj);
                ret->Set(id, obj);
            }
        }
        ++it;
    }
    IsolateHeap::serialized.clear();
    args.GetReturnValue().Set(ret);
}

void IsolateHeap::call(const FunctionCallbackInfo<Value>& args)
{
    Isolate* isolate = args.GetIsolate();
    HandleScope scope(isolate);
    ReturnValue<Value> ret = args.GetReturnValue();

    IsolateHeap* obj = ObjectWrap::Unwrap<IsolateHeap>(args.This());
    if (args.Length() < 2) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.call takes a function and callback argument"))));
        return;
    }
    if (args[0].IsEmpty() || !args[0]->IsString()) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.call takes a function argument"))));
        return;
    }
    if (args[1].IsEmpty() || !args[1]->IsFunction()) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.call takes a callback argument"))));
        return;
    }
    obj->callback.Reset(isolate, Handle<Function>::Cast(args[1]));

    std::string func;
    {
        Handle<String> funcarg = Handle<String>::Cast(args[0]);
        String::Utf8Value utfFunc(funcarg);
        func = *utfFunc;
    }

    std::string arg;
    if (args.Length() > 2) {
        if (args[2].IsEmpty() || !args[2]->IsString()) {
            ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.call function argument needs to be a string"))));
            return;
        }
        Handle<String> argarg = Handle<String>::Cast(args[2]);
        String::Utf8Value utfArg(argarg);
        arg = *utfArg;
    }

    if (!obj->thread) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.call need to call run first"))));
        return;
    }
    obj->thread->call(func, arg);
}

class FileOutputStream: public OutputStream
{
public:
    FileOutputStream(FILE* stream)
        : mStream(stream)
    {
    }

    virtual int GetChunkSize()
    {
        return 65536;
    }

    virtual void EndOfStream()
    {
    }

    virtual WriteResult WriteAsciiChunk(char* data, int size)
    {
        const size_t len = static_cast<size_t>(size);
        size_t off = 0;

        while (off < len && !feof(mStream) && !ferror(mStream))
            off += fwrite(data + off, 1, len - off, mStream);

        return (off == len) ? kContinue : kAbort;
    }

private:
    FILE* mStream;
};

static void log(FILE* file, const FunctionCallbackInfo<Value>& args)
{
    Isolate* isolate = args.GetIsolate();
    fprintf(file, "isolate(%p): ", isolate);
    const int len = args.Length();
    for (int i = 0; i < len; ++i) {
        String::Utf8Value val(args[i]);
        fprintf(file, "%s", *val);
        if (i + 1 < len)
            fprintf(file, " ");
    }
    fprintf(file, "\n");
    fflush(file);
}

void IsolateHeap::consoleLog(const FunctionCallbackInfo<Value>& args)
{
    Isolate* isolate = args.GetIsolate();
    HandleScope scope(isolate);
    log(stdout, args);
}

void IsolateHeap::consoleError(const FunctionCallbackInfo<Value>& args)
{
    Isolate* isolate = args.GetIsolate();
    HandleScope scope(isolate);
    log(stderr, args);
}

void IsolateHeap::snapshot(const FunctionCallbackInfo<Value>& args)
{
    Isolate* isolate = args.GetIsolate();
    HandleScope scope(isolate);
    ReturnValue<Value> ret = args.GetReturnValue();

    if (args.Length() != 1) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.snapshot takes a filename argument"))));
        return;
    }
    if (args[0].IsEmpty() || !args[0]->IsString()) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.snapshot takes a filename argument"))));
        return;
    }

    Handle<String> filename = Handle<String>::Cast(args[0]);
    String::Utf8Value filestr(filename);

    //Isolate* isolate = Isolate::GetCurrent();
    FILE* fp = fopen(*filestr, "w");
    if (!fp) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap.snapshot couldn't open file for write"))));
        return;
    }

    const HeapSnapshot* snap = isolate->GetHeapProfiler()->TakeHeapSnapshot(filename);
    FileOutputStream stream(fp);
    snap->Serialize(&stream, HeapSnapshot::kJSON);
    fclose(fp);
    const_cast<HeapSnapshot*>(snap)->Delete();
}

IsolateHeap::IsolateHeap()
    : ObjectWrap(), thread(0)
{
    if (inst) {
        fprintf(stderr, "IsolateHeap already exists");
        abort();
    }
    inst = this;
}

IsolateHeap::~IsolateHeap()
{
    if (inst != this) {
        fprintf(stderr, "IsolateHeap is different");
        abort();
    }
    inst = 0;
    if (thread) {
        thread->stop();
        thread->join();
        delete thread;
    }
}

void IsolateHeap::New(const FunctionCallbackInfo<Value>& args)
{
    Isolate* isolate = args.GetIsolate();
    HandleScope scope(isolate);
    ReturnValue<Value> ret = args.GetReturnValue();

    if (!args.IsConstructCall()) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "Use the new operator to create instances of this object"))));
        return;
    }
    if (args.Length() != 0) {
        ret.Set(isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "IsolateHeap takes no arguments"))));
        return;
    }

    Handle<ObjectTemplate> templ = ObjectTemplate::New();
    templ->SetInternalFieldCount(1);

    IsolateHeap* obj = new IsolateHeap;
    obj->Wrap(args.This());

    ret.Set(args.This());
}

void RegisterModule(Handle<Object> target)
{
    IsolateHeap::init(target);
}

NODE_MODULE(isolateheap, RegisterModule);
