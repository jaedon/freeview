/*
 * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */

#ifndef UTIL_H
#define UTIL_H

// #define MUTEX_DEBUG

#include <uv.h>
#ifdef MUTEX_DEBUG
#  include <map>
#  include <vector>
#  include <execinfo.h>
#  include <unistd.h>
#  include <stdio.h>
#endif

class UVMutex
{
public:
    UVMutex()
    {
        uv_mutex_init(&mutex);
    }
    ~UVMutex()
    {
        uv_mutex_destroy(&mutex);
    }

    void lock()
    {
        uv_mutex_lock(&mutex);

#ifdef MUTEX_DEBUG
        BTInfo& info = bts[uv_thread_self()];
        info.data.resize(50);
        info.size = backtrace(&info.data[0], 50);
        info.id = uv_thread_self();

        logholders();
#endif
    }
    void unlock()
    {
#ifdef MUTEX_DEBUG
        fprintf(stderr, "releasing from %lx\n", uv_thread_self());
        bts.erase(uv_thread_self());
#endif

        uv_mutex_unlock(&mutex);
    }

#ifdef MUTEX_DEBUG
    void logholders()
    {
        fprintf(stderr, "---\n");
        for (const auto& p : bts) {
            const BTInfo& info = p.second;
            fprintf(stderr, "!!! id %lx\n", info.id);
            backtrace_symbols_fd(&info.data[0], info.size, STDERR_FILENO);
        }
    }
#endif

private:
    uv_mutex_t mutex;

#ifdef MUTEX_DEBUG
    struct BTInfo
    {
        BTInfo() : size(0) { }

        std::vector<void*> data;
        int size;
        uv_thread_t id;
    };
    std::map<uv_thread_t, BTInfo> bts;
#endif

    friend class UVCondition;
};

class UVCondition
{
public:
    UVCondition()
    {
        uv_cond_init(&cond);
    }
    ~UVCondition()
    {
        uv_cond_destroy(&cond);
    }

    void wait(UVMutex& mutex)
    {
        uv_cond_wait(&cond, &mutex.mutex);
    }
    void signal()
    {
        uv_cond_signal(&cond);
    }
    void broadcast()
    {
        uv_cond_broadcast(&cond);
    }

private:
    uv_cond_t cond;
};

class UVMutexLocker
{
public:
    UVMutexLocker(UVMutex& mutex)
        : m(mutex), locked(true)
    {
        m.lock();
    }
    ~UVMutexLocker()
    {
        if (locked)
            m.unlock();
    }

    void unlock()
    {
        if (locked) {
            m.unlock();
            locked = false;
        }
    }

    void relock()
    {
        if (!locked) {
            m.lock();
            locked = true;
        }
    }

private:
    UVMutex& m;
    bool locked;
};

class UVThread
{
public:
    UVThread()
        : created(false)
    {
    }
    virtual ~UVThread()
    {
        join();
    }

    void start()
    {
        if (created)
            return;
        if (!uv_thread_create(&thr, staticStart, this))
            created = true;
    }

    void join()
    {
        if (!created)
            return;
        uv_thread_join(&thr);
        created = false;
    }

protected:
    virtual void run() = 0;

private:
    static void staticStart(void* arg)
    {
        UVThread* thr = static_cast<UVThread*>(arg);
        thr->run();
    }

private:
    uv_thread_t thr;
    bool created;
};

#endif
