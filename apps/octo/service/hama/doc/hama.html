<!DOCTYPE html>
<html>
<head>
<title>hama</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>HAMA</h1>
<h1>(Humax Application MAnager)</h1>
<h1>목적</h1>
<p>본 문서는 OCTO 2.x 프로젝트 에 포함 되어 있는 HAMA에 대하여 개발자들의 이해를 돕기 위해 작성된 문서이다.</p>
<p> </p>
<h1>1	소개</h1>
<p>본 문서는 HUMAX APPLICATION MANAGER 인 HAMA에 대한 문서로 OCTO2.2에서 각 PROCESS 들을 어떻게 관리하고 소통하게 하는지에 대한 전반적인 내용을 설명한다.</p>
<h1>2 개요</h1>
<p>HAMA란 Humax Application Manager의 약자로써 실질 적인 거의 모든 프로세스의 실행과 프로세스 간 의 통신을 관리 하고 dfb master와 sawman을 이용하여 window의 key 전달을 관리 한다. 각각의 프로세스 들을 관리할 목적이면 HAMA 내부에서 처리하게 될 것이다.</p>
<p>아래 그림은 Hama의 전체적인 기능을 설명하기 위한 용도로 제작 되었다.
HAMA의 가장 기본적인 역할은  각각의 Process들을 Launching 해주는 것이다. 
각 프로젝트의 rootfs에는 <em>/home/hconfig.cfg</em> 에 명시 되어있는 process들을 순차적으로 수행하는 기능을 가진다.</p>
<p>또한 HAMA는 각 process 들간의 통신을 위해 signal broadcasting을 제공하고 공유 가능한 DB용으로 Registry를 운용하고 있다.
registry 정보는 <em>/var/lib/humaxtv/registry.reg</em> 에 저장 되고 이정보를 토대로 여러 Process 들이 정보를 교환 할 수 있다.</p>
<p>마지막으로 Key Manager 기능이다.
우선 Octo 2.2 에서는 DFB Master를 사용하여 window를 관리 한다.
하지만 STB 특정 상 여러 윈도우가 없는 process들도 key를 처리해야 하는 상황이 생긴다. 하여 Window를 통해서만 key를 관리하는 DFB Master만으로 운용이 힘들다.
하여 여러 application들의 window를 관리해주는 saw man을 통해 window 정보 및 key 정보를 얻어와 별도의 ordering을 이용하여 필요한 process(window가 없는 process 포함) 들에게 key를 전달해주는 기능을 수행한다.</p>
<p><img src=".\hama.png" alt="hama.png" /></p>
<h1>3	기능</h1>
<h2>3.1. Launcher 기능</h2>
<p>Humax Octo2.2에서 각 프로세스들은 Hamalauncher에 의해 실행 된다.
Hama는 /etc/init.d/S90settop script에 의해 실행 된다.</p>
<p>S90settop</p>
<pre><code>exec dfbmaster &amp;
exec /home/hamalauncher &amp;
    exec /home/hama &amp;
</code></pre>

<p>Hanalauncher 에 의해 모든 process 들이 싱행된다.
Hama launcher는 /home/hconfig.cfg 파일을 읽어 들여 process 를 exec 한다.</p>
<p>/home/hconfig.cfg</p>
<pre><code>{&quot;name&quot;:&quot;thma&quot;,      &quot;exec&quot;:&quot;/home/thma/thma&quot;},
{&quot;name&quot;:&quot;pama&quot;,      &quot;exec&quot;:&quot;/home/pama/pama&quot;, &quot;term&quot;:1},
{&quot;name&quot;:&quot;sama&quot;,      &quot;exec&quot;:&quot;/home/sama/sama&quot;},
{&quot;name&quot;:&quot;nima&quot;,      &quot;exec&quot;:&quot;/home/nima/nima&quot;, &quot;term&quot;:1},
{&quot;name&quot;:&quot;obama&quot;,     &quot;exec&quot;:&quot;/home/obama/obama&quot;, &quot;term&quot;:1},
{&quot;name&quot;:&quot;ipepg&quot;,     &quot;exec&quot;:&quot;/home/ipepg/ipepg&quot;, &quot;condition&quot;:&quot;obama&quot;},
{&quot;name&quot;:&quot;remoteapp&quot;, &quot;exec&quot;:&quot;/home/remoteapp/remoteapp&quot;, &quot;condition&quot;:&quot;obama&quot;},
{&quot;name&quot;:&quot;restsvr&quot;,   &quot;exec&quot;:&quot;/usr/bin/node&quot;, &quot;condition&quot;:&quot;homma&quot;,&quot;arguments&quot;:[{&quot;arg&quot;:&quot;/home/node/app.js&quot;}]},
</code></pre>

<p>위와 같은 순서로 process 들이 실행 된다.</p>
<p>각 process 는 오류로 인해 kill 되어지면 hamalauncher가 monitoring 하고 있다가 restart 한다.</p>
<p>단, <strong>term : 1</strong>로 setting 되어진 process 들은 <strong>restart 하지 않는다</strong>.</p>
<p>또한 <strong>condition : Obama</strong> 와 같은 형태로 설정된 process 들은 <strong>obama에서 init이 완료된 후에 exec</strong> 된다. Process 간 dependency 를 표현한다.</p>
<p>각 프로세서들은 자신이 initialize를 끝냈다는 것을 HAPI_SendReadySignal() 을 이용해 hamalauncher 에 알린다.</p>
<p>추가적으로 <strong>arguments</strong> 가 있는데 <strong>실행할 프로세스에 argument를 전달 할때 필요</strong> 하고 아래 와 같이 사용한다.</p>
<p><strong>&quot;arguments&quot;: [{&quot;arg&quot;: &quot;argument1&quot;}, {&quot;arg&quot;: &quot;argument2&quot;}, {&quot;arg&quot;: &quot;argument3&quot;}, ... ]</strong> </p>
<h2>3.2.	Window manager</h2>
<p>Window Manager는 각각의 process와 sawman을 통해 윈도우 정보를 획득하여 내부 cache에 저장한다.
저장된 cache를 이용하여 현재의 window 의 plane order와 focus order를 조정한다.
이를 토대로 하여 process에서 plane order 변경을 요청하면 이를 sawman에 전달 한다.
Dfbmaster 에서 sawman을 통해 전달 된 키 정보를 모든 focus order를 가진 process에게 전달 한다.</p>
<p>키 전달 방식을 보면 아래와 같다.
 <img src="hama_key.png" /></p>
<p>첫 번째, KEY<em>POWER가 올라오면 HAMA에서는 forcus order 순으로 먼저 pama에게 key를 전달한다.
Pama는 KEY</em>POWER를 사용하고 consume 을 HAMA에게 return 해주면 HAMA는 KEY_POWER 정보를 삭제 한다.</p>
<p>두 번째, KEY<em>VOLUP을 sawman에서 받은 HAMA는 focus order상에 pama의 정보를 확인 한다. Pama의 경우 KEY</em>VOLUP을 HAMA에 등록해 두지 않은 상태여서 HAMA는 pama를 건너 뛰고 다음 focus order인 prism에 KEY<em>VOLUP을 보낸다. 
prism에서는 KEY</em>VOLUP 정보를 volume control하는 prism UI에서 사용 하고 consume을 HAMA에게 return 하고 HAMA는 이를 받아 삭제 한다.</p>
<p>세 번째, KEY<em>OK를 받은 HAMA는 pama에서 KEY</em>OK를 등록 하지 않았기 때문에 다음 window 인 PRISM에 전달 한다. PRISM은 자신이 사용할 필요가 없기 때문에 pass를 return 하고, HAMA는 다음 wiondow 인 MHEG에게 전달한다. 마찬가지로 MHEG과 HBBTV는 사용하지 않기 때문에 pass를 return 하게 되고, HAMA는 최종 oipf 에게 전달된다. oipf에서는 KEY<em>OK를 받아 channel list를 띄우고, consume 을 return한다. HAMA는 이를 받아 KEY</em>OK 정보를 삭제 한다.</p>
<p>마지막으로 KEY<em>RED에 대하여 살펴보자.
KEY</em>RED는 위의 KEY_OK와 마찬가지로 HBBTV까지 전달 된다. HBBTV는 HBBTV Launch를 위해 KEY<em>RED를 사용한다. KEY</em>RED를 사용하고 HAMA에게 consume을 return 하고, HAMA는 OIPF window가 남아있지만 사용된 KEY로 인식하고 정보를 삭제하고 OIPF에게는 KEY 정보를 보내지 않는다.</p>
<pre><code>HAPI_ReturnKeyEvent(HWINID_e eAppId, HInputRetType_e eRetType, HInputEvent_t *pEvent);
// key를 사용한 후 사용 결과를 return 
HAPI_GetInputEvent(HWINID_e eApplId, HInputEvent_t *pstInputEvent, HINT32 nTimeout);
// Key를 받기 위해 사용 하는 함수.
HAPI_AddVirtualWindow(HWINID_e eAppId);
// Key를 받기 위해 가상 윈도우를 추가해야함.
HAPI_RegisterAcceptableKey(HWINID_e eTargetId, HUINT32 eSymbol, HBOOL bRegister);
// 받기를 원하는 key를 hama에 등록한다.
HAPI_SetWindowStyle(HWINID_e eTargetId, HWINDOWSTYLE_e eWindowStyle, HBOOL bClear);
// window 및 key input 관련 style을 설정한다.
HAPI_SendReadySignal(pid_t pid);
// process가 init 과정을 완료 하면 해당 함수를 이용하여 signal을 보낸다.
HAPI_SendRemoteRCUKey(HUINT32 ulKeySymbol);
// 강제로 특정 RCU를 뿌리게 하는 함수.
</code></pre>

<p>default order 정보는 아래와 같이 시나리오로 정의 되어있다.</p>
<pre><code>static  SCENARIO_t  _astScenarioList[] =
{
    //  window id                       focus       stack       panel
    {   eAWINDOW_HAMA,                  0x2000,     0x0000,     0x0000},
    {   eAWINDOW_DAMA,                  0x2000,     0x0000,     0x0000},
    {   eAWINDOW_TR069,                 0x2000,     0x0000,     0x0000},
    {   eAWINDOW_PAMA,                  0x1000,     0x0000,     0x0000},
    {   eAWINDOW_TESTAPP,               0x0990,     0x0000,     0x0000},
    {   eAWINDOW_GWMPOPUP,              0x0900,     0x0100,     0x0200},
    {   eAWINDOW_KEYBOARD,              0x0901,     0x0101,     0x0300},
    {   eAWINDOW_SUBTITLEPLAYER,        0x0500,     0x0500,     0x0000},
    {   eAWINDOW_MHEGPLAYER,            0x0800,     0x0400,     0x0000},
    {   eAWINDOW_MHEGPLAYER_IMG_STILL,  0x0100,     0x0401,     0x0000},
    {   eAWINDOW_MHEGIB,                0x0900,     0x0400,     0x0000},
    {   eAWINDOW_OIPF,                  0x0600,     0x0301,     0x0100},
    {   eAWINDOW_HBBTV,                 0x0601,     0x0302,     0x0100},
    {   eAWINDOW_BSAUTOMSG,             0x0602,     0x0320,     0x0100},
    {   eAWINDOW_OTVB,                  0x0603,     0x0310,     0x0100},
    {   eAWINDOW_OTVS,                  0x0604,     0x0310,     0x0100},
    {   eAWINDOW_WIND3,                 0x0610,     0x0350,     0x0100},
    {   eAWINDOW_JAPAN_NATIVE_UI,       0x0804,     0x0501,     0x0000},
    {   eAWINDOW_ARIBCC_SUP,            0x0803,     0x0400,     0x0000},
    {   eAWINDOW_ARIBCC_CAP,            0x0802,     0x0401,     0x0000},
    {   eAWINDOW_BML,                   0x0801,     0x0500,     0x0000},
    {   eAWINDOW_BMLSTILL,              0x0800,     0x0501,     0x0000},
    {   eAWINDOW_RFVOD,                 0x0850,     0x0350,     0x0000},
    {   eAWINDOW_ANDROID,               0x0902,     0x0600,     0x0000},
};
</code></pre>

<h2>3.3. Signal Broadcasting</h2>
<p>hama는 process이 서로에게 자신의 상태를 알릴수 있고 다른 process들의 상태를 얻을 수 있도록 signal broadcasting 정보를 제공한다.</p>
<p>각 프로세스들은 다른 process 에게 특정 정보를 보내고 싶을 경우 아래 함수를 호출한다.</p>
<pre><code>HAPI_BroadcastSignal(const HCHAR *pszSignalName, HBOOL bBuffered, void * pvData);
// pszSignalName : 보내고자 하는 시그널 name
// bBuffered     : 받을 process가 받을 상태가 아니더라도 추후에 signal connecting 을 하면
//                 마지막 해당 signal에 대한 정보를 받아 볼수 있도록 하고 싶을 경우 
//                 true로 선택한다.
// pvData        : 해당 시그널과 함께 보낼 data
</code></pre>

<p>특정 signal 을 받고 싶은 process들은 다음 함수와 함께 callback을 등록 하면 된다.
보내는 쪽에서 bufferd signal로 등록 해 놓은 signal들은 아래 함수들을 등록하는 순간 hama에 저장 되어진 bufferd signal을 callback으로 전달 받게 된다.</p>
<pre><code>HAPI_ConnectSystemSignal(const HCHAR *pszSignalName, void * pvData,HxRPC_Noti_t cbRpcNotifier)
// pszSignalName : 받기를 원하는 system signal name
// cbRpcNotifier : SystemSignal이 발생하면 호출 되어질 callback function
// 사용중인 시스템시그널.
//  -- hama:onReadyProcess 
//  -- hama:onRegistryChanged
//  -- hama:onPanelPriority 

HAPI_ConnectSignal(const HCHAR *pszSignalName, void *pvUserData, HxRPC_Noti_t cbRpcNotifier)
// system signal을 제외한 signal을 받기 위해 사용한다.   
// pszSignalName은 다음 과같은 naming 방식을 따른다. &quot;**signal:onS**ubtitle**S**tate&quot;
</code></pre>

<h2>3.4.	Registry</h2>
<p>registry는 process간 공유가 필요한 data를 db처럼 사용가능 하도록 하기 위해 HAMA에서 제공하는 기능이다.</p>
<p>이 정보들은 비 휘발성으로 <em>&quot;/var/lib/humaxtv/registry.reg&quot;</em> 에 json 형태로 저장 된다.</p>
<p>저장되어진 값은 아래와 같이 확인이 가능하다.</p>
<p>내용을 보면 &quot;net<em>0</em>dhcp&quot;은 data 의 key가 되고 해당 key에 대하여 {&quot;owner&quot;:&quot;nima&quot;,&quot;value&quot;:0} 와 같이 value 값 외에  write 권한을 가진 owner가 존재 한다. &quot;net<em>0</em>dhcp&quot;에 대한 owner는 nima고 value는 0임을 확인 할수 있다.</p>
<pre><code>{
    &quot;net_0_dhcp&quot;         :{&quot;owner&quot;:&quot;nima&quot;,   &quot;value&quot;:0        },
    &quot;LastMasterUid&quot;      :{&quot;owner&quot;:&quot;prism&quot;,  &quot;value&quot;:164      },
    &quot;maturiyrating&quot;      :{&quot;owner&quot;:&quot;obama&quot;,  &quot;value&quot;:0        },
    &quot;gmtoffset&quot;          :{&quot;owner&quot;:&quot;obama&quot;,  &quot;value&quot;:60       },
    &quot;SATIP_DEVICE_ID_KEY&quot;:{&quot;owner&quot;:&quot;homma&quot;,  &quot;value&quot;:0        },
    &quot;operatortype&quot;       :{&quot;owner&quot;:&quot;obama&quot;,  &quot;value&quot;:&quot;none&quot;   },
    &quot;countrycode&quot;        :{&quot;owner&quot;:&quot;obama&quot;,  &quot;value&quot;:630      },
    &quot;audiolang0&quot;         :{&quot;owner&quot;:&quot;obama&quot;,  &quot;value&quot;:&quot;ger&quot;    },
    &quot;audiolang1&quot;         :{&quot;owner&quot;:&quot;obama&quot;,  &quot;value&quot;:&quot;ger&quot;    },
    &quot;hardofhearing&quot;      :{&quot;owner&quot;:&quot;obama&quot;,  &quot;value&quot;:0        },
    &quot;endpadding&quot;         :{&quot;owner&quot;:&quot;obama&quot;,  &quot;value&quot;:180      },
    .
    .
    .
}
</code></pre>

<p>관련 API 함수는 다음과 같다.</p>
<pre><code>HAPI_RemoveRegistry(void);
// Registry를 삭제한다.

HAPI_SetRegistryListener(void *pvUser, CBHAPIRegHandler pfnRegHandler);
// 특정 registry가 변경 되면 pfnRegHandler를 이요하여 noti 해준다.

#define HAPI_SetRegistryInt(pszKey, nValue)
#define HAPI_GetRegistryInt(pszKey, pnValue)
// int data를 Set/Get 할 경우 사용한다.

#define HAPI_SetRegistryStr(pszKey, pszValue)
#define HAPI_GetRegistryStr(pszKey, pszValue, nMax)
// string data를 Set/Get 할 경우 사용한다.

#define HAPI_SetRegistryEnum(pszKey, pszTagType, nEnum)
#define HAPI_GetRegistryEnum(pszKey, pszTagType, pnEnum)
// enum data를 string으로 Set/Get 할 경우 사용한다.
</code></pre>

<h1>4. CMD</h1>
<pre><code>#cmdconsole
#root:&gt;hama
#hama:&gt;hamacmd
#hama:hamacmd&gt;help
    printreg         :  printreg
                        // hama에 등록되어있는 registry 정보를 모두 표시한다.
    printmem         :  VmRSS : Physically used, VmSize : Virtually used
                        // process 들의 memory 정보를 표시한다.
    remove           :  remove application
                        // hama에서 pid에 해당하는 process 정보를 모두 삭제한다.
    changeorder      :  change stack or focus order : changeorder (0:1)(focus:window) targetid baseid (0:1)(up/down)
                        // window의 focus order를 변경한다. 
    print            :  hama process info print
                        // ex)print 1006 =&gt; 1006 은 pid 이고 &lt;0 이면 모든 process를 표시한다.
    printorder       :  window priority status
                        // 등록된 window들의 ordering 정보를 표시한다.
    printrpc         :  print rpc
                        // hama에 등록되어진 rpc 정보를 모두 표시한다.


#hama:hamacmd&gt;print 1006
    // 1006 은 pid 이고 &gt;0 이면 모든 process를 표시한다.

    ProcessInfo
      -- ProcessName   : [prism]
      --     PID       : [1006]
      -- Socket Handle : [5106228]
      -- state         : [5106228]
      --    Running    : [1943 sec]
      Window(Application) List 
       - applId [0x00000005] hookProcessPid [0] Pid [1006]
       - alreadyRemovePlane(0) nCurrentOpacity(ff) nLogicalOpacity(ff)
       - style [0x00000015] focus [0x00000900] stack [0x00000100] panel [0x00000200]
       - SaWManWindowHandle [0x2109d000] dfbWindowId [0x00000001]

       - applId [0x00000009] hookProcessPid [0] Pid [1006]
       - alreadyRemovePlane(0) nCurrentOpacity(ff) nLogicalOpacity(ff)
       - style [0x00000011] focus [0x00000500] stack [0x00000500] panel [0x00000000]
       - SaWManWindowHandle [0x2109dc00] dfbWindowId [0x00000002]

       - applId [0x00000009] hookProcessPid [0] Pid [1006]
       - alreadyRemovePlane(1) nCurrentOpacity(00) nLogicalOpacity(00)
       - style [0x00000001] focus [0x00000500] stack [0x00000500] panel [0x00000000]
       - SaWManWindowHandle [0x2109d400] dfbWindowId [0x00000004]


#hama:hamacmd&gt;printreg
    === HAMA REGISTRY ===
    [            nima] [          net_0_dhcp] (0)
    [           prism] [       LastMasterUid] (155)
    [           obama] [       maturiyrating] (0)
    [           obama] [           gmtoffset] (60)
    [           homma] [ SATIP_DEVICE_ID_KEY] (0)
    [           obama] [        operatortype] (none)
    [           obama] [         countrycode] (630)
    [           obama] [          audiolang0] (ger)
    [           obama] [          audiolang1] (ger)
    [           obama] [       hardofhearing] (0)
    [            nima] [       net_0_gateway] (192.168.11.1)
    [            pama] [PowerSavingOnStandby] (1)
    [           obama] [          endpadding] (180)
    [            pama] [         LastStandby] (0)
    [            nima] [           bt_enable] (0)
    [           obama] [   antennaconnection] (error)
    [           obama] [          timeupdate] (0)


#hama:hamacmd&gt; printmem
    Name:     hamalauncher
    VmSize:     6568 kB
    VmRSS:      1572 kB
    Name:   dama
    VmSize:    18160 kB
    VmRSS:      9404 kB
    Name:   pama
    VmSize:     9208 kB
    VmRSS:      1840 kB
    Name:   thma
    VmSize:    14084 kB
    VmRSS:      2952 kB
    Name:   nima
    VmSize:    16508 kB
    VmRSS:      4412 kB
    Name:   sama
    VmSize:    12276 kB
    VmRSS:      2820 kB
    Name:   umma
    VmSize:    19012 kB
    VmRSS:      5480 kB
    Name:   imma
    VmSize:    48008 kB
    VmRSS:     11756 kB
    Name:   obama
    VmSize:   116832 kB
    VmRSS:     16416 kB


#hama:hamacmd&gt; remove 1006
    [hama_command_remove_delete_application,277]  pid : 1006, nMonitor : 1
    &lt;--------------- Do not NEED Anymore.... [hama_command_doHamaApplicationDelete][222]
    &lt;--------------- Do not NEED Anymore.... [hama_command_doHamaApplicationDelete][223]
    &lt;--------------- Do not NEED Anymore.... [hama_command_doHamaApplicationDelete][224]
    &lt;--------------- Do not NEED Anymore.... [hama_command_doHamaApplicationDelete][225]


#hama:hamacmd&gt; printorder
    [   Window List Focus Order     ] 
    windowID : 0x0 ,  applID: 0x4,   stackPriority : 0x0,  FocusPriority : 0x1000           processName : pama
    windowID : 0x1 ,  applID: 0x5,   stackPriority : 0x100,  FocusPriority : 0x900          processName : prism
    windowID : 0x3 ,  applID: 0x14,   stackPriority : 0x400,  FocusPriority : 0x900         processName : mhegib
    windowID : 0x5 ,  applID: 0x12,   stackPriority : 0x310,  FocusPriority : 0x604         processName : corsair
    windowID : 0x6 ,  applID: 0xF,   stackPriority : 0x302,  FocusPriority : 0x601          processName : corsair
    windowID : 0x7 ,  applID: 0x10,   stackPriority : 0x301,  FocusPriority : 0x600         processName : corsair
    windowID : 0x2 ,  applID: 0x9,   stackPriority : 0x500,  FocusPriority : 0x500          processName : prism
    windowID : 0x4 ,  applID: 0x9,   stackPriority : 0x500,  FocusPriority : 0x500          processName : prism


#hama:hamacmd&gt; printrpc
           void hama.window.sendkey (HINT32 integer, void *pvData, int size)
            send key event (HWINID_e eWinId (eAWINDOW_HAMA means traverse key events), HInputEvent_t)
           void hama.window.deforder (HINT32 integer, HINT32 integer)
            set order default : (HWINID_e eWindowId, HSTACKTYPE_e)
           void hama.window.active (HINT32 integer, HINT32 integer)
            active window : (HWINID_e eWindowId, HBOOL bActive)
           void hama.registry.set (HINT32 integer, const HCHAR *string)
            HaMa Registry Set (HINT32 progId, HCHAR *jsonString)
           void hama.process.dfbready (void)
            dfb is ready : NULL
           void hama.window.regkey (HINT32 integer, HINT32 integer, HINT32 integer)
       callback signal:onMsgboxShow (void *pvData, int size)
       callback signal:onRpPeriodChanged (void *pvData, int size)
       callback signal:onSystemLanguageChanged (void *pvData, int size)
       callback signal:onSurferShutdown (void *pvData, int size)
       callback signal:onOtaStateChanged (void *pvData, int size)
       callback signal:onFactoryDefault (void *pvData, int size)
       callback signal:onStartPortal (void *pvData, int size)
    (R)callback signal:onFontTypeChanged (HINT32 integer)
    (R)callback signal:onSystemStateChanged (HINT32 integer)
    (R)callback signal:onBootupStateChanged (void *pvData, int size)
    .
    .
    .
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
