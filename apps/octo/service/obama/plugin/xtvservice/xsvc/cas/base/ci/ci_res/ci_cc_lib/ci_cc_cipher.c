/***************************************************************
* $Workfile:   ci_cc_cipher.c  $
* $Modtime:
* Auther : hmkim
*
* Desc : Content Control (CI+) Addon for
*        SHA-1, SHA-256,
*        RSASSA-PSS, RSASSA-PKCS1-V1_5,
*        AES-x-ECB, AES-x-CBC, AES-XCBC-MAC,
*        AES Based PRNG
*
* Copyright (c) 2008 by Humax Co., Ltd.
* All right reserved
****************************************************************/


/***************************************************************
* #ifdef statements and include ////////////////////////////////
***************************************************************/

#include "ci_cc_cipher.h"

/***************************************************************
* definition ///////////////////////////////////////////////////
***************************************************************/





/***************************************************************
* SHA (SHA-1 and SHA-256) //////////////////////////////////////
***************************************************************/

#define SHA_USE_POST_PADDING			// 스펙에 따라 먼저 패딩한 후에 SHA 연산을 거치는 것이 원칙이나 여기서는 마지막에 패딩하는 방식을 사용한다.

#define SHA_1_DIGEST_SIZE		20
#define SHA_256_DIGEST_SIZE	32

#define SHA_1_T_NUM			80
#define SHA_256_T_NUM			64

#define SHA_BLOCK_SIZE		64		// for SHA-1, SHA-224, SHA-256 (따라서 이들 알고리즘이 처리하는 메시지 길이는 최대 2^64)
#define SHA_MSG_BUF_SIZE		0x800	// 더 작아도 상관은 없으나 퍼포먼스에 영향이 있다.

typedef struct {
	unsigned long state[8];				// for saving hash values : 5 for SHA-1 and 8 for SHA-256
	unsigned long count[2];
	unsigned char buffer[SHA_BLOCK_SIZE];
} SHA_CTX;

/* basic functions */
#define rol(value, bits)	(((value) << (bits)) | ((value) >> (32 - (bits))))	/* The rotate left (circular left shift) operation */
#define ror(value, bits)	(((value) >> (bits)) | ((value) << (32 - (bits))))	/* The rotate right (circular right shift) operation */
#define shr(value, bits)	((value) >> (bits))										/* The right shift operation */

/* SHA-x functions : For SHA-1, ft (x, y, z) = */
#define Ch(x,y,z)			(((x) & ((y) ^ (z))) ^ (z)) /* (((x) & (y)) | ((~x) & (z))) */						/* For SHA-1, ft :  0 <= t <= 19 */
#define Parity(x,y,z)		((x) ^ (y) ^ (z))																		/* For SHA-1, ft : 20 <= t <= 39 and 60 <= t <= 79 */
#define Maj(x,y,z)			(((x) & (y)) | (((x) | (y)) & (z))) /* (((x) & (y)) | ((x) & (z)) | ((y) & (z))) */	/* For SHA-1, ft : 40 <= t <= 59 */

/* SHA-224 and SHA-256 Functions */
#define SIGMA0(x)			(ror(x,2)  ^ ror(x,13) ^ ror(x,22))
#define SIGMA1(x)			(ror(x,6)  ^ ror(x,11) ^ ror(x,25))
#define sigma0(x)			(ror(x,7)  ^ ror(x,18) ^ shr(x,3))
#define sigma1(x)			(ror(x,17) ^ ror(x,19) ^ shr(x,10))

/* SHA-1 Constants */
static unsigned long SHA_1_K[4] =
{
	0x5a827999,	/*  0 <= t <= 19 */
	0x6ed9eba1,	/* 20 <= t <= 39 */
	0x8f1bbcdc,	/* 40 <= t <= 59 */
	0xca62c1d6		/* 60 <= t <= 79 */
};

/* SHA-224 and SHA-256 Constants */
static unsigned long SHA_256_K[64] =
{
	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

/* for SHA-1 debugging */
#if 0
static int SHA_1_ROUND_COUNT;
#define SHA_1_CHECK_BEGIN		HxLOG_Print(" [->: %08X %08X %08X %08X %08X]\n", state[0], state[1], state[2], state[3], state[4]); SHA_1_ROUND_COUNT = 0;
#define SHA_1_CHECK			HxLOG_Print(" [%02d: %08X %08X %08X %08X %08X]\n", SHA_1_ROUND_COUNT++, a, b, c, d, e);
#define SHA_1_CHECK_END		HxLOG_Print(" [<-: %08X %08X %08X %08X %08X]\n", state[0], state[1], state[2], state[3], state[4]);
#else
#define SHA_1_CHECK_BEGIN
#define SHA_1_CHECK
#define SHA_1_CHECK_END
#endif

static void SHA_1_Transform(unsigned long state[5], unsigned char buffer[SHA_BLOCK_SIZE])
{
	unsigned long a, b, c, d, e, T;
	unsigned long W[SHA_1_T_NUM];
	int t, i;

	// 1. Prepare the message schedule, Wt :
    for (t = 0, i = 0; t < SHA_BLOCK_SIZE / 4; t++, i += 4)
		W[t] = (unsigned long)buffer[i] << 24 | (unsigned long)buffer[i+1] << 16 | (unsigned long)buffer[i+2] << 8 | (unsigned long)buffer[i+3];
    for (; t < SHA_1_T_NUM; t++)
		W[t] = rol(W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16], 1);

	// 2. Initialize the five working variables, a, b, c, d, and e :
	a = state[0];
	b = state[1];
	c = state[2];
	d = state[3];
	e = state[4];

	SHA_1_CHECK_BEGIN

	// 3. For t=0 to 79 :
	for (t = 0; t < SHA_1_T_NUM; t++)
	{
		T = rol(a,5) + e + W[t];
		if (t < 20)
			T += (Ch(b,c,d) + SHA_1_K[0]);
		else if (t < 40)
			T += (Parity(b,c,d) + SHA_1_K[1]);
		else if (t < 60)
			T += (Maj(b,c,d) + SHA_1_K[2]);
		else
			T += (Parity(b,c,d) + SHA_1_K[3]);
		e = d;
		d = c;
		c = rol(b,30);
		b = a;
		a = T;

		SHA_1_CHECK
	}

	// 4. Update the hash value :
	state[0] += a;
	state[1] += b;
	state[2] += c;
	state[3] += d;
	state[4] += e;

	SHA_1_CHECK_END
}

/* for SHA-256 debugging */
#if 0
static int SHA_256_ROUND_COUNT;
#define SHA_256_CHECK_BEGIN		HxLOG_Print(" [->: %08X %08X %08X %08X %08X %08X %08X %08X]\n", state[0], state[1], state[2], state[3], state[4], state[5], state[6], state[7]); SHA_256_ROUND_COUNT = 0;
#define SHA_256_CHECK			HxLOG_Print(" [%02d: %08X %08X %08X %08X %08X %08X %08X %08X]\n", SHA_256_ROUND_COUNT++, a, b, c, d, e, f, g, h);
#define SHA_256_CHECK_END		HxLOG_Print(" [<-: %08X %08X %08X %08X %08X %08X %08X %08X]\n", state[0], state[1], state[2], state[3], state[4], state[5], state[6], state[7]);
#else
#define SHA_256_CHECK_BEGIN
#define SHA_256_CHECK
#define SHA_256_CHECK_END
#endif

static void SHA_256_Transform(unsigned long state[8], unsigned char buffer[SHA_BLOCK_SIZE])
{
	unsigned long a, b, c, d, e, f, g, h, T1, T2;
	unsigned long W[SHA_256_T_NUM];
	int t, i;

	// 1. Prepare the message schedule, Wt :
    for (t = 0, i = 0; t < SHA_BLOCK_SIZE / 4; t++, i += 4)
		W[t] = (unsigned long)buffer[i] << 24 | (unsigned long)buffer[i+1] << 16 | (unsigned long)buffer[i+2] << 8 | (unsigned long)buffer[i+3];
    for (; t < SHA_256_T_NUM; t++)
		W[t] = sigma1(W[t-2]) + W[t-7] + sigma0(W[t-15]) + W[t-16];

	// 2. Initialize the eight working variables, a, b, c, d, e, f, g, and h :
	a = state[0];
	b = state[1];
	c = state[2];
	d = state[3];
	e = state[4];
	f = state[5];
	g = state[6];
	h = state[7];

	SHA_256_CHECK_BEGIN

	// 3. For t=0 to 63 :
	for (t = 0; t < SHA_256_T_NUM; t++)
	{
		T1 = h + SIGMA1(e) + Ch(e,f,g) + SHA_256_K[t] + W[t];
		T2 = SIGMA0(a) + Maj(a,b,c);
		h = g;
		g = f;
		f = e;
		e = d + T1;
		d = c;
		c = b;
		b = a;
		a = T1 + T2;

		SHA_256_CHECK
	}

	// 4. Update the hash value :
	state[0] += a;
	state[1] += b;
	state[2] += c;
	state[3] += d;
	state[4] += e;
	state[5] += f;
	state[6] += g;
	state[7] += h;

	SHA_256_CHECK_END
}

static void SHA_Init(int x, SHA_CTX *context) /* Initialize new context */
{
	if (x == 1)
	{
		// SHA-1 initialization constants : the initial hash value, H0
		context->state[0] = 0x67452301;
		context->state[1] = 0xEFCDAB89;
		context->state[2] = 0x98BADCFE;
		context->state[3] = 0x10325476;
		context->state[4] = 0xC3D2E1F0;
	}
	else if (x == 256)
	{
		// SHA-256 initialization constants : the initial hash value, H0
		context->state[0] = 0x6a09e667;
		context->state[1] = 0xbb67ae85;
		context->state[2] = 0x3c6ef372;
		context->state[3] = 0xa54ff53a;
		context->state[4] = 0x510e527f;
		context->state[5] = 0x9b05688c;
		context->state[6] = 0x1f83d9ab;
		context->state[7] = 0x5be0cd19;
	}
	else
	{
		HxLOG_Error("[CICC]---> SHA_Init()---> Error : %d not supported !!!\n", x);
		return;
	}

	context->count[0] = context->count[1] = 0;
}

static void SHA_Update(int x, SHA_CTX *context, unsigned char *data, unsigned long dataLen)
{
	void (*SHA_Transform)(unsigned long *state, unsigned char *buffer);
	unsigned long numByteDataProcessed;	// # of bytes processed so far
	unsigned long numByteInBuffMod64;		// # of bytes in the buffer mod 64

	if (x == 1)
	{
		SHA_Transform = SHA_1_Transform;
	}
	else if (x == 256)
	{
		SHA_Transform = SHA_256_Transform;
	}
	else
	{
		HxLOG_Error("[CICC]---> SHA_Update()---> Error : %d not supported !!!\n", x);
		return;
	}

	numByteInBuffMod64 = (context->count[0] >> 3) & 63; // numByteInBuffMod64 = (context->count[0] >> 3) % 64;

	// Adding in the number of bits of data
	if ((context->count[0] += dataLen << 3) < (dataLen << 3))
		context->count[1]++; // add in the carry bit

	context->count[1] += (dataLen >> 29);

	// If there is at least one block to be processed...
	if ((numByteInBuffMod64 + dataLen) > 63)
	{
		// Copy over 64-numByteInBuffMod64 bytes of data to the end of buffer
		HxSTD_memcpy(&context->buffer[numByteInBuffMod64], data, (numByteDataProcessed = 64 - numByteInBuffMod64));

		// Perform the transform on the buffer
		SHA_Transform(context->state, context->buffer);

		// As long as there are 64-bit blocks of data remaining, transform each one.
		for ( ; numByteDataProcessed + 63 < dataLen; numByteDataProcessed += 64)
			SHA_Transform(context->state, &data[numByteDataProcessed]);

		numByteInBuffMod64 = 0;
	}
	// Else there is not enough to process one block.
	else
	{
		numByteDataProcessed = 0;
	}

	// Copy over the remaining data into the buffer
	HxSTD_memcpy(&context->buffer[numByteInBuffMod64], &data[numByteDataProcessed], dataLen - numByteDataProcessed);
}

static void SHA_Final(int x, SHA_CTX *context, unsigned char *digest) /* Add padding and return the message digest. */
{
	unsigned long digest_size, i /*, j*/;

	if (x == 1)
	{
		digest_size = SHA_1_DIGEST_SIZE;
	}
	else if (x == 256)
	{
		digest_size = SHA_256_DIGEST_SIZE;
	}
	else
	{
		HxLOG_Error("[CICC]---> SHA_Final()---> Error : %d not supported !!!\n", x);
		return;
	}

#ifdef SHA_USE_POST_PADDING
{
	unsigned char numBits[8];

	// Record the number of bits
	#if 1
	for (i = 0; i < 8; i++)
		numBits[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)] >> ((3-(i & 3)) * 8) ) & 255); // Endian independent
	#else
	for (i = 1, j = 0; j < 8; i--, j += 4)
	{
		numBits[j] = (unsigned char)((context->count[i] >> 24) & 0xff);
		numBits[j+1] = (unsigned char)((context->count[i] >> 16) & 0xff);
		numBits[j+2] = (unsigned char)((context->count[i] >> 8) & 0xff);
		numBits[j+3] = (unsigned char)(context->count[i] & 0xff);
	}
	#endif

	// Add padding
	SHA_Update(x, context, (unsigned char *)"\200", 1);
	while ((context->count[0] & 504) != 448)
		SHA_Update(x, context, (unsigned char *)"\0", 1);

	// Append length
	SHA_Update(x, context, numBits, 8); // Should cause a SHA_1_Transform()
}
#endif

	// Store state in digest
	#if 1
    for (i = 0; i < digest_size; i++)
        digest[i] = (unsigned char)((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
	#else
	for (i = 0, j = 0; j < digest_size; i++, j += 4)
	{
		digest[j] = (unsigned char)((context->state[i] >> 24) & 0xff);
		digest[j+1] = (unsigned char)((context->state[i] >> 16) & 0xff);
		digest[j+2] = (unsigned char)((context->state[i] >> 8) & 0xff);
		digest[j+3] = (unsigned char)((context->state[i]) & 0xff);
	}
	#endif
}

void SHA_x(int x, unsigned char *Msg, unsigned long msgLen, unsigned char *digest) /* Digest의 공간 크기는 SHA_x_DIGEST_SIZE 이어야 한다. */
{
	SHA_CTX context;
	unsigned long i = 0, loop, remain;

	if (x != 1 && x != 256)
	{
		HxLOG_Error("[CICC]---> SHA()---> Error : x(%d)---> must be 1 or 256 !!!\n", x);
		return;
	}

	loop = msgLen / SHA_MSG_BUF_SIZE;
	remain = msgLen % SHA_MSG_BUF_SIZE;

	SHA_Init(x, &context);
	for (i = 0; i < loop; i++)
		SHA_Update(x, &context, &Msg[i*SHA_MSG_BUF_SIZE], SHA_MSG_BUF_SIZE);
	if (remain)
		SHA_Update(x, &context, &Msg[i*SHA_MSG_BUF_SIZE], remain);
	SHA_Final(x, &context, digest);
}

#ifdef SHA_TEST
void SHA_Test(void)
{
	unsigned char sha_1_digest[SHA_1_DIGEST_SIZE];
	unsigned char sha_256_digest[SHA_256_DIGEST_SIZE];
	unsigned char a[] = "abc";
	unsigned char b[] = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq";
	unsigned char c[] = "The quick brown fox jumps over the lazy dog";
	unsigned char d[] = "The quick brown fox jumps over the lazy dog.";
	unsigned char e[] = "";
	unsigned char result1[] = {0xA9,0x99,0x3E,0x36,0x47,0x06,0x81,0x6A,0xBA,0x3E,0x25,0x71,0x78,0x50,0xC2,0x6C,0x9C,0xD0,0xD8,0x9D};
	unsigned char result2[] = {0x84,0x98,0x3E,0x44,0x1C,0x3B,0xD2,0x6E,0xBA,0xAE,0x4A,0xA1,0xF9,0x51,0x29,0xE5,0xE5,0x46,0x70,0xF1};
	unsigned char result3[] = {0x2F,0xD4,0xE1,0xC6,0x7A,0x2D,0x28,0xFC,0xED,0x84,0x9E,0xE1,0xBB,0x76,0xE7,0x39,0x1B,0x93,0xEB,0x12};
	unsigned char result4[] = {0x40,0x8D,0x94,0x38,0x42,0x16,0xF8,0x90,0xFF,0x7A,0x0C,0x35,0x28,0xE8,0xBE,0xD1,0xE0,0xB0,0x16,0x21};
	unsigned char result5[] = {0xDA,0x39,0xA3,0xEE,0x5E,0x6B,0x4B,0x0D,0x32,0x55,0xBF,0xEF,0x95,0x60,0x18,0x90,0xAF,0xD8,0x07,0x09};
	unsigned char result6[] = {0xBA,0x78,0x16,0xBF,0x8F,0x01,0xCF,0xEA,0x41,0x41,0x40,0xDE,0x5D,0xAE,0x22,0x23,
		                        0xB0,0x03,0x61,0xA3,0x96,0x17,0x7A,0x9C,0xB4,0x10,0xFF,0x61,0xF2,0x00,0x15,0xAD};
	unsigned char result7[] = {0x24,0x8D,0x6A,0x61,0xD2,0x06,0x38,0xB8,0xE5,0xC0,0x26,0x93,0x0C,0x3E,0x60,0x39,
		                        0xA3,0x3C,0xE4,0x59,0x64,0xFF,0x21,0x67,0xF6,0xEC,0xED,0xD4,0x19,0xDB,0x06,0xC1};

	HxLOG_Print("\n SHA_Test (SHA-1) Start... ");
	SHA_1(a, 3, sha_1_digest);
	if (HxSTD_memcmp(sha_1_digest, result1, SHA_1_DIGEST_SIZE) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");
	SHA_1(b, 56, sha_1_digest);
	if (HxSTD_memcmp(sha_1_digest, result2, SHA_1_DIGEST_SIZE) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");
	SHA_1(c, 43, sha_1_digest);
	if (HxSTD_memcmp(sha_1_digest, result3, SHA_1_DIGEST_SIZE) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");
	SHA_1(d, 44, sha_1_digest);
	if (HxSTD_memcmp(sha_1_digest, result4, SHA_1_DIGEST_SIZE) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");
	SHA_1(e, 0, sha_1_digest);
	if (HxSTD_memcmp(sha_1_digest, result5, SHA_1_DIGEST_SIZE) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");
	HxLOG_Print("\n SHA_Test (SHA-1) End. \n");

	HxLOG_Print("\n SHA_Test (SHA-256) Start... ");
	SHA_256(a, 3, sha_256_digest);
	if (HxSTD_memcmp(sha_256_digest, result6, SHA_256_DIGEST_SIZE) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");
	SHA_256(b, 56, sha_256_digest);
	if (HxSTD_memcmp(sha_256_digest, result7, SHA_256_DIGEST_SIZE) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");
	HxLOG_Print("\n SHA_Test (SHA-256) End. \n");
}
#endif

/***************************************************************
* Pre-defined big numbers //////////////////////////////////////
***************************************************************/

bignum bn_zero	= {1, {0x00}};
bignum bn_one	= {1, {0x01}};
bignum bn_x10	= {1, {0x10}};
bignum bn_e		= {3, {0x01,0x00,0x01}};

/***************************************************************
* RSA (RSASSA-PSS + SHA-1 and RSASSA-PKCS1-V1_5 + SHA-256) /////
***************************************************************/

static int I2OSP(bignum *x, bn_len_type xLen, bignum *X) /* converts a nonnegative integer to an octet string of a specified length */
{
	// if x = 11259375 (0xab 0xcd 0xef) and xLen = 7, I2OSP() -> X = 0x00 0x00 0x00 0x00 0xab 0xcd 0xef

	if (x->len > xLen)
	{
		HxLOG_Error("[CICC]---> I2OSP()---> Error : integer too large !!!\n");
		return -1;
	}

	X->len = xLen;
	HxSTD_memset(X->num, 0x00, xLen - x->len);
	HxSTD_memcpy(&X->num[xLen - x->len], x->num, x->len);

	return ERR_OK;
}

static void OS2IP(bignum *X, bignum *x) /* converts an octet string to a nonnegative integer */
{
	// if X = 0x00 0x00 0x00 0x00 0xab 0xcd 0xef, OS2IP() -> x = 11259375 (0xab 0xcd 0xef), its length = 3

	bn_len_type i;

	for (i = 0; i < X->len; i++)
	{
		if (X->num[i] != 0x00)
			break;
	}

	x->len = X->len - i;
	HxSTD_memcpy(x->num, &X->num[i], x->len);
}

#ifndef DEACTIVATE_NOT_USED_FUNCTIONS

static int RSAEP(RSA_public_key *K, bignum *m, bignum *c) /* Encryption primitive function */
{
	/*
		< Input >
			(n, e) : RSA public key
			m      : message representative, an integer between 0 and n-1
		< Output >
			c      : ciphertext representative, an integer between 0 and n-1
		< Errors >
			message representative out of rang
		< Assumption >
			RSA public key (n, e) is valid
		< Steps >
			1. If the message representative m is not between 0 and n-1, output "message representative out of range" and stop.
			2. Let c = m^e mod n.
			3. Output c.
	*/

//	#define CHECK_RSAEP

	if (bn_cmp(m, K->n) >= 0)
	{
		HxLOG_Error("[CICC]---> RSAEP()---> Error : message representative out of range !!!\n");
		return -1;
	}

	bn_mod_exp(m, K->e, K->n, c);

#ifdef CHECK_RSAEP
{
	bn_len_type i;
	HxLOG_Print("RSAEP : m = ");
	for (i = 0; i < m->len; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", m->num[i]);
	}
	HxLOG_Print("\nRSAEP : c = ");
	for (i = 0; i < c->len; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", c->num[i]);
	}
	HxLOG_Print("\n");
}
#endif

	return ERR_OK;
}

static int RSADP(RSA_private_key *K, bignum *c, bignum *m) /* Decryption primitive function */
{
	/*
		< Input >
			K : RSA private key, where K has one of the following forms :
			    a pair (n, d)
			    a quintuple (p, q, dP, dQ, qInv) and a (possibly empty) sequence of triplets (ri, di, ti), i = 3, …, u
			c : ciphertext representative, an integer between 0 and n-1
		< Output >
			m : message representative, an integer between 0 and n-1
		< Errors >
			ciphertext representative out of range
		< Assumption >
			RSA private key K is valid
		< Steps >
			1. If the ciphertext representative c is not between 0 and n-1, output "ciphertext representative out of range" and stop.
			2. The message representative m is computed as follows.
			   a. If the first form (n, d) of K is used, let m = c^d mod n.
			   b. If the second form (p, q, dP, dQ, qInv) and (ri, di, ti) of K is used, proceed as follows :
			      1) Let m1 = c^dP mod p and m2 = c^dQ mod q.
			      2) If u > 2, let mi = c^di mod ri, i = 3, …, u.
			      3) Let h = (m1 - m2) x qInv mod p.
			      4) Let m = m2 + q x h.
			      5) If u > 2, let R = r1 and for i = 3 to u do
			         Let R = R x r(i-1).
			         Let h = (mi - m) x ti (mod ri).
			         Let m = m + R x h.
			3. Output m.
	*/

//	#define CHECK_RSADP

	bignum m1, m2, h, sub, mul;
	int neg;

	if (bn_cmp(c, K->n) >= 0)
	{
		HxLOG_Error("[CICC]---> RSADP()---> Error : ciphertext representative out of range !!!\n");
		return -1;
	}

	if (K->p && K->q && K->dP && K->dQ && K->qInv) // second form is used
	{
		bn_mod_exp(c, K->dP, K->p, &m1);
		bn_mod_exp(c, K->dQ, K->q, &m2);
		neg = bn_sub(&m1, &m2, &sub);
		bn_mul(&sub, K->qInv, &mul);
		bn_mod(&mul, K->p, &h);
		if (neg) bn_sub(K->p, &h, &h);
		bn_mul(K->q, &h, &mul);
		bn_add(&m2, &mul, m);
	}
	else // first form is used -> second form 에 비해 약 4배의 computation time을 요구하므로 가능한 second form 을 사용하도록 할 것 -> 어셈블리 코드로 작성하거나 타원 곡선 알고리즘 적용 등으로 개선?
	{
		bn_mod_exp(c, K->d, K->n, m);
	}

#ifdef CHECK_RSADP
{
	bn_len_type i;
	HxLOG_Print("RSADP : c = ");
	for (i = 0; i < c->len; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", c->num[i]);
	}
	HxLOG_Print("\nRSADP : m = ");
	for (i = 0; i < m->len; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", m->num[i]);
	}
	HxLOG_Print("\n");
}
#endif

	return ERR_OK;
}

#endif // not used

static int RSASP1(RSA_private_key *K, bignum *m, bignum *s) /* Signature primitive function */
{
	/*
		< Input >
			K : RSA private key, where K has one of the following forms :
			    a pair (n, d)
			    a quintuple (p, q, dP, dQ, qInv) and a (possibly empty) sequence of triplets (ri, di, ti), i = 3, …, u
			m : message representative, an integer between 0 and n-1
		< Output >
			s : signature representative, an integer between 0 and n-1
		< Errors >
			message representative out of range
		< Assumption >
			RSA private key K is valid
		< Steps >
			1. If the message representative m is not between 0 and n-1, output "message representative out of range" and stop.
			2. The signature representative s is computed as follows.
			   a. If the first form (n, d) of K is used, let s = m^d mod n.
			   b. If the second form (p, q, dP, dQ, qInv) and (ri, di, ti) of K is used, proceed as follows :
			      1) Let s1 = m^dP mod p and s2 = m^dQ mod q.
			      2) If u > 2, let si = m^di mod ri, i = 3, …, u.
			      3) Let h = (s1 - s2) x qInv mod p.
			      4) Let s = s2 + q x h.
			      5) If u > 2, let R = r1 and for i = 3 to u do
			         Let R = R x r(i-1).
			         Let h = (si - s) x ti (mod ri).
			         Let s = s + R x h.
			3. Output s.
	*/

//	#define CHECK_RSASP1

	bignum s1, s2, h, sub, mul;
	int neg;

	if (bn_cmp(m, K->n) >= 0)
	{
		HxLOG_Error("[CICC]---> RSASP1()---> Error : message representative out of range !!!\n");
		return -1;
	}

	if (K->p && K->q && K->dP && K->dQ && K->qInv) // second form is used
	{
		bn_mod_exp(m, K->dP, K->p, &s1);
		bn_mod_exp(m, K->dQ, K->q, &s2);
		neg = bn_sub(&s1, &s2, &sub);
		bn_mul(&sub, K->qInv, &mul);
		bn_mod(&mul, K->p, &h);
		if (neg) bn_sub(K->p, &h, &h);
		bn_mul(K->q, &h, &mul);
		bn_add(&s2, &mul, s);
	}
	else if(K->d)// first form is used -> second form 에 비해 약 4배의 computation time을 요구하므로 가능한 second form 을 사용하도록 할 것 -> 어셈블리 코드로 작성하거나 타원 곡선 알고리즘 적용 등으로 개선?
	{
			bn_mod_exp(m, K->d, K->n, s);
	}

#ifdef CHECK_RSASP1
{
	bn_len_type i;
	HxLOG_Print("RSASP1 : m = ");
	for (i = 0; i < m->len; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", m->num[i]);
	}
	HxLOG_Print("\nRSASP1 : s = ");
	for (i = 0; i < s->len; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", s->num[i]);
	}
	HxLOG_Print("\n");
}
#endif

	return ERR_OK;
}

static int RSAVP1(RSA_public_key *K, bignum *s, bignum *m) /* Verification primitive function */
{
	/*
		< Input >
			(n, e) : RSA public key
			s      : signature representative, an integer between 0 and n-1
		< Output >
			m      : message representative, an integer between 0 and n-1
		< Errors >
			signature representative out of range
		< Assumption >
			RSA public key (n, e) is valid
		< Steps >
			1. If the signature representative s is not between 0 and n-1, output "signature representative out of range" and stop.
			2. Let m = s^e mod n.
			3. Output m.
	*/

//	#define CHECK_RSAVP1

	if (bn_cmp(s, K->n) >= 0)
	{
		HxLOG_Error("[CICC]---> RSAVP1()---> Error : signature representative out of range !!!\n");
		return -1;
	}

	bn_mod_exp(s, K->e, K->n, m);

#ifdef CHECK_RSAVP1
{
	bn_len_type i;
	HxLOG_Print("RSAVP1 : s = ");
	for (i = 0; i < s->len; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", s->num[i]);
	}
	HxLOG_Print("\nRSAVP1 : m = ");
	for (i = 0; i < m->len; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", m->num[i]);
	}
	HxLOG_Print("\n");
}
#endif

	return ERR_OK;
}

static int MGF1(unsigned char *mgfSeed, bn_len_type mgfSeedLen, bn_len_type maskLen, unsigned char *mask) /* a Mask Generation Function based on a hash function (SHA-1). */
{
	/*
		< Options >
			Hash    : hash function (hLen denotes the length in octets of the hash function output)
		< Input >
			mgfSeed : seed from which mask is generated, an octet string
			maskLen : intended length in octets of the mask, at most 2^32 hLen
		< Output >
			mask    : mask, an octet string of length maskLen
		< Errors >
			mask too long
		< Steps >
			1. If maskLen > 2^32 hLen, output "mask too long" and stop.
			2. Let T be the empty octet string.
			3. For counter from 0 to ceiling function(maskLen/hLen) - 1, do the following :
			   a. Convert counter to an octet string C of length 4 octets : C = I2OSP (counter, 4).
			   b. Concatenate the hash of the seed mgfSeed and C to the octet string T : T = T || Hash (mgfSeed || C).
			4. Output the leading maskLen octets of T as the octet string mask.
	*/

	bn_len_type i, outlen = 0;
	unsigned char cnt[4];
	SHA_CTX context;
	unsigned char digest[SHA_1_DIGEST_SIZE];

	for (i = 0; outlen < maskLen; i++)
	{
		cnt[0] = (unsigned char)((i >> 24) & 0xff);
		cnt[1] = (unsigned char)((i >> 16) & 0xff);
		cnt[2] = (unsigned char)((i >> 8) & 0xff);
		cnt[3] = (unsigned char)(i & 0xff);
		SHA_Init(1, &context);
		SHA_Update(1, &context, mgfSeed, mgfSeedLen);
		SHA_Update(1, &context, cnt, 4);
		if (outlen + SHA_1_DIGEST_SIZE <= maskLen)
		{
			SHA_Final(1, &context, mask + outlen);
			outlen += SHA_1_DIGEST_SIZE;
		}
		else
		{
			SHA_Final(1, &context, digest);
			HxSTD_memcpy(mask + outlen, digest, maskLen - outlen);
			outlen = maskLen;
		}
	}

	return ERR_OK;
}

static int EMSA_PSS_ENCODE(bignum *M, bn_len_type emBits, bignum *salt, bignum *EM) /* EMSA-PSS-ENCODE function based on a hash function (SHA-1). */
{
	/*
		< Options >
			Hash   : hash function (hLen denotes the length in octets of the hash function output)
			MGF    : mask generation function
			sLen   : intended length in octets of the salt
		< Input >
			M      : message to be encoded, an octet string
			emBits : maximal bit length of the integer OS2IP (EM), at least 8 hLen + 8 sLen + 9
		< Output >
			EM     : encoded message, an octet string of length emLen = ceiling function(emBits/8)
		< Errors >
			message too long or encoding error
		< Steps >
			See below.
	*/

//	#define CHECK_EMSA_PSS_ENCODE

	unsigned char mHash[SHA_1_DIGEST_SIZE], H[SHA_1_DIGEST_SIZE];
	bn_len_type hLen = SHA_1_DIGEST_SIZE, sLen = salt->len, emLen = EM->len, i;
	unsigned char M_[MAX_BN_LEN], DB[MAX_BN_LEN], dbMask[MAX_BN_LEN];

#ifdef CHECK_EMSA_PSS_ENCODE
	HxLOG_Print("EMSA_PSS_ENCODE : emLen = %d, emBits = %d\n", emLen, emBits);
#endif

	/* 1. If the length of M is greater than the input limitation for the hash function (2^61-1 octets for SHA-1), output "message too long" and stop -> nothing to do in fact */

	/* 2. Let mHash = Hash (M), an octet string of length hLen. */
	SHA_1(M->num, M->len, mHash);

#ifdef CHECK_EMSA_PSS_ENCODE
	HxLOG_Print("EMSA_PSS_ENCODE : mHash = ");
	for (i = 0; i < SHA_1_DIGEST_SIZE; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", mHash[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 3. If emLen < hLen + sLen + 2, output "encoding error" and stop. */
	if (emLen < hLen + sLen + 2)
	{
		HxLOG_Error("[CICC]---> EMSA_PSS_ENCODE()---> Error : emLen(%d) is less than hLen(%d) + sLen(%d) + 2 !!!\n", emLen, hLen, sLen);
		return -1;
	}

	/* 4. Generate a random octet string salt of length sLen; if sLen = 0, then salt is the empty string -> I won't generate salt here. Use the given. */

#ifdef CHECK_EMSA_PSS_ENCODE
	HxLOG_Print("EMSA_PSS_ENCODE : salt = ");
	for (i = 0; i < sLen; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", salt->num[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; M' is an octet string of length 8 + hLen + sLen with eight initial zero octets. */
	HxSTD_memset(M_, 0x00, 8);
	HxSTD_memcpy(&M_[8], mHash, hLen);
	HxSTD_memcpy(&M_[8+hLen], salt->num, sLen);

#ifdef CHECK_EMSA_PSS_ENCODE
	HxLOG_Print("EMSA_PSS_ENCODE : M' = ");
	for (i = 0; i < 8 + hLen + sLen; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", M_[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 6. Let H = Hash (M'), an octet string of length hLen. */
	SHA_1(M_, 8 + hLen + sLen, H);

#ifdef CHECK_EMSA_PSS_ENCODE
	HxLOG_Print("EMSA_PSS_ENCODE : H = ");
	for (i = 0; i < SHA_1_DIGEST_SIZE; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", H[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2 zero octets. The length of PS may be 0. */
	/* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length emLen - hLen - 1. */
	HxSTD_memset(DB, 0x00, emLen - sLen - hLen - 2);
	DB[emLen - sLen - hLen - 2] = 0x01;
	HxSTD_memcpy(&DB[emLen - sLen - hLen - 1], salt->num, sLen);

#ifdef CHECK_EMSA_PSS_ENCODE
	HxLOG_Print("EMSA_PSS_ENCODE : DB = ");
	for (i = 0; i < emLen - hLen - 1; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", DB[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 9. Let dbMask = MGF (H, emLen - hLen - 1). */
	MGF1(H, hLen, emLen - hLen - 1, dbMask);

#ifdef CHECK_EMSA_PSS_ENCODE
	HxLOG_Print("EMSA_PSS_ENCODE : dbMask = ");
	for (i = 0; i < emLen - hLen - 1; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", dbMask[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 10. Let maskedDB = DB XOR dbMask. XOR is bit-wise exclusive-or of two octet strings. */
	for (i = 0; i < emLen - hLen - 1; i++)
		DB[i] ^= dbMask[i];

	/* 11. Set the leftmost 8 x emLen - emBits bits of the leftmost octet in maskedDB to zero. */
	DB[0] &= (0xff >> (8 * emLen - emBits));

#ifdef CHECK_EMSA_PSS_ENCODE
	HxLOG_Print("EMSA_PSS_ENCODE : maskedDB = ");
	for (i = 0; i < emLen - hLen - 1; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", DB[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 12. Let EM = maskedDB || H || 0xbc. */
	/* 13. Output EM. */
	HxSTD_memcpy(EM->num, DB, emLen - hLen - 1);
	HxSTD_memcpy(&EM->num[emLen - hLen - 1], H, hLen);
	EM->num[emLen - 1] = 0xbc;

#ifdef CHECK_EMSA_PSS_ENCODE
	HxLOG_Print("EMSA_PSS_ENCODE : EM = ");
	for (i = 0; i < emLen; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", EM->num[i]);
	}
	HxLOG_Print("\n");
#endif

	return ERR_OK;
}

static int EMSA_PSS_VERIFY(bignum *M, bignum *EM, bn_len_type emBits) /* EMSA-PSS-VERIFY function based on a hash function (SHA-1) : return 1 if consistent, 0 if inconsistent */
{
	/*
		< Options >
			Hash   : hash function (hLen denotes the length in octets of the hash function output)
			MGF    : mask generation function
			sLen   : intended length in octets of the salt
		< Input >
			M      : message to be verified, an octet string
			EM     : encoded message, an octet string of length emLen = ceiling function(emBits/8)
			emBits : maximal bit length of the integer OS2IP (EM), at least 8 hLen + 8 sLen + 9
		< Output >
			consistent or inconsistent
		< Steps >
			See below.
	*/

//	#define CHECK_EMSA_PSS_VERIFY

	unsigned char mHash[SHA_1_DIGEST_SIZE], H_[SHA_1_DIGEST_SIZE];
	bn_len_type hLen = SHA_1_DIGEST_SIZE, sLen = SHA_1_DIGEST_SIZE, emLen = EM->len, i;
	unsigned char *H, *salt;
	unsigned char DB[MAX_BN_LEN], M_[MAX_BN_LEN];

#ifdef CHECK_EMSA_PSS_VERIFY
	HxLOG_Print("EMSA_PSS_VERIFY : emLen = %d, emBits = %d\n", emLen, emBits);
	HxLOG_Print("EMSA_PSS_VERIFY : EM = ");
	for (i = 0; i < emLen; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", EM->num[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 1. If the length of M is greater than the input limitation for the hash function (2^61-1 octets for SHA-1), output "inconsistent" and stop -> nothing to do in fact */

	/* 2. Let mHash = Hash (M), an octet string of length hLen. */
	SHA_1(M->num, M->len, mHash);

#ifdef CHECK_EMSA_PSS_VERIFY
	HxLOG_Print("EMSA_PSS_VERIFY : mHash = ");
	for (i = 0; i < SHA_1_DIGEST_SIZE; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", mHash[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 3. If emLen < hLen + sLen + 2, output "inconsistent" and stop. */
	if (emLen < hLen + sLen + 2)
	{
		HxLOG_Error("[CICC]---> EMSA_PSS_VERIFY()---> Error : emLen(%d) is less than hLen(%d) + sLen(%d) + 2 !!!\n", emLen, hLen, sLen);
		return 0; // inconsistent
	}

	/* 4. If the rightmost octet of EM does not have hexadecimal value 0xbc, output "inconsistent" and stop. */
	if (EM->num[emLen - 1] != 0xbc)
	{
		HxLOG_Error("[CICC]---> EMSA_PSS_VERIFY()---> Error : the rightmost octet of EM (0x%02x) does not have hexadecimal value 0xbc !!!\n", EM->num[emLen - 1]);
		return 0; // inconsistent
	}

	/* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and let H be the next hLen octets. */
	H = EM->num + emLen - hLen - 1; // H length is hLen octets

#ifdef CHECK_EMSA_PSS_VERIFY
	HxLOG_Print("EMSA_PSS_VERIFY : maskedDB = ");
	for (i = 0; i < emLen - hLen - 1; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", EM->num[i]);
	}
	HxLOG_Print("\n");
	HxLOG_Print("EMSA_PSS_VERIFY : H = ");
	for (i = 0; i < SHA_1_DIGEST_SIZE; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", H[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 6. If the leftmost 8 x emLen - emBits bits of the leftmost octet in maskedDB are not all equal to zero, output "inconsistent" and stop. */
	if (EM->num[0] >> (8 - 8 * emLen - emBits))
	{
		HxLOG_Error("[CICC]---> EMSA_PSS_VERIFY()---> Error : the leftmost octet in maskedDB (0x%02x) have wrong value !!!\n", EM->num[0]);
		return 0; // inconsistent
	}

	/* 7. Let dbMask = MGF (H, emLen - hLen - 1). */
	MGF1(H, hLen, emLen - hLen - 1, DB);

#ifdef CHECK_EMSA_PSS_VERIFY
	HxLOG_Print("EMSA_PSS_VERIFY : dbMask = ");
	for (i = 0; i < emLen - hLen - 1; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", DB[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 8. Let DB = maskedDB XOR dbMask. XOR is bit-wise exclusive-or of two octet strings. */
	for (i = 0; i < emLen - hLen - 1; i++)
		DB[i] ^= EM->num[i];

	/* 9. Set the leftmost 8 x emLen - emBits bits of the leftmost octet in DB to zero. */
	DB[0] &= (0xff >> (8 * emLen - emBits));

#ifdef CHECK_EMSA_PSS_VERIFY
	HxLOG_Print("EMSA_PSS_VERIFY : DB = ");
	for (i = 0; i < emLen - hLen - 1; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", DB[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero or
	       if the octet at position emLen - hLen - sLen - 1 (the leftmost position is "position 1") does not have hexadecimal value 0x01, output "inconsistent" and stop. */
	for (i = 0; i < emLen - hLen - sLen - 2; i++)
	{
		if (DB[i] != 0x00)
		{
			HxLOG_Error("[CICC]---> EMSA_PSS_VERIFY()---> Error : the leftmost octets of DB are not zero !!!\n");
			return 0; // inconsistent
		}
	}
	if (DB[i] != 0x01)
	{
		HxLOG_Error("[CICC]---> EMSA_PSS_VERIFY()---> Error : the octet at %d of DB (0x%02x) does not have hexadecimal value 0x01 !!!\n", i, DB[i]);
		return 0; // inconsistent
	}

	/* 11. Let salt be the last sLen octets of DB. */
	salt = &DB[emLen - hLen - 1 - sLen];

#ifdef CHECK_EMSA_PSS_VERIFY
	HxLOG_Print("EMSA_PSS_VERIFY : salt = ");
	for (i = 0; i < sLen; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", salt[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 12. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; M' is an octet string of length 8 + hLen + sLen with eight initial zero octets. */
	HxSTD_memset(M_, 0x00, 8);
	HxSTD_memcpy(&M_[8], mHash, hLen);
	HxSTD_memcpy(&M_[8+hLen], salt, sLen);

#ifdef CHECK_EMSA_PSS_VERIFY
	HxLOG_Print("EMSA_PSS_VERIFY : M' = ");
	for (i = 0; i < 8 + hLen + sLen; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", M_[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 13. Let H' = Hash (M'), an octet string of length hLen. */
	SHA_1(M_, 8 + hLen + sLen, H_);

#ifdef CHECK_EMSA_PSS_VERIFY
	HxLOG_Print("EMSA_PSS_VERIFY : H' = ");
	for (i = 0; i < SHA_1_DIGEST_SIZE; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", H_[i]);
	}
	HxLOG_Print("\n");
#endif

	/* 14. If H = H', output "consistent." Otherwise, output "inconsistent." */
	if (HxSTD_memcmp(H, H_, hLen))
	{
		HxLOG_Error("[CICC]---> EMSA_PSS_VERIFY()---> Error : hashes are not matched !!!\n");
		return 0; // inconsistent
	}

	return 1; // consistent
}

static int EMSA_PKCS1_v1_5_ENCODE(bignum *M, bn_len_type emLen, bignum *EM) /* EMSA-PKCS1-v1_5-ENCODE function based on a hash function. */
{
	/*
		< Options >
			Hash   : hash function (hLen denotes the length in octets of the hash function output)
		< Input >
			M      : message to be encoded
			emLen  : intended length in octets of the encoded message, at least tLen + 11, where tLen is the octet length of the DER encoding T of a certain value computed during the encoding operation
		< Output >
			EM     : encoded message, an octet string of length emLen
		< Errors >
			message too long or intended encoded message length too short
		< Steps >
			See below.
	*/

//	#define CHECK_EMSA_PKCS1_v1_5_ENCODE

	/* 여기서는 hash function 으로 SHA-256 을 사용하기로 한다 */
	unsigned char H[SHA_256_DIGEST_SIZE];
	unsigned char T[SHA_256_DIGEST_SIZE + 19] = {0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20, 0x00,};
	bn_len_type tLen = SHA_256_DIGEST_SIZE + 19;

#ifdef CHECK_EMSA_PKCS1_v1_5_ENCODE
	HxLOG_Print("EMSA_PKCS1_v1_5_ENCODE : emLen = %d\n", emLen);
#endif

	/* 1. Apply the hash function to the message M to produce a hash value H : H = Hash (M). If the hash function outputs "message too long" output "message too long" and stop. */
	SHA_256(M->num, M->len, H);

#ifdef CHECK_EMSA_PKCS1_v1_5_ENCODE
{
	int i;
	HxLOG_Print("EMSA_PKCS1_v1_5_ENCODE : H = ");
	for (i = 0; i < SHA_256_DIGEST_SIZE; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", H[i]);
	}
	HxLOG_Print("\n");
}
#endif

	/* 2. Encode the algorithm ID for the hash function and the hash value into an ASN.1 value of type DigestInfo with the Distinguished Encoding Rules (DER) <- RFC 2313 (version 1.5) 에선 BER 였음에 유의.
	      Let T be the DER encoding of the DigestInfo value and let tLen be the length in octets of T.
	      The DER encoding T of the DigestInfo value is equal to the following:
	      MD2:     (0x)30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 02 05 00 04 10 || H.
	      MD5:     (0x)30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 05 05 00 04 10 || H.
	      SHA-1:   (0x)30 21 30 09 06 05 2b 0e 03 02 1a 05 00 04 14 || H.
	      SHA-256: (0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20 || H.
	      SHA-384: (0x)30 41 30 0d 06 09 60 86 48 01 65 03 04 02 02 05 00 04 30 || H.
	      SHA-512: (0x)30 51 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00 04 40 || H. */
	HxSTD_memcpy(&T[19], H, SHA_256_DIGEST_SIZE);

	/* 3. If emLen <  tLen + 11, output "intended encoded message length too short" and stop. */
	if (emLen < tLen + 11)
	{
		HxLOG_Error("[CICC]---> EMSA_PKCS1_v1_5_ENCODE()---> Error : emLen(%d) is less than tLen(%d) + 11 !!!\n", emLen, tLen);
		return -1;
	}

	/* 4. Generate an octet string PS consisting of emLen - tLen - 3 octets with hexadecimal value 0xff. The length of PS will be at least 8 octets -> 위의 3번 step 에서 체크됨 */
	/* 5. Concatenate PS, the DER encoding T, and other padding to form the encoded message EM as EM = 0x00 || 0x01 || PS || 0x00 || T */
	/* 6. Output EM. */
	EM->len = emLen;
	EM->num[0] = 0x00;
	EM->num[1] = 0x01;
	HxSTD_memset(&EM->num[2], 0xff, emLen - tLen - 3);
	EM->num[emLen - tLen - 1] = 0x00;
	HxSTD_memcpy(&EM->num[emLen - tLen], T, tLen);

#ifdef CHECK_EMSA_PKCS1_v1_5_ENCODE
{
	int i;
	HxLOG_Print("EMSA_PKCS1_v1_5_ENCODE : EM = ");
	for (i = 0; i < emLen; i++)
	{
		if ((i & 15) == 0)
			HxLOG_Print("\n");
		HxLOG_Print("%02x ", EM->num[i]);
	}
	HxLOG_Print("\n");
}
#endif

	return ERR_OK;
}

#ifndef DEACTIVATE_NOT_USED_FUNCTIONS

int RSAES_OAEP_ENCRYPT(RSA_public_key *K, bignum *M, bignum *L, bignum *C) /* RSAES-OAEP-ENCRYPT function based on a hash function (SHA-1). */
{
	// CI+에선 필요치 않아 구현하지는 않으나 현재 있는 함수들만으로 쉽게 구현할 수 있으므로 필요한 사람이 만들어 쓰도록...

	return ERR_OK;
}

int RSAES_OAEP_DECRYPT(RSA_private_key *K, bignum *C, bignum *L, bignum *M) /* RSAES-OAEP-DECRYPT function based on a hash function (SHA-1). */
{
	// CI+에선 필요치 않아 구현하지는 않으나 현재 있는 함수들만으로 쉽게 구현할 수 있으므로 필요한 사람이 만들어 쓰도록...

	return ERR_OK;
}

int RSAES_PKCS1_V1_5_ENCRYPT(RSA_public_key *K, bignum *M, bignum *C) /* RSAES-PKCS1-V1_5-ENCRYPT function. */
{
	// CI+에선 필요치 않아 구현하지는 않으나 현재 있는 함수들만으로 쉽게 구현할 수 있으므로 필요한 사람이 만들어 쓰도록...

	return ERR_OK;
}

int RSAES_PKCS1_V1_5_DECRYPT(RSA_private_key *K, bignum *C, bignum *M) /* RSAES-PKCS1-V1_5-DECRYPT function. */
{
	// CI+에선 필요치 않아 구현하지는 않으나 현재 있는 함수들만으로 쉽게 구현할 수 있으므로 필요한 사람이 만들어 쓰도록...

	return ERR_OK;
}

#endif // not used

int RSASSA_PSS_SIGN(RSA_private_key *K, bignum *M, bignum *salt, bignum *S) /* RSASSA-PSS-SIGN function */
{
	/*
		< Input >
			K : signer's RSA private key
			M : message to be signed, an octet string
		< Output >
			S : signature, an octet string of length k, where k is the length in octets of the RSA modulus n
		< Errors >
			message too long or encoding error
		< Steps >
			See below.
	*/

	bn_len_type k, modBits, i;
	bignum EM, m, s;

	/* 파라미터 체크 */
	if (K == NULL || K->n == NULL || M == NULL || salt == NULL || S == NULL)
	{
		HxLOG_Error("[CICC]---> RSASSA_PSS_SIGN()---> Error : null params !!!\n");
		return -1;
	}
	if (K->n->len < 1 || K->n->len > MAX_BN_LEN)
	{
		HxLOG_Error("[CICC]---> RSASSA_PSS_SIGN()---> Error : wrong length K %d !!!\n", K->n->len);
		return -1;
	}
	if (M->len < 1 || M->len > MAX_BN_LEN)
	{
		HxLOG_Error("[CICC]---> RSASSA_PSS_SIGN()---> Error : wrong length M %d !!!\n", M->len);
		return -1;
	}
	if (salt->len < 1 || salt->len > MAX_BN_LEN)
	{
		HxLOG_Error("[CICC]---> RSASSA_PSS_SIGN()---> Error : wrong length salt %d !!!\n", salt->len);
		return -1;
	}

	k = K->n->len;

	/* 1. EMSA-PSS encoding :
	      Apply the EMSA-PSS encoding operation to the message M to produce an encoded message EM of length, ceiling function((modBits-1)/8) octets
	      such that the bit length of the integer OS2IP (EM) is at most modBits-1, where modBits is the length in bits of the RSA modulus n : EM = EMSA-PSS-ENCODE (M, modBits-1).
	      Note that the octet length of EM will be one less than k if modBits-1 is divisible by 8 and equal to k otherwise.
	      If the encoding operation outputs "message too long" output "message too long" and stop.
	      If the encoding operation outputs "encoding error" output "encoding error" and stop. */
	for (i = 0; i < 8; i++)
	{
		if (K->n->num[0] & (0x80 >> i))
			break;
	}
	modBits = k * 8 - i;
	EM.len = ((modBits - 1) & 7) ? k : k - 1;
	if (EMSA_PSS_ENCODE(M, modBits-1, salt, &EM) < 0)
	{
		HxLOG_Error("[CICC]---> RSASSA_PSS_SIGN()---> Error : EMSA_PSS_ENCODE !!!\n");
		return -1;
	}

	/* 2. RSA signature (step a ~ c) : */

	/* a. Convert the encoded message EM to an integer message representative m : m = OS2IP (EM) */
	OS2IP(&EM, &m);

	/* b. Apply the RSASP1 signature primitive to the RSA private key K and the message representative m to produce an integer signature representative s : s = RSASP1 (K, m) */
	if (RSASP1(K, &m, &s) < 0)
	{
		HxLOG_Error("[CICC]---> RSASSA_PSS_SIGN()---> Error : message representative out of range !!!\n");
		return -1;
	}

	/* c. Convert the signature representative s to a signature S of length k octets : S = I2OSP (s, k) */
	/* 3. Output the signature S. */
	if (I2OSP(&s, k, S) < 0)
	{
		HxLOG_Error("[CICC]---> RSASSA_PSS_SIGN()---> Error : integer too large !!!\n");
		return -1;
	}

	return ERR_OK;
}

int RSASSA_PSS_VERIFY(RSA_public_key *K, bignum *M, bignum *S) /* RSASSA-PSS-VERIFY function : return 1 if valid signature, 0 if invalid signature */
{
	/*
		< Input >
			(n, e) : signer's RSA public key
			M      : message whose signature is to be verified, an octet string
			S      : signature to be verified, an octet string of length k, where k is the length in octets of the RSA modulus n
		< Output >
			valid signature or invalid signature
		< Steps >
			See below.
	*/

	bn_len_type k, modBits, emLen, i;
	bignum s, m, EM;

	/* 파라미터 체크 */
	if (K == NULL || K->n == NULL || M == NULL || S == NULL)
	{
		HxLOG_Error("[CICC]---> RSASSA_PSS_VERIFY()---> Error : null params !!!\n");
		return 0; // invalid signature
	}
	if (K->n->len < 1 || K->n->len > MAX_BN_LEN)
	{
		HxLOG_Error("[CICC]---> RSASSA_PSS_VERIFY()---> Error : wrong length K %d !!!\n", K->n->len);
		return 0; // invalid signature
	}
	if (M->len < 1 || M->len > MAX_BN_LEN)
	{
		HxLOG_Error("[CICC]---> RSASSA_PSS_VERIFY()---> Error : wrong length M %d !!!\n", M->len);
		return 0; // invalid signature
	}

	k = K->n->len;

	/* 1. Length checking : If the length of the signature S is not k octets, output "invalid signature" and stop. */
	if (S->len != k)
	{
		HxLOG_Error("[CICC]---> RSASSA_PSS_VERIFY()---> Error : the length of the signature (%d) is not %d octets !!!\n", S->len, k);
		return 0; // invalid signature
	}

	/* 2. RSA verification (step a ~ c) : */

	/* a. Convert the signature S to an integer signature representative s : s = OS2IP (S) */
	OS2IP(S, &s);

	/* b. Apply the RSAVP1 verification primitive to the RSA public key (n, e) and the signature representative s to produce an integer message representative m : m = RSAVP1 ((n, e), s).
	      If RSAVP1 output "signature representative out of range" output "invalid signature" and stop. */
	if (RSAVP1(K, &s, &m) < 0)
	{
		HxLOG_Error("[CICC]---> RSASSA_PSS_VERIFY()---> Error : signature representative out of range !!!\n");
		return 0; // invalid signature
	}

	/* c. Convert the message representative m to an encoded message EM of length emLen = ceiling function((modBits-1)/8) octets, where modBits is the length in bits of the RSA modulus n : EM = I2OSP (m, emLen).
	      Note that emLen will be one less than k if modBits-1 is divisible by 8 and equal to k otherwise.
	      If I2OSP outputs "integer too large" output "invalid signature" and stop. */
	for (i = 0; i < 8; i++)
	{
		if (K->n->num[0] & (0x80 >> i))
			break;
	}
	modBits = k * 8 - i;
	emLen = ((modBits - 1) & 7) ? k : k - 1;
	if (I2OSP(&m, emLen, &EM) < 0)
	{
		HxLOG_Error("[CICC]---> RSASSA_PSS_VERIFY()---> Error : integer too large !!!\n");
		return 0; // invalid signature
	}

	/* 3. EMSA-PSS verification : Apply the EMSA-PSS verification operation to the message M and the encoded message EM to determine whether they are consistent : Result = EMSA-PSS-VERIFY (M, EM, modBits-1) */
	/* 4. If Result = "consistent" output "valid signature." Otherwise, output "invalid signature." */
	if (EMSA_PSS_VERIFY(M, &EM, modBits-1))
		return 1; // valid signature
	else
		return 0; // invalid signature
}

int RSASSA_PKCS1_V1_5_SIGN(RSA_private_key *K, bignum *M, bignum *S) /* RSASSA-PKCS1-V1_5-SIGN function */
{
	/*
		< Input >
			K : signer's RSA private key
			M : message to be signed, an octet string
		< Output >
			S : signature, an octet string of length k, where k is the length in octets of the RSA modulus n
		< Errors >
			message too long or RSA modulus too short
		< Steps >
			See below.
	*/

	bn_len_type k;
	bignum EM, m, s;

	/* 파라미터 체크 */
	if (K == NULL || K->n == NULL || M == NULL || S == NULL)
	{
		HxLOG_Error("[CICC]---> RSASSA_PKCS1_V1_5_SIGN()---> Error : null params !!!\n");
		return -1;
	}
	if (K->n->len < 1 || K->n->len > MAX_BN_LEN)
	{
		HxLOG_Error("[CICC]---> RSASSA_PKCS1_V1_5_SIGN()---> Error : wrong length K %d !!!\n", K->n->len);
		return -1;
	}
	if (M->len < 1 || M->len > MAX_BN_LEN)
	{
		HxLOG_Error("[CICC]---> RSASSA_PKCS1_V1_5_SIGN()---> Error : wrong length M %d !!!\n", M->len);
		return -1;
	}

	k = K->n->len;

	/* 1. EMSA-PKCS1-v1_5 encoding :
	      Apply the EMSA-PKCS1-v1_5 encoding operation to the message M to produce an encoded message EM of length k octets : EM = EMSA-PKCS1-V1_5-ENCODE (M, k).
	      If the encoding operation outputs "message too long" output "message too long" and stop.
	      If the encoding operation outputs "intended encoded message length too short" output "RSA modulus too short" and stop. */
	if (EMSA_PKCS1_v1_5_ENCODE(M, k, &EM) < 0)
	{
		HxLOG_Error("[CICC]---> RSASSA_PKCS1_V1_5_SIGN()---> Error : EMSA_PKCS1_v1_5_ENCODE !!!\n");
		return -1;
	}

	/* 2. RSA signature (step a ~ c) : */

	/* a. Convert the encoded message EM to an integer message representative m : m = OS2IP (EM) */
	OS2IP(&EM, &m);

	/* b. Apply the RSASP1 signature primitive to the RSA private key K and the message representative m to produce an integer signature representative s : s = RSASP1 (K, m) */
	if (RSASP1(K, &m, &s) < 0)
	{
		HxLOG_Error("[CICC]---> RSASSA_PKCS1_V1_5_SIGN()---> Error : message representative out of range !!!\n");
		return -1;
	}

	/* c. Convert the signature representative s to a signature S of length k octets : S = I2OSP (s, k) */
	/* 3. Output the signature S. */
	if (I2OSP(&s, k, S) < 0)
	{
		HxLOG_Error("[CICC]---> RSASSA_PKCS1_V1_5_SIGN()---> Error : integer too large !!!\n");
		return -1;
	}

	return ERR_OK;
}

int RSASSA_PKCS1_V1_5_VERIFY(RSA_public_key *K, bignum *M, bignum *S) /* RSASSA-PKCS1-V1_5-VERIFY function : return 1 if valid signature, 0 if invalid signature */
{
	/*
		< Input >
			(n, e) : signer's RSA public key
			M      : message whose signature is to be verified, an octet string
			S      : signature to be verified, an octet string of length k, where k is the length in octets of the RSA modulus n
		< Output >
			valid signature or invalid signature
		< Errors >
			message too long or RSA modulus too short
		< Steps >
			See below.
	*/

//	#define CHECK_RSASSA_PKCS1_V1_5_VERIFY

	bn_len_type k;
	bignum s, m, EM1, EM2;

	/* 파라미터 체크 */
	if (K == NULL || K->n == NULL || M == NULL || S == NULL)
	{
		HxLOG_Error("[CICC]---> RSASSA_PKCS1_V1_5_VERIFY()---> Error : null params !!!\n");
		return 0; // invalid signature
	}
	if (K->n->len < 1 || K->n->len > MAX_BN_LEN)
	{
		HxLOG_Error("[CICC]---> RSASSA_PKCS1_V1_5_VERIFY()---> Error : wrong length K %d !!!\n", K->n->len);
		return 0; // invalid signature
	}
	if (M->len < 1 || M->len > MAX_BN_LEN)
	{
		HxLOG_Error("[CICC]---> RSASSA_PKCS1_V1_5_VERIFY()---> Error : wrong length M %d !!!\n", M->len);
		return 0; // invalid signature
	}

	k = K->n->len;

	/* 1. Length checking : If the length of the signature S is not k octets, output "invalid signature" and stop. */
	if (S->len != k)
	{
		HxLOG_Error("[CICC]---> RSASSA_PKCS1_V1_5_VERIFY()---> Error : the length of the signature (%d) is not %d octets !!!\n", S->len, k);
		return 0; // invalid signature
	}

	/* 2. RSA verification (step a ~ c) : */

	/* a. Convert the signature S to an integer signature representative s : s = OS2IP (S) */
	OS2IP(S, &s);

	/* b. Apply the RSAVP1 verification primitive to the RSA public key (n, e) and the signature representative s to produce an integer message representative m : m = RSAVP1 ((n, e), s).
	      If RSAVP1 output "signature representative out of range" output "invalid signature" and stop. */
	if (RSAVP1(K, &s, &m) < 0)
	{
		HxLOG_Error("[CICC]---> RSASSA_PKCS1_V1_5_VERIFY()---> Error : signature representative out of range !!!\n");
		return 0; // invalid signature
	}

	/* c. Convert the message representative m to an encoded message EM of length k octets : EM' = I2OSP (m, k).
	      If I2OSP outputs "integer too large" output "invalid signature" and stop. */
	if (I2OSP(&m, k, &EM1) < 0)
	{
		HxLOG_Error("[CICC]---> RSASSA_PKCS1_V1_5_VERIFY()---> Error : integer too large !!!\n");
		return 0; // invalid signature
	}

	/* 3. EMSA-PKCS1-v1_5 encoding :
	      Apply the EMSA-PKCS1-v1_5 encoding operation to the message M to produce a second encoded message EM' of length k octets : EM' = EMSA-PKCS1-V1_5-ENCODE (M, k).
	      If the encoding operation outputs "message too long" output "message too long" and stop.
	      If the encoding operation outputs "intended encoded message length too short" output "RSA modulus too short" and stop.*/
	if (EMSA_PKCS1_v1_5_ENCODE(M, k, &EM2) < 0)
	{
		HxLOG_Error("[CICC]---> RSASSA_PKCS1_V1_5_VERIFY()---> Error : EMSA_PKCS1_v1_5_ENCODE !!!\n");
		return 0; // invalid signature
	}

	/* 4. Compare the encoded message EM and the second encoded message EM'. If they are the same, output "valid signature"; otherwise, output "invalid signature." */
	if (bn_cmp(&EM1, &EM2) != 0)
	{
		HxLOG_Error("[CICC]---> RSASSA_PKCS1_V1_5_VERIFY()---> Error : EM1 != EM2 !!!\n");

		#ifdef CHECK_RSASSA_PKCS1_V1_5_VERIFY
		{
			int i;
			HxLOG_Print("RSASSA_PKCS1_V1_5_VERIFY : EM1 = ");
			for (i = 0; i < EM1.len; i++)
			{
				if ((i & 15) == 0)
					HxLOG_Print("\n");
				HxLOG_Print("%02x ", EM1.num[i]);
			}
			HxLOG_Print("\n");
			HxLOG_Print("RSASSA_PKCS1_V1_5_VERIFY : EM2 = ");
			for (i = 0; i < EM2.len; i++)
			{
				if ((i & 15) == 0)
					HxLOG_Print("\n");
				HxLOG_Print("%02x ", EM2.num[i]);
			}
			HxLOG_Print("\n");
		}
		#endif

		return 0; // invalid signature
	}

	return 1; // valid signature
}

#ifdef RSA_TEST
#ifdef INCLUDE_10XX_BITS_TEST
static void RSA_Test1(void)
{
	bignum n1 = {128, {
		0xA2, 0xBA, 0x40, 0xEE, 0x07, 0xE3, 0xB2, 0xBD, 0x2F, 0x02, 0xCE, 0x22, 0x7F, 0x36, 0xA1, 0x95,
		0x02, 0x44, 0x86, 0xE4, 0x9C, 0x19, 0xCB, 0x41, 0xBB, 0xBD, 0xFB, 0xBA, 0x98, 0xB2, 0x2B, 0x0E,
		0x57, 0x7C, 0x2E, 0xEA, 0xFF, 0xA2, 0x0D, 0x88, 0x3A, 0x76, 0xE6, 0x5E, 0x39, 0x4C, 0x69, 0xD4,
		0xB3, 0xC0, 0x5A, 0x1E, 0x8F, 0xAD, 0xDA, 0x27, 0xED, 0xB2, 0xA4, 0x2B, 0xC0, 0x00, 0xFE, 0x88,
		0x8B, 0x9B, 0x32, 0xC2, 0x2D, 0x15, 0xAD, 0xD0, 0xCD, 0x76, 0xB3, 0xE7, 0x93, 0x6E, 0x19, 0x95,
		0x5B, 0x22, 0x0D, 0xD1, 0x7D, 0x4E, 0xA9, 0x04, 0xB1, 0xEC, 0x10, 0x2B, 0x2E, 0x4D, 0xE7, 0x75,
		0x12, 0x22, 0xAA, 0x99, 0x15, 0x10, 0x24, 0xC7, 0xCB, 0x41, 0xCC, 0x5E, 0xA2, 0x1D, 0x00, 0xEE,
		0xB4, 0x1F, 0x7C, 0x80, 0x08, 0x34, 0xD2, 0xC6, 0xE0, 0x6B, 0xCE, 0x3B, 0xCE, 0x7E, 0xA9, 0xA5}
	};
	bignum n2 = {128, {
		0xA5, 0x6E, 0x4A, 0x0E, 0x70, 0x10, 0x17, 0x58, 0x9A, 0x51, 0x87, 0xDC, 0x7E, 0xA8, 0x41, 0xD1,
		0x56, 0xF2, 0xEC, 0x0E, 0x36, 0xAD, 0x52, 0xA4, 0x4D, 0xFE, 0xB1, 0xE6, 0x1F, 0x7A, 0xD9, 0x91,
		0xD8, 0xC5, 0x10, 0x56, 0xFF, 0xED, 0xB1, 0x62, 0xB4, 0xC0, 0xF2, 0x83, 0xA1, 0x2A, 0x88, 0xA3,
		0x94, 0xDF, 0xF5, 0x26, 0xAB, 0x72, 0x91, 0xCB, 0xB3, 0x07, 0xCE, 0xAB, 0xFC, 0xE0, 0xB1, 0xDF,
		0xD5, 0xCD, 0x95, 0x08, 0x09, 0x6D, 0x5B, 0x2B, 0x8B, 0x6D, 0xF5, 0xD6, 0x71, 0xEF, 0x63, 0x77,
		0xC0, 0x92, 0x1C, 0xB2, 0x3C, 0x27, 0x0A, 0x70, 0xE2, 0x59, 0x8E, 0x6F, 0xF8, 0x9D, 0x19, 0xF1,
		0x05, 0xAC, 0xC2, 0xD3, 0xF0, 0xCB, 0x35, 0xF2, 0x92, 0x80, 0xE1, 0x38, 0x6B, 0x6F, 0x64, 0xC4,
		0xEF, 0x22, 0xE1, 0xE1, 0xF2, 0x0D, 0x0C, 0xE8, 0xCF, 0xFB, 0x22, 0x49, 0xBD, 0x9A, 0x21, 0x37}
	};
	bignum n3 = {129, {
		0x49, 0x53, 0x70, 0xA1, 0xFB, 0x18, 0x54, 0x3C, 0x16, 0xD3, 0x63, 0x1E, 0x31, 0x63, 0x25, 0x5D,
		0xF6, 0x2B, 0xE6, 0xEE, 0xE8, 0x90, 0xD5, 0xF2, 0x55, 0x09, 0xE4, 0xF7, 0x78, 0xA8, 0xEA, 0x6F,
		0xBB, 0xBC, 0xDF, 0x85, 0xDF, 0xF6, 0x4E, 0x0D, 0x97, 0x20, 0x03, 0xAB, 0x36, 0x81, 0xFB, 0xBA,
		0x6D, 0xD4, 0x1F, 0xD5, 0x41, 0x82, 0x9B, 0x2E, 0x58, 0x2D, 0xE9, 0xF2, 0xA4, 0xA4, 0xE0, 0xA2,
		0xD0, 0x90, 0x0B, 0xEF, 0x47, 0x53, 0xDB, 0x3C, 0xEE, 0x0E, 0xE0, 0x6C, 0x7D, 0xFA, 0xE8, 0xB1,
		0xD5, 0x3B, 0x59, 0x53, 0x21, 0x8F, 0x9C, 0xCE, 0xEA, 0x69, 0x5B, 0x08, 0x66, 0x8E, 0xDE, 0xAA,
		0xDC, 0xED, 0x94, 0x63, 0xB1, 0xD7, 0x90, 0xD5, 0xEB, 0xF2, 0x7E, 0x91, 0x15, 0xB4, 0x6C, 0xAD,
		0x4D, 0x9A, 0x2B, 0x8E, 0xFA, 0xB0, 0x56, 0x1B, 0x08, 0x10, 0x34, 0x47, 0x39, 0xAD, 0xA0, 0x73,
		0x3F}
	};
#ifdef 	INCLUDE_1ST_FORM_TEST
	bignum d2 = {128, {
		0x33, 0xA5, 0x04, 0x2A, 0x90, 0xB2, 0x7D, 0x4F, 0x54, 0x51, 0xCA, 0x9B, 0xBB, 0xD0, 0xB4, 0x47,
		0x71, 0xA1, 0x01, 0xAF, 0x88, 0x43, 0x40, 0xAE, 0xF9, 0x88, 0x5F, 0x2A, 0x4B, 0xBE, 0x92, 0xE8,
		0x94, 0xA7, 0x24, 0xAC, 0x3C, 0x56, 0x8C, 0x8F, 0x97, 0x85, 0x3A, 0xD0, 0x7C, 0x02, 0x66, 0xC8,
		0xC6, 0xA3, 0xCA, 0x09, 0x29, 0xF1, 0xE8, 0xF1, 0x12, 0x31, 0x88, 0x44, 0x29, 0xFC, 0x4D, 0x9A,
		0xE5, 0x5F, 0xEE, 0x89, 0x6A, 0x10, 0xCE, 0x70, 0x7C, 0x3E, 0xD7, 0xE7, 0x34, 0xE4, 0x47, 0x27,
		0xA3, 0x95, 0x74, 0x50, 0x1A, 0x53, 0x26, 0x83, 0x10, 0x9C, 0x2A, 0xBA, 0xCA, 0xBA, 0x28, 0x3C,
		0x31, 0xB4, 0xBD, 0x2F, 0x53, 0xC3, 0xEE, 0x37, 0xE3, 0x52, 0xCE, 0xE3, 0x4F, 0x9E, 0x50, 0x3B,
		0xD8, 0x0C, 0x06, 0x22, 0xAD, 0x79, 0xC6, 0xDC, 0xEE, 0x88, 0x35, 0x47, 0xC6, 0xA3, 0xB3, 0x25}
	};
	bignum d3 = {128, {
		0x6C, 0x66, 0xFF, 0xE9, 0x89, 0x80, 0xC3, 0x8F, 0xCD, 0xEA, 0xB5, 0x15, 0x98, 0x98, 0x83, 0x61,
		0x65, 0xF4, 0xB4, 0xB8, 0x17, 0xC4, 0xF6, 0xA8, 0xD4, 0x86, 0xEE, 0x4E, 0xA9, 0x13, 0x0F, 0xE9,
		0xB9, 0x09, 0x2B, 0xD1, 0x36, 0xD1, 0x84, 0xF9, 0x5F, 0x50, 0x4A, 0x60, 0x7E, 0xAC, 0x56, 0x58,
		0x46, 0xD2, 0xFD, 0xD6, 0x59, 0x7A, 0x89, 0x67, 0xC7, 0x39, 0x6E, 0xF9, 0x5A, 0x6E, 0xEE, 0xBB,
		0x45, 0x78, 0xA6, 0x43, 0x96, 0x6D, 0xCA, 0x4D, 0x8E, 0xE3, 0xDE, 0x84, 0x2D, 0xE6, 0x32, 0x79,
		0xC6, 0x18, 0x15, 0x9C, 0x1A, 0xB5, 0x4A, 0x89, 0x43, 0x7B, 0x6A, 0x61, 0x20, 0xE4, 0x93, 0x0A,
		0xFB, 0x52, 0xA4, 0xBA, 0x6C, 0xED, 0x8A, 0x49, 0x47, 0xAC, 0x64, 0xB3, 0x0A, 0x34, 0x97, 0xCB,
		0xE7, 0x01, 0xC2, 0xD6, 0x26, 0x6D, 0x51, 0x72, 0x19, 0xAD, 0x0E, 0xC6, 0xD3, 0x47, 0xDB, 0xE9}
	};
#endif
	bignum p1 = {64, {
		0xD1, 0x7F, 0x65, 0x5B, 0xF2, 0x7C, 0x8B, 0x16, 0xD3, 0x54, 0x62, 0xC9, 0x05, 0xCC, 0x04, 0xA2,
		0x6F, 0x37, 0xE2, 0xA6, 0x7F, 0xA9, 0xC0, 0xCE, 0x0D, 0xCE, 0xD4, 0x72, 0x39, 0x4A, 0x0D, 0xF7,
		0x43, 0xFE, 0x7F, 0x92, 0x9E, 0x37, 0x8E, 0xFD, 0xB3, 0x68, 0xED, 0xDF, 0xF4, 0x53, 0xCF, 0x00,
		0x7A, 0xF6, 0xD9, 0x48, 0xE0, 0xAD, 0xE7, 0x57, 0x37, 0x1F, 0x8A, 0x71, 0x1E, 0x27, 0x8F, 0x6B}
	};
	bignum p2 = {64, {
		0xE7, 0xE8, 0x94, 0x27, 0x20, 0xA8, 0x77, 0x51, 0x72, 0x73, 0xA3, 0x56, 0x05, 0x3E, 0xA2, 0xA1,
		0xBC, 0x0C, 0x94, 0xAA, 0x72, 0xD5, 0x5C, 0x6E, 0x86, 0x29, 0x6B, 0x2D, 0xFC, 0x96, 0x79, 0x48,
		0xC0, 0xA7, 0x2C, 0xBC, 0xCC, 0xA7, 0xEA, 0xCB, 0x35, 0x70, 0x6E, 0x09, 0xA1, 0xDF, 0x55, 0xA1,
		0x53, 0x5B, 0xD9, 0xB3, 0xCC, 0x34, 0x16, 0x0B, 0x3B, 0x6D, 0xCD, 0x3E, 0xDA, 0x8E, 0x64, 0x43}
	};
	bignum p3 = {65, {
		0x08, 0xDA, 0xD7, 0xF1, 0x13, 0x63, 0xFA, 0xA6, 0x23, 0xD5, 0xD6, 0xD5, 0xE8, 0xA3, 0x19, 0x32,
		0x8D, 0x82, 0x19, 0x0D, 0x71, 0x27, 0xD2, 0x84, 0x6C, 0x43, 0x9B, 0x0A, 0xB7, 0x26, 0x19, 0xB0,
		0xA4, 0x3A, 0x95, 0x32, 0x0E, 0x4E, 0xC3, 0x4F, 0xC3, 0xA9, 0xCE, 0xA8, 0x76, 0x42, 0x23, 0x05,
		0xBD, 0x76, 0xC5, 0xBA, 0x7B, 0xE9, 0xE2, 0xF4, 0x10, 0xC8, 0x06, 0x06, 0x45, 0xA1, 0xD2, 0x9E,
		0xDB}
	};
	bignum q1 = {64, {
		0xC6, 0xD9, 0x2B, 0x6F, 0xEE, 0x74, 0x14, 0xD1, 0x35, 0x8C, 0xE1, 0x54, 0x6F, 0xB6, 0x29, 0x87,
		0x53, 0x0B, 0x90, 0xBD, 0x15, 0xE0, 0xF1, 0x49, 0x63, 0xA5, 0xE2, 0x63, 0x5A, 0xDB, 0x69, 0x34,
		0x7E, 0xC0, 0xC0, 0x1B, 0x2A, 0xB1, 0x76, 0x3F, 0xD8, 0xAC, 0x1A, 0x59, 0x2F, 0xB2, 0x27, 0x57,
		0x46, 0x3A, 0x98, 0x24, 0x25, 0xBB, 0x97, 0xA3, 0xA4, 0x37, 0xC5, 0xBF, 0x86, 0xD0, 0x3F, 0x2F}
	};
	bignum q2 = {64, {
		0xB6, 0x9D, 0xCA, 0x1C, 0xF7, 0xD4, 0xD7, 0xEC, 0x81, 0xE7, 0x5B, 0x90, 0xFC, 0xCA, 0x87, 0x4A,
		0xBC, 0xDE, 0x12, 0x3F, 0xD2, 0x70, 0x01, 0x80, 0xAA, 0x90, 0x47, 0x9B, 0x6E, 0x48, 0xDE, 0x8D,
		0x67, 0xED, 0x24, 0xF9, 0xF1, 0x9D, 0x85, 0xBA, 0x27, 0x58, 0x74, 0xF5, 0x42, 0xCD, 0x20, 0xDC,
		0x72, 0x3E, 0x69, 0x63, 0x36, 0x4A, 0x1F, 0x94, 0x25, 0x45, 0x2B, 0x26, 0x9A, 0x67, 0x99, 0xFD}
	};
	bignum q3 = {65, {
		0x08, 0x47, 0xE7, 0x32, 0x37, 0x6F, 0xC7, 0x90, 0x0F, 0x89, 0x8E, 0xA8, 0x2E, 0xB2, 0xB0, 0xFC,
		0x41, 0x85, 0x65, 0xFD, 0xAE, 0x62, 0xF7, 0xD9, 0xEC, 0x4C, 0xE2, 0x21, 0x7B, 0x97, 0x99, 0x0D,
		0xD2, 0x72, 0xDB, 0x15, 0x7F, 0x99, 0xF6, 0x3C, 0x0D, 0xCB, 0xB9, 0xFB, 0xAC, 0xDB, 0xD4, 0xC4,
		0xDA, 0xDB, 0x6D, 0xF6, 0x77, 0x56, 0x35, 0x8C, 0xA4, 0x17, 0x48, 0x25, 0xB4, 0x8F, 0x49, 0x70,
		0x6D}
	};
	bignum dP1 = {64, {
		0x9D, 0x0D, 0xBF, 0x83, 0xE5, 0xCE, 0x9E, 0x4B, 0x17, 0x54, 0xDC, 0xD5, 0xCD, 0x05, 0xBC, 0xB7,
		0xB5, 0x5F, 0x15, 0x08, 0x33, 0x0E, 0xA4, 0x9F, 0x14, 0xD4, 0xE8, 0x89, 0x55, 0x0F, 0x82, 0x56,
		0xCB, 0x5F, 0x80, 0x6D, 0xFF, 0x34, 0xB1, 0x7A, 0xDA, 0x44, 0x20, 0x88, 0x53, 0x57, 0x7D, 0x08,
		0xE4, 0x26, 0x28, 0x90, 0xAC, 0xF7, 0x52, 0x46, 0x1C, 0xEA, 0x05, 0x54, 0x76, 0x01, 0xBC, 0x4F}
	};
	bignum dP2 = {64, {
		0x28, 0xFA, 0x13, 0x93, 0x86, 0x55, 0xBE, 0x1F, 0x8A, 0x15, 0x9C, 0xBA, 0xCA, 0x5A, 0x72, 0xEA,
		0x19, 0x0C, 0x30, 0x08, 0x9E, 0x19, 0xCD, 0x27, 0x4A, 0x55, 0x6F, 0x36, 0xC4, 0xF6, 0xE1, 0x9F,
		0x55, 0x4B, 0x34, 0xC0, 0x77, 0x79, 0x04, 0x27, 0xBB, 0xDD, 0x8D, 0xD3, 0xED, 0xE2, 0x44, 0x83,
		0x28, 0xF3, 0x85, 0xD8, 0x1B, 0x30, 0xE8, 0xE4, 0x3B, 0x2F, 0xFF, 0xA0, 0x27, 0x86, 0x19, 0x79}
	};
	bignum dP3 = {65, {
		0x05, 0xC2, 0xA8, 0x3C, 0x12, 0x4B, 0x36, 0x21, 0xA2, 0xAA, 0x57, 0xEA, 0x2C, 0x3E, 0xFE, 0x03,
		0x5E, 0xFF, 0x45, 0x60, 0xF3, 0x3D, 0xDE, 0xBB, 0x7A, 0xDA, 0xB8, 0x1F, 0xCE, 0x69, 0xA0, 0xC8,
		0xC2, 0xED, 0xC1, 0x65, 0x20, 0xDD, 0xA8, 0x3D, 0x59, 0xA2, 0x3B, 0xE8, 0x67, 0x96, 0x3A, 0xC6,
		0x5F, 0x2C, 0xC7, 0x10, 0xBB, 0xCF, 0xB9, 0x6E, 0xE1, 0x03, 0xDE, 0xB7, 0x71, 0xD1, 0x05, 0xFD,
		0x85}
	};
	bignum dQ1 = {64, {
		0x12, 0x91, 0xA5, 0x24, 0xC6, 0xB7, 0xC0, 0x59, 0xE9, 0x0E, 0x46, 0xDC, 0x83, 0xB2, 0x17, 0x1E,
		0xB3, 0xFA, 0x98, 0x81, 0x8F, 0xD1, 0x79, 0xB6, 0xC8, 0xBF, 0x6C, 0xEC, 0xAA, 0x47, 0x63, 0x03,
		0xAB, 0xF2, 0x83, 0xFE, 0x05, 0x76, 0x9C, 0xFC, 0x49, 0x57, 0x88, 0xFE, 0x5B, 0x1D, 0xDF, 0xDE,
		0x9E, 0x88, 0x4A, 0x3C, 0xD5, 0xE9, 0x36, 0xB7, 0xE9, 0x55, 0xEB, 0xF9, 0x7E, 0xB5, 0x63, 0xB1}
	};
	bignum dQ2 = {64, {
		0x1A, 0x8B, 0x38, 0xF3, 0x98, 0xFA, 0x71, 0x20, 0x49, 0x89, 0x8D, 0x7F, 0xB7, 0x9E, 0xE0, 0xA7,
		0x76, 0x68, 0x79, 0x12, 0x99, 0xCD, 0xFA, 0x09, 0xEF, 0xC0, 0xE5, 0x07, 0xAC, 0xB2, 0x1E, 0xD7,
		0x43, 0x01, 0xEF, 0x5B, 0xFD, 0x48, 0xBE, 0x45, 0x5E, 0xAE, 0xB6, 0xE1, 0x67, 0x82, 0x55, 0x82,
		0x75, 0x80, 0xA8, 0xE4, 0xE8, 0xE1, 0x41, 0x51, 0xD1, 0x51, 0x0A, 0x82, 0xA3, 0xF2, 0xE7, 0x29}
	};
	bignum dQ3 = {65, {
		0x04, 0xCA, 0xE8, 0xAA, 0x0D, 0x9F, 0xAA, 0x16, 0x5C, 0x87, 0xB6, 0x82, 0xEC, 0x14, 0x0B, 0x8E,
		0xD3, 0xB5, 0x0B, 0x24, 0x59, 0x4B, 0x7A, 0x3B, 0x2C, 0x22, 0x0B, 0x36, 0x69, 0xBB, 0x81, 0x9F,
		0x98, 0x4F, 0x55, 0x31, 0x0A, 0x1A, 0xE7, 0x82, 0x36, 0x51, 0xD4, 0xA0, 0x2E, 0x99, 0x44, 0x79,
		0x72, 0x59, 0x51, 0x39, 0x36, 0x34, 0x34, 0xE5, 0xE3, 0x0A, 0x7E, 0x7D, 0x24, 0x15, 0x51, 0xE1,
		0xB9}
	};
	bignum qInv1 = {64, {
		0xA6, 0x3F, 0x1D, 0xA3, 0x8B, 0x95, 0x0C, 0x9A, 0xD1, 0xC6, 0x7C, 0xE0, 0xD6, 0x77, 0xEC, 0x29,
		0x14, 0xCD, 0x7D, 0x40, 0x06, 0x2D, 0xF4, 0x2A, 0x67, 0xEB, 0x19, 0x8A, 0x17, 0x6F, 0x97, 0x42,
		0xAA, 0xC7, 0xC5, 0xFE, 0xA1, 0x4F, 0x22, 0x97, 0x66, 0x2B, 0x84, 0x81, 0x2C, 0x4D, 0xEF, 0xC4,
		0x9A, 0x80, 0x25, 0xAB, 0x43, 0x82, 0x28, 0x6B, 0xE4, 0xC0, 0x37, 0x88, 0xDD, 0x01, 0xD6, 0x9F}
	};
	bignum qInv2 = {64, {
		0x27, 0x15, 0x6A, 0xBA, 0x41, 0x26, 0xD2, 0x4A, 0x81, 0xF3, 0xA5, 0x28, 0xCB, 0xFB, 0x27, 0xF5,
		0x68, 0x86, 0xF8, 0x40, 0xA9, 0xF6, 0xE8, 0x6E, 0x17, 0xA4, 0x4B, 0x94, 0xFE, 0x93, 0x19, 0x58,
		0x4B, 0x8E, 0x22, 0xFD, 0xDE, 0x1E, 0x5A, 0x2E, 0x3B, 0xD8, 0xAA, 0x5B, 0xA8, 0xD8, 0x58, 0x41,
		0x94, 0xEB, 0x21, 0x90, 0xAC, 0xF8, 0x32, 0xB8, 0x47, 0xF1, 0x3A, 0x3D, 0x24, 0xA7, 0x9F, 0x4D}
	};
	bignum qInv3 = {65, {
		0x07, 0xD3, 0xE4, 0x7B, 0xF6, 0x86, 0x60, 0x0B, 0x11, 0xAC, 0x28, 0x3C, 0xE8, 0x8D, 0xBB, 0x3F,
		0x60, 0x51, 0xE8, 0xEF, 0xD0, 0x46, 0x80, 0xE4, 0x4C, 0x17, 0x1E, 0xF5, 0x31, 0xB8, 0x0B, 0x2B,
		0x7C, 0x39, 0xFC, 0x76, 0x63, 0x20, 0xE2, 0xCF, 0x15, 0xD8, 0xD9, 0x98, 0x20, 0xE9, 0x6F, 0xF3,
		0x0D, 0xC6, 0x96, 0x91, 0x83, 0x9C, 0x4B, 0x40, 0xD7, 0xB0, 0x6E, 0x45, 0x30, 0x7D, 0xC9, 0x1F,
		0x3F}
	};
	bignum M1 = {114, {
		0x85, 0x9E, 0xEF, 0x2F, 0xD7, 0x8A, 0xCA, 0x00, 0x30, 0x8B, 0xDC, 0x47, 0x11, 0x93, 0xBF, 0x55,
		0xBF, 0x9D, 0x78, 0xDB, 0x8F, 0x8A, 0x67, 0x2B, 0x48, 0x46, 0x34, 0xF3, 0xC9, 0xC2, 0x6E, 0x64,
		0x78, 0xAE, 0x10, 0x26, 0x0F, 0xE0, 0xDD, 0x8C, 0x08, 0x2E, 0x53, 0xA5, 0x29, 0x3A, 0xF2, 0x17,
		0x3C, 0xD5, 0x0C, 0x6D, 0x5D, 0x35, 0x4F, 0xEB, 0xF7, 0x8B, 0x26, 0x02, 0x1C, 0x25, 0xC0, 0x27,
		0x12, 0xE7, 0x8C, 0xD4, 0x69, 0x4C, 0x9F, 0x46, 0x97, 0x77, 0xE4, 0x51, 0xE7, 0xF8, 0xE9, 0xE0,
		0x4C, 0xD3, 0x73, 0x9C, 0x6B, 0xBF, 0xED, 0xAE, 0x48, 0x7F, 0xB5, 0x56, 0x44, 0xE9, 0xCA, 0x74,
		0xFF, 0x77, 0xA5, 0x3C, 0xB7, 0x29, 0x80, 0x2F, 0x6E, 0xD4, 0xA5, 0xFF, 0xA8, 0xBA, 0x15, 0x98,
		0x90, 0xFC}
	};
	bignum M2 = {217, {
		0xCD, 0xC8, 0x7D, 0xA2, 0x23, 0xD7, 0x86, 0xDF, 0x3B, 0x45, 0xE0, 0xBB, 0xBC, 0x72, 0x13, 0x26,
		0xD1, 0xEE, 0x2A, 0xF8, 0x06, 0xCC, 0x31, 0x54, 0x75, 0xCC, 0x6F, 0x0D, 0x9C, 0x66, 0xE1, 0xB6,
		0x23, 0x71, 0xD4, 0x5C, 0xE2, 0x39, 0x2E, 0x1A, 0xC9, 0x28, 0x44, 0xC3, 0x10, 0x10, 0x2F, 0x15,
		0x6A, 0x0D, 0x8D, 0x52, 0xC1, 0xF4, 0xC4, 0x0B, 0xA3, 0xAA, 0x65, 0x09, 0x57, 0x86, 0xCB, 0x76,
		0x97, 0x57, 0xA6, 0x56, 0x3B, 0xA9, 0x58, 0xFE, 0xD0, 0xBC, 0xC9, 0x84, 0xE8, 0xB5, 0x17, 0xA3,
		0xD5, 0xF5, 0x15, 0xB2, 0x3B, 0x8A, 0x41, 0xE7, 0x4A, 0xA8, 0x67, 0x69, 0x3F, 0x90, 0xDF, 0xB0,
		0x61, 0xA6, 0xE8, 0x6D, 0xFA, 0xAE, 0xE6, 0x44, 0x72, 0xC0, 0x0E, 0x5F, 0x20, 0x94, 0x57, 0x29,
		0xCB, 0xEB, 0xE7, 0x7F, 0x06, 0xCE, 0x78, 0xE0, 0x8F, 0x40, 0x98, 0xFB, 0xA4, 0x1F, 0x9D, 0x61,
		0x93, 0xC0, 0x31, 0x7E, 0x8B, 0x60, 0xD4, 0xB6, 0x08, 0x4A, 0xCB, 0x42, 0xD2, 0x9E, 0x38, 0x08,
		0xA3, 0xBC, 0x37, 0x2D, 0x85, 0xE3, 0x31, 0x17, 0x0F, 0xCB, 0xF7, 0xCC, 0x72, 0xD0, 0xB7, 0x1C,
		0x29, 0x66, 0x48, 0xB3, 0xA4, 0xD1, 0x0F, 0x41, 0x62, 0x95, 0xD0, 0x80, 0x7A, 0xA6, 0x25, 0xCA,
		0xB2, 0x74, 0x4F, 0xD9, 0xEA, 0x8F, 0xD2, 0x23, 0xC4, 0x25, 0x37, 0x02, 0x98, 0x28, 0xBD, 0x16,
		0xBE, 0x02, 0x54, 0x6F, 0x13, 0x0F, 0xD2, 0xE3, 0x3B, 0x93, 0x6D, 0x26, 0x76, 0xE0, 0x8A, 0xED,
		0x1B, 0x73, 0x31, 0x8B, 0x75, 0x0A, 0x01, 0x67, 0xD0}
	};
	bignum M3 = {172, {
		0x81, 0x33, 0x2F, 0x4B, 0xE6, 0x29, 0x48, 0x41, 0x5E, 0xA1, 0xD8, 0x99, 0x79, 0x2E, 0xEA, 0xCF,
		0x6C, 0x6E, 0x1D, 0xB1, 0xDA, 0x8B, 0xE1, 0x3B, 0x5C, 0xEA, 0x41, 0xDB, 0x2F, 0xED, 0x46, 0x70,
		0x92, 0xE1, 0xFF, 0x39, 0x89, 0x14, 0xC7, 0x14, 0x25, 0x97, 0x75, 0xF5, 0x95, 0xF8, 0x54, 0x7F,
		0x73, 0x56, 0x92, 0xA5, 0x75, 0xE6, 0x92, 0x3A, 0xF7, 0x8F, 0x22, 0xC6, 0x99, 0x7D, 0xDB, 0x90,
		0xFB, 0x6F, 0x72, 0xD7, 0xBB, 0x0D, 0xD5, 0x74, 0x4A, 0x31, 0xDE, 0xCD, 0x3D, 0xC3, 0x68, 0x58,
		0x49, 0x83, 0x6E, 0xD3, 0x4A, 0xEC, 0x59, 0x63, 0x04, 0xAD, 0x11, 0x84, 0x3C, 0x4F, 0x88, 0x48,
		0x9F, 0x20, 0x97, 0x35, 0xF5, 0xFB, 0x7F, 0xDA, 0xF7, 0xCE, 0xC8, 0xAD, 0xDC, 0x58, 0x18, 0x16,
		0x8F, 0x88, 0x0A, 0xCB, 0xF4, 0x90, 0xD5, 0x10, 0x05, 0xB7, 0xA8, 0xE8, 0x4E, 0x43, 0xE5, 0x42,
		0x87, 0x97, 0x75, 0x71, 0xDD, 0x99, 0xEE, 0xA4, 0xB1, 0x61, 0xEB, 0x2D, 0xF1, 0xF5, 0x10, 0x8F,
		0x12, 0xA4, 0x14, 0x2A, 0x83, 0x32, 0x2E, 0xDB, 0x05, 0xA7, 0x54, 0x87, 0xA3, 0x43, 0x5C, 0x9A,
		0x78, 0xCE, 0x53, 0xED, 0x93, 0xBC, 0x55, 0x08, 0x57, 0xD7, 0xA9, 0xFB}
	};
	bignum salt1 = {20, {
		0xE3, 0xB5, 0xD5, 0xD0, 0x02, 0xC1, 0xBC, 0xE5, 0x0C, 0x2B, 0x65, 0xEF, 0x88, 0xA1, 0x88, 0xD8,
		0x3B, 0xCE, 0x7E, 0x61}
	};
	bignum salt2 = {20, {
		0xDE, 0xE9, 0x59, 0xC7, 0xE0, 0x64, 0x11, 0x36, 0x14, 0x20, 0xFF, 0x80, 0x18, 0x5E, 0xD5, 0x7F,
		0x3E, 0x67, 0x76, 0xAF}
	};
	bignum salt3 = {20, {
		0x1D, 0x65, 0x49, 0x1D, 0x79, 0xC8, 0x64, 0xB3, 0x73, 0x00, 0x9B, 0xE6, 0xF6, 0xF2, 0x46, 0x7B,
		0xAC, 0x4C, 0x78, 0xFA}
	};
	bignum S1 = {128, {
		0x8D, 0xAA, 0x62, 0x7D, 0x3D, 0xE7, 0x59, 0x5D, 0x63, 0x05, 0x6C, 0x7E, 0xC6, 0x59, 0xE5, 0x44,
		0x06, 0xF1, 0x06, 0x10, 0x12, 0x8B, 0xAA, 0xE8, 0x21, 0xC8, 0xB2, 0xA0, 0xF3, 0x93, 0x6D, 0x54,
		0xDC, 0x3B, 0xDC, 0xE4, 0x66, 0x89, 0xF6, 0xB7, 0x95, 0x1B, 0xB1, 0x8E, 0x84, 0x05, 0x42, 0x76,
		0x97, 0x18, 0xD5, 0x71, 0x5D, 0x21, 0x0D, 0x85, 0xEF, 0xBB, 0x59, 0x61, 0x92, 0x03, 0x2C, 0x42,
		0xBE, 0x4C, 0x29, 0x97, 0x2C, 0x85, 0x62, 0x75, 0xEB, 0x6D, 0x5A, 0x45, 0xF0, 0x5F, 0x51, 0x87,
		0x6F, 0xC6, 0x74, 0x3D, 0xED, 0xDD, 0x28, 0xCA, 0xEC, 0x9B, 0xB3, 0x0E, 0xA9, 0x9E, 0x02, 0xC3,
		0x48, 0x82, 0x69, 0x60, 0x4F, 0xE4, 0x97, 0xF7, 0x4C, 0xCD, 0x7C, 0x7F, 0xCA, 0x16, 0x71, 0x89,
		0x71, 0x23, 0xCB, 0xD3, 0x0D, 0xEF, 0x5D, 0x54, 0xA2, 0xB5, 0x53, 0x6A, 0xD9, 0x0A, 0x74, 0x7E}
	};
	bignum S2 = {128, {
		0x90, 0x74, 0x30, 0x8F, 0xB5, 0x98, 0xE9, 0x70, 0x1B, 0x22, 0x94, 0x38, 0x8E, 0x52, 0xF9, 0x71,
		0xFA, 0xAC, 0x2B, 0x60, 0xA5, 0x14, 0x5A, 0xF1, 0x85, 0xDF, 0x52, 0x87, 0xB5, 0xED, 0x28, 0x87,
		0xE5, 0x7C, 0xE7, 0xFD, 0x44, 0xDC, 0x86, 0x34, 0xE4, 0x07, 0xC8, 0xE0, 0xE4, 0x36, 0x0B, 0xC2,
		0x26, 0xF3, 0xEC, 0x22, 0x7F, 0x9D, 0x9E, 0x54, 0x63, 0x8E, 0x8D, 0x31, 0xF5, 0x05, 0x12, 0x15,
		0xDF, 0x6E, 0xBB, 0x9C, 0x2F, 0x95, 0x79, 0xAA, 0x77, 0x59, 0x8A, 0x38, 0xF9, 0x14, 0xB5, 0xB9,
		0xC1, 0xBD, 0x83, 0xC4, 0xE2, 0xF9, 0xF3, 0x82, 0xA0, 0xD0, 0xAA, 0x35, 0x42, 0xFF, 0xEE, 0x65,
		0x98, 0x4A, 0x60, 0x1B, 0xC6, 0x9E, 0xB2, 0x8D, 0xEB, 0x27, 0xDC, 0xA1, 0x2C, 0x82, 0xC2, 0xD4,
		0xC3, 0xF6, 0x6C, 0xD5, 0x00, 0xF1, 0xFF, 0x2B, 0x99, 0x4D, 0x8A, 0x4E, 0x30, 0xCB, 0xB3, 0x3C}
	};
	bignum S3 = {129, {
		0x02, 0x62, 0xAC, 0x25, 0x4B, 0xFA, 0x77, 0xF3, 0xC1, 0xAC, 0xA2, 0x2C, 0x51, 0x79, 0xF8, 0xF0,
		0x40, 0x42, 0x2B, 0x3C, 0x5B, 0xAF, 0xD4, 0x0A, 0x8F, 0x21, 0xCF, 0x0F, 0xA5, 0xA6, 0x67, 0xCC,
		0xD5, 0x99, 0x3D, 0x42, 0xDB, 0xAF, 0xB4, 0x09, 0xC5, 0x20, 0xE2, 0x5F, 0xCE, 0x2B, 0x1E, 0xE1,
		0xE7, 0x16, 0x57, 0x7F, 0x1E, 0xFA, 0x17, 0xF3, 0xDA, 0x28, 0x05, 0x2F, 0x40, 0xF0, 0x41, 0x9B,
		0x23, 0x10, 0x6D, 0x78, 0x45, 0xAA, 0xF0, 0x11, 0x25, 0xB6, 0x98, 0xE7, 0xA4, 0xDF, 0xE9, 0x2D,
		0x39, 0x67, 0xBB, 0x00, 0xC4, 0xD0, 0xD3, 0x5B, 0xA3, 0x55, 0x2A, 0xB9, 0xA8, 0xB3, 0xEE, 0xF0,
		0x7C, 0x7F, 0xEC, 0xDB, 0xC5, 0x42, 0x4A, 0xC4, 0xDB, 0x1E, 0x20, 0xCB, 0x37, 0xD0, 0xB2, 0x74,
		0x47, 0x69, 0x94, 0x0E, 0xA9, 0x07, 0xE1, 0x7F, 0xBB, 0xCA, 0x67, 0x3B, 0x20, 0x52, 0x23, 0x80,
		0xC5}
	};

	RSA_private_key PrivateKey1 = {&n1, NULL, &p1, &q1, &dP1, &dQ1, &qInv1};

#ifdef 	INCLUDE_1ST_FORM_TEST
	RSA_private_key PrivateKey2_1stForm = {&n2, &d2, NULL, NULL, NULL, NULL, NULL};
	RSA_private_key PrivateKey3_1stForm = {&n3, &d3, NULL, NULL, NULL, NULL, NULL};
#endif

	RSA_private_key PrivateKey2_2ndForm = {&n2, NULL, &p2, &q2, &dP2, &dQ2, &qInv2};
	RSA_private_key PrivateKey3_2ndForm = {&n3, NULL, &p3, &q3, &dP3, &dQ3, &qInv3};

	RSA_public_key PublicKey1 = {&n1, &bn_e};
	RSA_public_key PublicKey2 = {&n2, &bn_e};
	RSA_public_key PublicKey3 = {&n3, &bn_e};

	bignum Sig;
	bn_len_type i;

	// test 1 : 1024 bits RSA Key Pair 에 대해서 RSASSA-PSS sign & verify
	HxLOG_Print("\n RSA_Test (test 1) Start... \n");
	if (A_RSA_PSS(&PrivateKey1, &M1, &salt1, &Sig))
		HxLOG_Print(" ERROR !!!\n");
	else
	{
		HxLOG_Print(" Signature :");
		for (i = 0; i < Sig.len; i++)
		{
			if ((i & 15) == 0)
				HxLOG_Print("\n");
			HxLOG_Print(" %02x", Sig.num[i]);
		}
		HxLOG_Print("\n");
		if (bn_cmp(&Sig, &S1))
			HxLOG_Print(" invalid signature !!!\n");
		else
			HxLOG_Print(" valid signature generated \n"); // should be
	}
	if (V_RSA_PSS(&PublicKey1, &M1, &S1))
		HxLOG_Print(" valid signature verified \n"); // should be
	else
		HxLOG_Print(" invalid signature !!!\n");
	HxLOG_Print(" RSA_Test (test 1) End. \n");

	// test 2 : 1024 bits RSA Key Pair 에 대해서 RSASSA-PSS sign (private key 두 가지 유형에 대해 각기) & verify
	HxLOG_Print("\n RSA_Test (test 2) Start... \n");
#ifdef 	INCLUDE_1ST_FORM_TEST
	if (A_RSA_PSS(&PrivateKey2_1stForm, &M2, &salt2, &Sig))
		HxLOG_Print(" ERROR !!!\n");
	else
	{
		HxLOG_Print(" Signature :");
		for (i = 0; i < Sig.len; i++)
		{
			if ((i & 15) == 0)
				HxLOG_Print("\n");
			HxLOG_Print(" %02x", Sig.num[i]);
		}
		HxLOG_Print("\n");
		if (bn_cmp(&Sig, &S2))
			HxLOG_Print(" invalid signature !!!\n");
		else
			HxLOG_Print(" valid signature generated \n"); // should be
	}
#endif
	if (A_RSA_PSS(&PrivateKey2_2ndForm, &M2, &salt2, &Sig))
		HxLOG_Print(" ERROR !!!\n");
	else
	{
		HxLOG_Print(" Signature :");
		for (i = 0; i < Sig.len; i++)
		{
			if ((i & 15) == 0)
				HxLOG_Print("\n");
			HxLOG_Print(" %02x", Sig.num[i]);
		}
		HxLOG_Print("\n");
		if (bn_cmp(&Sig, &S2))
			HxLOG_Print(" invalid signature !!!\n");
		else
			HxLOG_Print(" valid signature generated \n"); // should be
	}
	if (V_RSA_PSS(&PublicKey2, &M2, &S2))
		HxLOG_Print(" valid signature verified \n"); // should be
	else
		HxLOG_Print(" invalid signature !!!\n");
	HxLOG_Print(" RSA_Test (test 2) End. \n");

	// test 3 : 1031 bits RSA Key Pair 에 대해서 RSASSA-PSS sign (private key 두 가지 유형에 대해 각기) & verify
	HxLOG_Print("\n RSA_Test (test 3) Start... \n");
#ifdef 	INCLUDE_1ST_FORM_TEST
	if (A_RSA_PSS(&PrivateKey3_1stForm, &M3, &salt3, &Sig))
		HxLOG_Print(" ERROR !!!\n");
	else
	{
		HxLOG_Print(" Signature :");
		for (i = 0; i < Sig.len; i++)
		{
			if ((i & 15) == 0)
				HxLOG_Print("\n");
			HxLOG_Print(" %02x", Sig.num[i]);
		}
		HxLOG_Print("\n");
		if (bn_cmp(&Sig, &S3))
			HxLOG_Print(" invalid signature !!!\n");
		else
			HxLOG_Print(" valid signature generated \n"); // should be
	}
#endif
	if (A_RSA_PSS(&PrivateKey3_2ndForm, &M3, &salt3, &Sig))
		HxLOG_Print(" ERROR !!!\n");
	else
	{
		HxLOG_Print(" Signature :");
		for (i = 0; i < Sig.len; i++)
		{
			if ((i & 15) == 0)
				HxLOG_Print("\n");
			HxLOG_Print(" %02x", Sig.num[i]);
		}
		HxLOG_Print("\n");
		if (bn_cmp(&Sig, &S3))
			HxLOG_Print(" invalid signature !!!\n");
		else
			HxLOG_Print(" valid signature generated \n"); // should be
	}
	if (V_RSA_PSS(&PublicKey3, &M3, &S3))
		HxLOG_Print(" valid signature verified \n"); // should be
	else
		HxLOG_Print(" invalid signature !!!\n");
	HxLOG_Print(" RSA_Test (test 3) End. \n");
}
#endif // #ifdef INCLUDE_10XX_BITS_TEST
#ifdef INCLUDE_2048_BITS_TEST
static void RSA_Test2(void)
{
	bignum n4 = {256, {
		0xA5, 0xDD, 0x86, 0x7A, 0xC4, 0xCB, 0x02, 0xF9, 0x0B, 0x94, 0x57, 0xD4, 0x8C, 0x14, 0xA7, 0x70,
		0xEF, 0x99, 0x1C, 0x56, 0xC3, 0x9C, 0x0E, 0xC6, 0x5F, 0xD1, 0x1A, 0xFA, 0x89, 0x37, 0xCE, 0xA5,
		0x7B, 0x9B, 0xE7, 0xAC, 0x73, 0xB4, 0x5C, 0x00, 0x17, 0x61, 0x5B, 0x82, 0xD6, 0x22, 0xE3, 0x18,
		0x75, 0x3B, 0x60, 0x27, 0xC0, 0xFD, 0x15, 0x7B, 0xE1, 0x2F, 0x80, 0x90, 0xFE, 0xE2, 0xA7, 0xAD,
		0xCD, 0x0E, 0xEF, 0x75, 0x9F, 0x88, 0xBA, 0x49, 0x97, 0xC7, 0xA4, 0x2D, 0x58, 0xC9, 0xAA, 0x12,
		0xCB, 0x99, 0xAE, 0x00, 0x1F, 0xE5, 0x21, 0xC1, 0x3B, 0xB5, 0x43, 0x14, 0x45, 0xA8, 0xD5, 0xAE,
		0x4F, 0x5E, 0x4C, 0x7E, 0x94, 0x8A, 0xC2, 0x27, 0xD3, 0x60, 0x40, 0x71, 0xF2, 0x0E, 0x57, 0x7E,
		0x90, 0x5F, 0xBE, 0xB1, 0x5D, 0xFA, 0xF0, 0x6D, 0x1D, 0xE5, 0xAE, 0x62, 0x53, 0xD6, 0x3A, 0x6A,
		0x21, 0x20, 0xB3, 0x1A, 0x5D, 0xA5, 0xDA, 0xBC, 0x95, 0x50, 0x60, 0x0E, 0x20, 0xF2, 0x7D, 0x37,
		0x39, 0xE2, 0x62, 0x79, 0x25, 0xFE, 0xA3, 0xCC, 0x50, 0x9F, 0x21, 0xDF, 0xF0, 0x4E, 0x6E, 0xEA,
		0x45, 0x49, 0xC5, 0x40, 0xD6, 0x80, 0x9F, 0xF9, 0x30, 0x7E, 0xED, 0xE9, 0x1F, 0xFF, 0x58, 0x73,
		0x3D, 0x83, 0x85, 0xA2, 0x37, 0xD6, 0xD3, 0x70, 0x5A, 0x33, 0xE3, 0x91, 0x90, 0x09, 0x92, 0x07,
		0x0D, 0xF7, 0xAD, 0xF1, 0x35, 0x7C, 0xF7, 0xE3, 0x70, 0x0C, 0xE3, 0x66, 0x7D, 0xE8, 0x3F, 0x17,
		0xB8, 0xDF, 0x17, 0x78, 0xDB, 0x38, 0x1D, 0xCE, 0x09, 0xCB, 0x4A, 0xD0, 0x58, 0xA5, 0x11, 0x00,
		0x1A, 0x73, 0x81, 0x98, 0xEE, 0x27, 0xCF, 0x55, 0xA1, 0x3B, 0x75, 0x45, 0x39, 0x90, 0x65, 0x82,
		0xEC, 0x8B, 0x17, 0x4B, 0xD5, 0x8D, 0x5D, 0x1F, 0x3D, 0x76, 0x7C, 0x61, 0x37, 0x21, 0xAE, 0x05}
	};
#ifdef 	INCLUDE_1ST_FORM_TEST
	bignum d4 = {256, {
		0x2D, 0x2F, 0xF5, 0x67, 0xB3, 0xFE, 0x74, 0xE0, 0x61, 0x91, 0xB7, 0xFD, 0xED, 0x6D, 0xE1, 0x12,
		0x29, 0x0C, 0x67, 0x06, 0x92, 0x43, 0x0D, 0x59, 0x69, 0x18, 0x40, 0x47, 0xDA, 0x23, 0x4C, 0x96,
		0x93, 0xDE, 0xED, 0x16, 0x73, 0xED, 0x42, 0x95, 0x39, 0xC9, 0x69, 0xD3, 0x72, 0xC0, 0x4D, 0x6B,
		0x47, 0xE0, 0xF5, 0xB8, 0xCE, 0xE0, 0x84, 0x3E, 0x5C, 0x22, 0x83, 0x5D, 0xBD, 0x3B, 0x05, 0xA0,
		0x99, 0x79, 0x84, 0xAE, 0x60, 0x58, 0xB1, 0x1B, 0xC4, 0x90, 0x7C, 0xBF, 0x67, 0xED, 0x84, 0xFA,
		0x9A, 0xE2, 0x52, 0xDF, 0xB0, 0xD0, 0xCD, 0x49, 0xE6, 0x18, 0xE3, 0x5D, 0xFD, 0xFE, 0x59, 0xBC,
		0xA3, 0xDD, 0xD6, 0x6C, 0x33, 0xCE, 0xBB, 0xC7, 0x7A, 0xD4, 0x41, 0xAA, 0x69, 0x5E, 0x13, 0xE3,
		0x24, 0xB5, 0x18, 0xF0, 0x1C, 0x60, 0xF5, 0xA8, 0x5C, 0x99, 0x4A, 0xD1, 0x79, 0xF2, 0xA6, 0xB5,
		0xFB, 0xE9, 0x34, 0x02, 0xB1, 0x17, 0x67, 0xBE, 0x01, 0xBF, 0x07, 0x34, 0x44, 0xD6, 0xBA, 0x1D,
		0xD2, 0xBC, 0xA5, 0xBD, 0x07, 0x4D, 0x4A, 0x5F, 0xAE, 0x35, 0x31, 0xAD, 0x13, 0x03, 0xD8, 0x4B,
		0x30, 0xD8, 0x97, 0x31, 0x8C, 0xBB, 0xBA, 0x04, 0xE0, 0x3C, 0x2E, 0x66, 0xDE, 0x6D, 0x91, 0xF8,
		0x2F, 0x96, 0xEA, 0x1D, 0x4B, 0xB5, 0x4A, 0x5A, 0xAE, 0x10, 0x2D, 0x59, 0x46, 0x57, 0xF5, 0xC9,
		0x78, 0x95, 0x53, 0x51, 0x2B, 0x29, 0x6D, 0xEA, 0x29, 0xD8, 0x02, 0x31, 0x96, 0x35, 0x7E, 0x3E,
		0x3A, 0x6E, 0x95, 0x8F, 0x39, 0xE3, 0xC2, 0x34, 0x40, 0x38, 0xEA, 0x60, 0x4B, 0x31, 0xED, 0xC6,
		0xF0, 0xF7, 0xFF, 0x6E, 0x71, 0x81, 0xA5, 0x7C, 0x92, 0x82, 0x6A, 0x26, 0x8F, 0x86, 0x76, 0x8E,
		0x96, 0xF8, 0x78, 0x56, 0x2F, 0xC7, 0x1D, 0x85, 0xD6, 0x9E, 0x44, 0x86, 0x12, 0xF7, 0x04, 0x8F}
	};
#endif
	bignum p4 = {128, {
		0xCF, 0xD5, 0x02, 0x83, 0xFE, 0xEE, 0xB9, 0x7F, 0x6F, 0x08, 0xD7, 0x3C, 0xBC, 0x7B, 0x38, 0x36,
		0xF8, 0x2B, 0xBC, 0xD4, 0x99, 0x47, 0x9F, 0x5E, 0x6F, 0x76, 0xFD, 0xFC, 0xB8, 0xB3, 0x8C, 0x4F,
		0x71, 0xDC, 0x9E, 0x88, 0xBD, 0x6A, 0x6F, 0x76, 0x37, 0x1A, 0xFD, 0x65, 0xD2, 0xAF, 0x18, 0x62,
		0xB3, 0x2A, 0xFB, 0x34, 0xA9, 0x5F, 0x71, 0xB8, 0xB1, 0x32, 0x04, 0x3F, 0xFE, 0xBE, 0x3A, 0x95,
		0x2B, 0xAF, 0x75, 0x92, 0x44, 0x81, 0x48, 0xC0, 0x3F, 0x9C, 0x69, 0xB1, 0xD6, 0x8E, 0x4C, 0xE5,
		0xCF, 0x32, 0xC8, 0x6B, 0xAF, 0x46, 0xFE, 0xD3, 0x01, 0xCA, 0x1A, 0xB4, 0x03, 0x06, 0x9B, 0x32,
		0xF4, 0x56, 0xB9, 0x1F, 0x71, 0x89, 0x8A, 0xB0, 0x81, 0xCD, 0x8C, 0x42, 0x52, 0xEF, 0x52, 0x71,
		0x91, 0x5C, 0x97, 0x94, 0xB8, 0xF2, 0x95, 0x85, 0x1D, 0xA7, 0x51, 0x0F, 0x99, 0xCB, 0x73, 0xEB}
	};
	bignum q4 = {128, {
		0xCC, 0x4E, 0x90, 0xD2, 0xA1, 0xB3, 0xA0, 0x65, 0xD3, 0xB2, 0xD1, 0xF5, 0xA8, 0xFC, 0xE3, 0x1B,
		0x54, 0x44, 0x75, 0x66, 0x4E, 0xAB, 0x56, 0x1D, 0x29, 0x71, 0xB9, 0x9F, 0xB7, 0xBE, 0xF8, 0x44,
		0xE8, 0xEC, 0x1F, 0x36, 0x0B, 0x8C, 0x2A, 0xC8, 0x35, 0x96, 0x92, 0x97, 0x1E, 0xA6, 0xA3, 0x8F,
		0x72, 0x3F, 0xCC, 0x21, 0x1F, 0x5D, 0xBC, 0xB1, 0x77, 0xA0, 0xFD, 0xAC, 0x51, 0x64, 0xA1, 0xD4,
		0xFF, 0x7F, 0xBB, 0x4E, 0x82, 0x99, 0x86, 0x35, 0x3C, 0xB9, 0x83, 0x65, 0x9A, 0x14, 0x8C, 0xDD,
		0x42, 0x0C, 0x7D, 0x31, 0xBA, 0x38, 0x22, 0xEA, 0x90, 0xA3, 0x2B, 0xE4, 0x6C, 0x03, 0x0E, 0x8C,
		0x17, 0xE1, 0xFA, 0x0A, 0xD3, 0x78, 0x59, 0xE0, 0x6B, 0x0A, 0xA6, 0xFA, 0x3B, 0x21, 0x6D, 0x9C,
		0xBE, 0x6C, 0x0E, 0x22, 0x33, 0x97, 0x69, 0xC0, 0xA6, 0x15, 0x91, 0x3E, 0x5D, 0xA7, 0x19, 0xCF}
	};
	bignum dP4 = {128, {
		0x1C, 0x2D, 0x1F, 0xC3, 0x2F, 0x6B, 0xC4, 0x00, 0x4F, 0xD8, 0x5D, 0xFD, 0xE0, 0xFB, 0xBF, 0x9A,
		0x4C, 0x38, 0xF9, 0xC7, 0xC4, 0xE4, 0x1D, 0xEA, 0x1A, 0xA8, 0x82, 0x34, 0xA2, 0x01, 0xCD, 0x92,
		0xF3, 0xB7, 0xDA, 0x52, 0x65, 0x83, 0xA9, 0x8A, 0xD8, 0x5B, 0xB3, 0x60, 0xFB, 0x98, 0x3B, 0x71,
		0x1E, 0x23, 0x44, 0x9D, 0x56, 0x1D, 0x17, 0x78, 0xD7, 0xA5, 0x15, 0x48, 0x6B, 0xCB, 0xF4, 0x7B,
		0x46, 0xC9, 0xE9, 0xE1, 0xA3, 0xA1, 0xF7, 0x70, 0x00, 0xEF, 0xBE, 0xB0, 0x9A, 0x8A, 0xFE, 0x47,
		0xE5, 0xB8, 0x57, 0xCD, 0xA9, 0x9C, 0xB1, 0x6D, 0x7F, 0xFF, 0x9B, 0x71, 0x2E, 0x3B, 0xD6, 0x0C,
		0xA9, 0x6D, 0x9C, 0x79, 0x73, 0xD6, 0x16, 0xD4, 0x69, 0x34, 0xA9, 0xC0, 0x50, 0x28, 0x1C, 0x00,
		0x43, 0x99, 0xCE, 0xFF, 0x1D, 0xB7, 0xDD, 0xA7, 0x87, 0x66, 0xA8, 0xA9, 0xB9, 0xCB, 0x08, 0x73}
	};
	bignum dQ4 = {128, {
		0xCB, 0x3B, 0x3C, 0x04, 0xCA, 0xA5, 0x8C, 0x60, 0xBE, 0x7D, 0x9B, 0x2D, 0xEB, 0xB3, 0xE3, 0x96,
		0x43, 0xF4, 0xF5, 0x73, 0x97, 0xBE, 0x08, 0x23, 0x6A, 0x1E, 0x9E, 0xAF, 0xAA, 0x70, 0x65, 0x36,
		0xE7, 0x1C, 0x3A, 0xCF, 0xE0, 0x1C, 0xC6, 0x51, 0xF2, 0x3C, 0x9E, 0x05, 0x85, 0x8F, 0xEE, 0x13,
		0xBB, 0x6A, 0x8A, 0xFC, 0x47, 0xDF, 0x4E, 0xDC, 0x9A, 0x4B, 0xA3, 0x0B, 0xCE, 0xCB, 0x73, 0xD0,
		0x15, 0x78, 0x52, 0x32, 0x7E, 0xE7, 0x89, 0x01, 0x5C, 0x2E, 0x8D, 0xEE, 0x7B, 0x9F, 0x05, 0xA0,
		0xF3, 0x1A, 0xC9, 0x4E, 0xB6, 0x17, 0x31, 0x64, 0x74, 0x0C, 0x5C, 0x95, 0x14, 0x7C, 0xD5, 0xF3,
		0xB5, 0xAE, 0x2C, 0xB4, 0xA8, 0x37, 0x87, 0xF0, 0x1D, 0x8A, 0xB3, 0x1F, 0x27, 0xC2, 0xD0, 0xEE,
		0xA2, 0xDD, 0x8A, 0x11, 0xAB, 0x90, 0x6A, 0xBA, 0x20, 0x7C, 0x43, 0xC6, 0xEE, 0x12, 0x53, 0x31}
	};
	bignum qInv4 = {128, {
		0x12, 0xF6, 0xB2, 0xCF, 0x13, 0x74, 0xA7, 0x36, 0xFA, 0xD0, 0x56, 0x16, 0x05, 0x0F, 0x96, 0xAB,
		0x4B, 0x61, 0xD1, 0x17, 0x7C, 0x7F, 0x9D, 0x52, 0x5A, 0x29, 0xF3, 0xD1, 0x80, 0xE7, 0x76, 0x67,
		0xE9, 0x9D, 0x99, 0xAB, 0xF0, 0x52, 0x5D, 0x07, 0x58, 0x66, 0x0F, 0x37, 0x52, 0x65, 0x5B, 0x0F,
		0x25, 0xB8, 0xDF, 0x84, 0x31, 0xD9, 0xA8, 0xFF, 0x77, 0xC1, 0x6C, 0x12, 0xA0, 0xA5, 0x12, 0x2A,
		0x9F, 0x0B, 0xF7, 0xCF, 0xD5, 0xA2, 0x66, 0xA3, 0x5C, 0x15, 0x9F, 0x99, 0x12, 0x08, 0xB9, 0x03,
		0x16, 0xFF, 0x44, 0x4F, 0x3E, 0x0B, 0x6B, 0xD0, 0xE9, 0x3B, 0x8A, 0x7A, 0x24, 0x48, 0xE9, 0x57,
		0xE3, 0xDD, 0xA6, 0xCF, 0xCF, 0x22, 0x66, 0xB1, 0x06, 0x01, 0x3A, 0xC4, 0x68, 0x08, 0xD3, 0xB3,
		0x88, 0x7B, 0x3B, 0x00, 0x34, 0x4B, 0xAA, 0xC9, 0x53, 0x0B, 0x4C, 0xE7, 0x08, 0xFC, 0x32, 0xB6}
	};
	bignum M4 = {163, {
		0x25, 0xF1, 0x08, 0x95, 0xA8, 0x77, 0x16, 0xC1, 0x37, 0x45, 0x0B, 0xB9, 0x51, 0x9D, 0xFA, 0xA1,
		0xF2, 0x07, 0xFA, 0xA9, 0x42, 0xEA, 0x88, 0xAB, 0xF7, 0x1E, 0x9C, 0x17, 0x98, 0x00, 0x85, 0xB5,
		0x55, 0xAE, 0xBA, 0xB7, 0x62, 0x64, 0xAE, 0x2A, 0x3A, 0xB9, 0x3C, 0x2D, 0x12, 0x98, 0x11, 0x91,
		0xDD, 0xAC, 0x6F, 0xB5, 0x94, 0x9E, 0xB3, 0x6A, 0xEE, 0x3C, 0x5D, 0xA9, 0x40, 0xF0, 0x07, 0x52,
		0xC9, 0x16, 0xD9, 0x46, 0x08, 0xFA, 0x7D, 0x97, 0xBA, 0x6A, 0x29, 0x15, 0xB6, 0x88, 0xF2, 0x03,
		0x23, 0xD4, 0xE9, 0xD9, 0x68, 0x01, 0xD8, 0x9A, 0x72, 0xAB, 0x58, 0x92, 0xDC, 0x21, 0x17, 0xC0,
		0x74, 0x34, 0xFC, 0xF9, 0x72, 0xE0, 0x58, 0xCF, 0x8C, 0x41, 0xCA, 0x4B, 0x4F, 0xF5, 0x54, 0xF7,
		0xD5, 0x06, 0x8A, 0xD3, 0x15, 0x5F, 0xCE, 0xD0, 0xF3, 0x12, 0x5B, 0xC0, 0x4F, 0x91, 0x93, 0x37,
		0x8A, 0x8F, 0x5C, 0x4C, 0x3B, 0x8C, 0xB4, 0xDD, 0x6D, 0x1C, 0xC6, 0x9D, 0x30, 0xEC, 0xCA, 0x6E,
		0xAA, 0x51, 0xE3, 0x6A, 0x05, 0x73, 0x0E, 0x9E, 0x34, 0x2E, 0x85, 0x5B, 0xAF, 0x09, 0x9D, 0xEF,
		0xB8, 0xAF, 0xD7}
	};
	bignum salt4 = {20, {
		0xAD, 0x8B, 0x15, 0x23, 0x70, 0x36, 0x46, 0x22, 0x4B, 0x66, 0x0B, 0x55, 0x08, 0x85, 0x91, 0x7C,
		0xA2, 0xD1, 0xDF, 0x28}
	};
	bignum S4 = {256, {
		0x6D, 0x3B, 0x5B, 0x87, 0xF6, 0x7E, 0xA6, 0x57, 0xAF, 0x21, 0xF7, 0x54, 0x41, 0x97, 0x7D, 0x21,
		0x80, 0xF9, 0x1B, 0x2C, 0x5F, 0x69, 0x2D, 0xE8, 0x29, 0x55, 0x69, 0x6A, 0x68, 0x67, 0x30, 0xD9,
		0xB9, 0x77, 0x8D, 0x97, 0x07, 0x58, 0xCC, 0xB2, 0x60, 0x71, 0xC2, 0x20, 0x9F, 0xFB, 0xD6, 0x12,
		0x5B, 0xE2, 0xE9, 0x6E, 0xA8, 0x1B, 0x67, 0xCB, 0x9B, 0x93, 0x08, 0x23, 0x9F, 0xDA, 0x17, 0xF7,
		0xB2, 0xB6, 0x4E, 0xCD, 0xA0, 0x96, 0xB6, 0xB9, 0x35, 0x64, 0x0A, 0x5A, 0x1C, 0xB4, 0x2A, 0x91,
		0x55, 0xB1, 0xC9, 0xEF, 0x7A, 0x63, 0x3A, 0x02, 0xC5, 0x9F, 0x0D, 0x6E, 0xE5, 0x9B, 0x85, 0x2C,
		0x43, 0xB3, 0x50, 0x29, 0xE7, 0x3C, 0x94, 0x0F, 0xF0, 0x41, 0x0E, 0x8F, 0x11, 0x4E, 0xED, 0x46,
		0xBB, 0xD0, 0xFA, 0xE1, 0x65, 0xE4, 0x2B, 0xE2, 0x52, 0x8A, 0x40, 0x1C, 0x3B, 0x28, 0xFD, 0x81,
		0x8E, 0xF3, 0x23, 0x2D, 0xCA, 0x9F, 0x4D, 0x2A, 0x0F, 0x51, 0x66, 0xEC, 0x59, 0xC4, 0x23, 0x96,
		0xD6, 0xC1, 0x1D, 0xBC, 0x12, 0x15, 0xA5, 0x6F, 0xA1, 0x71, 0x69, 0xDB, 0x95, 0x75, 0x34, 0x3E,
		0xF3, 0x4F, 0x9D, 0xE3, 0x2A, 0x49, 0xCD, 0xC3, 0x17, 0x49, 0x22, 0xF2, 0x29, 0xC2, 0x3E, 0x18,
		0xE4, 0x5D, 0xF9, 0x35, 0x31, 0x19, 0xEC, 0x43, 0x19, 0xCE, 0xDC, 0xE7, 0xA1, 0x7C, 0x64, 0x08,
		0x8C, 0x1F, 0x6F, 0x52, 0xBE, 0x29, 0x63, 0x41, 0x00, 0xB3, 0x91, 0x9D, 0x38, 0xF3, 0xD1, 0xED,
		0x94, 0xE6, 0x89, 0x1E, 0x66, 0xA7, 0x3B, 0x8F, 0xB8, 0x49, 0xF5, 0x87, 0x4D, 0xF5, 0x94, 0x59,
		0xE2, 0x98, 0xC7, 0xBB, 0xCE, 0x2E, 0xEE, 0x78, 0x2A, 0x19, 0x5A, 0xA6, 0x6F, 0xE2, 0xD0, 0x73,
		0x2B, 0x25, 0xE5, 0x95, 0xF5, 0x7D, 0x3E, 0x06, 0x1B, 0x1F, 0xC3, 0xE4, 0x06, 0x3B, 0xF9, 0x8F}
	};

#ifdef 	INCLUDE_1ST_FORM_TEST
	RSA_private_key PrivateKey4_1stForm = {&n4, &d4, NULL, NULL, NULL, NULL, NULL};
#endif
	RSA_private_key PrivateKey4_2ndForm = {&n4, NULL, &p4, &q4, &dP4, &dQ4, &qInv4};
	RSA_public_key PublicKey4 = {&n4, &bn_e};

	bignum Sig;
	bn_len_type i;

	// test 4 : 2048 bits RSA Key Pair 에 대해서 RSASSA-PSS sign (private key 두 가지 유형에 대해 각기) & verify
	HxLOG_Print("\n RSA_Test (test 4) Start... \n");
#ifdef 	INCLUDE_1ST_FORM_TEST
	if (A_RSA_PSS(&PrivateKey4_1stForm, &M4, &salt4, &Sig))
		HxLOG_Print(" ERROR !!!\n");
	else
	{
		HxLOG_Print(" Signature :");
		for (i = 0; i < Sig.len; i++)
		{
			if ((i & 15) == 0)
				HxLOG_Print("\n");
			HxLOG_Print(" %02x", Sig.num[i]);
		}
		HxLOG_Print("\n");
		if (bn_cmp(&Sig, &S4))
			HxLOG_Print(" invalid signature !!!\n");
		else
			HxLOG_Print(" valid signature generated \n"); // should be
	}
#endif
	if (A_RSA_PSS(&PrivateKey4_2ndForm, &M4, &salt4, &Sig))
		HxLOG_Print(" ERROR !!!\n");
	else
	{
		HxLOG_Print(" Signature :");
		for (i = 0; i < Sig.len; i++)
		{
			if ((i & 15) == 0)
				HxLOG_Print("\n");
			HxLOG_Print(" %02x", Sig.num[i]);
		}
		HxLOG_Print("\n");
		if (bn_cmp(&Sig, &S4))
			HxLOG_Print(" invalid signature !!!\n");
		else
			HxLOG_Print(" valid signature generated \n"); // should be
	}
	if (V_RSA_PSS(&PublicKey4, &M4, &S4))
		HxLOG_Print(" valid signature verified \n"); // should be
	else
		HxLOG_Print(" invalid signature !!!\n");
	HxLOG_Print(" RSA_Test (test 4) End. \n");
}
#endif // #ifdef INCLUDE_2048_BITS_TEST
static void RSA_Test3(void)
{
	bignum n4 = {256, {
		0xA5, 0xDD, 0x86, 0x7A, 0xC4, 0xCB, 0x02, 0xF9, 0x0B, 0x94, 0x57, 0xD4, 0x8C, 0x14, 0xA7, 0x70,
		0xEF, 0x99, 0x1C, 0x56, 0xC3, 0x9C, 0x0E, 0xC6, 0x5F, 0xD1, 0x1A, 0xFA, 0x89, 0x37, 0xCE, 0xA5,
		0x7B, 0x9B, 0xE7, 0xAC, 0x73, 0xB4, 0x5C, 0x00, 0x17, 0x61, 0x5B, 0x82, 0xD6, 0x22, 0xE3, 0x18,
		0x75, 0x3B, 0x60, 0x27, 0xC0, 0xFD, 0x15, 0x7B, 0xE1, 0x2F, 0x80, 0x90, 0xFE, 0xE2, 0xA7, 0xAD,
		0xCD, 0x0E, 0xEF, 0x75, 0x9F, 0x88, 0xBA, 0x49, 0x97, 0xC7, 0xA4, 0x2D, 0x58, 0xC9, 0xAA, 0x12,
		0xCB, 0x99, 0xAE, 0x00, 0x1F, 0xE5, 0x21, 0xC1, 0x3B, 0xB5, 0x43, 0x14, 0x45, 0xA8, 0xD5, 0xAE,
		0x4F, 0x5E, 0x4C, 0x7E, 0x94, 0x8A, 0xC2, 0x27, 0xD3, 0x60, 0x40, 0x71, 0xF2, 0x0E, 0x57, 0x7E,
		0x90, 0x5F, 0xBE, 0xB1, 0x5D, 0xFA, 0xF0, 0x6D, 0x1D, 0xE5, 0xAE, 0x62, 0x53, 0xD6, 0x3A, 0x6A,
		0x21, 0x20, 0xB3, 0x1A, 0x5D, 0xA5, 0xDA, 0xBC, 0x95, 0x50, 0x60, 0x0E, 0x20, 0xF2, 0x7D, 0x37,
		0x39, 0xE2, 0x62, 0x79, 0x25, 0xFE, 0xA3, 0xCC, 0x50, 0x9F, 0x21, 0xDF, 0xF0, 0x4E, 0x6E, 0xEA,
		0x45, 0x49, 0xC5, 0x40, 0xD6, 0x80, 0x9F, 0xF9, 0x30, 0x7E, 0xED, 0xE9, 0x1F, 0xFF, 0x58, 0x73,
		0x3D, 0x83, 0x85, 0xA2, 0x37, 0xD6, 0xD3, 0x70, 0x5A, 0x33, 0xE3, 0x91, 0x90, 0x09, 0x92, 0x07,
		0x0D, 0xF7, 0xAD, 0xF1, 0x35, 0x7C, 0xF7, 0xE3, 0x70, 0x0C, 0xE3, 0x66, 0x7D, 0xE8, 0x3F, 0x17,
		0xB8, 0xDF, 0x17, 0x78, 0xDB, 0x38, 0x1D, 0xCE, 0x09, 0xCB, 0x4A, 0xD0, 0x58, 0xA5, 0x11, 0x00,
		0x1A, 0x73, 0x81, 0x98, 0xEE, 0x27, 0xCF, 0x55, 0xA1, 0x3B, 0x75, 0x45, 0x39, 0x90, 0x65, 0x82,
		0xEC, 0x8B, 0x17, 0x4B, 0xD5, 0x8D, 0x5D, 0x1F, 0x3D, 0x76, 0x7C, 0x61, 0x37, 0x21, 0xAE, 0x05}
	};
#ifdef 	INCLUDE_1ST_FORM_TEST
	bignum d4 = {256, {
		0x2D, 0x2F, 0xF5, 0x67, 0xB3, 0xFE, 0x74, 0xE0, 0x61, 0x91, 0xB7, 0xFD, 0xED, 0x6D, 0xE1, 0x12,
		0x29, 0x0C, 0x67, 0x06, 0x92, 0x43, 0x0D, 0x59, 0x69, 0x18, 0x40, 0x47, 0xDA, 0x23, 0x4C, 0x96,
		0x93, 0xDE, 0xED, 0x16, 0x73, 0xED, 0x42, 0x95, 0x39, 0xC9, 0x69, 0xD3, 0x72, 0xC0, 0x4D, 0x6B,
		0x47, 0xE0, 0xF5, 0xB8, 0xCE, 0xE0, 0x84, 0x3E, 0x5C, 0x22, 0x83, 0x5D, 0xBD, 0x3B, 0x05, 0xA0,
		0x99, 0x79, 0x84, 0xAE, 0x60, 0x58, 0xB1, 0x1B, 0xC4, 0x90, 0x7C, 0xBF, 0x67, 0xED, 0x84, 0xFA,
		0x9A, 0xE2, 0x52, 0xDF, 0xB0, 0xD0, 0xCD, 0x49, 0xE6, 0x18, 0xE3, 0x5D, 0xFD, 0xFE, 0x59, 0xBC,
		0xA3, 0xDD, 0xD6, 0x6C, 0x33, 0xCE, 0xBB, 0xC7, 0x7A, 0xD4, 0x41, 0xAA, 0x69, 0x5E, 0x13, 0xE3,
		0x24, 0xB5, 0x18, 0xF0, 0x1C, 0x60, 0xF5, 0xA8, 0x5C, 0x99, 0x4A, 0xD1, 0x79, 0xF2, 0xA6, 0xB5,
		0xFB, 0xE9, 0x34, 0x02, 0xB1, 0x17, 0x67, 0xBE, 0x01, 0xBF, 0x07, 0x34, 0x44, 0xD6, 0xBA, 0x1D,
		0xD2, 0xBC, 0xA5, 0xBD, 0x07, 0x4D, 0x4A, 0x5F, 0xAE, 0x35, 0x31, 0xAD, 0x13, 0x03, 0xD8, 0x4B,
		0x30, 0xD8, 0x97, 0x31, 0x8C, 0xBB, 0xBA, 0x04, 0xE0, 0x3C, 0x2E, 0x66, 0xDE, 0x6D, 0x91, 0xF8,
		0x2F, 0x96, 0xEA, 0x1D, 0x4B, 0xB5, 0x4A, 0x5A, 0xAE, 0x10, 0x2D, 0x59, 0x46, 0x57, 0xF5, 0xC9,
		0x78, 0x95, 0x53, 0x51, 0x2B, 0x29, 0x6D, 0xEA, 0x29, 0xD8, 0x02, 0x31, 0x96, 0x35, 0x7E, 0x3E,
		0x3A, 0x6E, 0x95, 0x8F, 0x39, 0xE3, 0xC2, 0x34, 0x40, 0x38, 0xEA, 0x60, 0x4B, 0x31, 0xED, 0xC6,
		0xF0, 0xF7, 0xFF, 0x6E, 0x71, 0x81, 0xA5, 0x7C, 0x92, 0x82, 0x6A, 0x26, 0x8F, 0x86, 0x76, 0x8E,
		0x96, 0xF8, 0x78, 0x56, 0x2F, 0xC7, 0x1D, 0x85, 0xD6, 0x9E, 0x44, 0x86, 0x12, 0xF7, 0x04, 0x8F}
	};
#endif
	bignum p4 = {128, {
		0xCF, 0xD5, 0x02, 0x83, 0xFE, 0xEE, 0xB9, 0x7F, 0x6F, 0x08, 0xD7, 0x3C, 0xBC, 0x7B, 0x38, 0x36,
		0xF8, 0x2B, 0xBC, 0xD4, 0x99, 0x47, 0x9F, 0x5E, 0x6F, 0x76, 0xFD, 0xFC, 0xB8, 0xB3, 0x8C, 0x4F,
		0x71, 0xDC, 0x9E, 0x88, 0xBD, 0x6A, 0x6F, 0x76, 0x37, 0x1A, 0xFD, 0x65, 0xD2, 0xAF, 0x18, 0x62,
		0xB3, 0x2A, 0xFB, 0x34, 0xA9, 0x5F, 0x71, 0xB8, 0xB1, 0x32, 0x04, 0x3F, 0xFE, 0xBE, 0x3A, 0x95,
		0x2B, 0xAF, 0x75, 0x92, 0x44, 0x81, 0x48, 0xC0, 0x3F, 0x9C, 0x69, 0xB1, 0xD6, 0x8E, 0x4C, 0xE5,
		0xCF, 0x32, 0xC8, 0x6B, 0xAF, 0x46, 0xFE, 0xD3, 0x01, 0xCA, 0x1A, 0xB4, 0x03, 0x06, 0x9B, 0x32,
		0xF4, 0x56, 0xB9, 0x1F, 0x71, 0x89, 0x8A, 0xB0, 0x81, 0xCD, 0x8C, 0x42, 0x52, 0xEF, 0x52, 0x71,
		0x91, 0x5C, 0x97, 0x94, 0xB8, 0xF2, 0x95, 0x85, 0x1D, 0xA7, 0x51, 0x0F, 0x99, 0xCB, 0x73, 0xEB}
	};
	bignum q4 = {128, {
		0xCC, 0x4E, 0x90, 0xD2, 0xA1, 0xB3, 0xA0, 0x65, 0xD3, 0xB2, 0xD1, 0xF5, 0xA8, 0xFC, 0xE3, 0x1B,
		0x54, 0x44, 0x75, 0x66, 0x4E, 0xAB, 0x56, 0x1D, 0x29, 0x71, 0xB9, 0x9F, 0xB7, 0xBE, 0xF8, 0x44,
		0xE8, 0xEC, 0x1F, 0x36, 0x0B, 0x8C, 0x2A, 0xC8, 0x35, 0x96, 0x92, 0x97, 0x1E, 0xA6, 0xA3, 0x8F,
		0x72, 0x3F, 0xCC, 0x21, 0x1F, 0x5D, 0xBC, 0xB1, 0x77, 0xA0, 0xFD, 0xAC, 0x51, 0x64, 0xA1, 0xD4,
		0xFF, 0x7F, 0xBB, 0x4E, 0x82, 0x99, 0x86, 0x35, 0x3C, 0xB9, 0x83, 0x65, 0x9A, 0x14, 0x8C, 0xDD,
		0x42, 0x0C, 0x7D, 0x31, 0xBA, 0x38, 0x22, 0xEA, 0x90, 0xA3, 0x2B, 0xE4, 0x6C, 0x03, 0x0E, 0x8C,
		0x17, 0xE1, 0xFA, 0x0A, 0xD3, 0x78, 0x59, 0xE0, 0x6B, 0x0A, 0xA6, 0xFA, 0x3B, 0x21, 0x6D, 0x9C,
		0xBE, 0x6C, 0x0E, 0x22, 0x33, 0x97, 0x69, 0xC0, 0xA6, 0x15, 0x91, 0x3E, 0x5D, 0xA7, 0x19, 0xCF}
	};
	bignum dP4 = {128, {
		0x1C, 0x2D, 0x1F, 0xC3, 0x2F, 0x6B, 0xC4, 0x00, 0x4F, 0xD8, 0x5D, 0xFD, 0xE0, 0xFB, 0xBF, 0x9A,
		0x4C, 0x38, 0xF9, 0xC7, 0xC4, 0xE4, 0x1D, 0xEA, 0x1A, 0xA8, 0x82, 0x34, 0xA2, 0x01, 0xCD, 0x92,
		0xF3, 0xB7, 0xDA, 0x52, 0x65, 0x83, 0xA9, 0x8A, 0xD8, 0x5B, 0xB3, 0x60, 0xFB, 0x98, 0x3B, 0x71,
		0x1E, 0x23, 0x44, 0x9D, 0x56, 0x1D, 0x17, 0x78, 0xD7, 0xA5, 0x15, 0x48, 0x6B, 0xCB, 0xF4, 0x7B,
		0x46, 0xC9, 0xE9, 0xE1, 0xA3, 0xA1, 0xF7, 0x70, 0x00, 0xEF, 0xBE, 0xB0, 0x9A, 0x8A, 0xFE, 0x47,
		0xE5, 0xB8, 0x57, 0xCD, 0xA9, 0x9C, 0xB1, 0x6D, 0x7F, 0xFF, 0x9B, 0x71, 0x2E, 0x3B, 0xD6, 0x0C,
		0xA9, 0x6D, 0x9C, 0x79, 0x73, 0xD6, 0x16, 0xD4, 0x69, 0x34, 0xA9, 0xC0, 0x50, 0x28, 0x1C, 0x00,
		0x43, 0x99, 0xCE, 0xFF, 0x1D, 0xB7, 0xDD, 0xA7, 0x87, 0x66, 0xA8, 0xA9, 0xB9, 0xCB, 0x08, 0x73}
	};
	bignum dQ4 = {128, {
		0xCB, 0x3B, 0x3C, 0x04, 0xCA, 0xA5, 0x8C, 0x60, 0xBE, 0x7D, 0x9B, 0x2D, 0xEB, 0xB3, 0xE3, 0x96,
		0x43, 0xF4, 0xF5, 0x73, 0x97, 0xBE, 0x08, 0x23, 0x6A, 0x1E, 0x9E, 0xAF, 0xAA, 0x70, 0x65, 0x36,
		0xE7, 0x1C, 0x3A, 0xCF, 0xE0, 0x1C, 0xC6, 0x51, 0xF2, 0x3C, 0x9E, 0x05, 0x85, 0x8F, 0xEE, 0x13,
		0xBB, 0x6A, 0x8A, 0xFC, 0x47, 0xDF, 0x4E, 0xDC, 0x9A, 0x4B, 0xA3, 0x0B, 0xCE, 0xCB, 0x73, 0xD0,
		0x15, 0x78, 0x52, 0x32, 0x7E, 0xE7, 0x89, 0x01, 0x5C, 0x2E, 0x8D, 0xEE, 0x7B, 0x9F, 0x05, 0xA0,
		0xF3, 0x1A, 0xC9, 0x4E, 0xB6, 0x17, 0x31, 0x64, 0x74, 0x0C, 0x5C, 0x95, 0x14, 0x7C, 0xD5, 0xF3,
		0xB5, 0xAE, 0x2C, 0xB4, 0xA8, 0x37, 0x87, 0xF0, 0x1D, 0x8A, 0xB3, 0x1F, 0x27, 0xC2, 0xD0, 0xEE,
		0xA2, 0xDD, 0x8A, 0x11, 0xAB, 0x90, 0x6A, 0xBA, 0x20, 0x7C, 0x43, 0xC6, 0xEE, 0x12, 0x53, 0x31}
	};
	bignum qInv4 = {128, {
		0x12, 0xF6, 0xB2, 0xCF, 0x13, 0x74, 0xA7, 0x36, 0xFA, 0xD0, 0x56, 0x16, 0x05, 0x0F, 0x96, 0xAB,
		0x4B, 0x61, 0xD1, 0x17, 0x7C, 0x7F, 0x9D, 0x52, 0x5A, 0x29, 0xF3, 0xD1, 0x80, 0xE7, 0x76, 0x67,
		0xE9, 0x9D, 0x99, 0xAB, 0xF0, 0x52, 0x5D, 0x07, 0x58, 0x66, 0x0F, 0x37, 0x52, 0x65, 0x5B, 0x0F,
		0x25, 0xB8, 0xDF, 0x84, 0x31, 0xD9, 0xA8, 0xFF, 0x77, 0xC1, 0x6C, 0x12, 0xA0, 0xA5, 0x12, 0x2A,
		0x9F, 0x0B, 0xF7, 0xCF, 0xD5, 0xA2, 0x66, 0xA3, 0x5C, 0x15, 0x9F, 0x99, 0x12, 0x08, 0xB9, 0x03,
		0x16, 0xFF, 0x44, 0x4F, 0x3E, 0x0B, 0x6B, 0xD0, 0xE9, 0x3B, 0x8A, 0x7A, 0x24, 0x48, 0xE9, 0x57,
		0xE3, 0xDD, 0xA6, 0xCF, 0xCF, 0x22, 0x66, 0xB1, 0x06, 0x01, 0x3A, 0xC4, 0x68, 0x08, 0xD3, 0xB3,
		0x88, 0x7B, 0x3B, 0x00, 0x34, 0x4B, 0xAA, 0xC9, 0x53, 0x0B, 0x4C, 0xE7, 0x08, 0xFC, 0x32, 0xB6}
	};
	bignum M4 = {163, {
		0x25, 0xF1, 0x08, 0x95, 0xA8, 0x77, 0x16, 0xC1, 0x37, 0x45, 0x0B, 0xB9, 0x51, 0x9D, 0xFA, 0xA1,
		0xF2, 0x07, 0xFA, 0xA9, 0x42, 0xEA, 0x88, 0xAB, 0xF7, 0x1E, 0x9C, 0x17, 0x98, 0x00, 0x85, 0xB5,
		0x55, 0xAE, 0xBA, 0xB7, 0x62, 0x64, 0xAE, 0x2A, 0x3A, 0xB9, 0x3C, 0x2D, 0x12, 0x98, 0x11, 0x91,
		0xDD, 0xAC, 0x6F, 0xB5, 0x94, 0x9E, 0xB3, 0x6A, 0xEE, 0x3C, 0x5D, 0xA9, 0x40, 0xF0, 0x07, 0x52,
		0xC9, 0x16, 0xD9, 0x46, 0x08, 0xFA, 0x7D, 0x97, 0xBA, 0x6A, 0x29, 0x15, 0xB6, 0x88, 0xF2, 0x03,
		0x23, 0xD4, 0xE9, 0xD9, 0x68, 0x01, 0xD8, 0x9A, 0x72, 0xAB, 0x58, 0x92, 0xDC, 0x21, 0x17, 0xC0,
		0x74, 0x34, 0xFC, 0xF9, 0x72, 0xE0, 0x58, 0xCF, 0x8C, 0x41, 0xCA, 0x4B, 0x4F, 0xF5, 0x54, 0xF7,
		0xD5, 0x06, 0x8A, 0xD3, 0x15, 0x5F, 0xCE, 0xD0, 0xF3, 0x12, 0x5B, 0xC0, 0x4F, 0x91, 0x93, 0x37,
		0x8A, 0x8F, 0x5C, 0x4C, 0x3B, 0x8C, 0xB4, 0xDD, 0x6D, 0x1C, 0xC6, 0x9D, 0x30, 0xEC, 0xCA, 0x6E,
		0xAA, 0x51, 0xE3, 0x6A, 0x05, 0x73, 0x0E, 0x9E, 0x34, 0x2E, 0x85, 0x5B, 0xAF, 0x09, 0x9D, 0xEF,
		0xB8, 0xAF, 0xD7}
	};
	bignum S4 = {256, {
		0x6A, 0x93, 0xEB, 0x9A, 0x7D, 0x00, 0x81, 0xE9, 0x89, 0x20, 0x57, 0x94, 0xF0, 0xF6, 0x54, 0xD8,
		0xD3, 0xF9, 0xED, 0x45, 0xE0, 0x62, 0xEB, 0x0A, 0xEE, 0xE0, 0x2D, 0x36, 0x91, 0xAA, 0xF2, 0x3D,
		0x32, 0x20, 0xFA, 0x19, 0x5A, 0xCE, 0x45, 0x70, 0x5B, 0x61, 0x8E, 0x83, 0x70, 0x2F, 0xDC, 0xE4,
		0xDA, 0x4A, 0x5F, 0x38, 0x47, 0xCC, 0xCF, 0x9A, 0x63, 0xDC, 0x18, 0x2D, 0x58, 0x01, 0xC1, 0x45,
		0x6C, 0x1B, 0x1E, 0x21, 0x96, 0xD6, 0xD3, 0x0B, 0x52, 0x17, 0xF6, 0xC3, 0x09, 0xEB, 0xB4, 0x14,
		0x42, 0x3A, 0x41, 0xD4, 0x4D, 0xBA, 0x3C, 0x65, 0x0B, 0x85, 0x35, 0xDA, 0x4A, 0x98, 0xEF, 0xBB,
		0xCF, 0xE3, 0x0A, 0x3F, 0xCA, 0x0F, 0x5C, 0x5F, 0x41, 0xDD, 0x5E, 0x9D, 0xF2, 0xF7, 0xC8, 0xBA,
		0xCC, 0xF3, 0xB9, 0xCC, 0x64, 0x05, 0x7D, 0xB0, 0x50, 0xA2, 0x13, 0xD0, 0x52, 0x9D, 0x03, 0x15,
		0x32, 0xD4, 0xA8, 0x85, 0x1F, 0x03, 0x9D, 0x23, 0x0C, 0x00, 0x10, 0x94, 0xF4, 0x83, 0x0B, 0xED,
		0xBE, 0x49, 0xA5, 0xA5, 0x03, 0x8D, 0x43, 0x43, 0x84, 0x0D, 0xFB, 0x1E, 0x26, 0x29, 0x4B, 0x0E,
		0xD4, 0xAC, 0x54, 0x7B, 0xC2, 0xB9, 0x17, 0xCF, 0x02, 0xF0, 0x0C, 0x74, 0x73, 0xEF, 0x6C, 0xBD,
		0x4C, 0x59, 0x02, 0x1C, 0x4F, 0x1F, 0x24, 0xBF, 0xB9, 0xC0, 0x68, 0x6C, 0xBC, 0xA9, 0x24, 0xF2,
		0xF5, 0xF9, 0xA0, 0x1A, 0xDD, 0x2C, 0xF6, 0x79, 0x33, 0x2C, 0xA2, 0x18, 0x71, 0x9C, 0x69, 0xE7,
		0x60, 0x69, 0xD5, 0x8E, 0x6F, 0x06, 0x4B, 0x9A, 0x6E, 0x30, 0xD8, 0x88, 0xE2, 0xD2, 0x16, 0x6B,
		0x99, 0x7D, 0x65, 0x76, 0xE8, 0x3B, 0x17, 0x14, 0x91, 0x44, 0x34, 0xD3, 0x4C, 0x37, 0xEC, 0x3A,
		0x63, 0x69, 0xFD, 0x9B, 0x29, 0xFC, 0x20, 0xAB, 0xB2, 0x25, 0xA2, 0x50, 0x21, 0x37, 0xD8, 0x60}
	};

#ifdef 	INCLUDE_1ST_FORM_TEST
	RSA_private_key PrivateKey4_1stForm = {&n4, &d4, NULL, NULL, NULL, NULL, NULL};
#endif
	RSA_private_key PrivateKey4_2ndForm = {&n4, NULL, &p4, &q4, &dP4, &dQ4, &qInv4};
	RSA_public_key PublicKey4 = {&n4, &bn_e};

	bignum Sig;
	bn_len_type i;

	// test 5 : 2048 bits RSA Key Pair 에 대해서 RSASSA-PKCS1-V1_5 sign (private key 두 가지 유형에 대해 각기) & verify
	HxLOG_Print("\n RSA_Test (test 5) Start... \n");
#ifdef 	INCLUDE_1ST_FORM_TEST
	if (A_RSA_PKCS1_V1_5(&PrivateKey4_1stForm, &M4, &Sig))
		HxLOG_Print(" ERROR !!!\n");
	else
	{
		HxLOG_Print(" Signature :");
		for (i = 0; i < Sig.len; i++)
		{
			if ((i & 15) == 0)
				HxLOG_Print("\n");
			HxLOG_Print(" %02x", Sig.num[i]);
		}
		HxLOG_Print("\n");
		if (bn_cmp(&Sig, &S4))
			HxLOG_Print(" invalid signature !!!\n");
		else
			HxLOG_Print(" valid signature generated \n"); // should be
	}
#endif
	if (A_RSA_PKCS1_V1_5(&PrivateKey4_2ndForm, &M4, &Sig))
		HxLOG_Print(" ERROR !!!\n");
	else
	{
		HxLOG_Print(" Signature :");
		for (i = 0; i < Sig.len; i++)
		{
			if ((i & 15) == 0)
				HxLOG_Print("\n");
			HxLOG_Print(" %02x", Sig.num[i]);
		}
		HxLOG_Print("\n");
		if (bn_cmp(&Sig, &S4))
			HxLOG_Print(" invalid signature !!!\n");
		else
			HxLOG_Print(" valid signature generated \n"); // should be
	}
	if (V_RSA_PKCS1_V1_5(&PublicKey4, &M4, &S4))
		HxLOG_Print(" valid signature verified \n"); // should be
	else
		HxLOG_Print(" invalid signature !!!\n");
	HxLOG_Print(" RSA_Test (test 5) End. \n");
}
#ifdef INCLUDE_BN_TEST
extern void BN_Test(void);
#endif
#ifdef INCLUDE_MPI_TEST
extern void MPI_Test(void);
#endif
void RSA_Test(void)
{
#ifdef INCLUDE_BN_TEST
	BN_Test();
#endif
#ifdef INCLUDE_MPI_TEST
	MPI_Test();
#endif
#ifdef INCLUDE_10XX_BITS_TEST
	RSA_Test1();	// RSASSA-PSS sign & verify test
#endif
#ifdef INCLUDE_2048_BITS_TEST
	RSA_Test2();	// RSASSA-PSS sign & verify test
#endif
	RSA_Test3();	// RSASSA-PKCS1-V1_5 sign & verify test
}
#endif // #ifdef RSA_TEST

/***************************************************************
* Padding (for AES) ////////////////////////////////////////////
***************************************************************/

unsigned short GetAlignedLen(unsigned short usOrgLen)
{
	if (usOrgLen == 0)
	{
HxLOG_Error("[CICC]---> GetAlignedLen()---> Error : usOrgLen is zero\n");
		return CI_CC_CIPHER_BLOCK_SIZE;
	}

	if ((usOrgLen & CI_CC_CIPHER_BLOCK_SIZE_1) == 0) // if (usOrgLen % CI_CC_CIPHER_BLOCK_SIZE == 0)
	{
HxLOG_Error("[CICC]---> GetAlignedLen()---> Error : usOrgLen(%d)---> already aligned\n", usOrgLen);
		return usOrgLen;
	}

	return (usOrgLen / CI_CC_CIPHER_BLOCK_SIZE + 1) * CI_CC_CIPHER_BLOCK_SIZE;
}

void OneAndZeroesPadding(unsigned char *pucData, unsigned short usOrgLen)
	/* 입력 데이터의 공간 크기는 CI_CC_CIPHER_BLOCK_SIZE 의 배수이어야 한다. see GetAlignedLen(). */
{
	unsigned short usPaddingLen;

	if (usOrgLen == 0)
	{
HxLOG_Error("[CICC]---> OneAndZeroesPadding()---> Error : usOrgLen is zero\n");
		pucData[0] = 0x80;
		HxSTD_memset(&pucData[1], 0x00, CI_CC_CIPHER_BLOCK_SIZE-1);
		return;
	}

	if ((usOrgLen & CI_CC_CIPHER_BLOCK_SIZE_1) == 0) // if (usOrgLen % CI_CC_CIPHER_BLOCK_SIZE == 0)
	{
HxLOG_Error("[CICC]---> OneAndZeroesPadding()---> Error : usOrgLen(%d)---> no padding required\n", usOrgLen);
		return;
	}

	usPaddingLen = (usOrgLen / CI_CC_CIPHER_BLOCK_SIZE + 1) * CI_CC_CIPHER_BLOCK_SIZE - usOrgLen;

	pucData[usOrgLen] = 0x80;
	HxSTD_memset(&pucData[usOrgLen+1], 0x00, usPaddingLen-1);
}

/***************************************************************
* AES (AES-x-ECB and AES-x-CBC, x = 128, 192, 256) /////////////
***************************************************************/

#define Nb	4							/* The number of columns comprising a state in AES. This value 4 is a constant in AES. */ /* Nb*4 = CI_CC_CIPHER_BLOCK_SIZE */
static int Nk;							/* The number of 32 bit words in the key. Nk=128/32=4 for AES-128 and 6/8 for AES-192/256 */ /* Nk*4 = CI_CC_CIPHER_KEY_LEN */
static int Nr;							/* The number of rounds in AES Cipher. Nr=Nk+6=4+6=10 for AES-128 and 12/14 for AES-192/256 */
//static unsigned char in[16];			/* holds the PlainText to be encrypted or the CipherText to be decrypted. Nb*4 */
//static unsigned char out[16];			/* the CipherText or the PlainText as output of AES encryption or descryption. Nb*4 */
//static unsigned char Key[32];			/* key input to the AES Program. Nk*4 -> max 32 */
static unsigned char RoundKey[240];	/* stores the round keys used in each round to encrypt/decrypt the states. */
static unsigned char state[4][4];		/* holds the intermediate results during encryption or decryption. */
static int sbox[256] =					/* S-box: substitution values for the byte xy */
{
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};
static int rsbox[256] =				/* Inverse S-box: substitution values for the byte xy */
{
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};
static int Rcon[255] =					/* The round constant word array, Rcon[i], contains the values given by x to th e power (i-1) being powers of x (x is denoted as {02}) in the field GF(2^8) */
{
	0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
	0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
	0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
	0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
	0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
	0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
	0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
	0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
	0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
	0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
	0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
	0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
	0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
	0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
	0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
	0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb
};

#define getSBoxValue(num)		sbox[num]
#define getSBoxInvert(num)	rsbox[num]
#define xtime(x)				((x<<1) ^ (((x>>7) & 1) * 0x1b))	/* xtime is a macro that finds the product of {02} and the argument to xtime modulo {1b} */
#define Multiply(x,y)			(((y & 1) * x) ^ ((y>>1 & 1) * xtime(x)) ^ ((y>>2 & 1) * xtime(xtime(x))) ^ ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^ ((y>>4 & 1) * xtime(xtime(xtime(xtime(x)))))) /* Multiply is a macro used to multiply numbers in the field GF(2^8) */

static void KeyExpansion(unsigned char *Key) /* This function produces Nb(Nr+1) round keys. */
{
	int i, j;
	unsigned char temp[4], k;
	int i4, i14, iNk4, NbNr1 = Nb * (Nr+1);

	// The first round key is the key itself.
	for(i=0;i<Nk;i++)
	{
		i4 = i * 4;

		RoundKey[i4]=Key[i4];
		RoundKey[i4+1]=Key[i4+1];
		RoundKey[i4+2]=Key[i4+2];
		RoundKey[i4+3]=Key[i4+3];
	}

	// All other round keys are found from the previous round keys.
	while (i < NbNr1)
	{
		i14 = (i-1) * 4;
		i4 = i * 4;
		iNk4 = (i-Nk) * 4;

		for(j=0;j<4;j++)
		{
			temp[j]=RoundKey[i14 + j];
		}
		if (i % Nk == 0)
		{
			// This function rotates the 4 bytes in a word to the left once.
			// [a0,a1,a2,a3] becomes [a1,a2,a3,a0]

			// Function RotWord()
			{
				k = temp[0];
				temp[0] = temp[1];
				temp[1] = temp[2];
				temp[2] = temp[3];
				temp[3] = k;
			}

			// SubWord() is a function that takes a four-byte input word and
			// applies the S-box to each of the four bytes to produce an output word.

			// Function Subword()
			{
				temp[0]=getSBoxValue(temp[0]);
				temp[1]=getSBoxValue(temp[1]);
				temp[2]=getSBoxValue(temp[2]);
				temp[3]=getSBoxValue(temp[3]);
			}

			temp[0] =  temp[0] ^ Rcon[i/Nk];
		}
		else if (Nk > 6 && i % Nk == 4)
		{
			// Function Subword()
			{
				temp[0]=getSBoxValue(temp[0]);
				temp[1]=getSBoxValue(temp[1]);
				temp[2]=getSBoxValue(temp[2]);
				temp[3]=getSBoxValue(temp[3]);
			}
		}
		RoundKey[i4+0] = RoundKey[iNk4+0] ^ temp[0];
		RoundKey[i4+1] = RoundKey[iNk4+1] ^ temp[1];
		RoundKey[i4+2] = RoundKey[iNk4+2] ^ temp[2];
		RoundKey[i4+3] = RoundKey[iNk4+3] ^ temp[3];
		i++;
	}
}

static void AddRoundKey(int round) /* This function adds the round key to state. The round key is added to the state by an XOR function. */
{
	int i, j;
	int r4 = round * 4, rr;

	for(i=0;i<4;i++)
	{
		rr = (r4 + i) * Nb;

		for(j=0;j<4;j++)
		{
			state[j][i] ^= RoundKey[rr + j]; // state[j][i] ^= RoundKey[round * Nb * 4 + i * Nb + j];
		}
	}
}

static void SubBytes(void) /* This function substitutes the values in the state matrix with values in an S-box. */
{
	int i, j;

	for(i=0;i<4;i++)
	{
		for(j=0;j<4;j++)
		{
			state[i][j] = getSBoxValue(state[i][j]);
		}
	}
}

static void InvSubBytes(void) /* This function substitutes the values in the state matrix with values in an Inverse S-box. */
{
	int i, j;

	for(i=0;i<4;i++)
	{
		for(j=0;j<4;j++)
		{
			state[i][j] = getSBoxInvert(state[i][j]);
		}
	}
}

static void ShiftRows(void) /* This function shifts the rows in the state to the left. Each row is shifted with different offset. Offset = Row number. So the first row is not shifted. */
{
	unsigned char temp;

	// Rotate first row 1 columns to left
	temp=state[1][0];
	state[1][0]=state[1][1];
	state[1][1]=state[1][2];
	state[1][2]=state[1][3];
	state[1][3]=temp;

	// Rotate second row 2 columns to left
	temp=state[2][0];
	state[2][0]=state[2][2];
	state[2][2]=temp;

	temp=state[2][1];
	state[2][1]=state[2][3];
	state[2][3]=temp;

	// Rotate third row 3 columns to left
	temp=state[3][0];
	state[3][0]=state[3][3];
	state[3][3]=state[3][2];
	state[3][2]=state[3][1];
	state[3][1]=temp;
}

static void InvShiftRows(void) /* This function shifts the rows in the state to the right. Each row is shifted with different offset. Offset = Row number. So the first row is not shifted. */
{
	unsigned char temp;

	// Rotate first row 1 columns to right
	temp=state[1][3];
	state[1][3]=state[1][2];
	state[1][2]=state[1][1];
	state[1][1]=state[1][0];
	state[1][0]=temp;

	// Rotate second row 2 columns to right
	temp=state[2][0];
	state[2][0]=state[2][2];
	state[2][2]=temp;

	temp=state[2][1];
	state[2][1]=state[2][3];
	state[2][3]=temp;

	// Rotate third row 3 columns to right
	temp=state[3][0];
	state[3][0]=state[3][1];
	state[3][1]=state[3][2];
	state[3][2]=state[3][3];
	state[3][3]=temp;
}

static void MixColumns(void) /* This function mixes the columns of the state matrix. */
{
	int i;
	unsigned char Tmp, Tm, t;

	for(i=0;i<4;i++)
	{
		t = state[0][i];
		Tmp = state[0][i] ^ state[1][i] ^ state[2][i] ^ state[3][i] ;
		Tm = state[0][i] ^ state[1][i] ; Tm = xtime(Tm); state[0][i] ^= Tm ^ Tmp ;
		Tm = state[1][i] ^ state[2][i] ; Tm = xtime(Tm); state[1][i] ^= Tm ^ Tmp ;
		Tm = state[2][i] ^ state[3][i] ; Tm = xtime(Tm); state[2][i] ^= Tm ^ Tmp ;
		Tm = state[3][i] ^ t ; Tm = xtime(Tm); state[3][i] ^= Tm ^ Tmp ;
	}
}

static void InvMixColumns(void) /* This function mixes the columns of the state matrix. */
{
	int i;
	unsigned char a, b, c, d;

	for(i=0;i<4;i++)
	{
		a = state[0][i];
		b = state[1][i];
		c = state[2][i];
		d = state[3][i];

		state[0][i] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
		state[1][i] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
		state[2][i] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
		state[3][i] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
	}
}

static void Cipher(unsigned char *in, unsigned char *out) /* This is the main function that encrypts the PlainText. */
{
	int i, j, round = 0;
	int i4;

	// Copy the input PlainText to state array.
	for(i=0;i<4;i++)
	{
		i4 = i * 4;

		for(j=0;j<4;j++)
		{
			state[j][i] = in[i4 + j];
		}
	}

	// Add the First round key to the state before starting the rounds.
	AddRoundKey(0);

	// There will be Nr rounds.
	// The first Nr-1 rounds are identical.
	// These Nr-1 rounds are executed in the loop below.
	for(round=1;round<Nr;round++)
	{
		SubBytes();
		ShiftRows();
		MixColumns();
		AddRoundKey(round);
	}

	// The last round is given below.
	// The MixColumns function is not here in the last round.
	SubBytes();
	ShiftRows();
	AddRoundKey(Nr);

	// The encryption process is over.
	// Copy the state array to output array.
	for(i=0;i<4;i++)
	{
		i4 = i * 4;

		for(j=0;j<4;j++)
		{
			out[i4+j]=state[j][i];
		}
	}
}

static void InvCipher(unsigned char *in, unsigned char *out) /* This is the main function that decrypts the CipherText. */
{
	int i, j, round = 0;
	int i4;

	// Copy the input CipherText to state array.
	for(i=0;i<4;i++)
	{
		i4 = i * 4;

		for(j=0;j<4;j++)
		{
			state[j][i] = in[i4 + j];
		}
	}

	// Add the First round key to the state before starting the rounds.
	AddRoundKey(Nr);

	// There will be Nr rounds.
	// The first Nr-1 rounds are identical.
	// These Nr-1 rounds are executed in the loop below.
	for(round=Nr-1;round>0;round--)
	{
		InvShiftRows();
		InvSubBytes();
		AddRoundKey(round);
		InvMixColumns();
	}

	// The last round is given below.
	// The MixColumns function is not here in the last round.
	InvShiftRows();
	InvSubBytes();
	AddRoundKey(0);

	// The decryption process is over.
	// Copy the state array to output array.
	for(i=0;i<4;i++)
	{
		i4 = i * 4;

		for(j=0;j<4;j++)
		{
			out[i4+j]=state[j][i];
		}
	}
}

void E_AES_x(int x, unsigned char *Key, unsigned char *PlainText, unsigned char *CipherText) /* ECB mode */
	/* Key 길이는 Nk*4 이어야 한다. PlainText, CipherText 길이는 CI_CC_CIPHER_BLOCK_SIZE 이어야 한다. */
{
	if (x != 128 && x != 192 && x != 256)
	{
		HxLOG_Error("[CICC]---> E_AES_x()---> Error : x(%d)---> must be 128 or 192 or 256 !!!\n", x);
		return;
	}

	Nk = x / 32;
	Nr = Nk + 6;

	KeyExpansion(Key); // The Key-Expansion routine must be called before the encryption routine.
	Cipher(PlainText, CipherText); // The next function call encrypts the PlainText with the Key using AES algorithm.
}

void D_AES_x(int x, unsigned char *Key, unsigned char *CipherText, unsigned char *PlainText) /* ECB mode */
	/* Key 길이는 Nk*4 이어야 한다. PlainText, CipherText 길이는 CI_CC_CIPHER_BLOCK_SIZE 이어야 한다. */
{
	if (x != 128 && x != 192 && x != 256)
	{
		HxLOG_Error("[CICC]---> D_AES_x()---> Error : x(%d)---> must be 128 or 192 or 256 !!!\n", x);
		return;
	}

	Nk = x / 32;
	Nr = Nk + 6;

	KeyExpansion(Key); // The Key-Expansion routine must be called before the decryption routine.
	InvCipher(CipherText, PlainText); // The next function call decrypts the CipherText with the Key using AES algorithm.
}

void E_AES_x_CBC(int x, unsigned char *Key, unsigned char *PlainText, unsigned char *CipherText, unsigned short TextLen, unsigned char *IV)
	/* Key 길이는 Nk*4 이어야 한다. PlainText, CipherText 길이(TextLen값)는 CI_CC_CIPHER_BLOCK_SIZE 의 배수이어야 한다. see OneAndZeroesPadding(). */
{
	unsigned char V[CI_CC_CIPHER_BLOCK_SIZE];
	unsigned short i, j;

	if (TextLen == 0 || TextLen & CI_CC_CIPHER_BLOCK_SIZE_1) // if (TextLen == 0 || TextLen % CI_CC_CIPHER_BLOCK_SIZE)
	{
		HxLOG_Error("[CICC]---> E_AES_x_CBC()---> Error : TextLen(%d)---> padding required !!!\n", TextLen);
		return;
	}

	if (x != 128 && x != 192 && x != 256)
	{
		HxLOG_Error("[CICC]---> E_AES_x_CBC()---> Error : x(%d)---> must be 128 or 192 or 256 !!!\n", x);
		return;
	}

	Nk = x / 32;
	Nr = Nk + 6;

	KeyExpansion(Key);

	for (i = 0; i < CI_CC_CIPHER_BLOCK_SIZE; i++)
		V[i] = IV[i] ^ PlainText[i];

	Cipher(V, CipherText);

	for (i = CI_CC_CIPHER_BLOCK_SIZE; i < TextLen; i += CI_CC_CIPHER_BLOCK_SIZE)
	{
		for (j = 0; j < CI_CC_CIPHER_BLOCK_SIZE; j++)
			V[j] = CipherText[i-CI_CC_CIPHER_BLOCK_SIZE+j] ^ PlainText[i+j];

		Cipher(V, &CipherText[i]);
	}
}

void D_AES_x_CBC(int x, unsigned char *Key, unsigned char *CipherText, unsigned char *PlainText, unsigned short TextLen, unsigned char *IV)
	/* Key 길이는 Nk*4 이어야 한다. PlainText, CipherText 길이(TextLen값)는 CI_CC_CIPHER_BLOCK_SIZE 의 배수이어야 한다. see OneAndZeroesPadding(). */
{
	unsigned short i, j;

	if (TextLen == 0 || TextLen & CI_CC_CIPHER_BLOCK_SIZE_1) // if (TextLen == 0 || TextLen % CI_CC_CIPHER_BLOCK_SIZE)
	{
		HxLOG_Error("[CICC]---> D_AES_x_CBC()---> Error : TextLen(%d)---> padding required !!!\n", TextLen);
		return;
	}

	if (x != 128 && x != 192 && x != 256)
	{
		HxLOG_Error("[CICC]---> D_AES_x_CBC()---> Error : x(%d)---> must be 128 or 192 or 256 !!!\n", x);
		return;
	}

	Nk = x / 32;
	Nr = Nk + 6;

	KeyExpansion(Key);

	InvCipher(CipherText, PlainText);

	for (i = 0; i < CI_CC_CIPHER_BLOCK_SIZE; i++)
		PlainText[i] = IV[i] ^ PlainText[i];

	for (i = CI_CC_CIPHER_BLOCK_SIZE; i < TextLen; i += CI_CC_CIPHER_BLOCK_SIZE)
	{
		InvCipher(&CipherText[i], &PlainText[i]);

		for (j = 0; j < CI_CC_CIPHER_BLOCK_SIZE; j++)
			PlainText[i+j] = CipherText[i-CI_CC_CIPHER_BLOCK_SIZE+j] ^ PlainText[i+j];
	}
}

void AES_XCBC_MAC(unsigned char Key[16], unsigned char *M, unsigned short Len, unsigned char MAC[16])
{
	unsigned short usAlignedLen, i = 0, j;
	unsigned char *pucBuf = NULL;

	unsigned char K1[16] = {0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01};
	unsigned char K2[16] = {0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02};
	unsigned char K3[16] = {0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03};

	usAlignedLen = GetAlignedLen(Len);
	pucBuf = (unsigned char *)OxCAS_Malloc(usAlignedLen);
	if(pucBuf != NULL)
	{
		HxSTD_memcpy(pucBuf, M, Len);
		OneAndZeroesPadding(pucBuf, Len);

		E_AES_ECB(Key, K1, K1);
		E_AES_ECB(Key, K2, K2);
		E_AES_ECB(Key, K3, K3);

		HxSTD_memset(MAC, 0x00, 16);

		for (i = 0; i < usAlignedLen-16; i+=16)
		{
			for (j = 0; j < 16; j++)
				MAC[j] ^= pucBuf[i+j];
			E_AES_ECB(K1, MAC, MAC);
		}

		for (j = 0; j < 16; j++)
			MAC[j] ^= pucBuf[i+j];

		if (Len == 0 || Len & 15)
		{
			for (j = 0; j < 16; j++)
				MAC[j] ^= K3[j];
		}
		else
		{
			for (j = 0; j < 16; j++)
				MAC[j] ^= K2[j];
		}

		E_AES_ECB(K1, MAC, MAC);

		OxCAS_Free(pucBuf);
	}
}

#ifdef AES_TEST
static void AES_ECB_Test(void)
{
												/* 1	 2	  3 	4	  5    6	 7	  8 	9	 10    11	12	  13   14	 15   16 */
	unsigned char AES_Test_Key[16] 			= {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};
	unsigned char AES_Test_PlainText[16] 		= {0x32,0x43,0xf6,0xa8,0x88,0x5a,0x30,0x8d,0x31,0x31,0x98,0xa2,0xe0,0x37,0x07,0x34};
	unsigned char AES_Test_CipherText[16]	= {0x39,0x25,0x84,0x1d,0x02,0xdc,0x09,0xfb,0xdc,0x11,0x85,0x97,0x19,0x6a,0x0b,0x32};
	unsigned char AES_Test_ResultText[16];

	HxLOG_Print("\n AES_ECB_Test (Encrypt) Start... ");
	E_AES_ECB(AES_Test_Key, AES_Test_PlainText, AES_Test_ResultText);
	if (HxSTD_memcmp(AES_Test_ResultText, AES_Test_CipherText, 16) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");
	HxLOG_Print("\n AES_ECB_Test (Encrypt) End. \n");

	HxLOG_Print("\n AES_ECB_Test (Decrypt) Start... ");
	D_AES_ECB(AES_Test_Key, AES_Test_CipherText, AES_Test_ResultText);
	if (HxSTD_memcmp(AES_Test_ResultText, AES_Test_PlainText, 16) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");
	HxLOG_Print("\n AES_ECB_Test (Decrypt) End. \n");
}
static void AES_CBC_Test(void)
{
												 /* 1     2    3     4     5    6     7    8     9    10    11   12    13   14    15   16 */
	unsigned char AES_Test_Key[16] 			= {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};
	unsigned char AES_Test_IV[16]				= {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f};
	unsigned char AES_Test_PlainText[4*16]	= {0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
												   0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
												   0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef,
												   0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10};
	unsigned char AES_Test_CipherText[4*16]	= {0x76,0x49,0xab,0xac,0x81,0x19,0xb2,0x46,0xce,0xe9,0x8e,0x9b,0x12,0xe9,0x19,0x7d,
												   0x50,0x86,0xcb,0x9b,0x50,0x72,0x19,0xee,0x95,0xdb,0x11,0x3a,0x91,0x76,0x78,0xb2,
												   0x73,0xbe,0xd6,0xb8,0xe3,0xc1,0x74,0x3b,0x71,0x16,0xe6,0x9e,0x22,0x22,0x95,0x16,
												   0x3f,0xf1,0xca,0xa1,0x68,0x1f,0xac,0x09,0x12,0x0e,0xca,0x30,0x75,0x86,0xe1,0xa7};
	unsigned char AES_Test_ResultText[4*16];

	HxLOG_Print("\n AES_CBC_Test (Encrypt) Start... ");
	E_AES_CBC(AES_Test_Key, AES_Test_PlainText, AES_Test_ResultText, 4*16, AES_Test_IV);
	if (HxSTD_memcmp(AES_Test_ResultText, AES_Test_CipherText, 4*16) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");
	HxLOG_Print("\n AES_CBC_Test (Encrypt) End. \n");

	HxLOG_Print("\n AES_CBC_Test (Decrypt) Start... ");
	D_AES_CBC(AES_Test_Key, AES_Test_CipherText, AES_Test_ResultText, 4*16, AES_Test_IV);
	if (HxSTD_memcmp(AES_Test_ResultText, AES_Test_PlainText, 4*16) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");
	HxLOG_Print("\n AES_CBC_Test (Decrypt) End. \n");
}
static void AES_XCBC_MAC_Test(void)
{
	unsigned char Key[16]	= {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f};

	unsigned char M1[]		= {/* <empty string> */};
	unsigned char MAC1[16]	= {0x75,0xf0,0x25,0x1d,0x52,0x8a,0xc0,0x1c,0x45,0x73,0xdf,0xd5,0x84,0xd7,0x9f,0x29};

	unsigned char M2[3]		= {0x00,0x01,0x02};
	unsigned char MAC2[16]	= {0x5b,0x37,0x65,0x80,0xae,0x2f,0x19,0xaf,0xe7,0x21,0x9c,0xee,0xf1,0x72,0x75,0x6f};

	unsigned char M3[16]	= {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f};
	unsigned char MAC3[16]	= {0xd2,0xa2,0x46,0xfa,0x34,0x9b,0x68,0xa7,0x99,0x98,0xa4,0x39,0x4f,0xf7,0xa2,0x63};

	unsigned char M4[20]	= {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13};
	unsigned char MAC4[16]	= {0x47,0xf5,0x1b,0x45,0x64,0x96,0x62,0x15,0xb8,0x98,0x5c,0x63,0x05,0x5e,0xd3,0x08};

	unsigned char M5[32]	= {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
								0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f};
	unsigned char MAC5[16]	= {0xf5,0x4f,0x0e,0xc8,0xd2,0xb9,0xf3,0xd3,0x68,0x07,0x73,0x4b,0xd5,0x28,0x3f,0xd4};

	unsigned char M6[34]	= {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
								0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,0x21};
	unsigned char MAC6[16]	= {0xbe,0xcb,0xb3,0xbc,0xcd,0xb5,0x18,0xa3,0x06,0x77,0xd5,0x48,0x1f,0xb6,0xb4,0xd8};

	unsigned char M7[1000]	= {0x00,};
	unsigned char MAC7[16]	= {0xf0,0xda,0xfe,0xe8,0x95,0xdb,0x30,0x25,0x37,0x61,0x10,0x3b,0x5d,0x84,0x52,0x8f};

	unsigned char MAC[16];

	HxLOG_Print("\n AES_XCBC_MAC_Test Start... ");

	MAC_AES_XCBC(Key, M1, 0, MAC);
	if (HxSTD_memcmp(MAC, MAC1, 16) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");

	MAC_AES_XCBC(Key, M2, 3, MAC);
	if (HxSTD_memcmp(MAC, MAC2, 16) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");

	MAC_AES_XCBC(Key, M3, 16, MAC);
	if (HxSTD_memcmp(MAC, MAC3, 16) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");

	MAC_AES_XCBC(Key, M4, 20, MAC);
	if (HxSTD_memcmp(MAC, MAC4, 16) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");

	MAC_AES_XCBC(Key, M5, 32, MAC);
	if (HxSTD_memcmp(MAC, MAC5, 16) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");

	MAC_AES_XCBC(Key, M6, 34, MAC);
	if (HxSTD_memcmp(MAC, MAC6, 16) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");

	MAC_AES_XCBC(Key, M7, 1000, MAC);
	if (HxSTD_memcmp(MAC, MAC7, 16) == 0)
		HxLOG_Print(" OK"); // should be
	else
		HxLOG_Print(" NOT OK !!!");

	HxLOG_Print("\n AES_XCBC_MAC_Test End. \n");
}
void AES_Test(void)
{
	AES_ECB_Test();
	AES_CBC_Test();
	AES_XCBC_MAC_Test();
}
#endif

/***************************************************************
* PRNG (AES Based) /////////////////////////////////////////////
***************************************************************/

static void Counter(unsigned char *count, int i) /* count의 공간 크기가 16 이라면 초기 i 값은 15 이어야 한다. */
{
	if (i > 0)
	{
		if (count[i] == 0xff)
		{
			count[i] = 0x00;
			Counter(count, i-1); // recursive
		}
		else
		{
			count[i]++;
		}
	}
	else
	{
		if (count[0] == 0xff)
			count[0] = 0x00;
		else
			count[0]++;
	}
}

static unsigned char K[CI_CC_CIPHER_KEY_LEN]    = {0x62,0x79,0x20,0x68,0x6D,0x6B,0x69,0x6D,0x2C,0x20,0x68,0x75,0x6D,0x61,0x78,0x2E}; /* const */
static unsigned char D[CI_CC_CIPHER_BLOCK_SIZE] = {0x00,};

void PRNG(unsigned char *S, unsigned char *R) /* S, R의 공간 크기는 CI_CC_CIPHER_BLOCK_SIZE 이어야 한다. */
{
	int i;
	unsigned char I[CI_CC_CIPHER_BLOCK_SIZE];

	Counter(D, CI_CC_CIPHER_BLOCK_SIZE-1);		// D updated using monotonic counter (date/time vector를 이용하는 것이 좋겠지만 여기서는 간단히 monotonic counter를 사용하도록 한다)

	E_AES_ECB(K, D, I);

	for (i = 0; i < CI_CC_CIPHER_BLOCK_SIZE; i++)
		I[i] ^= S[i];

	E_AES_ECB(K, I, R);	// R 유도

	for (i = 0; i < CI_CC_CIPHER_BLOCK_SIZE; i++)
		I[i] ^= R[i];

	E_AES_ECB(K, I, S);	// 다음에 사용될 seed 유도
}

#ifdef PRNG_TEST
void PRNG_Test(void)
{
	unsigned char S[CI_CC_CIPHER_BLOCK_SIZE] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f};
	unsigned char R[CI_CC_CIPHER_BLOCK_SIZE];
	int i, j;

	HxLOG_Print("\n PRNG_Test (Counter) Start... \n");
	for (i = 0; i < 0xff; i++)
	{
		Counter(D, CI_CC_CIPHER_BLOCK_SIZE-1);
		for (j = 0; j < CI_CC_CIPHER_BLOCK_SIZE; j++)
			HxLOG_Print(" %02x", D[j]);
		HxLOG_Print("\n");
	}
	HxLOG_Print(" PRNG_Test (Counter) End. \n");

	HxLOG_Print("\n PRNG_Test (PRNG) Start... \n");
	for (i = 0; i < 0xff; i++)
	{
		PRNG(S, R);
		for (j = 0; j < CI_CC_CIPHER_BLOCK_SIZE; j++)
			HxLOG_Print(" %02x", R[j]);
		HxLOG_Print("\n");
	}
	HxLOG_Print(" PRNG_Test (PRNG) End. \n");
}
#endif

