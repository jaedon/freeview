/*******************************************************************
	File Description
*******************************************************************/
/*++
	@file   	 cxcore_stream.c
	@brief  	 stream table 관리 등등

	Description: File에 대한 설명을 적습니다.		\n
	Module: Layer와 모듈 명을 적습니다.			 	\n
	Remarks : 										\n

	Copyright (c) 2011 HUMAX Co., Ltd.				\n
	All rights reserved.							\n
--*/
/*******************************************************************/
/*
* Character encoding.
*
* MS949
*
* This source file that uses MS949 encoding.
* MS949 encoding 을 사용하는 source file 입니다.
* MS949 encodingを使用して source fileです。
* Quelldatei, die MS949-Codierung verwendet.
*
*/


/*
* ⓒ 2011-2012 Humax Co., Ltd.
* This program is produced by Humax Co., Ltd. ("Humax") and
* the proprietary Software of Humax and its licensors. Humax provides you, as an Authorized Licensee,
* non-assignable, non-transferable and non-exclusive license to use this Software.
* You acknowledge that this Software contains valuable trade secrets of Humax and by using this Software
* you agree to the responsibility to take all reasonable efforts to protect the any information
* you receive from Humax. You are not permitted to duplicate, modify, distribute, sell or lease and
* reverse engineer or extract the source code of this Software unless you have Humax's written permission to do so.
* If you have no authorized license, discontinue using this Software immediately.
*
* THE SOFTWARE IS PROVIDED "AS IS" AND HUMAX MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS,
* IMPLIED OR STATUTORY, OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.
* IN NO EVENT SHALL HUMAX BE LIABLE FOR LOST PROFITS, REVENUES, OR DATA, FINANCIAL LOSSES OR INDIRECT, SPECIAL,
*  CONSEQUENTIAL, EXEMPLARTY OR PUNITIVE DAMAGES WHATSOEVER RELATING TO YOUR USE OR INABILITY TO USE THE SOFTWARE.
*
* This License is effective until terminated. You may terminate this License at any time by destroying all copies
* of the Software including all documentation. This License will terminate immediately without notice from Humax
* to you if you fail to comply with any provision of this License. Upon termination, you must destroy all copies
* of the Software and all documentation.
*
* The laws of the Republic of Korea will apply to any disputes arising out of or relating to this Copyright Notice.
* All claims arising out of or relating to this Copyright Notice will be litigated in the Seoul Central District Court,
* in the Republic of Korea.
*/
/*******************************************************************/
#define ________CXCORE_STREAM_Private_Include_________________________________
/*******************************************************************/
#include <_svc_cas_sub_svc_api.h>

#include <cxmgr_action.h>
#include "../local_include/cxcore_main.h"
#include "../local_include/cxcore_os.h"
#include "../local_include/cxcore_ecm.h"
#include "../local_include/cxcore_stream.h"
#include "../local_include/cxcore_session.h"
#include "../local_include/cxcore_sc.h"

#if defined(CONFIG_MW_CAS_CONAX_CPM)
#include "../local_include/cxcore_cpm.h"
#endif

#include "../local_include/cx_dscr.h"
/*******************************************************************/
#define ________CXCORE_STREAM_Golbal_Value____________________________________
/*******************************************************************/
/*******************************************************************/
#define ________CXCORE_STREAM_Private_Define__________________________________
/*******************************************************************/
typedef enum
{
	eCxStream_NotUsed,
	eCxStream_Used,
} CxStreamState_t;

// information about each elementary stream
typedef struct
{
	HUINT16			usPid;
	//CAS_EsType_t 	eType;
	CxStreamState_t	eState;
	Handle_t		hSession;
	Handle_t		hEcm;
	Handle_t		hDescrambler;
#if defined(CONFIG_MW_CAS_CONAX_CPM)
	HUINT16			usCwpkId;
#endif
} CxStream_t;

/*******************************************************************/
#define ________CXCORE_STREAM_Private_Static_Value____________________________
/*******************************************************************/
STATIC HULONG	s_ulCxStreamSemId;

// elementary stream table
STATIC CxStream_t		s_astCxStream[CX_MAX_NUM_OF_ES];

/*******************************************************************/
#define ________CXCORE_STREAM_Global_Value____________________________________
/*******************************************************************/
/*******************************************************************/
#define ________CXCORE_STREAM_Private_Static_Prototype________________________
/*******************************************************************/
STATIC HERROR local_cxstream_OpenDescrambler(int nIdx, Handle_t hSession);
STATIC HERROR local_cxstream_CloseDescrambler(int nIdx);

STATIC HUINT16 local_cxstream_GetEcmPidFromPmt(Handle_t hSession, SvcCas_PmtInfo_t* pstPmtInfo, SvcCas_PmtElement_t* pstEsInfo);
STATIC HERROR local_cxstream_Add(Handle_t hSession, SvcCas_PmtInfo_t* pstPmtInfo, SvcCas_PmtElement_t* pstEsInfo);
STATIC HERROR local_cxstream_Delete(HINT32 nIdx);
STATIC HERROR local_cxstream_LinkEcm(Handle_t hSession, HINT32 nIdx, HUINT16 usEcmPid);
STATIC HERROR local_cxstream_UnlinkEcm(HINT32 nIdx);
STATIC HERROR local_cxstream_StartEcmFilter(HINT32 nIdx);
STATIC HERROR local_cxstream_StopEcmFilter(HINT32 nIdx);
/*******************************************************************/
#define ________CXCORE_STREAM_Private_Static_Prototype_Body___________________
/*******************************************************************/
/*******************************************************************/
#define ________CXCORE_STREAM_Public_Functions_Body___________________________
/*******************************************************************/
#define INIT_________________________________________________

HERROR CXSTREAM_InitCore(void)
{
	int		i;
	HINT32	nResult			= 0;

	ENTER_FUNCTION;

	nResult = CX_SEM_Create("CxCStrSem", &s_ulCxStreamSemId);
	if (nResult != ERR_OK)
	{
		HxLOG_Error("Failure in Semaphore Creation \r\n");
		LEAVE_FUNCTION;
		return ERR_FAIL;
	}

	CX_memset(s_astCxStream, 0, sizeof(CxStream_t) * CX_MAX_NUM_OF_ES);

	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		s_astCxStream[i].usPid = PID_NULL;
		//		s_astCxStream[i].eType 			= eEsType_None;
		s_astCxStream[i].eState = eCxStream_NotUsed;
		s_astCxStream[i].hSession = HANDLE_NULL;
		s_astCxStream[i].hEcm = HANDLE_NULL;
		s_astCxStream[i].hDescrambler = HANDLE_NULL;
#if defined(CONFIG_MW_CAS_CONAX_CPM)
		s_astCxStream[i].usCwpkId = 0;
#endif
	}

	LEAVE_FUNCTION;
	return ERR_OK;
}

#define DESCRAMBLER__________________________________________________

// 무조건 descrambler slot을 open 하는 것은 아니고, 연관된 ecm이 있는지 (scrambled 방송인지)확인 하고 open 함.
// 유효한 stream 인지, 이미 slot을 가지고 있는 지 등도 확인함.
// 이 함수를 호출하는 쪽에서는 조건 확인을 할 필요 없이, 일단 try 해본다는 개념으로.. 되면 되는거고 아니면 말고..
// nIdx는 stream table 상의 index
STATIC HERROR local_cxstream_OpenDescrambler(int nIdx, Handle_t hSession)
{
	HUINT32		ulHandle;
	HUINT8		aucCW[2][CX_CW_LENGTH];
	HUINT8* 	pucCWPK	= NULL;
#if defined(CONFIG_MW_CAS_CONAX_CPM)
	HUINT8		aucCWPK[CX_CPM_KEY_VALUE_BYTES];
#endif

	ENTER_FUNCTION;

	// for removing prevent issue
	if (nIdx < 0 || nIdx >= CX_MAX_NUM_OF_ES)
	{
		HxLOG_Error("wrong idx\r\n");
		return ERR_FAIL;
	}

	// 유효한 ES인지 확인
	if (s_astCxStream[nIdx].usPid == PID_NULL)
	{
		HxLOG_Error("null pid\r\n");
		return ERR_FAIL;
	}
	if (s_astCxStream[nIdx].eState != eCxStream_Used)
	{
		HxLOG_Error("not used stream\r\n");
		return ERR_FAIL;
	}

	// 이미 descrambler slot 할당 받았는지 확인
	if (s_astCxStream[nIdx].hDescrambler != HANDLE_NULL)
	{
		HxLOG_Error("descrambler slot is already assigned\r\n");
		return ERR_FAIL;
	}

	// hEcm 있는지 확인 (hEcm == NULL이면 free 서비스이고 descrambler 필요 없는거 같은데)
	if (s_astCxStream[nIdx].hEcm == HANDLE_NULL)
	{
		HxLOG_Error("free service\r\n");
		return ERR_FAIL;
	}

	// descrambler slot 할당
	// descrambler slot 할당
	ulHandle = CXDSCR_Open(s_astCxStream[nIdx].hEcm, nIdx, s_astCxStream[nIdx].usPid, CXACT_GetActionHandle(CXSESSION_GetStbHandle(hSession)));
	if (ulHandle == HANDLE_NULL)
	{
		HxLOG_Error("fail to open descrambler slot\r\n");
		return ERR_FAIL;
	}

	s_astCxStream[nIdx].hDescrambler = (Handle_t)ulHandle;

	// 기존에 ecm을 받아놓은게 있을지도 몰라.. 어차피 안나와도 그만이니 한번 CW 세팅을 해보자..
#if defined(CONFIG_MW_CAS_CONAX_CPM)
	if (CXECM_GetCWPK(s_astCxStream[nIdx].hEcm, aucCWPK) == ERR_OK)
	{
		pucCWPK = aucCWPK;
	}
#endif
	CXECM_GetCW(s_astCxStream[nIdx].hEcm, aucCW[0], aucCW[1]);
	CXDSCR_SetKeys(s_astCxStream[nIdx].hDescrambler, CX_CW_LENGTH, aucCW[0], CX_CW_LENGTH, aucCW[1], pucCWPK);

	LEAVE_FUNCTION;
	return ERR_OK;
}

// nIdx는 stream table 상의 index
STATIC HERROR local_cxstream_CloseDescrambler(int nIdx)
{
	ENTER_FUNCTION;

	// for removing prevent issue
	if (nIdx < 0 || nIdx >= CX_MAX_NUM_OF_ES)
	{
		HxLOG_Error("wrong idx\r\n");
		return ERR_FAIL;
	}

	// 유효한 ES인지 확인
	if (s_astCxStream[nIdx].usPid == PID_NULL)
	{
		HxLOG_Error("null pid\r\n");
		return ERR_FAIL;
	}

	// 이미 descrambler slot 할당 받았다면 close
	if (s_astCxStream[nIdx].hDescrambler != HANDLE_NULL)
	{
		//## descrambler slot close
		CXDSCR_Close(s_astCxStream[nIdx].hDescrambler, s_astCxStream[nIdx].usPid);
		s_astCxStream[nIdx].hDescrambler = HANDLE_NULL;
	}

	LEAVE_FUNCTION;
	return ERR_OK;
}

HERROR CXSTREAM_SetCW(Handle_t hEcm, HUINT32 ulOddLength, HUINT32 ulEvenLength, HUINT8* pucOddCw, HUINT8* pucEvenCw, HUINT8* pucEncKey, HUINT16 usEncKeyId)
{
	int		i;
	HUINT8	aucCW[2][CX_CW_LENGTH];

	ENTER_FUNCTION;

	if (ulOddLength && pucOddCw == NULL)
	{
		HxLOG_Error("wrong param\r\n");
		return ERR_FAIL;
	}
	if (ulEvenLength && pucEvenCw == NULL)
	{
		HxLOG_Error("wrong param\r\n");
		return ERR_FAIL;
	}

	CX_SEM_Get(s_ulCxStreamSemId);

	CX_memset(aucCW, 0x00, sizeof(aucCW));

	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		// 같은 ecm에 link된 모든 stream에 CW를 제공한다
		if (s_astCxStream[i].hEcm == hEcm && s_astCxStream[i].hDescrambler != HANDLE_NULL)
		{
			//## descrambler slot에 CW를 넣어준다
			if (ulOddLength)
			{
				CX_memcpy(aucCW[0], pucOddCw, CX_CW_LENGTH);
			}

			if (ulEvenLength)
			{
				CX_memcpy(aucCW[1], pucEvenCw, CX_CW_LENGTH);
			}

			// encrypted CW가 아니면 entropy reduction 해준다 !!
			if (pucEncKey == NULL)
			{
				if (ulOddLength)
				{
					aucCW[0][3] = aucCW[0][0] + aucCW[0][1] + aucCW[0][2];
					aucCW[0][7] = aucCW[0][4] + aucCW[0][5] + aucCW[0][6];
				}

				if (ulEvenLength)
				{
					aucCW[1][3] = aucCW[1][0] + aucCW[1][1] + aucCW[1][2];
					aucCW[1][7] = aucCW[1][4] + aucCW[1][5] + aucCW[1][6];
				}
			}

			CXDSCR_SetKeys(s_astCxStream[i].hDescrambler, ulOddLength, aucCW[0], ulEvenLength, aucCW[1], pucEncKey);

			// CW는 다음 ecm을 받기전에 쓸 일이 있을 수 있으니 보관을 해둔다.
#if defined(CONFIG_MW_CAS_CONAX_CPM)
			s_astCxStream[i].usCwpkId = usEncKeyId;//remove key 호출시 삭제하기 위해 보관...
			if (pucEncKey != NULL)
			{
				CXECM_SetCWPK(hEcm, pucEncKey);
			}
#endif

			CXECM_SetCW(hEcm, aucCW[0], ulOddLength, aucCW[1], ulEvenLength);

#ifdef CX_SUPPORT_SHARED_DESCRAMBLER_SLOT
			// descrambler slot을 공유한다면, set key도 한번만 하면 된다.
			break;
#endif
		}
	}

	CX_SEM_Release(s_ulCxStreamSemId);
	LEAVE_FUNCTION;
	return ERR_OK;
}

#define STREAM_TABLE__________________________________________________

// 주어진 es의 ecm pid를 찾는다.
STATIC HUINT16 local_cxstream_GetEcmPidFromPmt(Handle_t hSession, SvcCas_PmtInfo_t* pstPmtInfo, SvcCas_PmtElement_t* pstEsInfo)
{
	int		i;
	HUINT16	usPid;
	HUINT16	usCaSysId;
	HINT32	nRet;

	ENTER_FUNCTION;

	if (pstPmtInfo == NULL || pstEsInfo == NULL)
	{
		HxLOG_Error("wrong param\r\n");
		return PID_NULL;
	}

	nRet = CXSC_GetCaSysId(CXSESSION_GetScSlot(hSession));
	if (nRet == CX_ERR_INVALID_PARAMETER)
	{
		HxLOG_Error("fail to get ca_sys_id\r\n");
		return ERR_FAIL;
	}
	usCaSysId = (HUINT16)nRet;

	usPid = PID_NULL;

	if (pstEsInfo->bElementCaFlag)
	{
		for (i = 0; i < pstEsInfo->ulNumOfCaDescriptor; i++)
		{
			//## ca system id 비교 (ca_system_id는 카드에서 얻을 수 있을 것이다.. 그런데 카드가 없다면 어떻게 하지?)
			if (pstEsInfo->stElementCaDescriptor[i].usCaSysId == usCaSysId)
			{
				usPid = pstEsInfo->stElementCaDescriptor[i].usCaPid;
				break;
			}
		}
	}

	// 만약 elementary stream level에 ecm pid를 못찾으면 (ca_Descriptor가 없다면), program level에서 찾는다.
	if (usPid == PID_NULL)
	{
		if (pstPmtInfo->bProgramCaFlag)
		{
			for (i = 0; i < pstPmtInfo->ulNumOfProgramCaDescriptor; i++)
			{
				//## ca system id 비교 (ca_system_id는 카드에서 얻을 수 있을 것이다.. 그런데 카드가 없다면 어떻게 하지?)
				if (pstPmtInfo->stProgramCaDescriptor[i].usCaSysId == usCaSysId)
				{
					usPid = pstPmtInfo->stProgramCaDescriptor[i].usCaPid;
					break;
				}
			}
		}
	}

	HxLOG_Print("[Exit:ecm pid=%x]\r\n", usPid);
	return usPid;
}

STATIC HERROR local_cxstream_Add(Handle_t hSession, SvcCas_PmtInfo_t* pstPmtInfo, SvcCas_PmtElement_t* pstEsInfo)
{
	int		i;
	HUINT16	usEcmPid;

	ENTER_FUNCTION;

	if (pstPmtInfo == NULL || pstEsInfo == NULL)
	{
		HxLOG_Error("wrong param\r\n");
		return ERR_FAIL;
	}

	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		// 일단 pid로 빈 slot을 확인해보자
		if (s_astCxStream[i].usPid == PID_NULL)
		{
			s_astCxStream[i].usPid = pstEsInfo->usPid;
			//s_astCxStream[i].eType 	= pstEsInfo->eEsType;
			s_astCxStream[i].hSession = hSession;

			///////////////////////////////////////////////////////////////////////////////////////////////
			//
			// !!! 만약 setPid를 안쓰고 pmt 상의 모든 stream을 처리해야 한다면, 여기서 state를 무조건 used로 해주면 된다.. 참 쉽죠~잉~
			// s_astCxStream[i].eState = eCxStream_Used;
			//
			///////////////////////////////////////////////////////////////////////////////////////////////

			usEcmPid = local_cxstream_GetEcmPidFromPmt(hSession, pstPmtInfo, pstEsInfo);
			if (usEcmPid != PID_NULL)
			{
				// ecm pid가 있다면 hEcm 등록하고
				local_cxstream_LinkEcm(hSession, i, usEcmPid);

				// [improve speed]: 아래 함수 안에 들어가서도 used인지 확인 함
				if (s_astCxStream[i].eState == eCxStream_Used)
				{
					local_cxstream_StartEcmFilter(i);

					// descrambler도 등록해야지
					local_cxstream_OpenDescrambler(i, hSession);
				}
			}
			break;
		}
	}

	LEAVE_FUNCTION;
	return ERR_OK;
}

STATIC HERROR local_cxstream_Delete(HINT32 nIdx)
{
	ENTER_FUNCTION;

	if (s_astCxStream[nIdx].hSession == HANDLE_NULL)
	{
		HxLOG_Error("null handle\r\n");
		return ERR_FAIL;
	}

	// descrambler slot을 close한다
	local_cxstream_CloseDescrambler(nIdx);

	// ecm과 link 끊어요
	local_cxstream_UnlinkEcm(nIdx);

	s_astCxStream[nIdx].hSession = HANDLE_NULL;
	s_astCxStream[nIdx].eState = eCxStream_NotUsed;
	//s_astCxStream[nIdx].eType 		= eEsType_None;
	s_astCxStream[nIdx].usPid = PID_NULL;

	LEAVE_FUNCTION;
	return ERR_OK;
}

STATIC HERROR local_cxstream_LinkEcm(Handle_t hSession, HINT32 nIdx, HUINT16 usEcmPid)
{
	Handle_t	hEcm;

	ENTER_FUNCTION;

	//같은 ecm 있나 찾아보고 있으면 연결, 없으면 추가
	hEcm = CXECM_Add(hSession, usEcmPid);

	s_astCxStream[nIdx].hEcm = hEcm;

	if (hEcm == HANDLE_NULL)
	{
		HxLOG_Error("null handle\r\n");
		return ERR_FAIL;
	}

	//## ecm filter start 해야되나 ?
	//local_cxstream_StartEcmFilter(nIdx);
	LEAVE_FUNCTION;
	return ERR_OK;
}

STATIC HERROR local_cxstream_UnlinkEcm(HINT32 nIdx)
{
	ENTER_FUNCTION;

	// ecm table에서 삭제 5IAv4B ecmBJ?!<- >K>F<- GR 0E@S (filter stop55 >K>F<- GR 0M@S)
	CXECM_Delete(s_astCxStream[nIdx].hEcm);

	s_astCxStream[nIdx].hEcm = HANDLE_NULL;

	LEAVE_FUNCTION;
	return ERR_OK;
}

//stream이 not used이면 filter start 할 필요 없음
STATIC HERROR local_cxstream_StartEcmFilter(HINT32 nIdx)
{
	Handle_t	hEcm;

	ENTER_FUNCTION;

	hEcm = s_astCxStream[nIdx].hEcm;
	if (hEcm == HANDLE_NULL)
	{
		HxLOG_Error("wrong handle\r\n");
		LEAVE_FUNCTION;
		return ERR_FAIL;
	}

	if (s_astCxStream[nIdx].eState != eCxStream_Used)
	{
		HxLOG_Error("not used stream\r\n");
		LEAVE_FUNCTION;
		return ERR_FAIL;
	}

	if (CXSESSION_IsSelected(s_astCxStream[nIdx].hSession) == FALSE)
	{
		//아직 descramble하도록 선택되지 않은 상태이므로 ecm filter를 걸지 않도록 한다.
		HxLOG_Error("not selected\r\n");
		LEAVE_FUNCTION;
		return ERR_FAIL;
	}

	// filter start: both로 건다.. 이후로는 자동 toggle
	CXECM_StartFilter(hEcm, eCxEcm_Both);

	LEAVE_FUNCTION;
	return ERR_OK;
}

// 다른 session에서 쓰고 있다면 filter를 그냥 두고, 아니면 stop 시켜요
HERROR local_cxstream_StopEcmFilter(HINT32 nIdx)
{
	int			i;
	Handle_t	hEcm;
	Handle_t	hSession;

	ENTER_FUNCTION;

	hSession = s_astCxStream[nIdx].hSession;
	hEcm = s_astCxStream[nIdx].hEcm;

	if (hSession == HANDLE_NULL || hEcm == HANDLE_NULL)
	{
		HxLOG_Error("wrong param\r\n");
		return ERR_FAIL;
	}

	//다른 session에서 사용되는지 찾아보자
	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		if (s_astCxStream[i].usPid != PID_NULL &&			// 유효한 slot
			s_astCxStream[i].hSession != hSession && 		// 다른 session
			s_astCxStream[i].hEcm == hEcm && 				// 같은 ecm
			s_astCxStream[i].eState == eCxStream_Used)	// 사용중인 stream
		{
			break;
		}
	}

	if (i >= CX_MAX_NUM_OF_ES)
	{
		// 못 찾았다면 filter stop
		CXECM_StopFilter(hEcm);
	}

	LEAVE_FUNCTION;
	return ERR_OK;
}

// 각 type 별로 하나의 stream만 등록한다 치고..
//## 더 생각해보자... audio가 두개일수도 있어...
#if 0
HERROR CXSTREAM_SetPid(Handle_t hSession, CxEsPidInfo_t *pstEsInfo)
{
	int i, j;
	HBOOL bExist;

	ENTER_FUNCTION;

	if (hSession == HANDLE_NULL)
	{
		HxLOG_Error("wrong handle\r\n");
		return ERR_FAIL;
	}

	CX_SEM_Get(s_ulCxStreamSemId);

	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		if (s_astCxStream[i].usPid != PID_NULL)
		{
			bExist = FALSE;

			for (j = 0; j < pstEsInfo->ulPidNum; j++)
			{
				if (s_astCxStream[i].hSession == hSession && s_astCxStream[i].usPid == pstEsInfo->usPid[j])
				{
					bExist = TRUE;
					break;
				}
			}

			if (bExist)
			{
VK_Print("SetPID:update[%d,type:%d,pid:%x,st:%d]pid:%x\n", i,s_astCxStream[i].eType, s_astCxStream[i].usPid, s_astCxStream[i].eState, pstEsInfo->usPid[j]);
				// 이미 등록된 pid 이고, 앞으로도 사용할 pid임
				if (s_astCxStream[i].eState != eCxStream_Used)
				{
					s_astCxStream[i].eState = eCxStream_Used;
					// 아직 descrambler slot이 open되지 않았다면 open 시도
					local_cxstream_OpenDescrambler(i);
					//## ecm filter start 해야되나 ?
					local_cxstream_StartEcmFilter(i);
				}
			}
			else
			{
VK_Print("SetPID:delete[%d,type:%d,pid:%x,st:%d]pid:%x\n", i,s_astCxStream[i].eType, s_astCxStream[i].usPid, s_astCxStream[i].eState, pstEsInfo->usPid[j]);
				//있던 건데, 이제 없어질 pid
				if (s_astCxStream[i].eState != eCxStream_NotUsed)
				{
					// descrambler slot을 close한다
					local_cxstream_CloseDescrambler(i);
				}
				s_astCxStream[i].eState  = eCxStream_NotUsed;
			}
		}
	}

	for (j = 0; j < pstEsInfo->ulPidNum; j++)
	{
		if (pstEsInfo->usPid[j] != PID_NULL)
		{
			bExist = FALSE;
			for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
			{
				if (s_astCxStream[i].hSession == hSession && s_astCxStream[i].usPid == pstEsInfo->usPid[j])
				{
					bExist = TRUE;
					break;
				}
			}

			if (bExist)
			{
				// 이미 등록된 pid, 앞에서 처리했음.
			}
			else
			{
VK_Print("SetPID:add[%d,type:%d,pid:%x]\n", j,pstEsInfo->eType[j],pstEsInfo->usPid[j]);
				//기존에는 없던 건데, 새로 추가될 pid
				for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
				{
					// 일단 pid로 빈 slot을 확인해보자
					if (s_astCxStream[i].usPid == PID_NULL)
					{
						s_astCxStream[i].usPid 	= pstEsInfo->usPid[j];
						s_astCxStream[i].eType 	= pstEsInfo->eType[j];
						s_astCxStream[i].eState 	= eCxStream_Used;
						s_astCxStream[i].hSession	= hSession;
						break;
					}
				}
			}
		}
	}

	CX_SEM_Release(s_ulCxStreamSemId);

	HxLOG_Print("[Exit]3\r\n");
	return ERR_FAIL;
}
#else
//HERROR CXSTREAM_SetPid(Handle_t hSession, CAS_EsType_t eType, HUINT16 usPid, HBOOL bAdd)
HERROR CXSTREAM_SetPid(Handle_t hSession, HUINT16 usPid, HBOOL bAdd)
{
	int i;

	HxLOG_Print("[Enter(%x,%x)]\r\n", usPid, bAdd);

	if (hSession == HANDLE_NULL)
	{
		HxLOG_Error("wrong handle\r\n");
		return ERR_FAIL;
	}

	if (usPid == PID_NULL)
	{
		HxLOG_Error("null pid\r\n");
		return ERR_FAIL;
	}

	CX_SEM_Get(s_ulCxStreamSemId);

	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
//		if (s_astCxStream[i].hSession == hSession && s_astCxStream[i].eType == eType)
// type 구분을 하지 말아보자...
		if (s_astCxStream[i].hSession == hSession)
		{
			HxLOG_Print("SetPID[%d,pid:%x,st:%d]pid:%x\n", i, s_astCxStream[i].usPid, s_astCxStream[i].eState, usPid);

			if (s_astCxStream[i].usPid == usPid)
			{
				// 이미 등록된 pid (여기로 오면 pmt를 받았다는 것임)
				if (bAdd)
				{
					// 등록
					if (s_astCxStream[i].eState != eCxStream_Used)
					{
						s_astCxStream[i].eState = eCxStream_Used;
						// 아직 descrambler slot이 open되지 않았다면 open 시도
						local_cxstream_OpenDescrambler(i, hSession);
						//## ecm filter start 해야되나 ?
						local_cxstream_StartEcmFilter(i);
					}
				}
				else
				{
					// 제거
					if (s_astCxStream[i].eState != eCxStream_NotUsed)
					{
						s_astCxStream[i].eState = eCxStream_NotUsed;
						// descrambler slot을 close한다
						local_cxstream_CloseDescrambler(i);
						// ecm filter 처리 - 다른데서 쓰면 그냥 두고, 쓰지 않으면 없앤다.
//						local_cxstream_UnlinkEcm(i);
					}
				}

				CX_SEM_Release(s_ulCxStreamSemId);
				HxLOG_Print("[Exit]1\r\n");
				return ERR_OK;
			}
#if 0
			else
			{
				// 다른 pid 가 등록되어 있는 경우 (기존 것은 내리고 새로 등록한다)
				if (s_astCxStream[i].eState == eCxStream_Used)
				{
					// descrambler slot을 close한다
					local_cxstream_CloseDescrambler(i);
					// ecm filter 처리 - 다른데서 쓰면 그냥 두고, 쓰지 않으면 없앤다.
					local_cxstream_UnlinkEcm(i);
				}

				s_astCxStream[i].eState  = eCxStream_NotUsed;
				break;
			}
#endif
		}
	}

	// 없으면 추가 (여기로 왔다면 아직 pmt를 못받은 상태임)
	if (bAdd)
	{
		for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
		{
			// 일단 pid로 빈 slot을 확인해보자
			if (s_astCxStream[i].usPid == PID_NULL)
			{
				s_astCxStream[i].usPid 	= usPid;
//				s_astCxStream[i].eType 	= eType;
				s_astCxStream[i].eState 	= eCxStream_Used;
				s_astCxStream[i].hSession	= hSession;
				CX_SEM_Release(s_ulCxStreamSemId);
				HxLOG_Print("[Exit]2\r\n");
				return ERR_OK;
			}
		}
	}
	CX_SEM_Release(s_ulCxStreamSemId);

	HxLOG_Print("[Exit]3\r\n");
	return ERR_FAIL;
}
#endif

HBOOL CXSTREAM_IsConaxStream(Handle_t hSession)
{
	int					i, j;
	SvcCas_PmtInfo_t* 	pstPmtInfo;
	SvcCas_PmtElement_t* 							pstEsInfo;
	HBOOL				bFound			= FALSE;

	ENTER_FUNCTION;

	pstPmtInfo = CXSESSION_GetPmtInfo(hSession);

	if (pstPmtInfo == NULL)
	{
		HxLOG_Error("no pmt\r\n");
		return FALSE;
	}

	// program level에서 찾는다.
	if (pstPmtInfo->bProgramCaFlag)
	{
		for (i = 0; i < pstPmtInfo->ulNumOfProgramCaDescriptor; i++)
		{
			//## ca system id 비교
			if ((pstPmtInfo->stProgramCaDescriptor[i].usCaSysId & 0xFF00) == (eDxCAS_GROUPID_CX & 0xFF00))
			{
				bFound = TRUE;
				break;
			}
		}
	}

	// es level도 찾아본다
	if (bFound == FALSE)
	{
		for (i = 0; i < pstPmtInfo->ulNumOfElement; i++)
		{
			pstEsInfo = &pstPmtInfo->stElementInfo[i];

			if (pstEsInfo->bElementCaFlag)
			{
				for (j = 0; j < pstEsInfo->ulNumOfCaDescriptor; j++)
				{
					//## ca system id 비교
					if ((pstEsInfo->stElementCaDescriptor[j].usCaSysId & 0xFF00) == (eDxCAS_GROUPID_CX & 0xFF00))
					{
						bFound = TRUE;
						break;
					}
				}
			}

			// 찾았으면 그만 하자.
			if (bFound)
			{
				break;
			}
		}
	}

	HxLOG_Print("[Exit(%d)]\r\n", bFound);
	return bFound;
}

// pmt parsing하는 곳
HERROR CXSTREAM_ParsePmt(Handle_t hSession)
{
	int					i, j;
	HBOOL				bFound;
	HUINT16				usEcmPid;
	SvcCas_PmtInfo_t* 	pstPmtInfo;

	ENTER_FUNCTION;

	if (hSession == HANDLE_NULL)
	{
		HxLOG_Error("wrong handle\r\n");
		return ERR_FAIL;
	}

	pstPmtInfo = CXSESSION_GetPmtInfo(hSession);

	if (pstPmtInfo == NULL)
	{
		HxLOG_Error("null pmt info\r\n");
		return ERR_FAIL;
	}

	// smart card가 없으면 하지 마라..
	// ca_system_id 구분하는 것도 그렇고.. ecm filter도 걸필요가 없으니.. sc 들어오면 그때 하자
	// 이게 속도에 영향을 준다면 나중에 바꾸세요. (여기랑 scInserted에 pmt_parse 다시 호출하는 부분 수정하면 될거임)
	if (CXSESSION_GetScSlot(hSession) == CX_SC_NONE)
	{
		HxLOG_Error("no smartcard\r\n");
		return ERR_FAIL;
	}

	CX_SEM_Get(s_ulCxStreamSemId);

	//## 1. 이미 등록된 stream 정보를 updated pmt보고 업데이트 혹은 삭제
	//##		hSession, pid, type 같으면 update
	//##			hEcm도 같으면 skip
	//##			hEcm 다르면 기존 hEcm close 시도 (다른 곳서 사용중이면 지워지지는 않을 것), 새로운 hEcm 추가 (state=used이면 filter start)
	//##			descrambler open 시도 (hEcm 있는데 descrambler 할당 못받은 경우라면)
	//##		같은거 발견되지 않으면 delete
	//##			hEcm close 시도
	//##			descrambler close 시도
	//## 2. updated pmt에 남은 stream이 있다면 추가
	//##		추가 하고, hEcm도 추가하고.. 봐서 filter나 descrambler도 open하고..

	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		if (s_astCxStream[i].hSession == hSession && s_astCxStream[i].usPid != PID_NULL)
		{
			// 이미 저장된 elementary stream의 변경/삭제 여부를 확인한다

			bFound = FALSE;
			for (j = 0; j < pstPmtInfo->ulNumOfElement; j++)
			{
				if (s_astCxStream[i].usPid == pstPmtInfo->stElementInfo[j].usPid)
				//&& s_astCxStream[i].eType == pstPmtInfo->stElementInfo[j].eEsType)
				{
					//동일 es가 새로운 pmt에도 존재함 - 변경 여부 확인 (free <-> scrambled, ecm pid 변경 여부)
					HxLOG_Print("ALREADY EXIST(%x)\n", pstPmtInfo->stElementInfo[i].usPid);

					bFound = TRUE;
					usEcmPid = local_cxstream_GetEcmPidFromPmt(hSession, pstPmtInfo, &pstPmtInfo->stElementInfo[j]);

					if (usEcmPid == PID_NULL)
					{
						// hEcm = null 이면 변동 없는 것임, 아니라면 update
						if (s_astCxStream[i].hEcm != HANDLE_NULL)
						{
							HxLOG_Print("UPDATE(free)\n");
							// scrambled --> free로 변경
							// descrambler slot 내린다.
							local_cxstream_CloseDescrambler(i);
							// hEcm 내린다..
							local_cxstream_UnlinkEcm(i);
						}
					}
					else
					{
						// ecm pid 가 같다면 변경이 없다는 것, 아니라면 update
						if (CXECM_GetPid(s_astCxStream[i].hEcm) != usEcmPid)
						{
							HxLOG_Print("UPDATE(scr)\n");
							// hEcm 변경 필요함
							//기존 hEcm은 확인해서 내리도록하고, 새 hEcm 추가한다.
							if (s_astCxStream[i].hEcm != HANDLE_NULL)
							{
								local_cxstream_UnlinkEcm(i);
							}
							local_cxstream_LinkEcm(hSession, i, usEcmPid);

							// descrambler는 그냥 두고, 만약 free 채널 이었다면, descrambler slot 받아야함
							// sc 제거 후 동일한 service가 stop -> start 될 경우 descrambler 등록과 ecm filter가 동작하지 않아요...
						}

						local_cxstream_OpenDescrambler(i, hSession);
						local_cxstream_StartEcmFilter(i);
					}
					break;
				}
			}

			if (bFound == FALSE)
			{
				HxLOG_Print("NOT FOUND-DELETE(%x)\n", s_astCxStream[i].usPid);
				// 동일 es가 새로운 pmt에 존재하지 않음 - 삭제 처리
				local_cxstream_Delete(i);
			}
		}
	}

	// 새로운 pmt에 추가된 stream이 있는지 확인
	for (i = 0; i < pstPmtInfo->ulNumOfElement; i++)
	{
		if (pstPmtInfo->stElementInfo[i].usPid != PID_NULL && pstPmtInfo->stElementInfo[i].usPid != 0x0)
		{
			// 이미 존재하는 pid면 앞에서 update되었을 것이니 skip하고, 없던 것만 새로 추가
			for (j = 0; j < CX_MAX_NUM_OF_ES; j++)
			{
				if (s_astCxStream[j].hSession == hSession && s_astCxStream[j].usPid == pstPmtInfo->stElementInfo[i].usPid)
				{
					break;
				}
			}

			if (j == CX_MAX_NUM_OF_ES)
			{
				HxLOG_Print("NEW!(%x)\n", pstPmtInfo->stElementInfo[i].usPid);
				// 동일 pid 발견되지 않았음, 추가
				local_cxstream_Add(hSession, pstPmtInfo, &pstPmtInfo->stElementInfo[i]);
			}
		}
	}

	CX_SEM_Release(s_ulCxStreamSemId);
	LEAVE_FUNCTION;
	return ERR_OK;
}

HERROR CXSTREAM_DeleteAll(Handle_t hSession)
{
	int	i;

	ENTER_FUNCTION;

	if (hSession == HANDLE_NULL)
	{
		HxLOG_Error("null handle\r\n");
		return ERR_FAIL;
	}

	CX_SEM_Get(s_ulCxStreamSemId);

	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		// 해당 session의 모든 stream을 제거한다
		if (s_astCxStream[i].hSession == hSession)
		{
			local_cxstream_Delete(i);
		}
	}

	CX_SEM_Release(s_ulCxStreamSemId);

	LEAVE_FUNCTION;
	return ERR_OK;
}

// session 및 pid 정보를 초기화 한다
HERROR CXSTREAM_ResetStream(Handle_t hSession)
{
	HUINT32	i;

	ENTER_FUNCTION;

	if (hSession == HANDLE_NULL)
	{
		HxLOG_Error("null handle\r\n");
		return ERR_FAIL;
	}

	CX_SEM_Get(s_ulCxStreamSemId);

	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		if (s_astCxStream[i].hSession == hSession)
		{
			// descrambler slot을 close한다
			local_cxstream_CloseDescrambler(i);

			// session 정보 및 pid 정보를 clear
			// descrambler는 sc insert시 parsePMT 하면서 open된다
			s_astCxStream[i].hSession = HANDLE_NULL;
			s_astCxStream[i].usPid = PID_NULL;

			// setPid가 다시 내려오지 않으므로 state는 유지
			//s_astCxStream[i].eState	 	= eCxStream_NotUsed;
		}
	}

	CX_SEM_Release(s_ulCxStreamSemId);

	LEAVE_FUNCTION;
	return ERR_OK;
}

// free or scrambled svc 확인
HERROR CXSTREAM_IsScrambledSvc(Handle_t hSession, HBOOL* pbScrambled)
{
	int	i;

	ENTER_FUNCTION;

	if (hSession == HANDLE_NULL)
	{
		HxLOG_Error("wrong handle\r\n");
		return ERR_FAIL;
	}

	*pbScrambled = FALSE;

	CX_SEM_Get(s_ulCxStreamSemId);

	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		if (s_astCxStream[i].usPid != PID_NULL && s_astCxStream[i].hSession == hSession)
		{
			//if (s_astCxStream[i].hEcm != HANDLE_NULL && s_astCxStream[i].eState == eCxStream_Used)
			if (s_astCxStream[i].hEcm != HANDLE_NULL)
			{
				//연결된 ecm이 있다면 scrambled svc로 본다.
				*pbScrambled = TRUE;
				break;
			}
		}
	}

	CX_SEM_Release(s_ulCxStreamSemId);

	LEAVE_FUNCTION;
	return ERR_OK;
}

// 해당 session (service)에 속한 stream이 사용하는 모든 ecm filter를 start 시킨다.
HERROR CXSTREAM_StartAllEcmFilter(Handle_t hSession)
{
	int	i;

	ENTER_FUNCTION;

	if (hSession == HANDLE_NULL)
	{
		HxLOG_Error("wrong handle\r\n");
		return ERR_FAIL;
	}

	// smart card가 없으면 filter start 할 필요 없다
	if (CXSESSION_GetScSlot(hSession) == CX_SC_NONE)
	{
		HxLOG_Error("no smartcard\r\n");
		return ERR_OK;
	}

	CX_SEM_Get(s_ulCxStreamSemId);

	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		if (s_astCxStream[i].usPid != PID_NULL && s_astCxStream[i].hSession == hSession)
		{
			local_cxstream_StartEcmFilter(i);
		}
	}

	CX_SEM_Release(s_ulCxStreamSemId);

	LEAVE_FUNCTION;
	return ERR_OK;
}

// 해당 session (service)에 속한 stream이 사용하는 모든 ecm filter를 stop 시킨다.
HERROR CXSTREAM_StopAllEcmFilter(Handle_t hSession)
{
	int	i;

	ENTER_FUNCTION;

	if (hSession == HANDLE_NULL)
	{
		HxLOG_Error("null handle\r\n");
		return ERR_FAIL;
	}

	CX_SEM_Get(s_ulCxStreamSemId);

	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		if (s_astCxStream[i].usPid != PID_NULL && s_astCxStream[i].hSession == hSession)
		{
			local_cxstream_StopEcmFilter(i);
		}
	}

	CX_SEM_Release(s_ulCxStreamSemId);

	LEAVE_FUNCTION;
	return ERR_OK;
}

// 해당 session (service)에 속한 stream이 사용하는 모든 ecm filter를 restart 시킨다.
HERROR CXSTREAM_RestartAllEcmFilter(Handle_t hSession)
{
	HERROR	nErr;

	ENTER_FUNCTION;

	nErr = CXSTREAM_StopAllEcmFilter(hSession);

	if (nErr == ERR_OK)
	{
		nErr = CXSTREAM_StartAllEcmFilter(hSession);
	}

	LEAVE_FUNCTION;
	return nErr;
}

HERROR CXSTREAM_FindStreamBySessionAndEcm(Handle_t hSession, Handle_t hEcm)
{
	int	i;

	ENTER_FUNCTION;

	//	sem 걸면 안됨 (stream->ecm->stream call)
	//	CX_SEM_Get(s_ulCxStreamSemId);

	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		if (s_astCxStream[i].usPid != PID_NULL 		//
		&& s_astCxStream[i].hSession == hSession	//
		&& s_astCxStream[i].hEcm == hEcm)			//
		{
			break;
		}
	}

	if (i >= CX_MAX_NUM_OF_ES)
	{
		HxLOG_Error("not found\r\n");
		return ERR_FAIL;
	}

	LEAVE_FUNCTION;
	return ERR_OK;
}

Handle_t CXSTREAM_GetFirstSessionByEcm(Handle_t hEcm)
{
	int	i;

	ENTER_FUNCTION;

	//	sem 걸면 안됨 (stream->ecm->stream call)
	//	CX_SEM_Get(s_ulCxStreamSemId);

	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		if (s_astCxStream[i].usPid != PID_NULL && s_astCxStream[i].hEcm == hEcm)
		{
			break;
		}
	}

	if (i >= CX_MAX_NUM_OF_ES)
	{
		HxLOG_Error("not found\r\n");
		return HANDLE_NULL;
	}

	LEAVE_FUNCTION;
	return s_astCxStream[i].hSession;
}

HUINT32 CXSTREAM_GetAllSessionByEcm(Handle_t hEcm, Handle_t* phList)
{
	int		i, j;
	HUINT32	ulCount;

	ENTER_FUNCTION;

	CX_SEM_Get(s_ulCxStreamSemId);

	for (i = 0, ulCount = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		if (s_astCxStream[i].usPid != PID_NULL && s_astCxStream[i].hEcm == hEcm)
		{
			// 혹시 같은 session을 이미 찾았었는지 확인
			for (j = 0; j < ulCount; j++)
			{
				if (phList[j] == s_astCxStream[i].hSession)
				{
					break;
				}
			}

			if (j == ulCount)
			{
				phList[ulCount++] = s_astCxStream[i].hSession;
			}
		}
	}

	CX_SEM_Release(s_ulCxStreamSemId);
	LEAVE_FUNCTION;
	return ulCount;
}

#if defined(CONFIG_MW_CAS_CONAX_CPM)
HERROR CXSTREAM_RemoveCWPK(HUINT16 usKeyId)
{
	int	i;

	HxLOG_Print("[Enter]\n");

	if (usKeyId == 0)
	{
		return ERR_FAIL;
	}

	CX_SEM_Get(s_ulCxStreamSemId);

	// 해당 key id를 사용하는 descrambler의 CWPK를 clear 한다.
	for (i = 0; i < CX_MAX_NUM_OF_ES; i++)
	{
		if (s_astCxStream[i].usCwpkId == usKeyId && s_astCxStream[i].hDescrambler != HANDLE_NULL)
		{
			CXDSCR_ClearCWPK(s_astCxStream[i].hDescrambler);
			s_astCxStream[i].usCwpkId = 0;
		}
	}

	CX_SEM_Release(s_ulCxStreamSemId);

	HxLOG_Print("[Exit]\n");

	return ERR_OK;
}
#endif

#if defined(CONFIG_DEBUG)
STATIC HUINT8* local_cxstream_DEBUG_GetScStateStr(CxStreamState_t eState)
{
	switch (eState)
	{
		ENUM_TO_STR(eCxStream_NotUsed)
		ENUM_TO_STR(eCxStream_Used)
	}

	return "Unknown";
}

void CMD_CXSTREAM_PrintStreamContext(void)
{
	HUINT32	i;

	for (i = 0 ; i < CX_MAX_NUM_OF_ES ; i++)
	{
		HxLOG_Warning(HxANSI_COLOR_GREEN("CONAX STREAM (%d)\n"), i);

		HxLOG_Warning("\t hSession (%d, 0x%x)\n", CXSESSION_GetSessionIdx(s_astCxStream[i].hSession));
		HxLOG_Warning("\t eState (%s)\n", local_cxstream_DEBUG_GetScStateStr(s_astCxStream[i].eState));
		HxLOG_Warning("\t usPid (0x%x)\n", s_astCxStream[i].usPid);

		if(s_astCxStream[i].eState != eCxStream_Used)
			continue;

		HxLOG_Warning("\t hEcm (0x%x)\n", s_astCxStream[i].hEcm);
		HxLOG_Warning("\t hDescrambler (%d)\n", s_astCxStream[i].hDescrambler);
		HxLOG_Warning("\t usCwpkId (0x%x)\n", s_astCxStream[i].usCwpkId);
	}
}
#endif

