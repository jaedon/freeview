/* $Header: */
/*******************************************************************/
/************************* File Description ************************/
/*******************************************************************/
// File Name:		drv_channel_kraken.c
// Original Author: Full Name!!
// File Description:
// Module:
// Remarks:

/*******************************************************************/
/* Copyright (c) 2006 HUMAX Co., Ltd. 							   */
/* All rights reserved.											   */
/*******************************************************************/


/*******************************************************************/
/**************************** Header Files *************************/
/*******************************************************************/
// Start Including Headers

/* chip headers */
#include "string.h"
#include "htype.h"
#include "vkernel.h"

/* di headers */
#include "di_channel.h"
#include "di_channel_priv.h"
#include "di_channel_attr.h"

/* drv headers */
#include "drv_i2c.h"
#include "drv_gpio.h"
#include "drv_channel.h"
#include "drv_channel_lnb.h"
#include "drv_channel_db4506.h"

/* nexus headers */
#include "nexus_platform.h"
#include "nexus_frontend.h"
#include "nexus_frontend_4506.h"

// End Including Headers


/*******************************************************************/
/****************************** define *****************************/
/*******************************************************************/
// Start #define
#define MIN_WAIT_DELAY			(30)
#define RS_STUFF_BYTE			(16) // Normal
#define ODU_SETUP_TIME			(300) /* Outdoor Unit setup time 100ms */

#define CHANNEL_ID0				(0)
#define CHANNEL_ID1				(1)
#define CHANNEL_ID2				(2)
#define CHANNEL_ID3				(3)

#define DEVICE_SET0				(0)
#define DEVICE_SET1				(1)

#define NUM_OF_DEVICE_SET		(CONFIG_NUM_OF_SAT_CHANNEL/2)

#define CH_PRINT_LOW_LEVEL_ZAPPING_TIME
// End #define

/*******************************************************************/
/****************************** Debug ****************************/
/*******************************************************************/


/*******************************************************************/
/************************ global variables *************************/
/*******************************************************************/
// Start global variablee
HINT32	g_nPrintBER;

extern HINT32 show_di_ch;

// End global variable


/*******************************************************************/
/************************ static variables *************************/
/*******************************************************************/
// Start static variablee

static NEXUS_FrontendHandle s_stFrontend[CONFIG_NUM_OF_SAT_CHANNEL];
static NEXUS_3445LnaSettings s_stLnaSetting[NUM_OF_DEVICE_SET];

static const NEXUS_FrontendSatelliteCodeRate
	g_cr_scan = {0,0,0},
	g_cr_1_4 = {1,4,0},
	g_cr_1_2 = {1,2,0},
	g_cr_2_3 = {2,3,0},
	g_cr_3_4 = {3,4,0},
	g_cr_5_6 = {5,6,0},
	g_cr_6_7 = {6,7,0},
	g_cr_7_8 = {7,8,0},
	g_cr_5_11 = {5,11,0},
	g_cr_3_5 = {3,5,0},
	g_cr_4_5 = {4,5,0},
	g_cr_9_10 = {9,10,0},
	g_cr_8_9 = {8,9,0};

static CH_SAT_LnbStatus_t	s_stLnbState[CONFIG_NUM_OF_SAT_CHANNEL];

//static HUINT8 ucStuffByte = RS_STUFF_BYTE;

#ifdef CH_PRINT_LOW_LEVEL_ZAPPING_TIME
HUINT32 g_ulRequestTune[CONFIG_NUM_OF_SAT_CHANNEL];
HUINT32 g_ulLowLevelLockedTime[CONFIG_NUM_OF_SAT_CHANNEL] , g_ulLowLevelUnlockedTime[CONFIG_NUM_OF_SAT_CHANNEL] ;
#endif


/****************** Function 시작점에 필히 기록 ********************/
/*******************************************************************/
/*********************** Function Description***********************/
/*******************************************************************/
// Function Name:
// Function Description:
// Parameter:
// Return Value:

#define __DB4506_PRIVATE_FUNCITONS__

/*********************** Static Function ***********************/

/******************************************* Start of BCM4506 RF Input Power Monitoring Function *******************************************/
/**********************************************************************
bcm4506_MultU32U32() - multiplies a 32 bit number by a 32 bit number
and returns a 64 bit product
**********************************************************************/
void bcm4506_MultU32U32(uint32_t A, uint32_t B, uint32_t *P_hi, uint32_t *P_lo)
{
	uint32_t A_lo = A & 0xFFFF;
	uint32_t A_hi = (A >> 16) & 0xFFFF;
	uint32_t B_lo = B & 0xFFFF;
	uint32_t B_hi = (B >> 16) & 0xFFFF;
	uint32_t P, P0, P1, P2, P3, c;

	P = B_lo * A_lo;

	P0 = P & 0xFFFF;
	P1 = (P >> 16) & 0xFFFF;

	P = B_hi * A_hi;
	P2 = P & 0xFFFF;
	P3 = (P >> 16) & 0xFFFF;

	P = B_lo * A_hi;
	P1 += (P & 0xFFFF);
	P2 += ((P >> 16) & 0xFFFF);

	P = B_hi * A_lo;
	P1 += (P & 0xFFFF);
	P2 += ((P >> 16) & 0xFFFF);

	c = (P1 >> 16) & 0xFFFF;
	if (c)
	{
		P1 &= 0xFFFF;
		P2 += c;
	}

	c = (P2 >> 16) & 0xFFFF;
	if (c)
	{
		P2 &= 0xFFFF;
		P3 += c;
	}

	P3 &= 0xFFFF;

	*P_hi = P2 | (P3 << 16);
	*P_lo = P0 | (P1 << 16);
}


/**********************************************************************
bcm4506_DivU64U32() - divides a 64 bit unsigned number by a 32 bit
unsigned number
**********************************************************************/
void bcm4506_DivU64U32(uint32_t A_hi, uint32_t A_lo, uint32_t B, uint32_t *Q_hi, uint32_t *Q_lo)
{
	uint32_t X;
	int i;

	X = *Q_hi = *Q_lo = 0;

	for (i = 63; i >= 0; i--)
	{
		X = (X << 1);
		if (i >= 32)
		{
			*Q_hi = *Q_hi << 1;
			X |= ((A_hi & (1 << (i - 32))) ? 1 : 0);
		}
		else
		{
			*Q_lo = *Q_lo << 1;
			X |= ((A_lo & (1 << i)) ? 1 : 0);
		}

		if (X >= B)
		{
			if (i >= 32)
			{
				*Q_hi |= 1;
			}
			else
			{
				*Q_lo |= 1;
			}

			X -= B;
		}
	}
}


/**********************************************************************
bcm4506_log_x() - returns log(x) in 5.27 format
assumptions: x < 1, x is scaled 2^16
**********************************************************************/
int32_t bcm4506_log_x(uint32_t x)
{
	static int32_t log_table0[256] =
	{ /* 5.27 format */
		-1488522236 , /* 0 ( 0 ) */
		-1488522236 , /* 1 ( 1.52588E-05 ) */
		-1395489597 , /* 2 ( 3.05176E-05 ) */
		-1341068991 , /* 3 ( 4.57764E-05 ) */
		-1302456957 , /* 4 ( 6.10352E-05 ) */
		-1272507136 , /* 5 ( 7.62939E-05 ) */
		-1248036351 , /* 6 ( 9.15527E-05 ) */
		-1227346597 , /* 7 ( 0.000106812 ) */
		-1209424317 , /* 8 ( 0.00012207 ) */
		-1193615746 , /* 9 ( 0.000137329 ) */
		-1179474497 , /* 10 ( 0.000152588 ) */
		-1166682181 , /* 11 ( 0.000167847 ) */
		-1155003712 , /* 12 ( 0.000183105 ) */
		-1144260561 , /* 13 ( 0.000198364 ) */
		-1134313958 , /* 14 ( 0.000213623 ) */
		-1125053891 , /* 15 ( 0.000228882 ) */
		-1116391677 , /* 16 ( 0.000244141 ) */
		-1108254778 , /* 17 ( 0.000259399 ) */
		-1100583106 , /* 18 ( 0.000274658 ) */
		-1093326326 , /* 19 ( 0.000289917 ) */
		-1086441857 , /* 20 ( 0.000305176 ) */
		-1079893352 , /* 21 ( 0.000320435 ) */
		-1073649541 , /* 22 ( 0.000335693 ) */
		-1067683327 , /* 23 ( 0.000350952 ) */
		-1061971072 , /* 24 ( 0.000366211 ) */
		-1056492036 , /* 25 ( 0.00038147 ) */
		-1051227921 , /* 26 ( 0.000396729 ) */
		-1046162500 , /* 27 ( 0.000411987 ) */
		-1041281318 , /* 28 ( 0.000427246 ) */
		-1036571441 , /* 29 ( 0.000442505 ) */
		-1032021251 , /* 30 ( 0.000457764 ) */
		-1027620276 , /* 31 ( 0.000473022 ) */
		-1023359038 , /* 32 ( 0.000488281 ) */
		-1019228936 , /* 33 ( 0.00050354 ) */
		-1015222139 , /* 34 ( 0.000518799 ) */
		-1011331497 , /* 35 ( 0.000534058 ) */
		-1007550466 , /* 36 ( 0.000549316 ) */
		-1003873038 , /* 37 ( 0.000564575 ) */
		-1000293687 , /* 38 ( 0.000579834 ) */
		-996807316 , /* 39 ( 0.000595093 ) */
		-993409217 , /* 40 ( 0.000610352 ) */
		-990095031 , /* 41 ( 0.00062561 ) */
		-986860712 , /* 42 ( 0.000640869 ) */
		-983702502 , /* 43 ( 0.000656128 ) */
		-980616901 , /* 44 ( 0.000671387 ) */
		-977600646 , /* 45 ( 0.000686646 ) */
		-974650687 , /* 46 ( 0.000701904 ) */
		-971764173 , /* 47 ( 0.000717163 ) */
		-968938432 , /* 48 ( 0.000732422 ) */
		-966170958 , /* 49 ( 0.000747681 ) */
		-963459397 , /* 50 ( 0.000762939 ) */
		-960801533 , /* 51 ( 0.000778198 ) */
		-958195282 , /* 52 ( 0.000793457 ) */
		-955638676 , /* 53 ( 0.000808716 ) */
		-953129861 , /* 54 ( 0.000823975 ) */
		-950667081 , /* 55 ( 0.000839233 ) */
		-948248678 , /* 56 ( 0.000854492 ) */
		-945873081 , /* 57 ( 0.000869751 ) */
		-943538801 , /* 58 ( 0.00088501 ) */
		-941244425 , /* 59 ( 0.000900269 ) */
		-938988612 , /* 60 ( 0.000915527 ) */
		-936770086 , /* 61 ( 0.000930786 ) */
		-934587636 , /* 62 ( 0.000946045 ) */
		-932440107 , /* 63 ( 0.000961304 ) */
		-930326398 , /* 64 ( 0.000976563 ) */
		-928245461 , /* 65 ( 0.000991821 ) */
		-926196296 , /* 66 ( 0.00100708 ) */
		-924177946 , /* 67 ( 0.001022339 ) */
		-922189499 , /* 68 ( 0.001037598 ) */
		-920230081 , /* 69 ( 0.001052856 ) */
		-918298858 , /* 70 ( 0.001068115 ) */
		-916395028 , /* 71 ( 0.001083374 ) */
		-914517827 , /* 72 ( 0.001098633 ) */
		-912666518 , /* 73 ( 0.001113892 ) */
		-910840398 , /* 74 ( 0.00112915 ) */
		-909038791 , /* 75 ( 0.001144409 ) */
		-907261047 , /* 76 ( 0.001159668 ) */
		-905506542 , /* 77 ( 0.001174927 ) */
		-903774676 , /* 78 ( 0.001190186 ) */
		-902064873 , /* 79 ( 0.001205444 ) */
		-900376577 , /* 80 ( 0.001220703 ) */
		-898709255 , /* 81 ( 0.001235962 ) */
		-897062391 , /* 82 ( 0.001251221 ) */
		-895435490 , /* 83 ( 0.001266479 ) */
		-893828072 , /* 84 ( 0.001281738 ) */
		-892239678 , /* 85 ( 0.001296997 ) */
		-890669863 , /* 86 ( 0.001312256 ) */
		-889118195 , /* 87 ( 0.001327515 ) */
		-887584262 , /* 88 ( 0.001342773 ) */
		-886067661 , /* 89 ( 0.001358032 ) */
		-884568006 , /* 90 ( 0.001373291 ) */
		-883084922 , /* 91 ( 0.00138855 ) */
		-881618047 , /* 92 ( 0.001403809 ) */
		-880167031 , /* 93 ( 0.001419067 ) */
		-878731533 , /* 94 ( 0.001434326 ) */
		-877311226 , /* 95 ( 0.001449585 ) */
		-875905792 , /* 96 ( 0.001464844 ) */
		-874514923 , /* 97 ( 0.001480103 ) */
		-873138318 , /* 98 ( 0.001495361 ) */
		-871775690 , /* 99 ( 0.00151062 ) */
		-870426757 , /* 100 ( 0.001525879 ) */
		-869091246 , /* 101 ( 0.001541138 ) */
		-867768893 , /* 102 ( 0.001556396 ) */
		-866459442 , /* 103 ( 0.001571655 ) */
		-865162642 , /* 104 ( 0.001586914 ) */
		-863878252 , /* 105 ( 0.001602173 ) */
		-862606037 , /* 106 ( 0.001617432 ) */
		-861345767 , /* 107 ( 0.00163269 ) */
		-860097221 , /* 108 ( 0.001647949 ) */
		-858860182 , /* 109 ( 0.001663208 ) */
		-857634441 , /* 110 ( 0.001678467 ) */
		-856419793 , /* 111 ( 0.001693726 ) */
		-855216038 , /* 112 ( 0.001708984 ) */
		-854022984 , /* 113 ( 0.001724243 ) */
		-852840441 , /* 114 ( 0.001739502 ) */
		-851668227 , /* 115 ( 0.001754761 ) */
		-850506161 , /* 116 ( 0.00177002 ) */
		-849354071 , /* 117 ( 0.001785278 ) */
		-848211785 , /* 118 ( 0.001800537 ) */
		-847079139 , /* 119 ( 0.001815796 ) */
		-845955972 , /* 120 ( 0.001831055 ) */
		-844842125 , /* 121 ( 0.001846313 ) */
		-843737447 , /* 122 ( 0.001861572 ) */
		-842641786 , /* 123 ( 0.001876831 ) */
		-841554996 , /* 124 ( 0.00189209 ) */
		-840476937 , /* 125 ( 0.001907349 ) */
		-839407467 , /* 126 ( 0.001922607 ) */
		-838346452 , /* 127 ( 0.001937866 ) */
		-837293758 , /* 128 ( 0.001953125 ) */
		-836249257 , /* 129 ( 0.001968384 ) */
		-835212822 , /* 130 ( 0.001983643 ) */
		-834184328 , /* 131 ( 0.001998901 ) */
		-833163656 , /* 132 ( 0.00201416 ) */
		-832150687 , /* 133 ( 0.002029419 ) */
		-831145306 , /* 134 ( 0.002044678 ) */
		-830147400 , /* 135 ( 0.002059937 ) */
		-829156859 , /* 136 ( 0.002075195 ) */
		-828173575 , /* 137 ( 0.002090454 ) */
		-827197442 , /* 138 ( 0.002105713 ) */
		-826228356 , /* 139 ( 0.002120972 ) */
		-825266218 , /* 140 ( 0.00213623 ) */
		-824310928 , /* 141 ( 0.002151489 ) */
		-823362388 , /* 142 ( 0.002166748 ) */
		-822420506 , /* 143 ( 0.002182007 ) */
		-821485187 , /* 144 ( 0.002197266 ) */
		-820556341 , /* 145 ( 0.002212524 ) */
		-819633878 , /* 146 ( 0.002227783 ) */
		-818717713 , /* 147 ( 0.002243042 ) */
		-817807759 , /* 148 ( 0.002258301 ) */
		-816903932 , /* 149 ( 0.00227356 ) */
		-816006151 , /* 150 ( 0.002288818 ) */
		-815114336 , /* 151 ( 0.002304077 ) */
		-814228407 , /* 152 ( 0.002319336 ) */
		-813348288 , /* 153 ( 0.002334595 ) */
		-812473902 , /* 154 ( 0.002349854 ) */
		-811605176 , /* 155 ( 0.002365112 ) */
		-810742036 , /* 156 ( 0.002380371 ) */
		-809884412 , /* 157 ( 0.00239563 ) */
		-809032233 , /* 158 ( 0.002410889 ) */
		-808185431 , /* 159 ( 0.002426147 ) */
		-807343938 , /* 160 ( 0.002441406 ) */
		-806507687 , /* 161 ( 0.002456665 ) */
		-805676615 , /* 162 ( 0.002471924 ) */
		-804850657 , /* 163 ( 0.002487183 ) */
		-804029751 , /* 164 ( 0.002502441 ) */
		-803213836 , /* 165 ( 0.0025177 ) */
		-802402850 , /* 166 ( 0.002532959 ) */
		-801596735 , /* 167 ( 0.002548218 ) */
		-800795433 , /* 168 ( 0.002563477 ) */
		-799998886 , /* 169 ( 0.002578735 ) */
		-799207039 , /* 170 ( 0.002593994 ) */
		-798419836 , /* 171 ( 0.002609253 ) */
		-797637223 , /* 172 ( 0.002624512 ) */
		-796859147 , /* 173 ( 0.002639771 ) */
		-796085556 , /* 174 ( 0.002655029 ) */
		-795316397 , /* 175 ( 0.002670288 ) */
		-794551622 , /* 176 ( 0.002685547 ) */
		-793791180 , /* 177 ( 0.002700806 ) */
		-793035021 , /* 178 ( 0.002716064 ) */
		-792283099 , /* 179 ( 0.002731323 ) */
		-791535366 , /* 180 ( 0.002746582 ) */
		-790791776 , /* 181 ( 0.002761841 ) */
		-790052282 , /* 182 ( 0.0027771 ) */
		-789316841 , /* 183 ( 0.002792358 ) */
		-788585407 , /* 184 ( 0.002807617 ) */
		-787857938 , /* 185 ( 0.002822876 ) */
		-787134391 , /* 186 ( 0.002838135 ) */
		-786414723 , /* 187 ( 0.002853394 ) */
		-785698893 , /* 188 ( 0.002868652 ) */
		-784986861 , /* 189 ( 0.002883911 ) */
		-784278587 , /* 190 ( 0.00289917 ) */
		-783574030 , /* 191 ( 0.002914429 ) */
		-782873153 , /* 192 ( 0.002929688 ) */
		-782175916 , /* 193 ( 0.002944946 ) */
		-781482283 , /* 194 ( 0.002960205 ) */
		-780792216 , /* 195 ( 0.002975464 ) */
		-780105679 , /* 196 ( 0.002990723 ) */
		-779422635 , /* 197 ( 0.003005981 ) */
		-778743050 , /* 198 ( 0.00302124 ) */
		-778066889 , /* 199 ( 0.003036499 ) */
		-777394117 , /* 200 ( 0.003051758 ) */
		-776724701 , /* 201 ( 0.003067017 ) */
		-776058606 , /* 202 ( 0.003082275 ) */
		-775395802 , /* 203 ( 0.003097534 ) */
		-774736254 , /* 204 ( 0.003112793 ) */
		-774079931 , /* 205 ( 0.003128052 ) */
		-773426802 , /* 206 ( 0.003143311 ) */
		-772776836 , /* 207 ( 0.003158569 ) */
		-772130002 , /* 208 ( 0.003173828 ) */
		-771486271 , /* 209 ( 0.003189087 ) */
		-770845612 , /* 210 ( 0.003204346 ) */
		-770207997 , /* 211 ( 0.003219604 ) */
		-769573397 , /* 212 ( 0.003234863 ) */
		-768941783 , /* 213 ( 0.003250122 ) */
		-768313127 , /* 214 ( 0.003265381 ) */
		-767687402 , /* 215 ( 0.00328064 ) */
		-767064581 , /* 216 ( 0.003295898 ) */
		-766444637 , /* 217 ( 0.003311157 ) */
		-765827543 , /* 218 ( 0.003326416 ) */
		-765213273 , /* 219 ( 0.003341675 ) */
		-764601801 , /* 220 ( 0.003356934 ) */
		-763993103 , /* 221 ( 0.003372192 ) */
		-763387153 , /* 222 ( 0.003387451 ) */
		-762783926 , /* 223 ( 0.00340271 ) */
		-762183399 , /* 224 ( 0.003417969 ) */
		-761585546 , /* 225 ( 0.003433228 ) */
		-760990344 , /* 226 ( 0.003448486 ) */
		-760397771 , /* 227 ( 0.003463745 ) */
		-759807802 , /* 228 ( 0.003479004 ) */
		-759220415 , /* 229 ( 0.003494263 ) */
		-758635587 , /* 230 ( 0.003509521 ) */
		-758053296 , /* 231 ( 0.00352478 ) */
		-757473521 , /* 232 ( 0.003540039 ) */
		-756896240 , /* 233 ( 0.003555298 ) */
		-756321431 , /* 234 ( 0.003570557 ) */
		-755749073 , /* 235 ( 0.003585815 ) */
		-755179145 , /* 236 ( 0.003601074 ) */
		-754611628 , /* 237 ( 0.003616333 ) */
		-754046500 , /* 238 ( 0.003631592 ) */
		-753483741 , /* 239 ( 0.003646851 ) */
		-752923332 , /* 240 ( 0.003662109 ) */
		-752365253 , /* 241 ( 0.003677368 ) */
		-751809486 , /* 242 ( 0.003692627 ) */
		-751256010 , /* 243 ( 0.003707886 ) */
		-750704807 , /* 244 ( 0.003723145 ) */
		-750155858 , /* 245 ( 0.003738403 ) */
		-749609146 , /* 246 ( 0.003753662 ) */
		-749064651 , /* 247 ( 0.003768921 ) */
		-748522357 , /* 248 ( 0.00378418 ) */
		-747982244 , /* 249 ( 0.003799438 ) */
		-747444297 , /* 250 ( 0.003814697 ) */
		-746908497 , /* 251 ( 0.003829956 ) */
		-746374827 , /* 252 ( 0.003845215 ) */
		-745843271 , /* 253 ( 0.003860474 ) */
		-745313812 , /* 254 ( 0.003875732 ) */
		-744786433 /* 255 ( 0.003890991 ) */
	};

	static int32_t log_table1[256] =
	{ /* 5.27 format */
		-1488522236 , /* 0 ( 1.52588E-05 ) */
		-744261118 , /* 1 ( 0.00390625 ) */
		-651228479 , /* 2 ( 0.0078125 ) */
		-596807873 , /* 3 ( 0.01171875 ) */
		-558195839 , /* 4 ( 0.015625 ) */
		-528246018 , /* 5 ( 0.01953125 ) */
		-503775233 , /* 6 ( 0.0234375 ) */
		-483085479 , /* 7 ( 0.02734375 ) */
		-465163199 , /* 8 ( 0.03125 ) */
		-449354628 , /* 9 ( 0.03515625 ) */
		-435213379 , /* 10 ( 0.0390625 ) */
		-422421063 , /* 11 ( 0.04296875 ) */
		-410742594 , /* 12 ( 0.046875 ) */
		-399999443 , /* 13 ( 0.05078125 ) */
		-390052840 , /* 14 ( 0.0546875 ) */
		-380792773 , /* 15 ( 0.05859375 ) */
		-372130559 , /* 16 ( 0.0625 ) */
		-363993660 , /* 17 ( 0.06640625 ) */
		-356321988 , /* 18 ( 0.0703125 ) */
		-349065208 , /* 19 ( 0.07421875 ) */
		-342180739 , /* 20 ( 0.078125 ) */
		-335632234 , /* 21 ( 0.08203125 ) */
		-329388423 , /* 22 ( 0.0859375 ) */
		-323422209 , /* 23 ( 0.08984375 ) */
		-317709954 , /* 24 ( 0.09375 ) */
		-312230919 , /* 25 ( 0.09765625 ) */
		-306966804 , /* 26 ( 0.1015625 ) */
		-301901382 , /* 27 ( 0.10546875 ) */
		-297020200 , /* 28 ( 0.109375 ) */
		-292310323 , /* 29 ( 0.11328125 ) */
		-287760133 , /* 30 ( 0.1171875 ) */
		-283359158 , /* 31 ( 0.12109375 ) */
		-279097920 , /* 32 ( 0.125 ) */
		-274967818 , /* 33 ( 0.12890625 ) */
		-270961021 , /* 34 ( 0.1328125 ) */
		-267070379 , /* 35 ( 0.13671875 ) */
		-263289348 , /* 36 ( 0.140625 ) */
		-259611920 , /* 37 ( 0.14453125 ) */
		-256032569 , /* 38 ( 0.1484375 ) */
		-252546198 , /* 39 ( 0.15234375 ) */
		-249148099 , /* 40 ( 0.15625 ) */
		-245833913 , /* 41 ( 0.16015625 ) */
		-242599594 , /* 42 ( 0.1640625 ) */
		-239441384 , /* 43 ( 0.16796875 ) */
		-236355783 , /* 44 ( 0.171875 ) */
		-233339528 , /* 45 ( 0.17578125 ) */
		-230389569 , /* 46 ( 0.1796875 ) */
		-227503055 , /* 47 ( 0.18359375 ) */
		-224677314 , /* 48 ( 0.1875 ) */
		-221909840 , /* 49 ( 0.19140625 ) */
		-219198279 , /* 50 ( 0.1953125 ) */
		-216540415 , /* 51 ( 0.19921875 ) */
		-213934164 , /* 52 ( 0.203125 ) */
		-211377558 , /* 53 ( 0.20703125 ) */
		-208868743 , /* 54 ( 0.2109375 ) */
		-206405963 , /* 55 ( 0.21484375 ) */
		-203987560 , /* 56 ( 0.21875 ) */
		-201611963 , /* 57 ( 0.22265625 ) */
		-199277683 , /* 58 ( 0.2265625 ) */
		-196983307 , /* 59 ( 0.23046875 ) */
		-194727494 , /* 60 ( 0.234375 ) */
		-192508968 , /* 61 ( 0.23828125 ) */
		-190326518 , /* 62 ( 0.2421875 ) */
		-188178989 , /* 63 ( 0.24609375 ) */
		-186065280 , /* 64 ( 0.25 ) */
		-183984343 , /* 65 ( 0.25390625 ) */
		-181935178 , /* 66 ( 0.2578125 ) */
		-179916828 , /* 67 ( 0.26171875 ) */
		-177928381 , /* 68 ( 0.265625 ) */
		-175968963 , /* 69 ( 0.26953125 ) */
		-174037740 , /* 70 ( 0.2734375 ) */
		-172133910 , /* 71 ( 0.27734375 ) */
		-170256709 , /* 72 ( 0.28125 ) */
		-168405400 , /* 73 ( 0.28515625 ) */
		-166579280 , /* 74 ( 0.2890625 ) */
		-164777673 , /* 75 ( 0.29296875 ) */
		-162999929 , /* 76 ( 0.296875 ) */
		-161245424 , /* 77 ( 0.30078125 ) */
		-159513558 , /* 78 ( 0.3046875 ) */
		-157803755 , /* 79 ( 0.30859375 ) */
		-156115460 , /* 80 ( 0.3125 ) */
		-154448137 , /* 81 ( 0.31640625 ) */
		-152801273 , /* 82 ( 0.3203125 ) */
		-151174372 , /* 83 ( 0.32421875 ) */
		-149566955 , /* 84 ( 0.328125 ) */
		-147978561 , /* 85 ( 0.33203125 ) */
		-146408745 , /* 86 ( 0.3359375 ) */
		-144857077 , /* 87 ( 0.33984375 ) */
		-143323144 , /* 88 ( 0.34375 ) */
		-141806543 , /* 89 ( 0.34765625 ) */
		-140306888 , /* 90 ( 0.3515625 ) */
		-138823804 , /* 91 ( 0.35546875 ) */
		-137356929 , /* 92 ( 0.359375 ) */
		-135905913 , /* 93 ( 0.36328125 ) */
		-134470415 , /* 94 ( 0.3671875 ) */
		-133050108 , /* 95 ( 0.37109375 ) */
		-131644674 , /* 96 ( 0.375 ) */
		-130253805 , /* 97 ( 0.37890625 ) */
		-128877201 , /* 98 ( 0.3828125 ) */
		-127514572 , /* 99 ( 0.38671875 ) */
		-126165639 , /* 100 ( 0.390625 ) */
		-124830128 , /* 101 ( 0.39453125 ) */
		-123507775 , /* 102 ( 0.3984375 ) */
		-122198324 , /* 103 ( 0.40234375 ) */
		-120901524 , /* 104 ( 0.40625 ) */
		-119617134 , /* 105 ( 0.41015625 ) */
		-118344919 , /* 106 ( 0.4140625 ) */
		-117084649 , /* 107 ( 0.41796875 ) */
		-115836103 , /* 108 ( 0.421875 ) */
		-114599064 , /* 109 ( 0.42578125 ) */
		-113373323 , /* 110 ( 0.4296875 ) */
		-112158675 , /* 111 ( 0.43359375 ) */
		-110954920 , /* 112 ( 0.4375 ) */
		-109761866 , /* 113 ( 0.44140625 ) */
		-108579323 , /* 114 ( 0.4453125 ) */
		-107407109 , /* 115 ( 0.44921875 ) */
		-106245043 , /* 116 ( 0.453125 ) */
		-105092953 , /* 117 ( 0.45703125 ) */
		-103950667 , /* 118 ( 0.4609375 ) */
		-102818021 , /* 119 ( 0.46484375 ) */
		-101694854 , /* 120 ( 0.46875 ) */
		-100581007 , /* 121 ( 0.47265625 ) */
		-99476329 , /* 122 ( 0.4765625 ) */
		-98380668 , /* 123 ( 0.48046875 ) */
		-97293878 , /* 124 ( 0.484375 ) */
		-96215819 , /* 125 ( 0.48828125 ) */
		-95146349 , /* 126 ( 0.4921875 ) */
		-94085334 , /* 127 ( 0.49609375 ) */
		-93032640 , /* 128 ( 0.5 ) */
		-91988139 , /* 129 ( 0.50390625 ) */
		-90951704 , /* 130 ( 0.5078125 ) */
		-89923210 , /* 131 ( 0.51171875 ) */
		-88902538 , /* 132 ( 0.515625 ) */
		-87889569 , /* 133 ( 0.51953125 ) */
		-86884188 , /* 134 ( 0.5234375 ) */
		-85886282 , /* 135 ( 0.52734375 ) */
		-84895741 , /* 136 ( 0.53125 ) */
		-83912457 , /* 137 ( 0.53515625 ) */
		-82936324 , /* 138 ( 0.5390625 ) */
		-81967238 , /* 139 ( 0.54296875 ) */
		-81005100 , /* 140 ( 0.546875 ) */
		-80049810 , /* 141 ( 0.55078125 ) */
		-79101270 , /* 142 ( 0.5546875 ) */
		-78159388 , /* 143 ( 0.55859375 ) */
		-77224069 , /* 144 ( 0.5625 ) */
		-76295223 , /* 145 ( 0.56640625 ) */
		-75372760 , /* 146 ( 0.5703125 ) */
		-74456595 , /* 147 ( 0.57421875 ) */
		-73546641 , /* 148 ( 0.578125 ) */
		-72642814 , /* 149 ( 0.58203125 ) */
		-71745033 , /* 150 ( 0.5859375 ) */
		-70853218 , /* 151 ( 0.58984375 ) */
		-69967289 , /* 152 ( 0.59375 ) */
		-69087170 , /* 153 ( 0.59765625 ) */
		-68212784 , /* 154 ( 0.6015625 ) */
		-67344058 , /* 155 ( 0.60546875 ) */
		-66480918 , /* 156 ( 0.609375 ) */
		-65623294 , /* 157 ( 0.61328125 ) */
		-64771115 , /* 158 ( 0.6171875 ) */
		-63924313 , /* 159 ( 0.62109375 ) */
		-63082820 , /* 160 ( 0.625 ) */
		-62246570 , /* 161 ( 0.62890625 ) */
		-61415497 , /* 162 ( 0.6328125 ) */
		-60589540 , /* 163 ( 0.63671875 ) */
		-59768633 , /* 164 ( 0.640625 ) */
		-58952718 , /* 165 ( 0.64453125 ) */
		-58141732 , /* 166 ( 0.6484375 ) */
		-57335617 , /* 167 ( 0.65234375 ) */
		-56534315 , /* 168 ( 0.65625 ) */
		-55737768 , /* 169 ( 0.66015625 ) */
		-54945921 , /* 170 ( 0.6640625 ) */
		-54158718 , /* 171 ( 0.66796875 ) */
		-53376105 , /* 172 ( 0.671875 ) */
		-52598029 , /* 173 ( 0.67578125 ) */
		-51824438 , /* 174 ( 0.6796875 ) */
		-51055279 , /* 175 ( 0.68359375 ) */
		-50290504 , /* 176 ( 0.6875 ) */
		-49530062 , /* 177 ( 0.69140625 ) */
		-48773903 , /* 178 ( 0.6953125 ) */
		-48021981 , /* 179 ( 0.69921875 ) */
		-47274248 , /* 180 ( 0.703125 ) */
		-46530658 , /* 181 ( 0.70703125 ) */
		-45791164 , /* 182 ( 0.7109375 ) */
		-45055723 , /* 183 ( 0.71484375 ) */
		-44324289 , /* 184 ( 0.71875 ) */
		-43596820 , /* 185 ( 0.72265625 ) */
		-42873273 , /* 186 ( 0.7265625 ) */
		-42153605 , /* 187 ( 0.73046875 ) */
		-41437775 , /* 188 ( 0.734375 ) */
		-40725743 , /* 189 ( 0.73828125 ) */
		-40017469 , /* 190 ( 0.7421875 ) */
		-39312912 , /* 191 ( 0.74609375 ) */
		-38612035 , /* 192 ( 0.75 ) */
		-37914798 , /* 193 ( 0.75390625 ) */
		-37221165 , /* 194 ( 0.7578125 ) */
		-36531098 , /* 195 ( 0.76171875 ) */
		-35844561 , /* 196 ( 0.765625 ) */
		-35161517 , /* 197 ( 0.76953125 ) */
		-34481933 , /* 198 ( 0.7734375 ) */
		-33805771 , /* 199 ( 0.77734375 ) */
		-33132999 , /* 200 ( 0.78125 ) */
		-32463583 , /* 201 ( 0.78515625 ) */
		-31797488 , /* 202 ( 0.7890625 ) */
		-31134684 , /* 203 ( 0.79296875 ) */
		-30475136 , /* 204 ( 0.796875 ) */
		-29818813 , /* 205 ( 0.80078125 ) */
		-29165684 , /* 206 ( 0.8046875 ) */
		-28515718 , /* 207 ( 0.80859375 ) */
		-27868884 , /* 208 ( 0.8125 ) */
		-27225153 , /* 209 ( 0.81640625 ) */
		-26584494 , /* 210 ( 0.8203125 ) */
		-25946879 , /* 211 ( 0.82421875 ) */
		-25312279 , /* 212 ( 0.828125 ) */
		-24680665 , /* 213 ( 0.83203125 ) */
		-24052009 , /* 214 ( 0.8359375 ) */
		-23426284 , /* 215 ( 0.83984375 ) */
		-22803463 , /* 216 ( 0.84375 ) */
		-22183519 , /* 217 ( 0.84765625 ) */
		-21566425 , /* 218 ( 0.8515625 ) */
		-20952155 , /* 219 ( 0.85546875 ) */
		-20340684 , /* 220 ( 0.859375 ) */
		-19731985 , /* 221 ( 0.86328125 ) */
		-19126035 , /* 222 ( 0.8671875 ) */
		-18522808 , /* 223 ( 0.87109375 ) */
		-17922281 , /* 224 ( 0.875 ) */
		-17324428 , /* 225 ( 0.87890625 ) */
		-16729226 , /* 226 ( 0.8828125 ) */
		-16136653 , /* 227 ( 0.88671875 ) */
		-15546684 , /* 228 ( 0.890625 ) */
		-14959297 , /* 229 ( 0.89453125 ) */
		-14374469 , /* 230 ( 0.8984375 ) */
		-13792179 , /* 231 ( 0.90234375 ) */
		-13212403 , /* 232 ( 0.90625 ) */
		-12635122 , /* 233 ( 0.91015625 ) */
		-12060313 , /* 234 ( 0.9140625 ) */
		-11487955 , /* 235 ( 0.91796875 ) */
		-10918027 , /* 236 ( 0.921875 ) */
		-10350510 , /* 237 ( 0.92578125 ) */
		-9785382 , /* 238 ( 0.9296875 ) */
		-9222623 , /* 239 ( 0.93359375 ) */
		-8662214 , /* 240 ( 0.9375 ) */
		-8104136 , /* 241 ( 0.94140625 ) */
		-7548368 , /* 242 ( 0.9453125 ) */
		-6994892 , /* 243 ( 0.94921875 ) */
		-6443689 , /* 244 ( 0.953125 ) */
		-5894740 , /* 245 ( 0.95703125 ) */
		-5348028 , /* 246 ( 0.9609375 ) */
		-4803533 , /* 247 ( 0.96484375 ) */
		-4261239 , /* 248 ( 0.96875 ) */
		-3721126 , /* 249 ( 0.97265625 ) */
		-3183179 , /* 250 ( 0.9765625 ) */
		-2647379 , /* 251 ( 0.98046875 ) */
		-2113709 , /* 252 ( 0.984375 ) */
		-1582153 , /* 253 ( 0.98828125 ) */
		-1052694 , /* 254 ( 0.9921875 ) */
		-525315 , /* 255 ( 0.99609375 ) */
	};

	uint32_t idx, x0, x1, P_hi, P_lo, Q_hi, Q_lo;
	int32_t y0, y1, val;

	idx = (x >> 8) & 0xFF; /* idx is index into log table */

	if (idx == 0)
	{
		val = log_table0[x & 0xFF];
	}
	else
	{
		y0 = log_table1[idx];
		if (idx < 0xFF)
		{
			y1 = log_table1[idx+1];
		}
		else
		{
			y1 = 0;
		}

		x0 = x & 0xFF00;
		x1 = x & 0xFFFF;

		bcm4506_MultU32U32(x1 - x0, y1 - y0, &P_hi, &P_lo);
		bcm4506_DivU64U32(P_hi, P_lo, 256, &Q_hi, &Q_lo);

		val = y0 + (int32_t)Q_lo;
	}

	return val;
}


/**********************************************************************
bcm4506_interpolate_freq() - fixed point linear interpolation used in
power estimation
**********************************************************************/
int32_t bcm4506_interpolate_freq(uint32_t freq, uint32_t *F, int32_t *Y, int n)
{
	int32_t i, val;
	uint32_t P_hi, P_lo, Q_hi, Q_lo, diff;

	for (i = 1; i < n; i++)
	{
		if (freq < F[i])
		{
			break;
		}
	}

	if (i < n)
	{
		if (Y[i] >= Y[i-1])
		{
			diff = Y[i] - Y[i-1];
		}
		else
		{
			diff = Y[i-1] - Y[i];
		}

		bcm4506_MultU32U32(freq - F[i-1], diff, &P_hi, &P_lo);
		bcm4506_DivU64U32(P_hi, P_lo, F[i] - F[i-1], &Q_hi, &Q_lo);

		val = Q_lo;

		if (Y[i] < Y[i-1])
		{
			val = -val;
		}

		val += Y[i-1];
	}
	else
	{
		if (Y[n-1] >= Y[n-2])
		{
			diff = Y[n-1] - Y[n-2];
		}
		else
		{
			diff = Y[n-2] - Y[n-1];
		}

		bcm4506_MultU32U32(diff, freq - F[n-1], &P_hi, &P_lo);
		bcm4506_DivU64U32(P_hi, P_lo, F[n-1] - F[n-2], &Q_hi, &Q_lo);

		val = Q_lo;

		if (Y[n-1] < Y[n-2])
		{
			val = -val;
		}

		val += Y[n-1];
	}

	return val;
}


/**********************************************************************
bcm4506_get_input_power() - calculates input power in 2^-24 dBm
**********************************************************************/
void bcm4506_get_input_power(uint32_t rfagc, uint32_t ifagc, uint32_t agf, uint32_t tuner_freq, uint8_t bcm3445_agc, int32_t *pPower)
{
#define MAX_AIT (0xFFFF00)
#define MAX_AII (0xFFFFFF)
#define NUM_FREQS 7

	static uint32_t freq_range[NUM_FREQS] =
	{
		250000000UL,
		502000000UL,
		754000000UL,
		958000000UL,
		1350000000UL,
		1750000000UL,
		1970000000UL
	};

	static int32_t p2_all_fixed[3][NUM_FREQS] =
	{ /* parabolic interpolation for LNA, signed 7.25 */
		{
			-1406299800,
			1097947991,
			901647853,
			850339771,
			1096243426,
			716927349,
			1153346358
		},
		{
			2132122430,
			-163755694,
			17817403,
			61095909,
			-188827566,
			239957809,
			-202950626
		},
		{
			568542940,
			17069139,
			-19780337,
			-50918850,
			37379637,
			-88982998,
			12139993
		}
	};

	static int32_t x_offset_params_fixed[NUM_FREQS] =
	{ /* fine gain offset, signed 5.27 */
		-575257182,
		-576411454,
		-576143019,
		-576921482,
		-576263815,
		-576827529,
		-576559094
	};

	static int32_t p1_offset_params_fixed[NUM_FREQS] =
	{ /* input power offset, signed 8.24 */
		-1264097794,
		-1285117968,
		-1266205012,
		-1246743442,
		-1223837509,
		-1206979762,
		-1235058111
	};

	static int32_t m_rf1_params_fixed[NUM_FREQS] =
	{ /* slope for RF high gain region, signed 7.25 */
		-1035929334,
		-981457069,
		-1052297186,
		-1066775923,
		-1075265195,
		-1002636627,
		-1114409795
	};

	static int32_t m_rf2_params_fixed[NUM_FREQS] =
	{ /* slope for RF low gain region, signed 7.25 */
		-921763735,
		-878897948,
		-812376286,
		-755753182,
		-566992725,
		-606660775,
		-589393664
	};

	static int32_t m_if_params_fixed[NUM_FREQS] =
	{ /* slope for IF region, signed 6.26 */
		-2048833617,
		2100702059,
		-2030023003,
		-2003803570,
		-1902777886,
		-1794813145,
		-1846138005
	};

	static int32_t m_fine_params_fixed[NUM_FREQS] =
	{ /* slope for fine gain region, signed 5.27 */
		-1174525915,
		-977668774,
		-1052870967,
		-1074990048,
		-1125684084,
		-1185504926,
		-1201543944
	};

	int i;
	int32_t p2[3], x_offset, p1_offset, m_rf1, m_rf2, m_if, m_fine, Pin, Pin_agt, Pin_aif, Pin_aii, Pin_ait, Pin_lna, Pin_ndfctl, x;
	uint32_t aif, if_gain, max_if_gain, rf_gain, max_rf_gain, fine_gain, P_hi, P_lo, Q_hi, Q_lo, lna_gain, val, val2;
	uint8_t lna_agc;

	/* generate a set of interpolation parameters for power estimation */
	for (i = 0; i < 3; i++)
	{
		p2[i] = bcm4506_interpolate_freq(tuner_freq, freq_range, p2_all_fixed[i], NUM_FREQS);
	}
	x_offset = bcm4506_interpolate_freq(tuner_freq, freq_range, x_offset_params_fixed, NUM_FREQS);
	p1_offset = bcm4506_interpolate_freq(tuner_freq, freq_range, p1_offset_params_fixed, NUM_FREQS);
	m_rf1 = bcm4506_interpolate_freq(tuner_freq, freq_range, m_rf1_params_fixed, NUM_FREQS);
	m_rf2 = bcm4506_interpolate_freq(tuner_freq, freq_range, m_rf2_params_fixed, NUM_FREQS);
	m_if = bcm4506_interpolate_freq(tuner_freq, freq_range, m_if_params_fixed, NUM_FREQS);
	m_fine = bcm4506_interpolate_freq(tuner_freq, freq_range, m_fine_params_fixed, NUM_FREQS);

	/* initialize parameters */
#if 1
	lna_agc = bcm3445_agc;
#else
	lna_agc = 0;

	if (pLnaStatus)
	{
		if ((pLnaStatus->version != 0) && (pLnaStatus->tuner_input != BAST_Bcm3445OutputChannel_eNone) && (pLnaStatus->out_cfg != BAST_Bcm3445OutputConfig_eOff))
		{
			/* BCM3445 was detected and it is controlled by BCM4506 */
			lna_agc = pLnaStatus->agc;
		}
	}
#endif

	/* calculate rf_gain, if_gain, fine_gain, max_rf_gain, max_if_gain, and lna_gain in unsigned 16.16 format */
	bcm4506_MultU32U32(ifagc >> 8, 65536 * 2, &P_hi, &P_lo);
	bcm4506_DivU64U32(P_hi, P_lo, 16777216, &Q_hi, &Q_lo);
	if_gain = (Q_lo + 1) >> 1;

	bcm4506_MultU32U32(MAX_AII, 65536 * 2, &P_hi, &P_lo);
	bcm4506_DivU64U32(P_hi, P_lo, 16777216, &Q_hi, &Q_lo);
	max_if_gain = (Q_lo + 1) >> 1;

	bcm4506_MultU32U32(rfagc >> 8, 65536 * 2, &P_hi, &P_lo);
	bcm4506_DivU64U32(P_hi, P_lo, 16777216, &Q_hi, &Q_lo);
	rf_gain = (Q_lo + 1) >> 1;

	bcm4506_MultU32U32(MAX_AIT, 65536 * 2, &P_hi, &P_lo);
	bcm4506_DivU64U32(P_hi, P_lo, 16777216, &Q_hi, &Q_lo);
	max_rf_gain = (Q_lo + 1) >> 1;

	lna_gain = ((lna_agc * 2048) + 1) >> 1;

	aif = agf >> 8;

	bcm4506_MultU32U32(aif, 65536, &P_hi, &P_lo);
	bcm4506_DivU64U32(P_hi, P_lo, 16777216, &Q_hi, &fine_gain);

	/* get input power from AIF in 8.24 */
	/* Pin_aif = m_fine * (log(fine_gain) - x_offset); */
	if (fine_gain)
	{
		x = bcm4506_log_x(fine_gain) - x_offset; /* 5.27 */
		val = x;
		if (x < 0)
		{
			val = ~val + 1;
		}

		val2 = m_fine;
		if (m_fine < 0)
		{
			val2 = ~val2 + 1; /* 5.27 */
		}

		bcm4506_MultU32U32(val, val2, &P_hi, &P_lo); /* 10.54 */
		bcm4506_DivU64U32(P_hi, P_lo, 1073741824, &Q_hi, &Q_lo); /* divide by 2^30 */

		Pin_aif = Q_lo; /* 8.24 */
		if (((x >= 0) && (m_fine < 0)) || ((x < 0) && (m_fine >= 0)))
		{
			Pin_aif = -Pin_aif;
		}
	}
	else
	{
		Pin_aif = 0;
	}

	/* get input power from AII in 8.24 */
	/* Pin_aii = m_if * (if_gain - max_if_gain); */
	val = m_if;
	if (m_if < 0)
	{
		val = ~val + 1;
	}

	bcm4506_MultU32U32(max_if_gain - if_gain, val, &P_hi, &P_lo); /* 22.42 */
	bcm4506_DivU64U32(P_hi, P_lo, 262144, &Q_hi, &Q_lo); /* 8.24 */
	Pin_aii = (int32_t)Q_lo;

	if (m_if >= 0)
	{
		Pin_aii = -Pin_aii;
	}

	/* get input power from AIT in 8.24 */
	val = m_rf2;
	if (m_rf2 < 0)
	{
		val = ~val + 1;
	}

	if (rf_gain >= 32768)
	{
		/* Pin_ait = m_rf2 * (rf_gain - max_rf_gain) */
		bcm4506_MultU32U32(max_rf_gain - rf_gain, val, &P_hi, &P_lo); /* 23.41 */
		bcm4506_DivU64U32(P_hi, P_lo, 131072, &Q_hi, &Q_lo); /* 8.24 */
		Pin_ait = (int32_t)Q_lo;

		if (m_rf2 >= 0)
		{
			Pin_ait = -Pin_ait;
		}
	}
	else
	{
		/* Pin_ait = ((m_rf2 * (0.5 - max_rf_gain)) + (m_rf1 * (rf_gain - 0.5))) */
		bcm4506_MultU32U32(max_rf_gain - 32768, val, &P_hi, &P_lo); /* 23.41 */
		bcm4506_DivU64U32(P_hi, P_lo, 131072, &Q_hi, &Q_lo); /* 8.24 */
		Pin_ait = (int32_t)Q_lo;

		if (m_rf2 >= 0)
		{
			Pin_ait = -Pin_ait;
		}

		val = m_rf1;
		if (m_rf1 < 0)
		{
			val = ~val + 1;
		}

		bcm4506_MultU32U32(32768 - rf_gain, val, &P_hi, &P_lo); /* 23.41 */
		bcm4506_DivU64U32(P_hi, P_lo, 131072, &Q_hi, &Q_lo); /* 8.24 */

		if (m_rf1 >= 0)
		{
			Pin_ait -= (int32_t)Q_lo;
		}
		else
		{
			Pin_ait += (int32_t)Q_lo;
		}
	}

	/* get input power from LNA in 8.24 */
	if (lna_agc)
	{
		/* val*(p2[0]*val + p2[1]) + p2[2] */
		if (lna_gain <= 4096) /* 4/64 * 2^16 = 4096 */
		{
			val = 4096;
		}
		else
		{
			val = lna_gain;
		}

		if (p2[0] >= 0)
		{
			val2 = p2[0];
		}
		else
		{
			val2 = ~p2[0] + 1;
		}

		bcm4506_MultU32U32(val, val2, &P_hi, &P_lo); /* 23.41 */
		bcm4506_DivU64U32(P_hi, P_lo, 65536, &Q_hi, &Q_lo); /* 7.25 */

		if (p2[0] >= 0)
		{
			Pin_lna = (int32_t)Q_lo + p2[1];
		}
		else
		{
			Pin_lna = p2[1] - (int32_t)Q_lo;
		}

		if (Pin_lna >= 0)
		{
			val2 = Pin_lna;
		}
		else
		{
			val2 = ~Pin_lna + 1;
		}

		bcm4506_MultU32U32(val, val2, &P_hi, &P_lo); /* 23.41 */
		bcm4506_DivU64U32(P_hi, P_lo, 65536, &Q_hi, &Q_lo); /* 7.25 */

		if (Pin_lna >= 0)
		{
			Pin_lna = (int32_t)Q_lo + p2[2];
		}
		else
		{
			Pin_lna = p2[2] - (int32_t)Q_lo;
		}

		Pin_lna = Pin_lna / 2; /* 8.24 */

		if (lna_gain <= 4096)
		{
			if (Pin_lna >= 0)
			{
				val2 = Pin_lna;
			}
			else
			{
				val2 = ~Pin_lna + 1;
			}

			bcm4506_MultU32U32(lna_gain << 4, val2, &P_hi, &P_lo); /* 24.40 */
			bcm4506_DivU64U32(P_hi, P_lo, 65536, &Q_hi, &Q_lo); /* 8.24 */

			if (Pin_lna >= 0)
			{
				Pin_lna = Q_lo;
			}
			else
			{
				Pin_lna = ~Q_lo + 1;
			}
		}
	}
	else
	{
		Pin_lna = 0;
	}

	/* AGT adjustment */
	if ((agf & 0x0F) != 0x0A)
	{
		Pin_agt = 114293314;
	}
	else
	{
		Pin_agt = 0;
	}

	/* non-decimating filter adjustment */
	switch (agf & 0xC0)
	{
		/* quarterband */
		case 0x00:
			/* no adjustment */
			Pin_ndfctl = 0;
			break;

		/* thirdband */
		case 0x40:
			/* adjust by -20log10(.75) */
			Pin_ndfctl = 41922483;
			break;

		/* halfband */
		case 0x80:
			/* adjust by -20log10(.5) */
			Pin_ndfctl = 101008905;
			break;

		/* sharpened halfband */
		default:
			/* adjust by -20log10(.25) */
			Pin_ndfctl = 202017810;
			break;
	}

	/* Pin = total input power, signed 8.24 */
	Pin = p1_offset + Pin_aif + Pin_aii + Pin_ait + Pin_lna + Pin_agt + Pin_ndfctl;

	/* Divide by 2^24 */
	*pPower = Pin / 16777216;
}
/******************************************** End of BCM4506 RF Input Power Monitoring Function ********************************************/


static HUINT32 GetFreqSearchRange( HUINT32 ulSymbolRate )
{
	HUINT32 ulFreqSearchrange = 0;
	/*************************************
	        Normal Search range                                     Support CI+ Certi
		[Symbolrate]          [Search range]
		45 ~ 20Ms/s =	+/- (10MHz)                            45 ~ 22Ms/s    =	+/- (8MHz)
		20 ~ 18Ms/s =	+/- (8MHz)                              22 ~ 18Ms/s    =	+/- (6MHz)
		18 ~ 11Ms/s =	+/- (6MHz)                              18 ~ 11Ms/s    =	+/- (6MHz)
		11 ~ 8Ms/s	=	+/- (5MHz)                      11 ~ 8Ms/s	=	+/- (5MHz)
		8 ~ 4Ms/s	=	+/- (4MHz)                       8 ~ 4Ms/s	=	+/- (4MHz)
		4 ~ 1Ms/s	=	+/- (3.8MHz)                    4 ~ 1Ms/s	=	+/- (3.8MHz)
	**************************************/

	if(( ulSymbolRate >= 1000) && (ulSymbolRate <= 4000))
	{
		ulFreqSearchrange = 3800000;
	}
	else if(( ulSymbolRate > 4000) && (ulSymbolRate <= 8000))
	{
		ulFreqSearchrange = 4000000;
	}
	else if(( ulSymbolRate > 8000) && (ulSymbolRate <= 11000))
	{
		ulFreqSearchrange = 5000000;
	}
	else if(( ulSymbolRate > 11000) && (ulSymbolRate <= 18000))
	{
		ulFreqSearchrange = 6000000;
	}
#if defined( CONFIG_SUPPORT_CI_PLUS_CERTI )
       else if(( ulSymbolRate > 18000) && (ulSymbolRate <= 22000))
	{
		ulFreqSearchrange = 6000000;
	}
	else if(( ulSymbolRate > 22000) && (ulSymbolRate <= 45000))
	{
		ulFreqSearchrange = 8000000;
	}
	else
	{
		ulFreqSearchrange = 8000000;
	}
#else
	else if(( ulSymbolRate > 18000) && (ulSymbolRate <= 20000))
	{
		ulFreqSearchrange = 8000000;
	}
	else if(( ulSymbolRate > 20000) && (ulSymbolRate <= 45000))
	{
		ulFreqSearchrange = 10000000;
	}
	else
	{
		ulFreqSearchrange = 10000000;
	}
#endif

	return ulFreqSearchrange;
}



static NEXUS_FrontendSatelliteCodeRate GetNexusCodeRate(
	CH_SAT_CodeRate_e		etFecCodeRate
	)
{
	NEXUS_FrontendSatelliteCodeRate etCodeRate = g_cr_scan;

	switch(etFecCodeRate)
	{
		case DI_CH_SCODERATE_AUTO:
			etCodeRate = g_cr_scan;
			break;

		case DI_CH_SCODERATE_1_2:
			etCodeRate = g_cr_1_2;
			break;

		case DI_CH_SCODERATE_2_3:
			etCodeRate = g_cr_2_3;
			break;

		case DI_CH_SCODERATE_3_4:
			etCodeRate = g_cr_3_4;
			break;

		case DI_CH_SCODERATE_5_6:
			etCodeRate = g_cr_5_6;
			break;

		case DI_CH_SCODERATE_7_8:
			etCodeRate = g_cr_7_8;
			break;

		case DI_CH_S2CODERATE_3_5: /** DVB-S2:QPSK DVB-S2:8PSK */
			etCodeRate = g_cr_3_5;
			break;

		case DI_CH_S2CODERATE_4_5:  /** DVB-S2:QPSK */
			etCodeRate = g_cr_4_5;
			break;

		case DI_CH_SCODERATE_5_11:
			etCodeRate = g_cr_5_11;
			break;

		case DI_CH_SCODERATE_6_7:
			etCodeRate = g_cr_6_7;
			break;

		case DI_CH_S2CODERATE_8_9: /** DVB-S2:QPSK 	DVB-S2:8PSK */
			etCodeRate = g_cr_8_9;
			break;

		case DI_CH_S2CODERATE_9_10:  /** DVB-S2:QPSK 	DVB-S2:8PSK */
			etCodeRate = g_cr_9_10;
			break;

		default:
			CH_DI_Print(4, ("[GetNexusCodeRate] default: etCodeRate(%d)!\n", etFecCodeRate));
			break;
	}

	CH_DI_Print(4, ("[GetNexusCodeRate] etFecCodeRate (%d) ->  etCodeRate (%d/%d) \n", etFecCodeRate, etCodeRate.numerator, etCodeRate.denominator));

	return etCodeRate;
}


static NEXUS_FrontendSatelliteMode GetNexusMode(
				CH_SAT_TransportSpec_e	etTransSpec,
				CH_SAT_Modulation_e 	etModulation
)
{
	NEXUS_FrontendSatelliteMode etSatMode = NEXUS_FrontendSatelliteMode_eMax;

	if( etTransSpec == DI_CH_TRANS_DVBS )
	{
		if( etModulation == DI_CH_PSK_QPSK )
		{
			etSatMode = NEXUS_FrontendSatelliteMode_eDvb;
			CH_DI_Print(4, (" NEXUS_FrontendSatelliteMode_eDvb'.. (DVB-S)\n"));
		}
		else
		{
			etSatMode = NEXUS_FrontendSatelliteMode_eDvb;//NEXUS_FrontendSatelliteMode_eDvbScan;
			CH_DI_Print(4, (" NEXUS_FrontendSatelliteMode_eDvbScan'.. (DVB-S, AUTO)\n"));
		}
	}
	else if( etTransSpec == DI_CH_TRANS_DVBS2 )
	{
		if( etModulation == DI_CH_PSK_QPSK )
		{
			etSatMode = NEXUS_FrontendSatelliteMode_eQpskLdpc;
			CH_DI_Print(4, (" NEXUS_FrontendSatelliteMode_eQpskLdpc'.. (DVB-S2, QPSK)\n"));
		}
		else if(etModulation == DI_CH_PSK_8PSK )
		{
			etSatMode = NEXUS_FrontendSatelliteMode_e8pskLdpc;
			CH_DI_Print(4, (" NEXUS_FrontendSatelliteMode_e8pskLdpc'.. (DVB-S2, 8PSK)\n"));
		}
		else
		{
			etSatMode = NEXUS_FrontendSatelliteMode_eLdpc;//NEXUS_FrontendSatelliteMode_eLdpcScan;
			CH_DI_Print(4, (" NEXUS_FrontendSatelliteMode_eLdpcScan'.. (DVB-S2, AUTO)\n"));
		}
	}
	else
	{
		CH_DI_Print(1, ("[GetNexusMode] ERR! etTransSpec (%d)!\n", etTransSpec));
	}

	return etSatMode;
}

static void ConvertNexusToDiParam( NEXUS_FrontendSatelliteMode etSatMode, NEXUS_FrontendSatelliteCodeRate etCodeRate, CH_SAT_TuneParam_t * pstTuneParam )
{
	if(etSatMode == NEXUS_FrontendSatelliteMode_eDvb)
	{
		pstTuneParam->etTransSpec = DI_CH_TRANS_DVBS;
		pstTuneParam->etModulation	= DI_CH_PSK_QPSK;
		CH_DI_Print(4, ("[DB4506_NexusUpdateInfo] %x : DVBS, QPSK \n", etSatMode));
	}
	else if(etSatMode == NEXUS_FrontendSatelliteMode_eQpskLdpc)
	{
		pstTuneParam->etTransSpec = DI_CH_TRANS_DVBS2;
		pstTuneParam->etModulation	= DI_CH_PSK_QPSK;
		CH_DI_Print(4, ("[DB4506_NexusUpdateInfo] %x : DVBS2, QPSK \n", etSatMode));
	}
	else if(etSatMode == NEXUS_FrontendSatelliteMode_e8pskLdpc)
	{
		pstTuneParam->etTransSpec = DI_CH_TRANS_DVBS2;
		pstTuneParam->etModulation	= DI_CH_PSK_8PSK;
		CH_DI_Print(4, ("[DB4506_NexusUpdateInfo] %x : DVBS2, 8PSK \n", etSatMode));
	}
	else
	{
		pstTuneParam->etModulation	= DI_CH_PSK_AUTO;
	}

	CH_DI_Print(4, ("[DB4506_NexusUpdateInfo] etTransSpec [%d] , etModulation [%d]  \n", pstTuneParam->etTransSpec, pstTuneParam->etModulation ));

	if(etCodeRate.numerator == 1 && etCodeRate.denominator == 2)
		pstTuneParam->etFecCodeRate = DI_CH_SCODERATE_1_2;
	else if(etCodeRate.numerator == 2 && etCodeRate.denominator == 3)
		pstTuneParam->etFecCodeRate = DI_CH_SCODERATE_2_3;
	else if(etCodeRate.numerator == 3 && etCodeRate.denominator == 4)
		pstTuneParam->etFecCodeRate = DI_CH_SCODERATE_3_4;
	else if(etCodeRate.numerator == 5 && etCodeRate.denominator == 6)
		pstTuneParam->etFecCodeRate = DI_CH_SCODERATE_5_6;
	else if(etCodeRate.numerator == 7 && etCodeRate.denominator == 8)
		pstTuneParam->etFecCodeRate = DI_CH_SCODERATE_7_8;
	else if(etCodeRate.numerator == 3 && etCodeRate.denominator == 5)
		pstTuneParam->etFecCodeRate = DI_CH_S2CODERATE_3_5;
	else if(etCodeRate.numerator == 4 && etCodeRate.denominator == 5)
		pstTuneParam->etFecCodeRate = DI_CH_S2CODERATE_4_5;
	else if(etCodeRate.numerator == 8 && etCodeRate.denominator == 9)
		pstTuneParam->etFecCodeRate = DI_CH_S2CODERATE_8_9;
	else if(etCodeRate.numerator == 9 && etCodeRate.denominator == 10)
		pstTuneParam->etFecCodeRate = DI_CH_S2CODERATE_9_10;
	else
	{
		pstTuneParam->etFecCodeRate = DI_CH_SCODERATE_AUTO;
		CH_DI_Print(4, ("DI_CH_SCODERATE_AUTO \n"));
	}

	CH_DI_Print(4, (" etFecCodeRate [%d] \n",  pstTuneParam->etFecCodeRate));

	return;
}

static void ConvertDiToNexusParam( CH_SAT_TuneParam_t *pstSatTuneParam, NEXUS_FrontendSatelliteSettings *pstNexusTuneParam )
{

	if( pstSatTuneParam->etAntennaType == DI_CH_ANT_TYPE_SCD )
	{
		pstNexusTuneParam->frequency = pstSatTuneParam->ulScdUserBandFreq * MHZ_TO_HZ;
	}
	else
	{
		pstNexusTuneParam->frequency = pstSatTuneParam->ulFrequency * MHZ_TO_HZ;//KHZ_TO_HZ;
	}

	pstNexusTuneParam->symbolRate = pstSatTuneParam->ulSymbolRate * KHZ_TO_HZ;

	pstNexusTuneParam->mode = GetNexusMode( pstSatTuneParam->etTransSpec, pstSatTuneParam->etModulation );

	pstNexusTuneParam->codeRate = GetNexusCodeRate(pstSatTuneParam->etFecCodeRate);

	pstNexusTuneParam->searchRange = GetFreqSearchRange(pstSatTuneParam->ulSymbolRate);

	pstNexusTuneParam ->ldpcPilotScan = true;
	pstNexusTuneParam ->ldpcPilot = false;
	pstNexusTuneParam ->ldpcPilotPll = false;

	pstNexusTuneParam->carrierOffset = 0;

	return;
}


static HUINT32 ConvertStrengthLevel(
	HINT32  nInputPower
)
{
	HUINT32 ulStrength = 0;

	CH_DI_Print(4, ("[ConvertStrengthLevel] Input_power: %d \n", nInputPower));

	if(nInputPower >= -12)			// < -30 dBm
		ulStrength = 100;
	else if( nInputPower >= -18)	// -35 dBm
		ulStrength = 90;
	else if( nInputPower >= -27)	// -40 dBm
		ulStrength = 85;
	else if( nInputPower >= -31)	// -45 dBm
		ulStrength = 80;
	else if( nInputPower >= -35)	// -50 dBm
		ulStrength = 75;
	else if( nInputPower >= -39)	// -55 dBm
		ulStrength = 70;
	else if( nInputPower >= -45)	// -60 dBm
		ulStrength = 60;
	else if( nInputPower >= -50)	// -65 dBm
		ulStrength = 50;
	else if( nInputPower >= -54)	// -70 dBm
		ulStrength = 40;
	else if( nInputPower >= -59)	// -75 dBm
		ulStrength = 30;
	else if( nInputPower >= -65)	// -80 dBm
		ulStrength = 20;
	else							// -85 dBm
		ulStrength = 10;

	CH_DI_Print(4, ("[ConvertStrengthLevel] => ulStrength: (%d)  \n", ulStrength ));

	return ulStrength;
}



static HUINT32 ConvertQualityLevel(
	HUINT32 ulInSnr
)
{
	HUINT32 ulQuality = 0;

	CH_DI_Print(4, ("[ConvertQualityLevel] ulInSnr: %d \n", ulInSnr));

	if( ulInSnr > 1116)			//11.16 dB / 10 dB
		ulQuality = 100;
	else if( ulInSnr > 1066)	//10.66dB / 9.5 dB
		ulQuality = 95;
	else if( ulInSnr > 1016)	//10.16dB / 9 dB
		ulQuality = 90;
	else if( ulInSnr > 964)		//9.64 dB / 8.5 dB
		ulQuality = 85;
	else if( ulInSnr > 917)		//9.17 dB / 8 dB
		ulQuality = 80;
	else if( ulInSnr > 867)		//8.67 dB / 7.5 dB
		ulQuality = 75;
	else if( ulInSnr > 816)		//8.16 dB / 7 dB
		ulQuality = 70;
	else if( ulInSnr > 767)		//7.67 dB / 6.5 dB
		ulQuality = 65;
	else if( ulInSnr > 717)		//7.17 dB / 6 dB
		ulQuality = 60;
	else if( ulInSnr > 668)		//6.68 dB / 5.5 dB
		ulQuality = 55;
	else if( ulInSnr > 620)		//6.2 dB / 5 dB
		ulQuality = 50;
	else if( ulInSnr > 572)		//5.72 dB / 4.5 dB
		ulQuality = 45;
	else if( ulInSnr > 525)		//5.25 dB / 4 dB
		ulQuality = 40;
	else if( ulInSnr > 477)		//4.77 dB / 3.5 dB
		ulQuality = 35;
	else if( ulInSnr > 434)		//4.34 dB / 3 dB
		ulQuality = 30;
	else if( ulInSnr > 330)		//3.3 dB / 2 dB
		ulQuality = 20;
	else if( ulInSnr > 230)		//2.3 dB / 1 dB
		ulQuality = 10;
	else
		ulQuality = 5;

	CH_DI_Print(4, ("[ConvertQualityLevel] => ulQuality: (%d)	\n", ulQuality ));

	return ulQuality;

}


static int GetSignalStatus( int nChannelId, DI_CH_SignalQuality_t *pstSignalInfo )
{
	NEXUS_Error 	etNErrorCode = NEXUS_SUCCESS;
	NEXUS_FrontendSatelliteStatus stFrontendStatus;

	HINT32 input_power, nUnitId, nRfInputId;
	HUINT8 ucLnaAgc, uc3445LnaAgc0, uc3445LnaAgc1;

	HUINT8  ucRetBER = 0;
	HUINT32 ulStrength = 0;

	nUnitId = GetDeviceUnitId( nChannelId );
	nRfInputId = GetRfInputId( nChannelId );

	DRV_CH_LockI2c(nUnitId);

	etNErrorCode = NEXUS_Frontend_GetSatelliteStatus(s_stFrontend[nUnitId], &stFrontendStatus);
	if(etNErrorCode != NEXUS_SUCCESS)
	{
		CH_DI_Print(0, ( "[GetSignalStatus] [%d] ERR! NEXUS_Frontend_GetSatelliteStatus (0x%x)",nUnitId, etNErrorCode ));
		DRV_CH_UnLockI2c(nUnitId);
		return DI_CH_ERR;
	}

	DRV_CH_UnLockI2c(nUnitId);

	CH_DI_Print(5, ("Selected Tuner ID = %d\n", nUnitId));
	CH_DI_Print(5, ("----------------------------------------------------------------------------------------\n"));
	CH_DI_Print(5, ("frequency            =(%d)Hz\n", stFrontendStatus.frequency                        ));
	CH_DI_Print(5, ("demodLocked          =(%d)\n", stFrontendStatus.demodLocked                      ));
	CH_DI_Print(5, ("bertLocked           =(%d)\n", stFrontendStatus.bertLocked                       ));
	CH_DI_Print(5, ("symbolRate           =(%d)\n", stFrontendStatus.symbolRate                       ));
	CH_DI_Print(5, ("symbolRateError      =(%d)\n", stFrontendStatus.symbolRateError                  ));
	CH_DI_Print(5, ("carrierOffset        =(%d)\n", stFrontendStatus.carrierOffset                    ));
	//CH_DI_Print(5, ("carrierError         =(%d)\n", stFrontendStatus.carrierError                     ));
	CH_DI_Print(5, ("outputBitRate        =(%d)\n", stFrontendStatus.outputBitRate                    ));
	CH_DI_Print(5, ("ifAgcLevel           =(%d)\n", stFrontendStatus.ifAgcLevel                       ));
	CH_DI_Print(5, ("rfAgcLevel           =(%d)\n", stFrontendStatus.rfAgcLevel                       ));
	CH_DI_Print(5, ("intAgcLevel          =(%d)\n", stFrontendStatus.intAgcLevel                      ));
	CH_DI_Print(5, ("snrEstimate          =(%d)(1/100 dB)\n", stFrontendStatus.snrEstimate                      ));
	CH_DI_Print(5, ("berEstimate          =(%d)\n", stFrontendStatus.berEstimate                      ));
	CH_DI_Print(5, ("fecCorrected         =(%d)\n", stFrontendStatus.fecCorrected                     ));
	CH_DI_Print(5, ("fecUncorrected       =(%d)\n", stFrontendStatus.fecUncorrected                   ));
	CH_DI_Print(5, ("fecClean             =(%d)\n", stFrontendStatus.fecClean                         ));
	CH_DI_Print(5, ("bitErrCorrected      =(%d)\n", stFrontendStatus.bitErrCorrected                  ));
	CH_DI_Print(5, ("reacquireCount       =(%d)\n", stFrontendStatus.reacquireCount                   ));
#if (NEXUS_VERSION < 1200)
	CH_DI_Print(5, ("berErrors            =(%d)\n", stFrontendStatus.berErrors                        ));
#else
	CH_DI_Print(5, ("berErrorCount        =(%d)\n", stFrontendStatus.berErrorCount                    ));
#endif
	CH_DI_Print(5, ("preViterbiErrorCount =(%d)\n", stFrontendStatus.preViterbiErrorCount             ));
	CH_DI_Print(5, ("mpegErrors           =(%d)\n", stFrontendStatus.mpegErrors                       ));
	CH_DI_Print(5, ("mpegCount            =(%d)\n", stFrontendStatus.mpegCount                        ));
	CH_DI_Print(5, ("ifAgc                =(%d)\n", stFrontendStatus.ifAgc                            ));
	CH_DI_Print(5, ("rfAgc                =(%d)\n", stFrontendStatus.rfAgc                            ));
	CH_DI_Print(5, ("agf                  =(%d)\n", stFrontendStatus.agf                              ));
	CH_DI_Print(5, ("----------------------------------------------------------------------------------------\n"));
	CH_DI_Print(5, ("chipId               =(%x)\n", stFrontendStatus.version.chipId                   ));
	CH_DI_Print(5, ("chipVersion          =(%x)\n", stFrontendStatus.version.chipVersion              ));
	CH_DI_Print(5, ("bondingOption        =(%x)\n", stFrontendStatus.version.bondingOption            ));
	CH_DI_Print(5, ("MajVer               =(%x)\n", stFrontendStatus.version.apMicrocodeVersion       ));
	CH_DI_Print(5, ("MinVer               =(%x)\n", stFrontendStatus.version.hostConfigurationVersion ));
	CH_DI_Print(5, ("----------------------------------------------------------------------------------------\n"));

	DRV_CH_LockI2c(nRfInputId);

	etNErrorCode = NEXUS_Frontend_Get3445LnaAgc(s_stFrontend[nRfInputId], &uc3445LnaAgc0, &uc3445LnaAgc1);
	if(etNErrorCode != NEXUS_SUCCESS)
	{
		CH_DI_Print(0, ( "[GetSignalStatus] [%d] ERR! NEXSUS_Frontend_Get3445LnaAgc (0x%x)",nRfInputId, etNErrorCode ));
		DRV_CH_UnLockI2c(nRfInputId);
		return DI_CH_ERR;
	}

	DRV_CH_UnLockI2c(nRfInputId);

	if ((nUnitId % 2) == 0)
	{
		ucLnaAgc = uc3445LnaAgc0;
	}
	else
	{
		ucLnaAgc = uc3445LnaAgc1;
	}

	CH_DI_Print(5, ("Selected RF Input ID = %d\n", nRfInputId));
	CH_DI_Print(5, ("----------------------------------------------------------------------------------------\n"));
	CH_DI_Print(5, ("LNA1 AGC             =(%d)\n", uc3445LnaAgc0                                     ));
	CH_DI_Print(5, ("LNA2 AGC             =(%d)\n", uc3445LnaAgc1                                     ));
	CH_DI_Print(5, ("----------------------------------------------------------------------------------------\n"));

	bcm4506_get_input_power(stFrontendStatus.rfAgc, stFrontendStatus.ifAgc, stFrontendStatus.agf, stFrontendStatus.frequency, ucLnaAgc, &input_power);

	ulStrength = ConvertStrengthLevel(input_power);
	ucRetBER = ConvertQualityLevel(stFrontendStatus.snrEstimate);

	if( stFrontendStatus.demodLocked == true)
	{
		pstSignalInfo->fSnr = ((float)(stFrontendStatus.snrEstimate))/100;
		pstSignalInfo->ulAgc = 0;
		pstSignalInfo->ulRfAgc = (HUINT32)stFrontendStatus.rfAgc;
		pstSignalInfo->ulIfAgc = (HUINT32)stFrontendStatus.ifAgc;
		pstSignalInfo->ulUnCorrectedNo = stFrontendStatus.fecUncorrected;
		pstSignalInfo->fSignalInputPower = (HFLOAT32)input_power;
		pstSignalInfo->fBer = stFrontendStatus.berEstimate;
		pstSignalInfo->ulQuality = (HUINT32)ucRetBER;
		pstSignalInfo->ulStrength = ulStrength;
	}
	else
	{
		/* demod unlock */
		pstSignalInfo->fSnr = 0;
		pstSignalInfo->ulAgc = 0;
		pstSignalInfo->ulRfAgc = 0;
		pstSignalInfo->ulIfAgc = 0;
		pstSignalInfo->ulUnCorrectedNo = 0;
		pstSignalInfo->fSignalInputPower = 0;
		pstSignalInfo->fBer = 0;
		pstSignalInfo->ulQuality = 0;
		pstSignalInfo->ulStrength = 0;

		CH_DI_Print(1, ( "[GetSignalStatus] [%d] Demod UnLocked \n", nUnitId));
	}

	return DI_CH_OK;
}


static void DiseqcCompleteCallback(void *data, int unused)
{
	BSTD_UNUSED(data);
	BSTD_UNUSED(unused);
}

static int  ResetGpio(int nUnitId)
{
	CH_DI_Print(2,("[ResetGpio] nUnitId[%d] \n", nUnitId));

	if(nUnitId == CHANNEL_ID0)	/* Master BCM4506 */
	{
		DRV_GPIO_Write(GPIO_ID_nCH0_RST, GPIO_HI);
		VK_TASK_Sleep(30);

		DRV_GPIO_Write(GPIO_ID_nCH0_RST, GPIO_LOW);
		VK_TASK_Sleep(30);

		DRV_GPIO_Write(GPIO_ID_nCH0_RST, GPIO_HI);
		VK_TASK_Sleep(240);
	}
	else if(nUnitId == CHANNEL_ID2)	/* Slave BCM4506 */
	{
		DRV_GPIO_Write(GPIO_ID_nCH1_RST, GPIO_HI);
		VK_TASK_Sleep(30);

		DRV_GPIO_Write(GPIO_ID_nCH1_RST, GPIO_LOW);
		VK_TASK_Sleep(30);

		DRV_GPIO_Write(GPIO_ID_nCH1_RST, GPIO_HI);
		VK_TASK_Sleep(240);
	}
	else
	{
		CH_DI_Print(2, ("[ResetGpio] No need to control reset GPIO for nUnitId[%d] \n", nUnitId));
	}

	return DI_CH_OK;
}

#define __DB4506_PUBLIC_FUNCITONS__

/*********************** External Function ***********************/
void DRV_S_InstallApi( void )
{
	NIM_InitDevice 			= &DB4506_InitDevice;
	NIM_SetTune 			= &DB4506_SetTune;
	NIM_CheckTuneState 		= &DB4506_CheckTuneState;
	NIM_CheckLock 			= &DB4506_CheckLock;
	NIM_GetSignalInfo 		= &DB4506_GetSignalInfo;
	NIM_SetPowerState 		= &DB4506_SetPowerState;
	NIM_EnableTsOutput 		= &DB4506_EnableTsOutput;
	NIM_DisableTsOutput 	= &DB4506_DisableTsOutput;
	NIM_SendDiseqcMsg 		= &DB4506_SendDiseqcMsg;
	NIM_UpdateTunedParam	= &DB4506_UpdateTunedParam;
	NIM_SetInputMode		= &DB4506_SetInputMode;
	NIM_SetInputSource		= &DB4506_SetInputSource;
	NIM_SetToneBurst		= &DB4506_SetToneBurst;

	LNB_Get22KhzTone		= &DB4506_LnbGet22KhzTone;
	LNB_Set22KhzTone		= &DB4506_LnbSet22KhzTone;

	LNB_InitDevice 			= &DRV_CH_LNB_Init;
	LNB_SetOutput			= &DRV_CH_LNB_SetOutput;
	LNB_SetPolarisation 	= &DRV_CH_LNB_SetPolar;
	LNB_CheckAntState		= &DRV_CH_LNB_CheckAntState;
	return;
}



int DB4506_InitDevice( int nChannelId )
{
	int				nUnitId;
	int				nDeviceSetId;
	NEXUS_Error 	etNErrorCode = NEXUS_SUCCESS;
	NEXUS_FrontendHandle	stFrontend;
	HUINT32			ulI2cBusId = I2C_CHANNEL_CHANNEL;

	NEXUS_PlatformConfiguration platformConfig;

	nUnitId = GetDeviceUnitId( nChannelId );

	DRV_CH_LockI2c(nUnitId);

	ResetGpio(nUnitId);

	if ((nUnitId == 0) || (nUnitId == 1))
	{
		ulI2cBusId = I2C_CHANNEL_CHANNEL;

	}
	else if ((nUnitId == 2) || (nUnitId == 3))
	{
		ulI2cBusId = I2C_CHANNEL_CHANNEL2;
	}

	DRV_I2c_SetClock( ulI2cBusId, DRV_I2C_CLOCK_400K );
	stFrontend = NEXUS_Platform_OpenFrontend(nUnitId);
	if (stFrontend == NULL)
	{
		CH_DI_Print(0,("[DB4506_InitDevice] [%d] FW Download Fail, Re-try with I2C 100KHz \n",nUnitId));

		ResetGpio(nUnitId);
		DRV_I2c_SetClock( ulI2cBusId, DRV_I2C_CLOCK_100K );
		stFrontend = NEXUS_Platform_OpenFrontend(nUnitId);
		if (stFrontend == NULL)
		{
			CH_DI_Print(0,("[DB4506_InitDevice] [%d] Unable to open Satellite-capable frontend \n",nUnitId));
			DRV_CH_UnLockI2c(nUnitId);
			return DI_CH_ERR;
		}
	}
	DRV_I2c_SetClock( ulI2cBusId, DRV_I2C_CLOCK_100K );

	NEXUS_Platform_GetConfiguration(&platformConfig);

	s_stFrontend[nUnitId] = platformConfig.frontend[nUnitId];
	if( NULL == s_stFrontend[nUnitId] )
	{
		CH_DI_Print(0, ("[DB4506_InitDevice] [%d] ERR! Unable to find Satellite-capable frontend\n",nUnitId));
		DRV_CH_UnLockI2c(nUnitId);
		return DI_CH_ERR;
	}

	//CH_DI_Print(4,("CH[%d] s_stFrontend (%x), frontend(0x%x) \n", nUnitId, s_stFrontend[nUnitId], platformConfig.frontend[nUnitId] ));

	etNErrorCode = NEXUS_Frontend_ResetDiseqc(s_stFrontend[nUnitId], FALSE);
	if(etNErrorCode != NEXUS_SUCCESS)
	{
		CH_DI_Print(0, ( "[DB4506_InitDevice] [%d] ERR! NEXUS_Frontend_ResetDiseqc() Error Code(0x%x)",nUnitId, etNErrorCode ));
		DRV_CH_UnLockI2c(nUnitId);
		return DI_CH_ERR;
	}

	/* PKT_CLK runs continuously.*//* false=CLK runs continuously, true=CLK is suppressed when VALID not active */
	etNErrorCode = NEXUS_Frontend_SetXportCtrl(s_stFrontend[nUnitId], FALSE);
	if(etNErrorCode != NEXUS_SUCCESS)
	{
		CH_DI_Print(0, ( "[DB4506_InitDevice] [%d] ERR! NEXUS_Frontend_SetXportCtrl() Error Code(0x%x)",nUnitId, etNErrorCode ));
		DRV_CH_UnLockI2c(nUnitId);
		return DI_CH_ERR;
	}

	if ((nChannelId == CHANNEL_ID0) || (nChannelId == CHANNEL_ID1))
	{
		SetRfInputId(nChannelId,DI_CH_RF_INPUT1);
		nDeviceSetId = DEVICE_SET0;
		s_stLnaSetting[nDeviceSetId].out1 = NEXUS_3445LnaInput_eIn1Vga;
		s_stLnaSetting[nDeviceSetId].out2 = NEXUS_3445LnaInput_eIn1Vga;
		s_stLnaSetting[nDeviceSetId].daisy = NEXUS_3445LnaInput_eNone;
	}
	else
	{
		SetRfInputId(nChannelId,DI_CH_RF_INPUT2);
		nDeviceSetId = DEVICE_SET1;
		s_stLnaSetting[nDeviceSetId].out1 = NEXUS_3445LnaInput_eIn2Vga;
		s_stLnaSetting[nDeviceSetId].out2 = NEXUS_3445LnaInput_eIn2Vga;
		s_stLnaSetting[nDeviceSetId].daisy = NEXUS_3445LnaInput_eNone;
	}

	etNErrorCode = NEXUS_Frontend_Set3445LnaSettings(s_stFrontend[nUnitId],&s_stLnaSetting[nDeviceSetId]);
	if(etNErrorCode != NEXUS_SUCCESS)
	{
		CH_DI_Print(0, ( "[DB4506_InitDevice] [%d] ERR! NEXUS_Frontend_Set3445LnaSettings() Error Code(0x%x)",nUnitId, etNErrorCode ));
		DRV_CH_UnLockI2c(nUnitId);
		return DI_CH_ERR;
	}

	DRV_CH_UnLockI2c(nUnitId);

	return DI_CH_OK;
}



int DB4506_SetTune( int nChannelId, CH_SAT_TuneParam_t *pstSatTuneParam )
{
	NEXUS_Error 	etNErrorCode = NEXUS_SUCCESS;
	NEXUS_FrontendSatelliteSettings satSettings;
	int nUnitId = 0;

	nUnitId = GetDeviceUnitId( nChannelId );

	DRV_CH_LockI2c(nUnitId);

	/* Reset(Untune) Before Settune  */
	NEXUS_Frontend_Untune(s_stFrontend[nUnitId]);

	//CH_DI_Print("4, (nUnitId(%d), frontend(%x) \n", nUnitId , frontend));

	NEXUS_Frontend_GetDefaultSatelliteSettings(&satSettings);

	ConvertDiToNexusParam( pstSatTuneParam, &satSettings);

	#if 0 // TODO:
	/* RS Stuff byte*/
	etNErrorCode = NEXUS_Frontend_SetStuffBytes(s_stFrontend[nUnitId], &ucStuffByte);// (16byte)
	if(etNErrorCode != NEXUS_SUCCESS)
	{
		CH_DI_Print(0, ( "[DB4506_SetTune] [%d] ERR! NEXUS_Frontend_SetStuffBytes() Error Code(0x%x)",nUnitId, etNErrorCode ));
		return DI_CH_ERR;
	}
	#endif

	CH_DI_Print(2, ("ODU_SETUP_TIME (%d) \n", ODU_SETUP_TIME));

	VK_TASK_Sleep( ODU_SETUP_TIME );

	//satSettings.lockCallback.callback = lock_callback;
	//satSettings.lockCallback.context = frontend;

	CH_DI_Print(2, ("\n ############	Tuning NEXUS_Frontend_Satellite [%d]  ############ \n",nChannelId));

	#ifdef CH_PRINT_LOW_LEVEL_ZAPPING_TIME
	g_ulRequestTune[nUnitId] = VK_TIMER_GetSystemTick();
	#endif

	etNErrorCode = NEXUS_Frontend_TuneSatellite(s_stFrontend[nUnitId], &satSettings);
	if(etNErrorCode != NEXUS_SUCCESS)
	{
		CH_DI_Print(0, ( "[DB4506_SetTune] [%d] ERR! NEXUS_Frontend_TuneSatellite() Error Code(0x%x)",nUnitId, etNErrorCode ));
		DRV_CH_UnLockI2c(nUnitId);
		return DI_CH_ERR;
	}

	DRV_CH_UnLockI2c(nUnitId);

	return DI_CH_OK;
}



int DB4506_CheckTuneState( int nChannelId, CH_SAT_TransportSpec_e etSatSystem, HUINT32 ulSymbolRate )
{
	HBOOL	 bLockStatus = FALSE;
	int i;
	int nDelay = 0;
	int nRetryCount = 0;
	int nUnitId;
	CH_Status_e etCurrentState;

	nUnitId = GetDeviceUnitId( nChannelId );

	if( etSatSystem == DI_CH_TRANS_DVBS )
	{
		if( (ulSymbolRate < LOW_SYMBOL_RATE_LIMIT) ||
		(ulSymbolRate > HIGH_SYMBOL_RATE_LIMIT) )
		{
			//100*35 = 3500ms
			nDelay = 100;
			nRetryCount = 35;
		}
		else
		{
			//100*20 = 2000ms
			nDelay = 100;
			nRetryCount = 20;
		}
	}
	else //DI_CH_TRANS_DVBS2
	{
		if( (ulSymbolRate < LOW_SYMBOL_RATE_LIMIT) ||
		(ulSymbolRate > HIGH_SYMBOL_RATE_LIMIT) )
		{
			//100*40 = 4000ms
			nDelay = 100;
			nRetryCount = 40;
		}
		else
		{
			//100*30 = 3000ms
			nDelay = 100;
			nRetryCount = 30;
		}
	}

	CH_DI_Print(3, ("nDelay [%d]:[%d] nRetryCount\n", nDelay, nRetryCount));
	VK_TASK_Sleep(MIN_WAIT_DELAY);

	for( i=0; i<nRetryCount; i++ )
	{
		etCurrentState =	GetTuneStatus(nChannelId);
		if( ( etCurrentState == CH_STATUS_IDLE) || (etCurrentState == CH_STATUS_CANCLE) )
		{
			CH_DI_Print(1, ("Cancel locking status...\n"));
			return DI_CH_CANCEL_TUNE;
		}

		bLockStatus = DB4506_CheckLock( nChannelId );
		CH_DI_Print(3, ("[%d] bLockStatus : %d [%d]\n", nChannelId, bLockStatus, i));

		if( bLockStatus == TRUE )
		{
			#ifdef CH_PRINT_LOW_LEVEL_ZAPPING_TIME
			g_ulLowLevelLockedTime[nChannelId] = VK_TIMER_GetSystemTick();
			CH_DI_Print(0, ("[DB4506_CheckTuneState] [%d] Lock Time( %d )ms  \n" ,nChannelId, g_ulLowLevelLockedTime[nChannelId] - g_ulRequestTune[nChannelId] ));
			#endif
			CH_DI_Print(1, (">>>>>>>>>>>>>>>>>ACQ_LOCKED_AND_TRACKING [%d ms] \n", (i * nDelay)));
			return DI_CH_OK;
		}
		else
		{
			VK_TASK_Sleep(nDelay);
		}
	}

	#ifdef CH_PRINT_LOW_LEVEL_ZAPPING_TIME
	g_ulLowLevelUnlockedTime[nChannelId] = VK_TIMER_GetSystemTick();
	CH_DI_Print(0, ("[DB4506_CheckTuneState] [%d] UnLock Time( %d )ms  \n", nChannelId, g_ulLowLevelUnlockedTime[nChannelId] - g_ulRequestTune[nChannelId] ));
	#endif

	return DI_CH_ERR;

}



HBOOL DB4506_CheckLock( int nChannelId )
{
	int nRet =FALSE ;
	HUINT8 nUnitId;
	NEXUS_Error etNErrorCode = NEXUS_SUCCESS;
	NEXUS_FrontendSatelliteStatus status;

	nUnitId = GetDeviceUnitId( nChannelId );

	DRV_CH_LockReentrant();

	DRV_CH_LockI2c( nUnitId);

	etNErrorCode = NEXUS_Frontend_GetSatelliteStatus(s_stFrontend[nUnitId], &status);
	if(etNErrorCode != NEXUS_SUCCESS)
	{
		CH_DI_Print(0, ( "[DB4506_CheckLock] [%d] ERR! NEXUS_Frontend_GetSatelliteStatus() Error Code(0x%x)",nUnitId, etNErrorCode ));
	}
	else
	{
		CH_DI_Print(6, ("----------------------------------------------------------------------------------------\n"));
		CH_DI_Print(6, ( " apMicrocodeVersion = [Major:Minor][0x%x:0x%x]\n", status.version.apMicrocodeVersion, status.version.hostConfigurationVersion));
		CH_DI_Print(6, ("----------------------------------------------------------------------------------------\n"));

		CH_DI_Print(6, ("[DB4506_CheckLock] (%d) status.tunerLocked (%d)\n",nUnitId ,status.tunerLocked));
		CH_DI_Print(6, ("[DB4506_CheckLock] (%d) status.demodLocked (%d)\n",nUnitId , status.demodLocked));
		CH_DI_Print(6, ("[DB4506_CheckLock] (%d) status.bertLocked (%d)\n",nUnitId, status.bertLocked));

		if ( status.demodLocked == TRUE )
		{
			//LOCK
			nRet = TRUE;
			CH_DI_Print(6, (">>>>> LOCK [%d] <<<<<	\n", nUnitId));

#if 0
			if (nUnitId == 0)
			{
				CH_DI_Print(0, ("------------------------------------\n"));
				CH_DI_Print(0, ("snrEstimate		  =(%d)(1/100 dB)\n", status.snrEstimate						));
				CH_DI_Print(0, ("berEstimate		  =(%d)\n", status.berEstimate					  ));
				CH_DI_Print(0, ("fecCorrected		  =(%d)\n", status.fecCorrected					  ));
				CH_DI_Print(0, ("fecUncorrected 	  =(%d)\n", status.fecUncorrected 				  ));
				CH_DI_Print(0, ("fecClean			  =(%d)\n", status.fecClean						  ));
				CH_DI_Print(0, ("bitErrCorrected	  =(%d)\n", status.bitErrCorrected				  ));
				CH_DI_Print(0, ("reacquireCount 	  =(%d)\n", status.reacquireCount 				  ));
#if (NEXUS_VERSION < 1200)
				CH_DI_Print(0, ("berErrors			  =(%d)\n", status.berErrors						  ));
#else
				CH_DI_Print(0, ("berErrorCount		  =(%d)\n", status.berErrorCount					  ));
#endif

				CH_DI_Print(0, ("preViterbiErrorCount =(%d)\n", status.preViterbiErrorCount			  ));
				CH_DI_Print(0, ("mpegErrors 		  =(%d)\n", status.mpegErrors 					  ));
				CH_DI_Print(0, ("mpegCount			  =(%d)\n", status.mpegCount						  ));
				CH_DI_Print(0, ("ifAgc                =(%u)\n", status.ifAgc                            ));
				CH_DI_Print(0, ("rfAgc                =(%u)\n", status.rfAgc                            ));
				CH_DI_Print(0, ("------------------------------------\n"));
			}
#endif
		}
		else
		{
			//unlock
			nRet = FALSE;
			CH_DI_Print(6, (">>>>> UNLOCK [%d]<<<<<  \n",nUnitId));
		}
	}

	DRV_CH_UnLockI2c( nUnitId);

	DRV_CH_UnLockReentrant();

	return(nRet);
}



int DB4506_GetSignalInfo( int nChannelId, DI_CH_SignalQuality_t *pstSignalInfo )
{
	int nResult = DI_CH_OK;

	nResult = GetSignalStatus( nChannelId, pstSignalInfo);

	return nResult;
}



int DB4506_SetPowerState( int nChannelId, CH_Power_e etPower )
{
	int nResult = DI_CH_OK;
	int nUnitId;
	//	BERR_Code etNErrorCode = BERR_SUCCESS;
	//	BAST_P_ChannelHandle *pstChannelHandle;

	nUnitId = GetDeviceUnitId( nChannelId );

	if( etPower == CH_POWER_OFF ) // set standby
	{
		CH_DI_Print(2, (">>>>>NEXUS_PowerDown <<<<< \n"));
		/*
		//DEV_TUNER_LOCK();
		//etBErrorCode = BAST_PowerDown(s_stBastChannelHandle[nUnitId], BAST_CORE_SDS);
		//DEV_TUNER_UNLOCK();
		if(etBErrorCode != BERR_SUCCESS)
		{
		CH_DI_Print(0, ( "nUnitId(%d): etBErrorCode(0x%x)", nUnitId, etBErrorCode ));
		nResult = DI_CH_ERR;
		}
		*/
	}
	else // unset standby
	{
		CH_DI_Print(2, (">>>>>NEXUS_PowerUp <<<<<< \n"));
		/*
		//DEV_TUNER_LOCK();
		//etBErrorCode = BAST_PowerUp(s_stBastChannelHandle[nUnitId], BAST_CORE_SDS);
		//DEV_TUNER_UNLOCK();
		if(etNErrorCode != BERR_SUCCESS)
		{
		CH_DI_Print(0, ( "nUnitId(%d): etBErrorCode(0x%x)", nUnitId, etBErrorCode) );
		nResult = DI_CH_ERR;
		}
		*/
	}

	return nResult;
}



int DB4506_EnableTsOutput( int nChannelId )
{
	NEXUS_Error 	etNErrorCode = NEXUS_SUCCESS;
	int nUnitId;

	nUnitId = GetDeviceUnitId( nChannelId );

	DRV_CH_LockI2c(nUnitId);

	CH_DI_Print(2, ("[%d] Enable TS Output ===== \n", nUnitId));

	etNErrorCode = NEXUS_Frontend_SetTsOutput(s_stFrontend[nUnitId], true);
	if(etNErrorCode != NEXUS_SUCCESS)
	{
		CH_DI_Print(0, ( "[DB4506_EnableTsOutput] [%d] ERR! NEXUS_Frontend_SetTsOutput()  Error Code(0x%x)", nUnitId, etNErrorCode));
		DRV_CH_UnLockI2c(nUnitId);
		return DI_CH_ERR;
	}

	DRV_CH_UnLockI2c(nUnitId);

	return DI_CH_OK;
}



int DB4506_DisableTsOutput( int nChannelId )
{
	NEXUS_Error 	etNErrorCode = NEXUS_SUCCESS;
	int nUnitId;

	nUnitId = GetDeviceUnitId( nChannelId );

	DRV_CH_LockI2c(nUnitId);

	CH_DI_Print(2, ("[%d] Disable TS Output ===== \n", nUnitId));

	etNErrorCode = NEXUS_Frontend_SetTsOutput(s_stFrontend[nUnitId], false);
	if(etNErrorCode != NEXUS_SUCCESS)
	{
		CH_DI_Print(0, ( "[DB4506_DisableTsOutput] [%d] ERR! NEXUS_Frontend_SetTsOutput()  Error Code(0x%x)", nUnitId, etNErrorCode));
		DRV_CH_UnLockI2c(nUnitId);
		return DI_CH_ERR;
	}

	DRV_CH_UnLockI2c(nUnitId);

	return DI_CH_OK;

}


int DB4506_SetToneBurst(int nChannelId, HBOOL bToneOn, CH_SAT_DiseqcInput_e etInput, CH_SAT_AntennaType_e etAntennaType, CH_SAT_DiseqcVer_e etDiseqcVer )
{
	int nResult	= DI_CH_OK;
	int nRfInputId;

	NEXUS_Error 	etNErrorCode = NEXUS_SUCCESS;

	CH_UNUSED(etDiseqcVer);

	nRfInputId = GetRfInputId( nChannelId );

	NEXUS_FrontendDiseqcSettings diseqcSettings;

	DRV_CH_LockI2c(nRfInputId);

	VK_memset(&diseqcSettings, 0, sizeof(NEXUS_FrontendDiseqcSettings));

	diseqcSettings.toneEnabled = (bool)bToneOn;
	diseqcSettings.toneMode = NEXUS_FrontendDiseqcToneMode_eEnvelope;
	diseqcSettings.replyDisabled = TRUE;

	switch( etInput )
	{
		case DI_CH_DISEQC_INPUT_A:
		case DI_CH_DISEQC_INPUT_C:
		case DI_CH_DISEQC_INPUT_TB_A:
			diseqcSettings.toneBurst = NEXUS_FrontendDiseqcToneBurst_eUnmodulated;
			break;

		case DI_CH_DISEQC_INPUT_B:
		case DI_CH_DISEQC_INPUT_D:
		case DI_CH_DISEQC_INPUT_TB_B:
			diseqcSettings.toneBurst = NEXUS_FrontendDiseqcToneBurst_eNominal;
			break;

		case DI_CH_DISEQC_INPUT_SCD_A:
		case DI_CH_DISEQC_INPUT_SCD_B:
		case DI_CH_DISEQC_INPUT_NONE:
			diseqcSettings.toneBurst = NEXUS_FrontendDiseqcToneBurst_eNone;
		default:
			break;
	}

	if (etAntennaType == DI_CH_ANT_TYPE_SCD)
	{
		diseqcSettings.ucPreTxDelay = 8;
		diseqcSettings.ulBurstQuietTime = 0;
	}
	else	/* DiSEqC, LNB, Motor, SMATV */
	{
		diseqcSettings.ucPreTxDelay = 20;
		diseqcSettings.ulBurstQuietTime = 0;
	}

	etNErrorCode = NEXUS_Frontend_SetDiseqcSettings(s_stFrontend[nRfInputId], &diseqcSettings);
	if(etNErrorCode != NEXUS_SUCCESS)
	{
		CH_DI_Print(0, ( "[SetToneBurst] [%d] ERR! NEXUS_Frontend_SetDiseqcSettings() ErrorCode(0x%x), etInput(%d) \n",nRfInputId, etNErrorCode, etInput ));
		nResult = DI_CH_ERR;
	}

	DRV_CH_UnLockI2c(nRfInputId);

	return nResult;

}


int DB4506_SendDiseqcMsg(
int nChannelId,
HUINT8 *pucSendBuf,
HUINT8 ucNumOfBuf,
CH_SAT_DiseqcInput_e etDiseqcInput
)
{
	NEXUS_Error 	etNErrorCode = NEXUS_SUCCESS;
	NEXUS_CallbackDesc 	callback;
	int i;
	int 			nRfInputId;

	nRfInputId = GetRfInputId( nChannelId );

	DRV_CH_LockI2c(nRfInputId);

	VK_memset(&callback, 0, sizeof(NEXUS_CallbackDesc));

	callback.callback = DiseqcCompleteCallback;
	callback.context = s_stFrontend[nRfInputId];

	CH_UNUSED(etDiseqcInput);

#if 0 //TODO_ILEE
	VK_TASK_Sleep(10 );//Delay for Diseqc Msg Initial Reset Timing
	CH_DI_Print(0, ("===== DiseqcMessage ChannelId[%d]:[%d]nUnitId =====\n", nChannelId, nUnitId));
#endif
	CH_DI_Print(3, ("[%d] ===== DiseqcMessage Length(%d) =====\n", nChannelId, ucNumOfBuf));

	if(show_di_ch > 2)
	{
		for( i=0; i<ucNumOfBuf; i++)
		{
			DI_UART_Print("[%02x] ", pucSendBuf[i]);
		}
	}
	CH_DI_Print(3, ("\n===== DiseqcMessage End =======\n"));

	etNErrorCode = NEXUS_Frontend_SendDiseqcMessage(s_stFrontend[nRfInputId], pucSendBuf, ucNumOfBuf, &callback);
	if(etNErrorCode != NEXUS_SUCCESS)
	{
		CH_DI_Print(0, ( "[DB4506_SendDiseqcCommand] [%d] NEXUS_Frontend_SendDiseqcMessage() Error Code(0x%x)", nRfInputId, etNErrorCode));
		DRV_CH_UnLockI2c(nRfInputId);
		return DI_CH_ERR;
	}

	DRV_CH_UnLockI2c(nRfInputId);

	return DI_CH_OK;
}


int DB4506_UpdateTunedParam( int nChannelId, CH_SAT_TuneParam_t * pstTuneParam )
{
	int   nResult = DI_CH_OK;
	int 	nUnitId;

	NEXUS_Error 	etNErrorCode = NEXUS_SUCCESS;
	NEXUS_FrontendSatelliteStatus stStatus;

	nUnitId = GetDeviceUnitId( nChannelId );

	DRV_CH_LockI2c(nUnitId);

	if( (pstTuneParam->etFecCodeRate == DI_CH_SCODERATE_AUTO)
	|| (pstTuneParam->etModulation == DI_CH_PSK_AUTO) )
	{

		CH_DI_Print(4, ("[DB4506_UpdateTunedParam] ============================ \n"));

		etNErrorCode = NEXUS_Frontend_GetSatelliteStatus(s_stFrontend[nUnitId], &stStatus);
		if(etNErrorCode == NEXUS_SUCCESS)
		{
			ConvertNexusToDiParam(stStatus.mode, stStatus.codeRate, pstTuneParam );
		}
		else
		{
			CH_DI_Print(0, ("[DB4506_UpdateTunedParam] [%d] ERR! NEXUS_Frontend_GetSatelliteStatus() Error Code(0x%x) \n ", nUnitId, etNErrorCode));
			nResult = DI_CH_ERR;
		}
	}

	DRV_CH_UnLockI2c(nUnitId);

	return nResult;

}


int DB4506_SetInputMode( int nChannelId, CH_SAT_InputMode_e etInputMode )
{
	CH_UNUSED(nChannelId);
	CH_UNUSED(etInputMode);

	return DI_CH_NOT_SUPPORTED;
}


int DB4506_SetInputSource( int nChannelId, DI_CH_InputSource_e etInputSource )
{
	int 			nUnitId;
	int				nDeviceSetId;
	NEXUS_Error 	etNErrorCode = NEXUS_SUCCESS;
	NEXUS_3445LnaInput	etTempLnaOut;

	nUnitId = GetDeviceUnitId( nChannelId );

	DRV_CH_LockI2c(nUnitId);

	if (etInputSource >= DI_CH_RF_INPUTMAX)
	{
		return DI_CH_PARAM_ERR;
	}

	CH_DI_Print(1, ( "[DB4506_SetInputSource] nUnitId[%d] : etInputSource(%d) \n", nUnitId, etInputSource ));

	if ((nChannelId == CHANNEL_ID0) || (nChannelId == CHANNEL_ID1))
		nDeviceSetId = DEVICE_SET0;
	else
		nDeviceSetId = DEVICE_SET1;

	if (etInputSource == DI_CH_RF_INPUT1)
		etTempLnaOut = NEXUS_3445LnaInput_eIn1Vga;
	else
		etTempLnaOut = NEXUS_3445LnaInput_eIn2Vga;

	if ((nChannelId%2) == 0)
	{
		s_stLnaSetting[nDeviceSetId].out1 = etTempLnaOut;
	}
	else
	{
		s_stLnaSetting[nDeviceSetId].out2 = etTempLnaOut;
	}

	CH_DI_Print(0,("\n"));

	etNErrorCode = NEXUS_Frontend_Set3445LnaSettings(s_stFrontend[nUnitId], &s_stLnaSetting[nDeviceSetId]);
	if(etNErrorCode != NEXUS_SUCCESS)
	{
		CH_DI_Print(0, ( "[DB4506_SetInputSource] [%d] NEXUS_Frontend_Set3445LnaSettings() Error Code(0x%x)", nUnitId, etNErrorCode));
		DRV_CH_UnLockI2c(nUnitId);
		return DI_CH_ERR;
	}
	else
	{
		SetRfInputId(nChannelId, etInputSource);
	}

	DRV_CH_UnLockI2c(nUnitId);

	return DI_CH_OK;
}


HBOOL DB4506_LnbGet22KhzTone( int nChannelId )
{
	int 			nRfInputId;

	nRfInputId = GetRfInputId( nChannelId );

	return s_stLnbState[nRfInputId].bToneEnabled;

}


int DB4506_LnbSet22KhzTone( int nChannelId, HBOOL b22kTone )
{
	int nResult = DI_CH_OK;
	int nRfInputId;
	NEXUS_Error 	etNErrorCode = NEXUS_SUCCESS;

	nRfInputId = GetRfInputId( nChannelId );

	NEXUS_FrontendDiseqcSettings diseqcSettings;

	DRV_CH_LockI2c(nRfInputId);

	NEXUS_Frontend_GetDiseqcSettings(s_stFrontend[nRfInputId], &diseqcSettings);

	diseqcSettings.toneMode = NEXUS_FrontendDiseqcToneMode_eEnvelope;
	diseqcSettings.toneEnabled = (bool)b22kTone;

	etNErrorCode = NEXUS_Frontend_SetDiseqcSettings(s_stFrontend[nRfInputId], &diseqcSettings);
	if(etNErrorCode != NEXUS_SUCCESS)
	{
		CH_DI_Print(0, ( "[DB4506_LnbSet22KhzTone] [%d] ERR! NEXUS_Frontend_SetDiseqcSettings() ErrorCode(0x%x), bDiseqcTone(%d) \n",nRfInputId, etNErrorCode, diseqcSettings.toneEnabled ));
		DRV_CH_UnLockI2c(nRfInputId);
		return DI_CH_ERR;
	}

	s_stLnbState[nRfInputId].bToneEnabled = b22kTone;

	DRV_CH_UnLockI2c(nRfInputId);

	return nResult;
} // end of drv_channel_LNB22KHzTone

/*********************** End of File ******************************/

