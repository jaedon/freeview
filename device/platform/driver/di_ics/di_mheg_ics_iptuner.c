//-------------------------------------------------------------------/
//
//	di_mheg_ics_iptuner.c
//
//	Copyright (c) 2008 Valups Corp.
//
//-------------------------------------------------------------------/

//-------------------------------------------------------------------/
// Revision history
//   10/31/08  first generated by Whiterub
//-------------------------------------------------------------------/

#include <stdio.h>
#include <string.h>
#include <unistd.h>   

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <linux/sockios.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>	/** for 64bit MACRO ex>PRId64 */



#include "taskdef.h"

#include "di_iptuner_underflow.h"

#include "di_mheg_ics.h"
#include "di_mheg_ics_iptuner.h"
#include "stream_http.h"

#include "di_mheg_ics_iptuner_underflow.h"
#include "di_iptuner_stream.h"

#include "di_uart.h"


/*******************************************************************/
/********************      Global Variables     ********************/
/*******************************************************************/


/*******************************************************************/
/********************      Defines         *************************/
/*******************************************************************/

//#define DEBUG_VFIO_FUNCTION

//#define DI_MHEG_ICS_DEBUG

#ifdef DI_MHEG_ICS_DEBUG
#define MhegIcsData			DI_UART_Print
#define MhegIcsDebug		DI_UART_Print
#define MhegIcsError		DI_UART_Print
#else
#define MhegIcsData			while (0) ((int (*)(char *, ...)) 0)
#define MhegIcsDebug		while (0) ((int (*)(char *, ...)) 0)
#define MhegIcsError		DI_UART_Print
#endif

#ifdef DI_MHEG_ICS_DEBUG
#define MhegIcsFunctionEnter(a)		DI_UART_Print("(+)%s[%d]\n", __FUNCTION__, a)
#define MhegIcsFunctionExit			DI_UART_Print("(-)%s\n", __FUNCTION__)
#else
#define MhegIcsFunctionEnter(a)
#define MhegIcsFunctionExit
#endif

#ifdef DEBUG_VFIO_FUNCTION
#define MhegVFIOData		DI_UART_Print
#define MhegVFIODebug		DI_UART_Print
#define MhegVFIOError		DI_UART_Print

#define MhegVFIOFunctionEnter	//DI_UART_Print("(+)%s\n", __FUNCTION__)
#define MhegVFIOFunctionExit	//DI_UART_Print("(-)%s\n", __FUNCTION__)
#else
#define MhegVFIOData		
#define MhegVFIODebug		
#define MhegVFIOError		DI_UART_Print

#define MhegVFIOFunctionEnter
#define MhegVFIOFunctionExit
#endif


#define UNUSED_PARAM(x)  ((void)x)

#define MHEG_ICS_MAX_BITRATE						(12 * 1024 * 1024)		// 12Mbps
#define	MHEG_ICS_DEFAULT_BITRATE					(2048000)		//About 2Mbps


#define PAL_MHEG_ICS_IPTUNER_DNP_FILE_PATH_PREFIX        "/mnt/hd3/ics_down_file"


#define	MHEG_ICS_IPTUNER_DNP_STACK_SIZE					(256*1024)	/* 256Kbytes */
#define	MHEG_ICS_IPTUNER_DNP_TASK_PRIORITY					(10)
#define	MHEG_ICS_IPTUNER_DNP_MSG_QUEUE_SIZE				(10)
#define	MHEG_ICS_IPTUNER_DNP_WAITEVTTIME					(60000)		/* 3000msec = 3sec */
#define	MHEG_ICS_IPTUNER_DNP_CALLBACK_WAITCOUNT			(10)		/* 20 * 100msec = 1sec */
#define MHEG_ICS_IPTUNER_DNP_PROBE_SEEK_CALLBACK_WAITCOUNT (100000)	/* 100000 times X MHEG_ICS_IPTUNER_DNP_CALLBACK_WAITTTIME */
#define	MHEG_ICS_IPTUNER_DNP_SEEK_CALLBACK_WAITCOUNT		(100000)	/* 100000 times X MHEG_ICS_IPTUNER_DNP_CALLBACK_WAITTTIME */
#define	MHEG_ICS_IPTUNER_DNP_CALLBACK_WAITTTIME			(100)		/* 100msec = 0.1sec */
#define	MHEG_ICS_IPTUNER_DNP_MSGQ_TIMEOUT				(500)

//#define MAX_IP_SIZE			(128)	/** bytes */
//#define MAX_PORT_SIZE		(16)	/** bytes */
#define MAX_FILE_NAME_SIZE	(2048)	/** bytes */ /** FIXME : will be extended for URL size */ 


#define MHEG_ICS_PRDN_ISVALID(Array, chunk_offset) 		((*(Array + PRDN_GET_BYTE_OFF(chunk_offset))) & (1 << PRDN_GET_BIT_OFF(chunk_offset)))
#define MHEG_ICS_PRDN_SETVALID(Array, chunk_offset) 	*(Array + PRDN_GET_BYTE_OFF(chunk_offset)) |= (HUINT8)(1 << PRDN_GET_BIT_OFF(chunk_offset))

#define MAX_PRDN_BUFFERING_PERCENT 99999



/*******************************************************************/
/********************      Typedef         *************************/
/*******************************************************************/

/*******************************************************************/
/********************      Static Variables     ********************/
/*******************************************************************/

static DI_MHEG_ICS_IPTUNER_t	*s_pstIpTuner[MAX_MHEG_ICS_IPTUNER_NUM] = {NULL, };

static HUINT32				s_ulRungDnpNumber = 0;

static HINT64				s_nllLastPosition[MAX_MHEG_ICS_IPTUNER_NUM] = {0, };

/*******************************************************************/
/********************    Local  Functions       *************************/
/*******************************************************************/

#define _____Define_INTERNAL_APIs________________________________________________________________




static HERROR 		local_mheg_ics_stream_HTTP_Open(HUINT32	ulHandle, HINT8 *url, const HINT8 *mode);
static HERROR 		local_mheg_ics_stream_HTTP_Close(HUINT32	ulHandle);
static HERROR 		local_mheg_ics_stream_HTTP_Receive(HUINT32	ulHandle);
static HINT32 		local_mheg_ics_stream_HTTP_Seek(HUINT32 ulHandle, off_t offset, int whence);
static HERROR 		local_mheg_ics_stream_HTTP_Read (HUINT32 ulHandle, void *ptr, size_t size, size_t nmemb, size_t *ptReadSize);


static void 		local_mheg_ics_stream_HTTP_DnpStartReceiving(DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner);
static void 		local_mheg_ics_stream_HTTP_DnpStopReceiving(DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner);
static void 		local_mheg_ics_stream_HTTP_DnpPauseReceiving(DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner);
static void 		local_mheg_ics_stream_HTTP_DnpResumeReceiving(DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner);

static DI_ERR_CODE	local_mheg_ics_iptuner_DnpOpen(HUINT32	ulHandle, HINT8 *url, DI_MEDIA_INFO_t *pstMediaInfo);
static DI_ERR_CODE	local_mheg_ics_iptuner_DnpClose(HUINT32	ulHandle);
static void 		local_mheg_ics_iptuner_DnpStart(DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner);
static void 		local_mheg_ics_iptuner_DnpStop(DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner);
static DI_ERR_CODE 	local_mheg_ics_iptuner_DnpSetReadyStateCallback(HUINT32 ulHandle, fn_readystate_callback pFn);
static DI_ERR_CODE 	local_mheg_ics_iptuner_DnpGetInfo (HUINT32 ulHandle, DI_IPTUNER_Info_t *pInfo);
static DI_ERR_CODE 	local_mheg_ics_iptuner_DnpControl (HUINT32 ulHandle, DI_IPTUNER_CMD_e cmd, HUINT64 val);
static DI_ERR_CODE 	local_mheg_ics_iptuner_DnpUpdateDownloadSpeed(HUINT32 ulHandle, HULONG ulStartClock, HINT32 nDownloadBytes, HUINT32 ulLoopCount);
static DI_ERR_CODE 	local_mheg_ics_iptuner_DnpCalcBufferingInfo(HUINT32 ulHandle, HUINT32 unDuration);
//static DI_ERR_CODE 	local_mheg_ics_iptuner_DnpGetDownloadedBytes(HUINT32 ulHandle, HUINT64 *pullDownloadedBytes);
static DI_ERR_CODE 	local_mheg_ics_iptuner_DnpGetBufferedDataSize(HUINT32 ulHandle, HUINT64 *pullBufferedData, HBOOL *bIsFullChunk, HINT64 llFileLength);


static void 	local_mheg_ics_iptuner_DnpInitTread(HUINT32	ulHandle);
static void 	IPTUNER_MHEG_ICS_DnpTask (void *pParam);




#define _____INTERNAL_APIs________________________________________________________________


#ifdef ENABLE_MAPPED_DNP
HBOOL MHEG_ICS_PRDN_IsRangeValid(HUINT32 ulHandle, HINT32 nchunkoffStart, HINT32 nchunkoffEnd)
{
	register HINT32 i;
	
	//MhegIcsFunctionEnter(ulHandle);

	/* block accessing Freed Download Progress Array */
	if(s_pstIpTuner[ulHandle]->stPrdnInfo.bDownCompleted == TRUE)
	{
		return TRUE;
	}

	/* invalid args check */
	if(nchunkoffStart > s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffPrdnEof)
	{
		MhegIcsError("invalid arg error : read request is beyond the file length chunk off %d * chunk_size %d\n", nchunkoffStart, (HINT32)PRDN_GET_RAW_OFF_FROM_CHUNK_OFF(1));
		return FALSE;
	}
	if(nchunkoffEnd > s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffPrdnEof)
	{
		nchunkoffEnd = s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffPrdnEof;
	}


	//MhegIcsDebug ("[%d] \t ### M[%d] (nchunkoffStart:nchunkoffEnd)=(%d:%d)\n\n", __LINE__, ulHandle, nchunkoffStart, nchunkoffEnd);
	for(i = nchunkoffStart; i <= nchunkoffEnd; i++)
	{		
		if(!MHEG_ICS_PRDN_ISVALID(s_pstIpTuner[ulHandle]->stPrdnInfo.pucChunkDownloadStatusArray, i))
		{
			if(s_pstIpTuner[ulHandle]->bHttpPauseReceiving != TRUE)
			{
				/*
				if(s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffOldPrdnRequestedSeekPoint != nchunkoffStart)
				{
					MhegIcsDebug ("=== REQ a seek point\n");
					s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffPrdnRequestedSeekPoint = nchunkoffStart;
					s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffOldPrdnRequestedSeekPoint = nchunkoffStart;
				}
				*/
			}
			//MhegIcsFunctionExit;

			return FALSE;
		}
	}

	//MhegIcsFunctionExit;
	
	return TRUE;
}



HBOOL MHEG_ICS_PRDN_IsCompleted(DI_MHEG_ICS_Prdn_Info_t *pstPrdnInfo)
{
	//MhegIcsFunctionEnter(ulHandle);

#if 0 /* warning: statement with no effect */
	for(g_nchunkoffIsCompletedStart; g_nchunkoffIsCompletedStart <= g_nchunkoffPrdnEof; g_nchunkoffIsCompletedStart++)
#else

	for(/*g_nchunkoffIsCompletedStart*/; pstPrdnInfo->nchunkoffIsCompletedStart <= pstPrdnInfo->nchunkoffPrdnEof; pstPrdnInfo->nchunkoffIsCompletedStart++)
#endif
	{
		if(!MHEG_ICS_PRDN_ISVALID(pstPrdnInfo->pucChunkDownloadStatusArray, pstPrdnInfo->nchunkoffIsCompletedStart))			
		{
			return FALSE;
		}
	}

	MhegIcsError ("===== MHEG_ICS_IPTUNER PROGRESS DN COMPLETE[%d] =====\n", pstPrdnInfo->nCBulDeviceId);
	MhegIcsError ("===== MHEG_ICS_IPTUNER PROGRESS DN COMPLETE =====\n");
	MhegIcsError ("===== MHEG_ICS_IPTUNER PROGRESS DN COMPLETE =====\n");

	pstPrdnInfo->nBufferingPercent = 100*1000;	
	pstPrdnInfo->nBufferingLeftTime = 0;

	{ /* wait ultil call back is registered */
		HUINT32 wait_counter = 0;
		while(TRUE)
		{
			if(pstPrdnInfo->pReadyStateCallbackFunc || wait_counter >= 7)
			{
				break;
			}
			VK_TASK_Sleep(1000);
			wait_counter++;
		}
	}
	
	if(pstPrdnInfo->pReadyStateCallbackFunc)
	{
		VK_TASK_Sleep(500);
		pstPrdnInfo->pReadyStateCallbackFunc(pstPrdnInfo->nCBulDeviceId, DI_MEDIA_EVENT_BUFFER_READY_STATE, DI_IPTUNER_DNP_READYSTATE_FULLDOWN_COMPLETED); /* 3 == DOWNLOAD COMPLETED */
		pstPrdnInfo->pReadyStateCallbackFunc = NULL;
	}

	//MhegIcsFunctionExit;

	return TRUE;
}
#endif



/** VFIO (for DNP) Open Function */
static int vfio_cb_mheg_ics_iptuner_DnpOpen (const HINT8 *path, const HINT8 *mode, VFIO_Handle_t *ptHandle)
{
	int		ret=VFIO_ERROR_SUCCESS;
	int		fd;
	HUINT32	ulMediaId;

	UNUSED_PARAM (mode);
	MhegVFIOFunctionEnter;

	MhegVFIOData("[%s] [%d] path=%s, mode=%s\n",__FUNCTION__,__LINE__, path, mode);
	if(ptHandle == NULL)
	{
		MhegVFIOError("ptHandle is NULL\n");
		ret = VFIO_ERROR_BAD_PARAMETER;
		goto error;
	}

	ulMediaId = (HUINT32)ptHandle->pDnpUserData;

	/* error check */
	if(s_pstIpTuner[ulMediaId]->hVFIO.pDnpUserData == NULL)
	{
		MhegVFIOError("pDnpUserData is NULL\n");
		ptHandle->ucAvailable = 0;
		ret = VFIO_ERROR_IN_DEVICE;
		goto error;
	}
	else
	{
		ptHandle->pDnpUserData = s_pstIpTuner[ulMediaId]->hVFIO.pDnpUserData;
	}
	
	fd = open ( s_pstIpTuner[ulMediaId]->pSaveFileName, O_RDONLY|O_SYNC, 0666);
	if ( fd < 0 )
	{
		ptHandle->ucAvailable = 0;
		ret = VFIO_ERROR_IN_DEVICE;
		MhegVFIOError("\n\t[VFIO][%d] Error>> Open(mediaId, name) = (%d, %s)\n",__LINE__, ulMediaId, s_pstIpTuner[ulMediaId]->pSaveFileName);
	}
	else
	{
		ptHandle->ucAvailable = 1;
		ptHandle->tFile.callback.unHandle = (HUINT32)fd;
		MhegVFIODebug("\n\t[VFIO][%d] Open(mediaId, fd, name) = (%d, 0x%X, %s)\n",
			__LINE__, ulMediaId, ptHandle->tFile.callback.unHandle, s_pstIpTuner[ulMediaId]->pSaveFileName);
	}
error:
	
	MhegVFIOFunctionExit;

	return ret;
}

/** VFIO (for DNP) Close Function */
static int vfio_cb_mheg_ics_iptuner_DnpClose (VFIO_Handle_t tHandle)
{
	int		ret=VFIO_ERROR_SUCCESS;

	MhegVFIOFunctionEnter;

	MhegVFIODebug("\n\t[VFIO][%d] Close(fd) = (0x%X)\n", __LINE__, tHandle.tFile.callback.unHandle);
	tHandle.ucAvailable = 0;
	(void)close ((int)tHandle.tFile.callback.unHandle);
	
	MhegVFIOFunctionExit;

	return ret;
}
		
/** VFIO (for DNP) Read Function */
static int vfio_cb_mheg_ics_iptuner_DnpRead (VFIO_Handle_t tHandle, void *ptr, size_t size, size_t nmemb, size_t *ptReadSize)
{
	int		ret=VFIO_ERROR_SUCCESS;
	ssize_t	readCnt=0;
	size_t	unRequestSize=(size*nmemb);	
	int		nLoopCnt=0;
	struct stat	sb;
	off_t		cur=0;
	off_t		pre_read_cur=0;

	HUINT32					ulHandle;
	MHEG_DNP_USER_DATA_t	*pMhegDnpUserData = (MHEG_DNP_USER_DATA_t*)tHandle.pDnpUserData;
	DNP_USER_DATA_t			*pDnpUserData;
	
	if(pMhegDnpUserData == NULL)
	{
		MhegVFIOError("pDnpUserData is NULL\n");
		return VFIO_ERROR_IN_DEVICE; /* this value is transformed to 0(EOF) in b_stdio_read */
	}

	MhegVFIOFunctionEnter;	
	
	ulHandle = pMhegDnpUserData->ulHandle;
	pDnpUserData = &pMhegDnpUserData->stData;

	(void) VK_SEM_Get(s_pstIpTuner[ulHandle]->ulDNPReadSema);


	//MhegVFIOError("%s (%d) M[%d] size=%d, nmemb=%d\n",__FUNCTION__,__LINE__, ulHandle, size, nmemb);

	/*
	if( (s_nllLastPosition[ulHandle] != 0)
		&& (pDnpUserData->unOpenFromNexusHandle == tHandle.tFile.callback.unHandle) )
	{
		cur = lseek((int)tHandle.tFile.callback.unHandle, (off_t)s_nllLastPosition[ulHandle], SEEK_SET);
		s_nllLastPosition[ulHandle] = 0;
	}
	*/

	*ptReadSize = 0;
	cur = lseek((int)tHandle.tFile.callback.unHandle, 0, SEEK_CUR);
	pre_read_cur = cur;
	if ( (off_t)-1 == cur )
	{
		MhegVFIOError("%s (%d) Error>  lseek()\n",__FUNCTION__,__LINE__);
		ret = VFIO_ERROR_IN_DEVICE;
		*ptReadSize = 0;
	}
	else
	{		
		//MhegVFIODebug ("%s (%d) cur=%"PRId64" reqSize(%d)\n",__FUNCTION__,__LINE__, cur,unRequestSize);
		while ( nLoopCnt++ < MHEG_ICS_IPTUNER_DNP_CALLBACK_WAITCOUNT )
		{
			if(s_pstIpTuner[ulHandle]->bIsPlaybackStop == TRUE)
			{
				MhegVFIOError("%s (%d) Error> read() is stopped by user.(stop event).\n",__FUNCTION__,__LINE__);
				ret = VFIO_ERROR_IN_DEVICE;
				*ptReadSize = 0;
				break;
			}

			if (fstat((int)tHandle.tFile.callback.unHandle, &sb)<0)
			{
				MhegVFIOError("%s (%d) Error> fstat()\n",__FUNCTION__,__LINE__);
				ret = VFIO_ERROR_IN_DEVICE;
				break;
			}
			else
			{
#ifdef ENABLE_MAPPED_DNP			
				if( (cur >= s_pstIpTuner[ulHandle]->nFileLength) 
					|| ((s_pstIpTuner[ulHandle]->nEndPosition != 0) && (cur >= s_pstIpTuner[ulHandle]->nEndPosition))) /* bound check */
				{
					MhegVFIOError("%s (%d) ICS[%d]offset(%"PRId64") is  more than filesize...!!\n",__FUNCTION__,__LINE__, ulHandle, cur);
					ret = VFIO_ERROR_SUCCESS;
					s_pstIpTuner[ulHandle]->stPrdnInfo.bReadCompleted = TRUE;
					*ptReadSize = 0;
					break;
				}
				
				if(s_pstIpTuner[ulHandle]->stPrdnInfo.bForwardPlay == FALSE && pDnpUserData->unOpenFromNexusHandle == tHandle.tFile.callback.unHandle)
				{
					if(MHEG_ICS_PRDN_IsRangeValid(ulHandle, PRDN_GET_CHUNK_OFF(cur), PRDN_GET_CHUNK_OFF(cur + unRequestSize - 1))) /* if last_pre_read_cur is consumed */
					{
						pre_read_cur = cur;
						MhegVFIOData("read from buffer\n");
					}
					else
					{
						pre_read_cur = cur - DEFAULT_PRDN_BACKTRICK_PREBUFFERING_SIZE;
						MhegVFIOData("pre buffering ...\n");
						s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffLastPrebufferIdx = PRDN_GET_CHUNK_OFF(cur + unRequestSize - 1);
						
						if(s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffLastPrebufferIdx > s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffPrdnEof)
						{
							s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffLastPrebufferIdx = s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffPrdnEof;
						}
						s_pstIpTuner[ulHandle]->stPrdnInfo.bPrebufferingRequested = TRUE;
					}
					if(pre_read_cur < 0)
					{
						pre_read_cur = 0;
						MhegVFIOData("Set ZERO!!\n");
					}
				}
				else
				{
					pre_read_cur = cur;
				}
				
				if( pDnpUserData->unOpenFromNexusHandle == tHandle.tFile.callback.unHandle) /* unhandle for player. not indexer or prober */
				{
					off_t displacement = pre_read_cur - (pDnpUserData->player_last_read_cursor + pDnpUserData->player_last_read_size);
					HINT32 nContinueousReadThreadshold = -8192;

					//MhegVFIOError("%s (%d) M[%d] fd(0x%X) pre_read_cur(%"PRId64")\n",__FUNCTION__,__LINE__, ulHandle, pDnpUserData->unOpenFromNexusHandle, pre_read_cur);

					/*
					if((s_pstIpTuner[ulHandle]->stPrdnInfo.bForwardPlay == TRUE) && (pre_read_cur < pDnpUserData->player_last_read_cursor))
					{
						ret = VFIO_ERROR_SUCCESS;
						*ptReadSize = 0;
						break;
					}
					*/

					if(s_pstIpTuner[ulHandle]->stPrdnInfo.bForwardPlay == FALSE)
					{
						nContinueousReadThreadshold = -1024*1024; /* 1MB */
					}

					s_pstIpTuner[ulHandle]->stPrdnInfo.ullDataReadOffset =(HUINT64)pre_read_cur;
					//MhegVFIOError("%s (%d) @@@@ ICS[%d]DataReadOffset(%"PRId64") \n",__FUNCTION__,__LINE__, ulHandle, s_pstIpTuner[ulHandle]->stPrdnInfo.ullDataReadOffset);
					s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffCurrentReadPoint = PRDN_GET_CHUNK_OFF(pre_read_cur); /* cursor of prdn buffering. meaningfull only for player */

					if(displacement >= nContinueousReadThreadshold && displacement <= 0) /* nexus tends to read overlappedly in normal play */
					{
						;//MhegVFIODebug("Player Continueous Read disp=%d\n",(int)displacement);
					}
					else
					{
						if(s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffOldPrdnRequestedSeekPoint != s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffCurrentReadPoint)
						{
							MhegVFIOData("=====Player Request Seek displace is %d\n", (int)displacement);
							s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffPrdnRequestedSeekPoint = s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffCurrentReadPoint;
							s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffOldPrdnRequestedSeekPoint = s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffCurrentReadPoint; /* this will prevent duplicate seek request */
						}
					}

					pDnpUserData->player_last_read_cursor = pre_read_cur;
				}
				
				if ( pDnpUserData->bDNPNetworkError == TRUE )
				{
					MhegVFIOError("%s (%d) Error> DNP Network Error, return VFIO_ERROR_IN_DEVICE\n",__FUNCTION__,__LINE__);
					ret = VFIO_ERROR_IN_DEVICE; /* this value is transformed to 0(EOF) in b_stdio_read */
					break;
				}

				//MhegVFIOError("%s (%d) (cur:pre_read_cur:reqsize) = (%"PRId64":%"PRId64":%d) \n",__FUNCTION__,__LINE__, cur, pre_read_cur, unRequestSize);

				if(  MHEG_ICS_PRDN_IsRangeValid(ulHandle, PRDN_GET_CHUNK_OFF(pre_read_cur), PRDN_GET_CHUNK_OFF(cur + unRequestSize - 1))  )
#else
				if ( ((cur+unRequestSize) <= sb.st_size) || (cur+unRequestSize >= s_pstIpTuner[ulHandle]->nFileLength))
#endif
				{
					s_pstIpTuner[ulHandle]->stPrdnInfo.bPrebufferingRequested = FALSE;
					readCnt = read((int)tHandle.tFile.callback.unHandle, ptr, unRequestSize);
					if ( readCnt < 0 )
					{
						MhegVFIOError("%s (%d) Error>  read()\n",__FUNCTION__,__LINE__);
						ret = VFIO_ERROR_IN_DEVICE;
						*ptReadSize = 0;
					}
					else
					{				
						if( pDnpUserData->unOpenFromNexusHandle == tHandle.tFile.callback.unHandle) /* unhandle for player. not indexer or prober */
						{
							pDnpUserData->player_last_read_size = readCnt;
							//MhegVFIOError("%s (%d) \t @@@@ ICS[%d] fd(0x%X), read_cur(%"PRId64"), read_size(%d) \n",__FUNCTION__, __LINE__, ulHandle, pDnpUserData->unOpenFromNexusHandle, pDnpUserData->player_last_read_cursor, pDnpUserData->player_last_read_size);
						}
						*ptReadSize = readCnt;
					}
					break;
				}
				else
				{
					MhegVFIOData("%s (%d) Waiting> - Not enough data ! download size(%"PRId64"), request offset (%"PRId64")\n"
							, __FUNCTION__, __LINE__ , (HINT64)sb.st_size, (HINT64)(cur+unRequestSize) );

					/* DNP Probe 시 Network 에러는 totoally fail처리 */
					if ( pDnpUserData->nPurpose ==  1
							&& pDnpUserData->bDNPNetworkError == TRUE )
					{
						MhegVFIOError ("%s (%d) Error> DNP Network Error, return VFIO_ERROR_IN_DEVICE\n",__FUNCTION__,__LINE__);
						ret = VFIO_ERROR_IN_DEVICE; /* this value is transformed to 0(EOF) in b_stdio_read */
						break;
					}
				}
			}
			(void) VK_TASK_Sleep (MHEG_ICS_IPTUNER_DNP_CALLBACK_WAITTTIME);

		} /* end of while */
	}
	
	////MhegIcsError
	MhegVFIODebug("\t @@@ M[%d] Read(fd, reqsize, readCnt, cursor)=(0x%X, %d, %d, %"PRId64")\n"
					, ulHandle, tHandle.tFile.callback.unHandle, size, *ptReadSize, cur);

	#if 0
	if( ((cur + *ptReadSize) >= s_pstIpTuner[ulHandle]->nFileLength) 
		|| ((s_pstIpTuner[ulHandle]->nEndPosition != 0) && ((cur + *ptReadSize) >= s_pstIpTuner[ulHandle]->nEndPosition))) /* bound check */
	{					
		s_pstIpTuner[ulHandle]->stPrdnInfo.bReadCompleted = TRUE;
		MhegVFIOError("%s (%d) ICS[%d]Read completed..!!(%"PRId64", %"PRId64")\n",__FUNCTION__,__LINE__, ulHandle, cur, *ptReadSize);
	}
	#endif

	(void) VK_SEM_Release (s_pstIpTuner[ulHandle]->ulDNPReadSema);

	MhegVFIOFunctionExit;

	return ret;
}

/** 
 * VFIO (for DNP) Seek Function 
 * call by : DI_MEDIA_Probe 
 *
 * Probe를 시도할 때 bmedia player단에서 요구하는 Probe Point까지
 * Download 받지 못한 경우 Seek을 통해 받을때까지 Check 하는 Function
 *
 * 해당 offset까지 Seek 이 성공하는 경우 bmedia_player는 비로소 Probe를 시도한다. 
 */
static int vfio_cb_mheg_ics_iptuner_DnpSeek (VFIO_Handle_t tHandle, off_t offset, int whence)
{
	int		ret=VFIO_ERROR_SUCCESS;
	off_t	curOffset;
	
	int		nLoopCnt=0;
	struct stat	sb;
	off_t		cur=0;

	int		nIsReady=FALSE;
	
	HUINT32 				ulHandle;
	MHEG_DNP_USER_DATA_t	*pMhegDnpUserData = (MHEG_DNP_USER_DATA_t*)tHandle.pDnpUserData;
		
	if(pMhegDnpUserData == NULL)
	{
		MhegVFIOError("pDnpUserData is NULL\n");
		return VFIO_ERROR_IN_DEVICE; /* this value is transformed to 0(EOF) in b_stdio_read */
	}

	MhegVFIOFunctionEnter;	
	
	ulHandle = pMhegDnpUserData->ulHandle;	

	//MhegVFIOError("%s (%d) offset=%"PRId64", whence=%d\n",__FUNCTION__,__LINE__,offset, whence);

	
	cur = lseek((int)tHandle.tFile.callback.unHandle, 0, SEEK_CUR);
	if ( (off_t)-1 == cur )
	{
		MhegVFIOError("%s (%d) Error>  lseek() - 1\n",__FUNCTION__,__LINE__);
		ret = -1;
	}
	else
	{
		while ( nLoopCnt++ < MHEG_ICS_IPTUNER_DNP_PROBE_SEEK_CALLBACK_WAITCOUNT)
		{
			if(s_pstIpTuner[ulHandle]->bIsPlaybackStop == TRUE)
			{
				MhegVFIOError("%s (%d) Error>  s_bIsPlaybackStop() - 1\n",__FUNCTION__,__LINE__);
				ret = -1;
				break;
			}

			if (fstat((int)tHandle.tFile.callback.unHandle, &sb)<0)
			{
				MhegVFIOError("%s (%d) Error> Fail fstat().\n",__FUNCTION__,__LINE__);
			}
			else
			{
				MhegVFIODebug ("%s(%d)  SEEK_CUR (%d) SEEK_SET(%d) whence (%d) sb.st_size(%"PRId64") \n"
							,__FUNCTION__
							,__LINE__
							,SEEK_CUR
							,SEEK_SET
							,whence
							,(HINT64)sb.st_size);
#if 0
				MhegVFIOError("%s(%d)  cur (%"PRId64") offset(%"PRId64") s_nFileLength (%"PRId64") sb.st_size(%"PRId64") \n"
							,__FUNCTION__
							,__LINE__
							,cur
							,offset
							,s_nFileLength
							,sb.st_size);
				MhegVFIOError("%s(%d)  cur+offset+64K %"PRId64" offset+64K %"PRId64" \n"
							,__FUNCTION__,__LINE__,((cur+offset)+(6*1024)),((offset)+(6*1024)));
#endif

#ifdef ENABLE_MAPPED_DNP
				/* bound check를 해서 bound를 넘는 read호출을 방지 */
				if( SEEK_CUR == whence )
				{
					if(cur+offset >= s_pstIpTuner[ulHandle]->nFileLength)
					{
						MhegVFIODebug("Seek Request is beyond the file length\n");
						return -1;
					}
				}
				else if ( SEEK_SET == whence )
				{
					if(offset > s_pstIpTuner[ulHandle]->nFileLength)
					{
						MhegVFIODebug("Seek Request is beyond the file length\n");
						return -1;
					}
				}
				else if( SEEK_END == whence )
				{
					offset = s_pstIpTuner[ulHandle]->nFileLength - 1; /* last index */
					whence = SEEK_SET;
				}
				else
				{
					MhegVFIOError("%s(%d) Error > Invalid whence enum\n", __FUNCTION__, __LINE__);
				}
#else

				if ( SEEK_CUR == whence )
				{
					if ((((cur+offset)+(6*1024)) <= s_pstIpTuner[ulHandle]->nFileLength) && (((cur+offset)+(6*1024)) <= sb.st_size))
					{
						nIsReady = TRUE;
					}
					else if ( (((cur+offset)+(6*1024)) > s_pstIpTuner[ulHandle]->nFileLength) && ((cur+offset) <= sb.st_size))
					{
						VK_TASK_Sleep(100); /* brcm work around */						
						nIsReady = TRUE;
					}
					/* else - { continue } */
				}
				else if ( SEEK_SET == whence )
				{
					if (((offset+(6*1024)) <= s_pstIpTuner[ulHandle]->nFileLength) && (((offset)+(6*1024)) <= sb.st_size))
					{
						nIsReady = TRUE;
					}
					else if ( ((offset+(6*1024)) > s_pstIpTuner[ulHandle]->nFileLength) && (offset <= sb.st_size))
					{
						VK_TASK_Sleep(100); /* brcm work around */
						nIsReady = TRUE;
					}
					/* else - { continue } */
				}
				else
#endif					
				{
					nIsReady = TRUE;
				}
				
				if ( TRUE == nIsReady )
				{
					curOffset = lseek((int)tHandle.tFile.callback.unHandle, offset, whence);
					if ( (off_t)-1 == curOffset )
					{
						MhegVFIOError("%s (%d) Error>  lseek() - 2\n",__FUNCTION__,__LINE__);
						ret = -1;
					}
					/* else { continue } */

					break;
				}
				else
				{
						MhegVFIOData("%s (%d) Seeking> - Not enough data ! real size(%"PRId64"), request size(%"PRId64")\n"
						,__FUNCTION__,__LINE__
						,(HINT64)sb.st_size, (HINT64)(offset));
				}
			}

			VK_TASK_Sleep (MHEG_ICS_IPTUNER_DNP_CALLBACK_WAITTTIME);
		}
	}

	MhegVFIOFunctionExit;

	return ret;
}

/** VFIO (for DNP) Tell Function */
static int vfio_cb_mheg_ics_iptuner_DnpTell (VFIO_Handle_t tHandle, off_t *plCurOffset)
{
	int		ret=VFIO_ERROR_SUCCESS;

	MhegVFIOFunctionEnter;

	*plCurOffset = lseek((int)tHandle.tFile.callback.unHandle, 0, SEEK_CUR);
	if ( (off_t)-1 == *plCurOffset )
	{
		MhegVFIOError("%s (%d) Error>  lseek()\n",__FUNCTION__,__LINE__);
		ret = -1;
	}
	/* else { continue } */

	MhegVFIOData("%s(%d) plCurOffset (%"PRId64")\n",__FUNCTION__,__LINE__,*plCurOffset);
	
	MhegVFIOFunctionExit;

	return ret;
}

/** VFIO (for DNP) IsEOF Function */
static int vfio_cb_mheg_ics_iptuner_DnpIsEOF (VFIO_Handle_t tHandle)
{
	int			ret=VFIO_ERROR_SUCCESS;
	struct stat	sb;
	off_t		cur=0;

	MhegVFIOFunctionEnter;

	if (fstat((int)tHandle.tFile.callback.unHandle, &sb)<0)
	{
		MhegVFIOError("%s (%d) Error> fstat()\n",__FUNCTION__,__LINE__);
		ret = -1;
	}
	else
	{
		cur = lseek((int)tHandle.tFile.callback.unHandle, 0, SEEK_CUR);
		if ( (off_t)-1 == cur )
		{
			MhegVFIOError("%s (%d) Error>  lseek()\n",__FUNCTION__,__LINE__);
			ret = -1;
		}
		else
		{
			/* TODO :: */
			if ( cur == sb.st_size )
			{
				MhegVFIODebug("\t[VFIO][%d] fd(0x%X) is EOF..!!\n", __LINE__, (int)tHandle.tFile.callback.unHandle);
				ret = 1;
			}
			else
			{
				ret = 0;
			}
		}
	}
	
	MhegVFIOFunctionExit;

	return ret;
}

/** VFIO (for DNP) OpenFromNexus Function */
static int vfio_cb_mheg_ics_iptuner_DnpOpenFromNexus (const HINT8 *path, const unsigned int flags, VFIO_Handle_t *ptHandle)
{
	int		ret=VFIO_ERROR_SUCCESS;
	int		fd;
	HUINT32	i, ulMediaId;


	MhegVFIOFunctionEnter;
	MhegVFIOData("%s (%d)  path=%s, flags=%d\n",__FUNCTION__,__LINE__, path, flags);

	/* warning: unused parameter 'path' */
	/* warning: unused parameter 'flags' */
	/* Just post the debug message instead of  UNUSED_PARAM() */
	/* Dont use UNUSED_PARAM(path); UNUSED_PARAM(flags); */

	if(ptHandle == NULL)
	{
		MhegVFIOError("ptHandle is NULL\n");
		ret = VFIO_ERROR_BAD_PARAMETER;
		goto error;
	}

	for(i = 0; i < MAX_MHEG_ICS_IPTUNER_NUM; i++)
	{
		if( s_pstIpTuner[i] == NULL)
		{
			continue;
		}
		
		MhegVFIOData("%s (%d)  url=%s\n",__FUNCTION__,__LINE__, s_pstIpTuner[i]->stIptuner.url);
		if((s_pstIpTuner[i]->stIptuner.isAvailable == TRUE)
			&& (VK_strcmp(path, s_pstIpTuner[i]->stIptuner.url) == 0))
		{
			ulMediaId = i;
			break;
		}
	}

	if(i == MAX_MHEG_ICS_IPTUNER_NUM)
	{
		MhegVFIOError("Valid IPTuner Not found...!!\n");
		ret = VFIO_ERROR_BAD_PARAMETER;
		goto error;
	}

	/* error check */
	if(s_pstIpTuner[ulMediaId]->hVFIO.pDnpUserData == NULL)
	{
		MhegVFIOError("pDnpUserData is NULL\n");
		ptHandle->ucAvailable = 0;
		ret = VFIO_ERROR_IN_DEVICE;
		goto error;
	}
	else
	{
		ptHandle->pDnpUserData = s_pstIpTuner[ulMediaId]->hVFIO.pDnpUserData;
	}

	fd = open(s_pstIpTuner[ulMediaId]->pSaveFileName, O_RDONLY|O_SYNC, 0666);
	if ( fd < 0 )
	{
		MhegVFIOError("\n\t[VFIO-Nexus][%d] Error>> Open(mediaId, name) = (%d, %s)\n",__LINE__, ulMediaId, s_pstIpTuner[ulMediaId]->pSaveFileName);
		ptHandle->ucAvailable = 0;
		ret = VFIO_ERROR_IN_DEVICE;
	}
	else
	{
		ptHandle->ucAvailable = 1;
		ptHandle->tFile.callback.unHandle = (HUINT32)fd;
		if(((MHEG_DNP_USER_DATA_t *)ptHandle->pDnpUserData)->stData.unOpenFromNexusHandle == 0) /* first open if for player. second is for indexer */
		{
			//MhegVFIODebug//
			MhegIcsError("\t ====\n\t M[%d] OPEN FOR PLAYER(0x%X)\n", ulMediaId, ptHandle->tFile.callback.unHandle);
			((MHEG_DNP_USER_DATA_t *)ptHandle->pDnpUserData)->stData.unOpenFromNexusHandle = ptHandle->tFile.callback.unHandle;
			((MHEG_DNP_USER_DATA_t *)ptHandle->pDnpUserData)->stData.player_last_read_cursor = 0;
		}
		else
		{
			MhegVFIODebug("====\nOPEN FOR INDEXER\n");
		}
		MhegVFIODebug("\n\t[VFIO-Nexus][%d] Open(mediaId, fd, name) = (%d, 0x%X, %s)\n",
			__LINE__, ulMediaId, ptHandle->tFile.callback.unHandle, s_pstIpTuner[ulMediaId]->pSaveFileName);
	}
error:

	MhegVFIOFunctionExit;

	return ret;
}

/** VFIO (for DNP) SeekFromNexus Function */
static off_t vfio_cb_mheg_ics_iptuner_DnpSeekForNexus (VFIO_Handle_t tHandle, off_t offset, int whence)
{
	off_t		curOffset=(off_t)-1;
	
	int		nLoopCnt=0;
	struct stat	sb;
	off_t		cur=0;

	int		nIsReady=FALSE;

	HUINT32 				ulHandle;
	MHEG_DNP_USER_DATA_t	*pMhegDnpUserData = (MHEG_DNP_USER_DATA_t*)tHandle.pDnpUserData;
		
	if(pMhegDnpUserData == NULL)
	{
		MhegVFIOError("pDnpUserData is NULL\n");
		return VFIO_ERROR_IN_DEVICE; /* this value is transformed to 0(EOF) in b_stdio_read */
	}

	MhegVFIOFunctionEnter;	
	ulHandle = pMhegDnpUserData->ulHandle;

	MhegVFIOData("%s (%d) offset=%"PRId64", whence=%d\n",__FUNCTION__,__LINE__, offset, whence);

	cur = lseek((int)tHandle.tFile.callback.unHandle, 0, SEEK_CUR);
	if ( (off_t)-1 == cur )
	{
		MhegVFIOError("%s (%d) Error>  lseek() - 1\n",__FUNCTION__,__LINE__);
		curOffset = (off_t)-1;
	}
	else
	{
		while ( nLoopCnt++ < MHEG_ICS_IPTUNER_DNP_SEEK_CALLBACK_WAITCOUNT)
		{
			if(s_pstIpTuner[ulHandle]->bIsPlaybackStop==TRUE)
			{
				MhegVFIOError("%s (%d) Error>  s_bIsPlaybackStop() - 1\n",__FUNCTION__,__LINE__);
				curOffset = (off_t)-1;
				break;
			}
			
			if (fstat((int)tHandle.tFile.callback.unHandle, &sb)<0)
			{
				MhegVFIOError("%s (%d) Error>  fstat() - 1\n",__FUNCTION__,__LINE__);
			}
			else
			{
#ifdef ENABLE_MAPPED_DNP
				/* no check */
#else
				if ( SEEK_CUR == whence )
				{
					if ( (cur + offset) <= sb.st_size )
					{
						nIsReady = TRUE;
					}
					/* else - { continue } */
				}
				else if ( SEEK_SET == whence )
				{
					if ( offset <= sb.st_size )
					{
						nIsReady = TRUE;
					}
					/* else - { continue } */
				}
				else
#endif
				{
					nIsReady = TRUE;
				}
				
				if ( TRUE == nIsReady )
				{
					curOffset = lseek((int)tHandle.tFile.callback.unHandle, offset, whence);

					break;
				}
				else
				{
					if ( SEEK_CUR == whence )
					{
						MhegVFIODebug ("%s (%d) Seeking> - Not enough data ! real size(%"PRId64"), request size(%"PRId64")\n"
						,__FUNCTION__,__LINE__
						,(HINT64)sb.st_size, (HINT64)(cur+offset));
					}
					else
					{
						MhegVFIODebug ("%s (%d) Seeking> - Not enough data ! real size(%"PRId64"), request size(%"PRId64")\n"
						,__FUNCTION__,__LINE__
						,(HINT64)sb.st_size, (HINT64)(offset));
					}
				}
			}

			VK_TASK_Sleep (MHEG_ICS_IPTUNER_DNP_CALLBACK_WAITTTIME);
		} /* end of while */
	}
	
	//MhegVFIOError("%s (%d) m[%d] curOffset=%"PRId64"\n",__FUNCTION__,__LINE__, ulHandle, curOffset);
	MhegVFIOFunctionExit;

	return curOffset;
}

/** VFIO (for DNP) BoundsFromNexus Function */
static int vfio_cb_mheg_ics_iptuner_DnpBoundsForNexus(VFIO_Handle_t tHandle, off_t *file_size)
{
	int		ret=VFIO_ERROR_SUCCESS;
#if 0
	struct stat	sb;
#endif	
	HUINT32 				ulHandle;
	MHEG_DNP_USER_DATA_t	*pMhegDnpUserData = (MHEG_DNP_USER_DATA_t*)tHandle.pDnpUserData;
		
	if(pMhegDnpUserData == NULL)
	{
		MhegVFIOError("pDnpUserData is NULL\n");
		return VFIO_ERROR_IN_DEVICE; /* this value is transformed to 0(EOF) in b_stdio_read */
	}

	MhegVFIOFunctionEnter;	
	ulHandle = pMhegDnpUserData->ulHandle;

#if	0 /** need whole file size */
	if (fstat((int)tHandle.tFile.callback.unHandle, &sb)<0)
	{
		MhegVFIOError("[vfio_cb_mheg_ics_iptuner_DnpBoundsForNexus] Error - fstat()\n");
		ret = VFIO_ERROR_IN_DEVICE;

		*file_size = 0;
	}
	else
	{
		*file_size = sb.st_size;
	}
#else	
	if(s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffForcedStop != 0)
	{
		*file_size = (off_t)PRDN_GET_RAW_OFF_FROM_CHUNK_OFF(s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffForcedStop);
	}
	else
	{
		*file_size = s_pstIpTuner[ulHandle]->nFileLength;
	}	
#endif

	////MhegIcsDebug
	MhegVFIODebug("\t [VFIO:%d] M[%d] DnpBound =%"PRId64"\n",__LINE__, ulHandle, *file_size );
	MhegVFIOFunctionExit;

	return ret;
}


static DI_IPTUNER_Index_e local_mheg_ics_iptuner_GetTunerIndex (DI_IPTUNER_DownloadType_e nDownloadType, HINT8 *url)
{
	DI_IPTUNER_Index_e nTunerIndex = DI_IPTUNER_MAX_NUM;
	DI_IPTUNER_ProtocolType_e nProtocolType = DI_IPTUNER_PROTOCOL_UNKNOWN;
	URL_t stTmpUrl;

	MhegVFIOFunctionEnter(nDownloadType);
	/* TODO  : junsy
	 * Protocol Type은 입력되는 URL 을 Parsing 하여 얻는다.
	 * 또한 URL_t 정보를 활용할 방법이 필요함.
	 */
	/** Check URI */
	VK_memset (&stTmpUrl,0,sizeof(URL_t));

	if(nDownloadType != DI_IPTUNER_DLNA)
	{
		UTIL_UrlParse (&stTmpUrl, (const char*)url, 0);

		if (!VK_strncmp (stTmpUrl.psz_protocol,"http",4))
		{
			nProtocolType = DI_IPTUNER_PROTOCOL_HTTP;
			/* for SSTR */
			if(stTmpUrl.psz_path != NULL)
			{
				if(NULL != strstr(stTmpUrl.psz_path,".ism/Manifest") || NULL != strstr(stTmpUrl.psz_path,".ism/manifest")
				|| NULL != strstr(stTmpUrl.psz_path,".isml/Manifest") || NULL != strstr(stTmpUrl.psz_path,".isml/manifest")				
				|| NULL != strstr(stTmpUrl.psz_path,".smil/Manifest") || NULL != strstr(stTmpUrl.psz_path,".smil/manifest"))
				{
					nProtocolType = DI_IPTUNER_PROTOCOL_SSTR;
				}
				if(NULL != strstr(stTmpUrl.psz_path,".m3u8"))
				{
					nProtocolType = DI_IPTUNER_PROTOCOL_HLS;
				}				
			}
		}
		else if (!VK_strcmp(stTmpUrl.psz_protocol,"mms"))
		{
			nProtocolType = DI_IPTUNER_PROTOCOL_MMS;
		}
		else if (!VK_strcmp(stTmpUrl.psz_protocol,"rtsp"))
		{
			nProtocolType = DI_IPTUNER_PROTOCOL_RTSP;
		}
		else if (!VK_strcmp(stTmpUrl.psz_protocol,"ftp"))
		{
			nProtocolType = DI_IPTUNER_PROTOCOL_FTP;
		}
		UTIL_UrlClean (&stTmpUrl);
	}

	switch (nDownloadType)
	{
		case DI_IPTUNER_FULL_DOWNLOAD :
			MhegIcsError ("[%s] [%d] %d FULL Download support in the future.\n",__FUNCTION__,__LINE__, nDownloadType);
			break;
		case DI_IPTUNER_PLAYABLE_DOWNLOAD:
			switch ( nProtocolType )
			{
				case DI_IPTUNER_PROTOCOL_HTTP :
					nTunerIndex = DI_IPTUNER_DNP_HTTP;
					break;
				case DI_IPTUNER_PROTOCOL_MMS :
					nTunerIndex = DI_IPTUNER_DNP_MMS;
					break;
				case DI_IPTUNER_PROTOCOL_RTSP :
					nTunerIndex = DI_IPTUNER_DNP_RTSP;
					break;
				case DI_IPTUNER_PROTOCOL_FTP :
					nTunerIndex = DI_IPTUNER_DNP_FTP;
					break ;
				case DI_IPTUNER_PROTOCOL_UNKNOWN :
					MhegIcsError (" %s (%d) Error> Invalid Protocol Type\n",__FUNCTION__,__LINE__ );
					break;
				default :
					MhegIcsError (" %s (%d) Error> %d Protocol Type is not supported(DNP)\n",__FUNCTION__,__LINE__, nProtocolType );
					break;
			}
			break;
		case DI_IPTUNER_STREAMING :
			switch ( nProtocolType )
			{
				case DI_IPTUNER_PROTOCOL_HTTP :
					nTunerIndex = DI_IPTUNER_STREAM_HTTP;
					break;
				case DI_IPTUNER_PROTOCOL_MMS :
					nTunerIndex = DI_IPTUNER_STREAM_MMS;
					break;
				case DI_IPTUNER_PROTOCOL_RTSP :
					nTunerIndex = DI_IPTUNER_STREAM_RTSP;
					break ;
#ifdef CONFIG_MEDIA_SSTR					
				case DI_IPTUNER_PROTOCOL_SSTR : /* for SSTR */
					nTunerIndex = DI_IPTUNER_STREAM_SSTR;
					break ;
#endif
				case DI_IPTUNER_PROTOCOL_HLS : 
					nTunerIndex = DI_IPTUNER_STREAM_HLS;
					break ;				
				case DI_IPTUNER_PROTOCOL_HTTP_CHNK : /* for HTTP Chunked Live Streaming */
					nTunerIndex = DI_IPTUNER_STREAM_HTTP_CHNK;
					break;
				case DI_IPTUNER_PROTOCOL_UNKNOWN :
					MhegIcsError (" %s (%d) Error> Invalid Protocol Type\n",__FUNCTION__,__LINE__ );
					break;
				default :
					MhegIcsError (" %s (%d) Error> %d Protocol Type is not supported (STREAMING)\n",__FUNCTION__,__LINE__, nProtocolType );
					break;
			}
			break;
		case DI_IPTUNER_DLNA:
			nTunerIndex = DI_IPTUNER_DLNA_DNP;
			break;
		default :
			MhegIcsError ("%s (%d) Error> Download Type(%d) is not supported(IPTUNER)\n",__FUNCTION__,__LINE__, nDownloadType );
			break;
	} /* End of switch */

	MhegVFIOFunctionExit;
	return nTunerIndex ;
}

static void local_mheg_ics_iptuner_DnpInitTread(HUINT32	ulHandle)
{
	DI_IPTUNER_Msg_t s_Msg;
	HINT32 nVKRet;

	MhegIcsFunctionEnter(ulHandle);

	if ( s_pstIpTuner[ulHandle]->bIsInitialized != TRUE )
	{
		nVKRet = VK_MSG_Create(MHEG_ICS_IPTUNER_DNP_MSG_QUEUE_SIZE, sizeof(s_Msg), "MHEG_DNP_MSGQ", &s_pstIpTuner[ulHandle]->ulDNPMsgQId, VK_SUSPENDTYPE_FIFO);
		if ( VK_OK != nVKRet )
		{
			MhegIcsError("[%s] [%d] DNP Task msgQ creation fail err = 0x%x\n",__FUNCTION__,__LINE__, nVKRet );
			return;
		}	/* Semaphore for shared data between main_task and timer_task */


		nVKRet = VK_SEM_Create(&s_pstIpTuner[ulHandle]->ulDNPSema, "MHEG_DNPTunerSema", VK_SUSPENDTYPE_PRIORITY);
		if ( VK_OK != nVKRet )
		{
			MhegIcsError("[%s] [%d] DNP Timer sema creation fail err = 0x%x\n",__FUNCTION__,__LINE__, nVKRet );
			return;
		}



		nVKRet = VK_SEM_Create(&s_pstIpTuner[ulHandle]->ulDNPReadSema,  "MHEG_DNPTunerReadSema", VK_SUSPENDTYPE_PRIORITY);
		if ( VK_OK != nVKRet )
		{
			MhegIcsError("[%s] [%d] DNP Read sema creation fail err = 0x%x\n",__FUNCTION__,__LINE__, nVKRet );
			return;
		}

		s_pstIpTuner[ulHandle]->bDNPTaskQuit = FALSE;

		/** Create Download Task */
		nVKRet = VK_TASK_Create( IPTUNER_MHEG_ICS_DnpTask
							, USER_PRIORITY8	// temp priority TODO:
							, MHEG_ICS_IPTUNER_DNP_STACK_SIZE
							, "MHEG_DNP_Tuner"
							, (void*)ulHandle
							, &s_pstIpTuner[ulHandle]->ulDNPTaskId
							, TRUE);
		if ( VK_OK != nVKRet )
		{
			MhegIcsError("%s (%d) Error> DNP Tuner task creation fail err = 0x%x\n",__FUNCTION__,__LINE__, nVKRet);
			return;
		}
		else
		{
			nVKRet = VK_EVENT_Create (&s_pstIpTuner[ulHandle]->ulTunerEventID, "MHEG_DNPTunerEvent");
			if ( VK_OK != nVKRet )
			{
				MhegIcsError("%s (%d) Error> Error(0x%x) in VK_EVENT_Create()\n\r", __FUNCTION__,__LINE__,nVKRet);
				return;
			}
			else
			{
				s_pstIpTuner[ulHandle]->bIsInitialized = TRUE;
			}
		}

		/** Start Download Task */		
		VK_TASK_Start(s_pstIpTuner[ulHandle]->ulDNPTaskId);
	}
	else
	{		
		MhegIcsError("%s (%d) Error>  (%d) Already initialized !\n",__FUNCTION__,__LINE__, ulHandle);	
	}
	MhegIcsFunctionExit;

	return;
}



static HBOOL local_mheg_ics_stream_UseHttpsProtocol(STREAM_ACCESS_t *pAccess)
{
	if ( pAccess == NULL ) return FALSE;
	if ( pAccess->psz_path == NULL ) return FALSE;

	return ( VK_strncmp(pAccess->psz_path, "https", 5) == 0 ) ? TRUE : FALSE;
}

static HERROR local_mheg_ics_stream_HTTP_Open(HUINT32	ulHandle, HINT8 *url, const HINT8 *mode)
{
	HINT32 				nRet = DI_IPT_SUCCESS;
	HINT32 				vRet = VFIO_ERROR_SUCCESS;
	HTTP_ACCESS_SYS_t 	*pstHttpSys=NULL;
	
#if SUPPORT_COOKIE
	char *psCookie = NULL;
	URL_t tUrl;
#endif

	UNUSED_PARAM(mode);

	MhegIcsFunctionEnter(ulHandle);

#if SUPPORT_COOKIE
	VK_MEM_Memset(&tUrl, 0x0, sizeof(tUrl));
	UTIL_UrlParse(&tUrl, (const char *)url, 0);
	if(tUrl.psz_cookie != NULL)
	{
		psCookie = VK_StrDup(tUrl.psz_cookie);
	}
	UTIL_UrlClean(&tUrl);
#endif
	
	VK_MEM_Memset (&s_pstIpTuner[ulHandle]->hHttpAccess, 0, sizeof (STREAM_ACCESS_t));
	s_pstIpTuner[ulHandle]->hHttpAccess.psz_path = VK_StrDup((char *)url);
#if SUPPORT_COOKIE
	if(psCookie != NULL)
	{
		s_pstIpTuner[ulHandle]->hHttpAccess.psz_cookie = psCookie;
	}
#endif	

	if(s_pstIpTuner[ulHandle]->hHttpAccess.psz_path == NULL)
	{
		MhegIcsError("%s(%d) : Error> Fail Mem alloc.\n",__FUNCTION__,__LINE__);
		s_pstIpTuner[ulHandle]->hVFIO.ucAvailable = 0;
		vRet = VFIO_ERROR_IN_DEVICE;
	}
	else
	{
		nRet = STREAM_HTTP_Open (&s_pstIpTuner[ulHandle]->hHttpAccess);
		if(nRet != DI_IPT_SUCCESS)
		{
			MhegIcsError("%s(%d) : Error> HTTP_Open Fail.\n",__FUNCTION__,__LINE__);
			s_pstIpTuner[ulHandle]->hHttpAccess.b_alive = TRUE;
			s_pstIpTuner[ulHandle]->hVFIO.ucAvailable = 0;

			if(s_pstIpTuner[ulHandle]->hHttpAccess.psz_path != NULL)
			{
				DD_MEM_Free(s_pstIpTuner[ulHandle]->hHttpAccess.psz_path);
				s_pstIpTuner[ulHandle]->hHttpAccess.psz_path =NULL;
			}
			/* else { continue; } */
#if SUPPORT_COOKIE
			if(s_pstIpTuner[ulHandle]->hHttpAccess.psz_cookie != NULL)
			{
				DD_MEM_Free(s_pstIpTuner[ulHandle]->hHttpAccess.psz_cookie);
				s_pstIpTuner[ulHandle]->hHttpAccess.psz_cookie =NULL;
			}
			/* else { continue; } */
#endif
			vRet = VFIO_ERROR_IN_DEVICE;
		}
		else
		{
			MhegIcsData("%s(%d) : i_update       = %d \n",__FUNCTION__,__LINE__,s_pstIpTuner[ulHandle]->hHttpAccess.info.i_update);
			MhegIcsData("%s(%d) : i_size         = %"PRId64"\n",__FUNCTION__,__LINE__,s_pstIpTuner[ulHandle]->hHttpAccess.info.i_size);
			MhegIcsData("%s(%d) : i_pos          = %"PRId64"\n",__FUNCTION__,__LINE__,s_pstIpTuner[ulHandle]->hHttpAccess.info.i_pos);
			MhegIcsData("%s(%d) : b_eof          = %d \n",__FUNCTION__,__LINE__,s_pstIpTuner[ulHandle]->hHttpAccess.info.b_eof);
			MhegIcsData("%s(%d) : i_title        = %d \n",__FUNCTION__,__LINE__,s_pstIpTuner[ulHandle]->hHttpAccess.info.i_title);
			MhegIcsData("%s(%d) : i_seekpoint    = %d \n",__FUNCTION__,__LINE__,s_pstIpTuner[ulHandle]->hHttpAccess.info.i_seekpoint);
			MhegIcsData("%s(%d) : b_prebuffered  = %d \n",__FUNCTION__,__LINE__,s_pstIpTuner[ulHandle]->hHttpAccess.info.b_prebuffered);

			if((s_pstIpTuner[ulHandle]->hHttpAccess.info.i_size > 0) && (s_pstIpTuner[ulHandle]->hHttpAccess.info.i_size < 4*1024))
			{
				MhegIcsError("%s(%d) : Error> HTTP_Open Fail.\n",__FUNCTION__,__LINE__);
				MhegIcsError("%s(%d) : Error> Invalid File Size(File Size = %"PRId64".\n",__FUNCTION__,__LINE__, s_pstIpTuner[ulHandle]->hHttpAccess.info.i_size);
				s_pstIpTuner[ulHandle]->hHttpAccess.b_alive = TRUE;
				s_pstIpTuner[ulHandle]->hVFIO.ucAvailable = 0;

				(void)STREAM_HTTP_Close (&s_pstIpTuner[ulHandle]->hHttpAccess);
				
				if(s_pstIpTuner[ulHandle]->hHttpAccess.psz_path != NULL)
				{
					DD_MEM_Free(s_pstIpTuner[ulHandle]->hHttpAccess.psz_path);
					s_pstIpTuner[ulHandle]->hHttpAccess.psz_path =NULL;
				}
				/* else { continue; } */
#if SUPPORT_COOKIE
				if(s_pstIpTuner[ulHandle]->hHttpAccess.psz_cookie != NULL)
				{
					DD_MEM_Free(s_pstIpTuner[ulHandle]->hHttpAccess.psz_cookie);
					s_pstIpTuner[ulHandle]->hHttpAccess.psz_cookie =NULL;
				}
				/* else { continue; } */
#endif
				vRet = VFIO_ERROR_IN_DEVICE;
			}
			else
			{
				pstHttpSys = (HTTP_ACCESS_SYS_t*) s_pstIpTuner[ulHandle]->hHttpAccess.p_sys;
				s_pstIpTuner[ulHandle]->hVFIO.ucAvailable = 1;
				s_pstIpTuner[ulHandle]->hVFIO.tFile.callback.unHandle = (HUINT32) pstHttpSys->fd; /** http socket descriptor */
				MhegIcsData("%s(%d) : callback handle=0x%x\n",__FUNCTION__,__LINE__, s_pstIpTuner[ulHandle]->hVFIO.tFile.callback.unHandle);
			}
		}

		nRet = VK_SEM_Create(&s_pstIpTuner[ulHandle]->ulHttpSemId,"MHEG_httpSema", VK_SUSPEND_PRIORITY);
		if( nRet != VK_OK )
		{
			MhegIcsError("%s(%d) Error(0x%x) \n\r",__FUNCTION__,__LINE__, nRet);

			(void)STREAM_HTTP_Close (&s_pstIpTuner[ulHandle]->hHttpAccess);
			
			if(s_pstIpTuner[ulHandle]->hHttpAccess.psz_path != NULL)
			{
				DD_MEM_Free(s_pstIpTuner[ulHandle]->hHttpAccess.psz_path);
				s_pstIpTuner[ulHandle]->hHttpAccess.psz_path =NULL;
			}
			/* else { continue; } */
#if SUPPORT_COOKIE
			if(s_pstIpTuner[ulHandle]->hHttpAccess.psz_cookie != NULL)
			{
				DD_MEM_Free(s_pstIpTuner[ulHandle]->hHttpAccess.psz_cookie);
				s_pstIpTuner[ulHandle]->hHttpAccess.psz_cookie =NULL;
			}
			/* else { continue; } */
#endif
			MhegIcsFunctionExit;
			return VFIO_ERROR_IN_DEVICE;
		}
	}

	MhegIcsFunctionExit;
	return vRet;
}

static HERROR 	local_mheg_ics_stream_HTTP_Close(HUINT32	ulHandle)
{
	HINT32 vRet = VFIO_ERROR_SUCCESS;
	
	MhegIcsFunctionEnter(ulHandle);

	/* In multi-open case, the http session should be closed only once. */
	if(s_pstIpTuner[ulHandle]->hHttpAccess.b_alive == FALSE)
	{
		MhegIcsDebug("%s(%d) : HTTP Session is already closed.\n",__FUNCTION__,__LINE__);
		goto success;
	}

	(void)VK_SEM_Get(s_pstIpTuner[ulHandle]->ulHttpSemId);

	s_pstIpTuner[ulHandle]->stPrdnInfo.pReadyStateCallbackFunc = NULL;

	(void) STREAM_HTTP_Close (&s_pstIpTuner[ulHandle]->hHttpAccess);

	s_pstIpTuner[ulHandle]->hHttpAccess.b_alive = FALSE;

	if(s_pstIpTuner[ulHandle]->hHttpAccess.psz_path != NULL)
	{
		DD_MEM_Free(s_pstIpTuner[ulHandle]->hHttpAccess.psz_path);
		s_pstIpTuner[ulHandle]->hHttpAccess.psz_path =NULL;
	}
	/* else { continue; } */

#if SUPPORT_COOKIE
	if(s_pstIpTuner[ulHandle]->hHttpAccess.psz_cookie != NULL)
	{
		DD_MEM_Free(s_pstIpTuner[ulHandle]->hHttpAccess.psz_cookie);
		s_pstIpTuner[ulHandle]->hHttpAccess.psz_cookie =NULL;
	}
	/* else { continue; } */			
#endif
	
	(void)VK_SEM_Release (s_pstIpTuner[ulHandle]->ulHttpSemId);
	
 	(void)VK_SEM_Destroy(s_pstIpTuner[ulHandle]->ulHttpSemId);
	s_pstIpTuner[ulHandle]->ulHttpSemId = 0;

success:	

	if(s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData)
	{
		DD_MEM_Free(s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData);
		s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData = NULL;
	}
	
	MhegIcsFunctionExit;

	return vRet;
}

static HERROR local_mheg_ics_stream_HTTP_Receive(HUINT32	ulHandle)
{
	HINT8 *pBuffer=NULL;
	HINT32 nRecvLength=0;
	DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner = s_pstIpTuner[ulHandle];
	
	HINT64 nContentLength;
	HINT32 flags = O_CREAT|O_TRUNC|O_WRONLY|O_SYNC;
	HINT32 nRc = -1;
	DNP_USER_DATA_t * pDnpUserData;

	DI_ERR_CODE nRet = DI_ERR_OK;
	HULONG ulStartClock = 0;
	HUINT32 ulLoopCount = 0;

	/* prdn vars */
	HINT32 nReadBufferSize = 0;
	HINT32 nPrdnDownloadStatusArraySize;
	HINT32 nchunkoffLastWritten = 0;
	HINT32 nchunkoffWritingCur = 0;
	HINT32 nSumofRecvLength = 0;
	HUINT32 nBufferingSizeInChunkBeforeProbe = 0;

	if(pMhegIpTuner == NULL)
	{
		MhegIcsError("Error > MhegIpTuner[%d] is NULL\n", ulHandle);
		return -1;
	}

	nContentLength = pMhegIpTuner->hHttpAccess.info.i_size;
	
	pMhegIpTuner->stPrdnInfo.nLastReadyStateSentTime = 0;
	pMhegIpTuner->stPrdnInfo.nBufferSizeInChunkCount = 256; /* 8KB * 256 = 2MB */
	pMhegIpTuner->stPrdnInfo.nDownloadedChunkCount = 0;
	pMhegIpTuner->stPrdnInfo.nchunkoffLastPrebufferIdx = 0;

	pMhegIpTuner->stPrdnInfo.nIsPrebufferingCompleted = 0;

	pMhegIpTuner->stPrdnInfo.nSumLength = 0;
	//pMhegIpTuner->stPrdnInfo.nPausePosition = 0;
	pMhegIpTuner->stPrdnInfo.nchunkoffForcedStop = 0;
	
	MhegIcsFunctionEnter(ulHandle);

	if(pMhegIpTuner->hVFIO.pDnpUserData == NULL)
	{
		MhegIcsError("Error > %s(%d) pGeneral Ptr is NULL\n", __FUNCTION__, __LINE__);
		return -1;
	}
	else
	{
		MHEG_DNP_USER_DATA_t *pMhegDnpUserData = (MHEG_DNP_USER_DATA_t *)pMhegIpTuner->hVFIO.pDnpUserData;
		pDnpUserData = &(pMhegDnpUserData->stData);
	}
	 
	/* init progressive down extern variable */
	pMhegIpTuner->stPrdnInfo.nchunkoffPrdnEof = PRDN_GET_CHUNK_OFF(nContentLength - 1); /* count -> zero base index -> chunk_off */
	nPrdnDownloadStatusArraySize = PRDN_GET_BYTE_OFF(pMhegIpTuner->stPrdnInfo.nchunkoffPrdnEof) + 1; /* chunk_off -> byte_offset -> byte_count */

	pMhegIpTuner->stPrdnInfo.bDownCompleted = FALSE;
	pMhegIpTuner->stPrdnInfo.nchunkoffIsCompletedStart = 0;
	pMhegIpTuner->stPrdnInfo.bForwardPlay = TRUE;
#if 1	/* JWKIM, workardound: for Maxdome Service */
	pMhegIpTuner->stPrdnInfo.bPlayFFTrick = FALSE;
#endif
	pMhegIpTuner->stPrdnInfo.nchunkoffOldPrdnRequestedSeekPoint = -1;
	pMhegIpTuner->stPrdnInfo.nchunkoffPrdnRequestedSeekPoint = 0; /* start point */
	nReadBufferSize  = (HINT32)PRDN_GET_RAW_OFF_FROM_CHUNK_OFF(1);
	nBufferingSizeInChunkBeforeProbe = 0;

	/* if the size of chunk is 64Kbytes */
	if(pMhegIpTuner->stPrdnInfo.nchunkoffPrdnEof <= (12800/8))/* lesser than 100MB */
	{
		if ( local_mheg_ics_stream_UseHttpsProtocol(&pMhegIpTuner->hHttpAccess) == TRUE )
		{
			nBufferingSizeInChunkBeforeProbe = 16*3; /* 3MB */
		}
		else
		{
			nBufferingSizeInChunkBeforeProbe = 24; /* 1.5MB */
		}
	}
	else if(pMhegIpTuner->stPrdnInfo.nchunkoffPrdnEof <= (256000/8))/* lesser than 2GB */
	{
		if ( local_mheg_ics_stream_UseHttpsProtocol(&pMhegIpTuner->hHttpAccess) == TRUE )
		{
			nBufferingSizeInChunkBeforeProbe = 32*3; /* 6MB */
		}
		else
		{
			nBufferingSizeInChunkBeforeProbe = 40; /* 2.5MB */
		}
	}
	else /* larger than 2GB */
	{
		if ( local_mheg_ics_stream_UseHttpsProtocol(&pMhegIpTuner->hHttpAccess) == TRUE )
		{
			/* 0.1% e.g.) 4GB need 16MB */
			nBufferingSizeInChunkBeforeProbe = (pMhegIpTuner->stPrdnInfo.nchunkoffPrdnEof/1000)*3;
		}
		else
		{
			/* 0.1% e.g.) 4GB need 4MB */
			nBufferingSizeInChunkBeforeProbe = (pMhegIpTuner->stPrdnInfo.nchunkoffPrdnEof/1000);
		}
	}
	MhegIcsDebug("Before Probe Buffering Size is %uKB\n", nBufferingSizeInChunkBeforeProbe * 8);

	if(pMhegIpTuner->stPrdnInfo.pucChunkDownloadStatusArray != NULL)
	{
		MhegIcsDebug("@@@@@ [%s:%d] g_pucPrdnChunkDownloadStatusArray is Free\n", __func__, __LINE__);
		DD_MEM_Free(pMhegIpTuner->stPrdnInfo.pucChunkDownloadStatusArray);
		pMhegIpTuner->stPrdnInfo.pucChunkDownloadStatusArray = NULL;
	}

	pMhegIpTuner->stPrdnInfo.pucChunkDownloadStatusArray = (HUINT8 *) DD_MEM_Alloc ( nPrdnDownloadStatusArraySize );
	if(pMhegIpTuner->stPrdnInfo.pucChunkDownloadStatusArray == NULL)
	{
		MhegIcsError("s(%d) Error> PRDN Progress Array Heap Memory Allocation Fail. size (%d) !!\n",__FUNCTION__,__LINE__,nPrdnDownloadStatusArraySize);
		goto exit_stop;
	}
	VK_MEM_Memset(pMhegIpTuner->stPrdnInfo.pucChunkDownloadStatusArray, 0, nPrdnDownloadStatusArraySize); /* clear status */

	/* show some debug info */
	MhegIcsDebug("nPrdnDownloadStatusArraySize = %d\n", nPrdnDownloadStatusArraySize);
	MhegIcsDebug("pMhegIpTuner->stPrdnInfo.nchunkoffPrdnEof = %d\n", pMhegIpTuner->stPrdnInfo.nchunkoffPrdnEof);

	/* Open DNP FilePath */
	pMhegIpTuner->nWfd = open (pMhegIpTuner->pSaveFileName, flags, 0666);
	if(pMhegIpTuner->nWfd<0)
	{
		MhegIcsError("s(%d) :  Error> %s open fail (HTTP_DNP) \n",__FUNCTION__,__LINE__, pMhegIpTuner->pSaveFileName);
		return -1;
	}

	MhegIcsDebug ("%s(%d): Open %s.\n",__FUNCTION__,__LINE__, pMhegIpTuner->pSaveFileName);
	MhegIcsDebug ("%s(%d): nContentLength (%"PRId64")bytes \n",__FUNCTION__,__LINE__,nContentLength);

	/* heap allocation */
	pBuffer = (HINT8*) DD_MEM_Alloc (nReadBufferSize);
	if(pBuffer==NULL)
	{
		MhegIcsError("s(%d) Error> Heap Memory Allocation Fail. size (%d) !!\n",__FUNCTION__,__LINE__,nReadBufferSize);
		goto exit_stop;
	}

	pMhegIpTuner->nFileLength = nContentLength;

	/** HTTP DNP Main Download Loop */
	do
	{
		if ( (pMhegIpTuner->bIsEvtSend == FALSE)
				 && ((HUINT32)pMhegIpTuner->stPrdnInfo.nDownloadedChunkCount >= nBufferingSizeInChunkBeforeProbe) )
		{
			pMhegIpTuner->bIsEvtSend = TRUE;
			(void) VK_EVENT_Send (pMhegIpTuner->ulTunerEventID, (unsigned long)0);
		}		

		if ( pMhegIpTuner->bHttpStopReceiving == TRUE)
		{
			MhegIcsDebug("%s(%d) : User Stoped Receiving !!\n",__FUNCTION__,__LINE__);
			goto exit_stop;
		}

		if ( pMhegIpTuner->bHttpPauseReceiving == TRUE)
		{
			//MhegIcsDebug("%s(%d) : User Paused Receiving !!\n",__FUNCTION__,__LINE__);
			VK_TASK_Sleep(100);
			continue;
		}

		#if 1
		if(pMhegIpTuner->stPrdnInfo.nchunkoffForcedStop != 0) 				
		{			
			if( nchunkoffWritingCur >= (HINT32)(pMhegIpTuner->stPrdnInfo.nchunkoffForcedStop) ) 				
			{
				//pMhegIpTuner->stPrdnInfo.nchunkoffForcedStop = 0;
				pMhegIpTuner->stPrdnInfo.bDownCompleted = TRUE;
				local_mheg_ics_stream_HTTP_DnpPauseReceiving(pMhegIpTuner);

				MhegIcsError ("===== MHEG_ICS_IPTUNER PRDN PAUSE[%d]=>(WritingChunkNum:%d) =====\n", ulHandle, nchunkoffWritingCur);
				MhegIcsError ("===== MHEG_ICS_IPTUNER PRDN PAUSE =====\n");					

				if(pMhegIpTuner->stPrdnInfo.pReadyStateCallbackFunc)
				{
					MhegIcsError ("===== MHEG_ICS_IPTUNER PRDN PAUSE =====\n");
					VK_TASK_Sleep(500);
					pMhegIpTuner->stPrdnInfo.pReadyStateCallbackFunc(pMhegIpTuner->stPrdnInfo.nCBulDeviceId, DI_MEDIA_EVENT_BUFFER_READY_STATE, DI_IPTUNER_DNP_READYSTATE_FULLDOWN_COMPLETED); /* 3 == DOWNLOAD COMPLETED */					
					continue;
				}				
				else
				{
					MhegIcsError ("\n\n Error>> pReadyStateCallbackFunc is NULL !!!\n\n");
				}
			}
		}
		#endif

		if(pMhegIpTuner->stPrdnInfo.nchunkoffPrdnRequestedSeekPoint != -1)
		{
			//MhegIcsDebug("================ recv SEEK  %d\n", g_nchunkoffPrdnRequestedSeekPoint);
			nchunkoffWritingCur = pMhegIpTuner->stPrdnInfo.nchunkoffPrdnRequestedSeekPoint;
			pMhegIpTuner->stPrdnInfo.nchunkoffPrdnRequestedSeekPoint = -1;
		}

		if(!MHEG_ICS_PRDN_ISVALID(pMhegIpTuner->stPrdnInfo.pucChunkDownloadStatusArray, nchunkoffWritingCur))		
		{
			#if 1
			/*XXX: Error check */
			if(!((nchunkoffLastWritten == 0) && (nchunkoffWritingCur == 0))
				&& (nchunkoffLastWritten + 1 != nchunkoffWritingCur))
			{
				MhegIcsDebug("================BEFORE  SEEK \n");
				{
					HUINT32 nNetworkRetryCount = 0;
					while(local_mheg_ics_stream_HTTP_Seek(ulHandle, PRDN_GET_RAW_OFF_FROM_CHUNK_OFF(nchunkoffWritingCur), SEEK_SET) == -1)
					{
						nNetworkRetryCount++;
						MhegIcsError("Seek Failed, Retrying (%u)...\n", nNetworkRetryCount);
						VK_TASK_Sleep(100);
						if(nNetworkRetryCount > DI_IPTUNER_DNP_RETRY_COUNT_ON_NET_ERROR)
						{
							MhegIcsError("Send Failed code To DNP Reader(Player,Indexer)\n");
							pDnpUserData->bDNPNetworkError = TRUE;
							pMhegIpTuner->bHttpStopReceiving = TRUE;
							VK_TASK_Sleep(100);

							goto exit_stop;							

						}
						if ( TRUE == pMhegIpTuner->bHttpStopReceiving)
						{
							MhegIcsDebug("%s(%d) : User Stoped Receiving !!\n",__FUNCTION__,__LINE__);
							goto exit_stop;
						}

						if ( TRUE == pMhegIpTuner->bHttpPauseReceiving)
						{
							//MhegIcsDebug("%s(%d) : User Paused Receiving !!\n",__FUNCTION__,__LINE__);
							VK_TASK_Sleep(100);
							continue;
						}
					}
				}

				MhegIcsDebug("================SEEK  DONE \n");
				MhegIcsDebug("================SEEK  DONE \n");
				MhegIcsDebug("================SEEK  DONE \n");
				MhegIcsDebug("seeked chunk i = %d\n", nchunkoffWritingCur);
			}
			#endif

			/* fill chunk */
			{
				HUINT32 nNetworkRetryCount2 = 0;
				nRecvLength = 0;
				VK_MEM_Memset(pBuffer,0,nReadBufferSize);
				nSumofRecvLength = 0;

				if(ulLoopCount == 0)
				{
					ulStartClock = VK_TIMER_GetSystemTick();					
				}
				ulLoopCount++;

				while(nSumofRecvLength < nReadBufferSize)
				{
					(void) local_mheg_ics_stream_HTTP_Read (ulHandle, pBuffer + nSumofRecvLength, nReadBufferSize - nSumofRecvLength, 1, (size_t *)&nRecvLength);

					if ( TRUE == pMhegIpTuner->bHttpStopReceiving)
					{
						MhegIcsDebug("%s(%d) : User Stoped Receiving !!\n",__FUNCTION__,__LINE__);
						goto exit_stop;
					}

					if(nRecvLength <= 0)
					{
						if(nchunkoffWritingCur == pMhegIpTuner->stPrdnInfo.nchunkoffPrdnEof)
						{
							/* meet end of stream? -> partial chunk */
							if(nSumofRecvLength >= nContentLength - PRDN_GET_RAW_OFF_FROM_CHUNK_OFF(pMhegIpTuner->stPrdnInfo.nchunkoffPrdnEof))
							{
								break; /* go to success case */
							}
						}
						/* retry */
						nNetworkRetryCount2++;
						MhegIcsError("%s(%d) Network Read Error(%d). Retrying Count = %u Reconnect...\n", __FUNCTION__, __LINE__, nRecvLength, nNetworkRetryCount2);
						{
							HUINT32 nNetworkRetryCount3 = 0;
							while(local_mheg_ics_stream_HTTP_Seek(ulHandle, PRDN_GET_RAW_OFF_FROM_CHUNK_OFF(nchunkoffWritingCur) + nSumofRecvLength, SEEK_SET) == -1)
							{
								nNetworkRetryCount3++;
								MhegIcsError("Seek Failed, Retrying (%u)...\n", nNetworkRetryCount3);
								VK_TASK_Sleep(100);
								if(nNetworkRetryCount3 > DI_IPTUNER_DNP_RETRY_COUNT_ON_NET_ERROR)
								{
									MhegIcsError("Send Failed code To DNP Reader(Player,Indexer)\n");
									pDnpUserData->bDNPNetworkError = TRUE;
									pMhegIpTuner->bHttpStopReceiving = TRUE;
									VK_TASK_Sleep(100);

									goto exit_stop;
								}
								if ( TRUE == pMhegIpTuner->bHttpStopReceiving)
								{
									MhegIcsDebug("%s(%d) : User Stoped Receiving !!\n",__FUNCTION__,__LINE__);
									goto exit_stop;
								}

								if ( TRUE == pMhegIpTuner->bHttpPauseReceiving)
								{
									//MhegIcsDebug("%s(%d) : User Paused Receiving !!\n",__FUNCTION__,__LINE__);
									VK_TASK_Sleep(100);
									continue;
								}
							}
						}
						if(nNetworkRetryCount2 > DI_IPTUNER_DNP_RETRY_COUNT_ON_NET_ERROR)
						{
							MhegIcsError("Send Failed code To DNP Reader(Player,Indexer)\n");
							pDnpUserData->bDNPNetworkError = TRUE;
							pMhegIpTuner->bHttpStopReceiving = TRUE;
							VK_TASK_Sleep(100);

							goto exit_stop;
						}

						if ( TRUE == pMhegIpTuner->bHttpStopReceiving)
						{
							MhegIcsDebug("%s(%d) : User Stoped Receiving !!\n",__FUNCTION__,__LINE__);
							goto exit_stop;
						}

						if ( TRUE == pMhegIpTuner->bHttpPauseReceiving)
						{
							//MhegIcsDebug("%s(%d) : User Paused Receiving !!\n",__FUNCTION__,__LINE__);
							VK_TASK_Sleep(100);
							continue;
						}
						MhegIcsError("Retrying to network read...\n");
						continue;
					}
					nSumofRecvLength += nRecvLength;
				}

				
				nRet = local_mheg_ics_iptuner_DnpUpdateDownloadSpeed(ulHandle, ulStartClock, nRecvLength, ulLoopCount);
				if(nRet != DI_ERR_OK)
				{
					;//MhegIcsData("@@@@@ [%s:%d:%d] Updating DownloadSpeed is failed\n", __func__, __LINE__, nRet);
				}
				else
				{
					ulLoopCount = 0;
				}
				
			}

			/* success case */
			(void)lseek(pMhegIpTuner->nWfd, PRDN_GET_RAW_OFF_FROM_CHUNK_OFF(nchunkoffWritingCur), SEEK_SET);
			nRc = write (pMhegIpTuner->nWfd, pBuffer, nSumofRecvLength);
			if(nRc<0)
			{
				MhegIcsError("s(%d) : Error > HDD Write Error Occured !! \n",__FUNCTION__,__LINE__);
				MhegIcsError("Send Failed code To DNP Reader(Player,Indexer)\n");
				pDnpUserData->bDNPNetworkError = TRUE;
				continue;
			}
			else
			{
				;//MhegIcsError("\t $$$ M[%d] Write[%d](fd, offset, size) = (0x%X, %"PRId64", %d)\n"
				//			, ulHandle, nchunkoffWritingCur, pMhegIpTuner->nWfd, PRDN_GET_RAW_OFF_FROM_CHUNK_OFF(nchunkoffWritingCur), nRc);
			}
			//fsync(pMhegIpTuner->nWfd);

			MHEG_ICS_PRDN_SETVALID(pMhegIpTuner->stPrdnInfo.pucChunkDownloadStatusArray, nchunkoffWritingCur);			

			nchunkoffLastWritten = nchunkoffWritingCur;
			pMhegIpTuner->stPrdnInfo.nDownloadedChunkCount ++;

			//MhegIcsData ("%s (%d) : sum(%"PRId64") remained(%"PRId64")\n",__FUNCTION__,__LINE__,off_t_continuous_end, nContentLength-off_t_continuous_end);

			VK_TASK_Sleep(5); /* may yield thread control : Do not change value => ICS021 Scene3 */
		}
		
		if(pDnpUserData->uiContentDuration != 0)
		{
			nRet = local_mheg_ics_iptuner_DnpCalcBufferingInfo(ulHandle, pDnpUserData->uiContentDuration);
			if(nRet != DI_ERR_OK)
			{
				MhegIcsData("@@@@@ [%s:%d] Calcurating BufferingInfo is Failed\n", __func__, __LINE__);
			}
		}
		
		{
			nchunkoffWritingCur++;

			if(pMhegIpTuner->stPrdnInfo.bForwardPlay == FALSE && nchunkoffWritingCur > pMhegIpTuner->stPrdnInfo.nchunkoffLastPrebufferIdx
					&& pMhegIpTuner->stPrdnInfo.nchunkoffLastPrebufferIdx != 0)
			{
				nchunkoffWritingCur = pMhegIpTuner->stPrdnInfo.nchunkoffLastPrebufferIdx - PRDN_GET_CHUNK_OFF(DEFAULT_PRDN_BACKTRICK_PREBUFFERING_SIZE) * 2;
				pMhegIpTuner->stPrdnInfo.nchunkoffLastPrebufferIdx -= PRDN_GET_CHUNK_OFF(DEFAULT_PRDN_BACKTRICK_PREBUFFERING_SIZE);
				if(nchunkoffWritingCur < 0)
				{
					nchunkoffWritingCur = 0;
				}
				if(pMhegIpTuner->stPrdnInfo.nchunkoffLastPrebufferIdx < 0)
				{
					pMhegIpTuner->stPrdnInfo.nchunkoffLastPrebufferIdx = 0;
				}
			}
			if(nchunkoffWritingCur > pMhegIpTuner->stPrdnInfo.nchunkoffPrdnEof)
			{
				MhegIcsDebug("PRDN Meets EOF. writing cur = 0\n");
				if(MHEG_ICS_PRDN_IsCompleted(&pMhegIpTuner->stPrdnInfo))
				{
					break;
				}
				nchunkoffWritingCur = 0;
			}			
		}
	} while ( TRUE );


exit_stop:

	if(pMhegIpTuner->bDiscarded == FALSE)	
	{
		//pMhegIpTuner->stPrdnInfo.pReadyStateCallbackFunc = NULL;

		if ( pMhegIpTuner->bIsEvtSend == FALSE) /* if the probe is not started, start probe */
		{
			pMhegIpTuner->bIsEvtSend = TRUE;
			(void) VK_EVENT_Send (pMhegIpTuner->ulTunerEventID, (unsigned long)0);
		}

		pMhegIpTuner->stPrdnInfo.bDownCompleted = TRUE;
		pMhegIpTuner->bIsEvtSend = FALSE;
	}

	if(pMhegIpTuner->stPrdnInfo.pucChunkDownloadStatusArray != NULL)
	{
		DD_MEM_Free(pMhegIpTuner->stPrdnInfo.pucChunkDownloadStatusArray);
		pMhegIpTuner->stPrdnInfo.pucChunkDownloadStatusArray = NULL;
	}	

	if(pBuffer != NULL)
	{
		DD_MEM_Free(pBuffer);
		pBuffer = NULL;
	}

	close(pMhegIpTuner->nWfd);
	pMhegIpTuner->nWfd = -1;	

	MhegIcsFunctionExit;
	
	return 0;		
}

static HINT32 	local_mheg_ics_stream_HTTP_Seek(HUINT32 ulHandle, off_t offset, int whence)
{
	DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner = s_pstIpTuner[ulHandle];

	if(pMhegIpTuner == NULL)
	{
		MhegIcsError(" s_pstIpTuner[%d] isn't opened.!!! \n", ulHandle);
		return DI_ERR_NO_ALLOC;
	}
	
	MhegIcsFunctionEnter(ulHandle);

	(void)VK_SEM_Get(pMhegIpTuner->ulHttpSemId);
	MhegIcsData("[%s:%d] : Media[%d] offset=%"PRId64", whence=%d\n",__FUNCTION__,__LINE__, ulHandle, (HINT64)offset, whence);
	
	if(whence == SEEK_END)
	{
		offset = pMhegIpTuner->hHttpAccess.info.i_size;
	}

	if(pMhegIpTuner->hHttpAccess.info.i_pos == offset)
	{		
		(void)VK_SEM_Release (pMhegIpTuner->ulHttpSemId);
		MhegIcsFunctionExit;
		return VFIO_ERROR_SUCCESS;
	}

	{
		HINT32 nFailCounter = 0;
		while(DI_IPT_SUCCESS != STREAM_HTTP_Seek ( &pMhegIpTuner->hHttpAccess, (HINT64)offset ))
		{
			nFailCounter++;
			MhegIcsError("s(%d) Error> STREAM_HTTP_Seek fail Retrying...\n",__FUNCTION__,__LINE__);

			if(nFailCounter > 3)
			{
				MhegIcsError("s(%d) Error> STREAM_HTTP_Seek fail count exceed threadsholuld. Return Error...\n",__FUNCTION__,__LINE__);
				(void)VK_SEM_Release (pMhegIpTuner->ulHttpSemId);
				MhegIcsFunctionExit;
				return -1;
			}
		}	
	}

	(void)VK_SEM_Release (pMhegIpTuner->ulHttpSemId);
	MhegIcsFunctionExit;

	return VFIO_ERROR_SUCCESS;
}

static HERROR 	local_mheg_ics_stream_HTTP_Read (HUINT32 ulHandle, void *ptr, size_t size, size_t nmemb, size_t *ptReadSize)
{
	size_t sz_Real=0;
	size_t sz_Try = size*nmemb;

	HINT32 n_ReturnedValue = 0;
	HINT32 	ReadFail_retrycount =0;
	int 	error_Timeoutcount =0;

	int ret = VFIO_ERROR_SUCCESS;
	
	DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner = s_pstIpTuner[ulHandle];

	if(pMhegIpTuner == NULL)
	{
		MhegIcsError(" s_pstIpTuner[%d] isn't opened.!!! \n", ulHandle);
		return DI_ERR_NO_ALLOC;
	}
	
	//MhegIcsFunctionEnter(ulHandle);
	
	n_ReturnedValue = 0;
	ReadFail_retrycount =0;
	error_Timeoutcount =0;
	
	(void)VK_SEM_Get(pMhegIpTuner->ulHttpSemId);

	if(pMhegIpTuner->hHttpAccess.info.i_size < pMhegIpTuner->hHttpAccess.info.i_pos + sz_Try)
	{
		sz_Try = pMhegIpTuner->hHttpAccess.info.i_size - pMhegIpTuner->hHttpAccess.info.i_pos;
	}

	do
	{
		n_ReturnedValue = STREAM_HTTP_Read ( &pMhegIpTuner->hHttpAccess, (HUINT8 *)ptr+sz_Real, sz_Try - sz_Real );

		if(n_ReturnedValue == DI_IPT_ETIMEOUT)
		{
			if(error_Timeoutcount != 2)
			{
				error_Timeoutcount++;
				continue;
			}
			else
			{
				error_Timeoutcount = 0;
			}
		}	

		if(n_ReturnedValue < 0)
		{
			if(sz_Real > 0)
			{				
				*ptReadSize = sz_Real;
			}
			else
			{
				*ptReadSize = 0;
				ret = VFIO_ERROR_FAIL;
			}

			goto error;
		}
		else
		{
			sz_Real += n_ReturnedValue;
		}
		
		if((ReadFail_retrycount == 100)&&(sz_Real == 0))
		{
			MhegIcsError("##### %s(%d) Retry Fail(Read Size = 0)(RetryCount=%d) #####\n\n", __FUNCTION__, __LINE__, ReadFail_retrycount);
			*ptReadSize = sz_Real;
			(void)STREAM_HTTP_Seek (&pMhegIpTuner->hHttpAccess, pMhegIpTuner->hHttpAccess.info.i_pos);
			ReadFail_retrycount = 0;
			goto error;
		}
		
		if((ReadFail_retrycount == 100)&&(sz_Real > 0))
		{
			*ptReadSize = sz_Real;
			MhegIcsError("##### %s(%d) Retry Fail(Read Size != 0)(RetryCount=%d, sz_Real=%d) #####\n\n", __FUNCTION__, __LINE__, ReadFail_retrycount, sz_Real);
			(void)STREAM_HTTP_Seek (&pMhegIpTuner->hHttpAccess, pMhegIpTuner->hHttpAccess.info.i_pos);
			ReadFail_retrycount = 0;				
			goto error; 			
		}

		ReadFail_retrycount++;
	}
	while (sz_Real < sz_Try);

	*ptReadSize = sz_Real;

error:

	//MhegIcsDebug("\t @@ %s(%d) : Media[%d] tryRead(%d) realRead(%d)\n",__FUNCTION__,__LINE__, ulHandle, sz_Try, sz_Real);
	(void)VK_SEM_Release (pMhegIpTuner->ulHttpSemId);
	
	//MhegIcsFunctionExit;

	return ret;
}


static void local_mheg_ics_stream_HTTP_DnpStartReceiving(DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner)
{
	MhegIcsFunctionEnter((HUINT32) pMhegIpTuner);
	pMhegIpTuner->bHttpStopReceiving = FALSE;
	pMhegIpTuner->bHttpPauseReceiving = FALSE;
	MhegIcsFunctionExit;
}

static void local_mheg_ics_stream_HTTP_DnpStopReceiving(DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner)
{
	MhegIcsFunctionEnter((HUINT32) pMhegIpTuner);
	pMhegIpTuner->bHttpStopReceiving = TRUE;
	MhegIcsFunctionExit;
}

static void local_mheg_ics_stream_HTTP_DnpPauseReceiving(DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner)
{
	MhegIcsFunctionEnter((HUINT32) pMhegIpTuner);
	pMhegIpTuner->bHttpPauseReceiving = TRUE;
	MhegIcsFunctionExit;
}

static void local_mheg_ics_stream_HTTP_DnpResumeReceiving(DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner)
{
	MhegIcsFunctionEnter((HUINT32) pMhegIpTuner);	
	pMhegIpTuner->bHttpPauseReceiving = FALSE;
	MhegIcsFunctionExit;
}



static DI_ERR_CODE local_mheg_ics_iptuner_DnpOpen(HUINT32	ulHandle, HINT8 *url, DI_MEDIA_INFO_t *pstMediaInfo)
{
	HINT32  	nVKRet;	
	HINT32  	i, nUrlLen;
	HINT8 		*dnpUrl=NULL;
	DI_ERR_CODE  nRet = DI_ERR_ERROR;

	
	DI_IPTUNER_Msg_t s_Msg;
	VFIO_Callback_t stCBFunction;

	HULONG	ulevent;
	
	MhegIcsFunctionEnter(ulHandle);
 
	if(url == NULL)
	{
		MhegIcsError("s(%d) :  url is NULL !\n",__FUNCTION__,__LINE__);
		return DI_ERR_ERROR;
	}

	if(pstMediaInfo == NULL)
	{
		MhegIcsError("s(%d) : pstMediaInfo is NULL !\n",__FUNCTION__,__LINE__);
		return DI_ERR_ERROR;
	}

	s_pstIpTuner[ulHandle]->bIsPlaybackStop = FALSE;

	//DI_IPTUNER_DnpStop
	local_mheg_ics_iptuner_DnpInitTread(ulHandle);

	if(s_ulRungDnpNumber == 0)
	{
		/*  VFIO에 callback 함수 등록 */
		(void)VK_MEM_Memset(&stCBFunction, 0x0, sizeof(VFIO_Callback_t));

		stCBFunction.Open 			=(VFIOOpenCB)  vfio_cb_mheg_ics_iptuner_DnpOpen;
		stCBFunction.Close			=(VFIOCloseCB) vfio_cb_mheg_ics_iptuner_DnpClose;
		stCBFunction.Read			=(VFIOReadCB)  vfio_cb_mheg_ics_iptuner_DnpRead;
		stCBFunction.Seek			=(VFIOSeekCB)  vfio_cb_mheg_ics_iptuner_DnpSeek;
		stCBFunction.Tell			=(VFIOTellCB)  vfio_cb_mheg_ics_iptuner_DnpTell;
		stCBFunction.IsEOF			=(VFIOIsEOFCB) vfio_cb_mheg_ics_iptuner_DnpIsEOF;
		stCBFunction.OpenNexus		=(VFIOOpenFromNexusCB) vfio_cb_mheg_ics_iptuner_DnpOpenFromNexus;
		stCBFunction.SeekNexus		=(VFIOSeekForNexusCB) vfio_cb_mheg_ics_iptuner_DnpSeekForNexus;
		stCBFunction.BoundsNexus	=(VFIOBoundsForNexusCB) vfio_cb_mheg_ics_iptuner_DnpBoundsForNexus;
		(void) VFIO_RegisterCallback (VFIO_CALLBACK_TYPE_DNP, stCBFunction);
	}
	s_ulRungDnpNumber++;

	(void) VK_MEM_Memset(&s_Msg, 0x0, sizeof(s_Msg));

	if(local_mheg_ics_stream_HTTP_Open(ulHandle, url, 0) == ERR_OK)
	{
		s_Msg.unMsg = TUNER_DNP_MSG_HTTP_PROBE;
	}
	else
	{
		MhegIcsError("%s (%d) Error>  local_mheg_ics_stream_HTTP_Open Fail\n",__FUNCTION__,__LINE__);
		nRet = DI_ERR_ERROR;
		return nRet;
	}
	
	for(i = 0; i < DNP_DOWNLOAD_SPEED_COUNT; i++)
	{
		s_pstIpTuner[ulHandle]->stPrdnInfo.nArrayDownloadSpeed[i] = -1;
	}
	s_pstIpTuner[ulHandle]->stPrdnInfo.nDownloadSpeedIndex = 0;

	/* pDnpUserData 할당(DnpClose에서 Free) 및 초기화 */
	{
		MHEG_DNP_USER_DATA_t * pDnpUserData = DD_MEM_Alloc(sizeof(MHEG_DNP_USER_DATA_t));
		VK_memset((void*)pDnpUserData, 0, sizeof(MHEG_DNP_USER_DATA_t));
		pDnpUserData->ulHandle = ulHandle;
		pDnpUserData->stData.nPurpose = 1; // TODO REPLACE WITH ENUM
		/*
		pDnpUserData->stData.bDNPNetworkError = FALSE;
		pDnpUserData->stData.unOpenFromNexusHandle = 0;
		pDnpUserData->stData.uiMediaMaxBitrateInChunkPerSec = 0;  // 0 if unknown 
		pDnpUserData->stData.bProbeDone = FALSE;		
		pDnpUserData->stData.uiContentDuration = 0;
		*/
		s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData = (void*)pDnpUserData; // HTTP OPEN과 DNP OPEN은 GneralPtr을 공유 ; owner = DNP		
		s_pstIpTuner[ulHandle]->stPrdnInfo.nBufferingTime = 0;
		s_pstIpTuner[ulHandle]->stPrdnInfo.bPrebufferingRequested = FALSE;
	}

	local_mheg_ics_iptuner_DnpStart(s_pstIpTuner[ulHandle]);
	
	/* IPTUNER_DnpTask에서 stHandle를 HTTP dnp receive task로 넘겨줌*/
	/* 이를 통해 dnp thread(reader)와 http thread(writer)가 pDnpUserData를 공유*/
	(void) VK_MSG_Send ( s_pstIpTuner[ulHandle]->ulDNPMsgQId, (HUINT32 *)&s_Msg, sizeof(DI_IPTUNER_Msg_t) ) ;

	nVKRet = VK_EVENT_ReceiveTimeout (s_pstIpTuner[ulHandle]->ulTunerEventID, &ulevent, MHEG_ICS_IPTUNER_DNP_WAITEVTTIME);
	if (nVKRet != ERR_OK)
	{
		MhegIcsError("%s (%d) Error> VK_EVENT_ReceiveTimeout (%x) !\n",__FUNCTION__,__LINE__, (int)nVKRet);
		nRet = DI_ERR_ERROR;
	}
	else
	{
		/*XXX: For TEST DI_MEDIA_Probe를 위해서는 URL앞에 [dnp]를 붙여 줘야 한다.*/
		nUrlLen = VK_strlen((char*)url)+6;
		dnpUrl = (HINT8*) DD_MEM_Alloc (nUrlLen);
		if(dnpUrl==NULL)
		{
			nRet = DI_ERR_ERROR; 
			MhegIcsError("s(%d) Error> Heap Memory Allocation Fail. size (%d) !!\n",__FUNCTION__,__LINE__,MAX_FILE_NAME_SIZE);
		}
		else
		{
			VK_MEM_Memset(dnpUrl, 0, nUrlLen);

			nVKRet = snprintf((char*)dnpUrl, nUrlLen, "[dnp]%s", url);
			if(nVKRet < 0)
			{
				MhegIcsError("%s(%d) Error> can't make url for dnp\n",__FUNCTION__,__LINE__);
				nRet = ERR_FAIL; 
			}		
			else
			{
				/* Probe Media */
				nRet = DI_MHEG_ICS_Probe(ulHandle, (HUINT8*)dnpUrl, pstMediaInfo);

				/* ICS009 Scene3, Scene5 
				    Bitrate calcuration 실패 시에 2Mbps로 설정하고 duration 구함. 
				*/
				if( (pstMediaInfo->max_bitrate > MHEG_ICS_MAX_BITRATE) || (pstMediaInfo->max_bitrate == 0) )
				{
					MhegIcsError("%s(%d)\t Error >>> Invalid BITRATE(%d)\n",__FUNCTION__,__LINE__, pstMediaInfo->max_bitrate);
					pstMediaInfo->max_bitrate = MHEG_ICS_DEFAULT_BITRATE;
					pstMediaInfo->duration = (HINT64)((HUINT64)(s_pstIpTuner[ulHandle]->nFileLength * 1000) / (MHEG_ICS_DEFAULT_BITRATE >> 3));
				}
				
				((MHEG_DNP_USER_DATA_t *)s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData)->stData.nPurpose = 0;
			}
			
			if (nRet != ERR_OK)
			{
				MhegIcsError("%s (%d) Error> DI_MHEG_ICS_Probe : %d\n",__FUNCTION__,__LINE__, nRet);
			}
			else
			{
#ifdef DI_IPTUNER_DNP_DEBUG
				(void) DI_MEDIA_PrintProbeInfo (pstMediaInfo);
#endif

#ifdef ENABLE_MAPPED_DNP
				nRet = (DI_ERR_CODE)DI_MHEG_ICS_IPTUNER_UnderflowMonitorInitThread(ulHandle, pstMediaInfo, s_pstIpTuner[ulHandle]->nFileLength);
				if(nRet != DI_ERR_OK)
				{
					MhegIcsError("@@@@@ [%s:%d:%d] MHEG_IPTUNER UnderflowMonitoring Thread can't create\n", __func__, __LINE__, nRet);
				}
#endif


				if(pstMediaInfo->max_bitrate == 0) /* unknown */
				{
					((MHEG_DNP_USER_DATA_t *)s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData)->stData.uiMediaMaxBitrateInChunkPerSec = 3327106 / 8 / (HUINT32)PRDN_GET_RAW_OFF_FROM_CHUNK_OFF(1); /* default bitrate */
				}
				else
				{
					((MHEG_DNP_USER_DATA_t *)s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData)->stData.uiMediaMaxBitrateInChunkPerSec = pstMediaInfo->max_bitrate / 8 / (HUINT32)PRDN_GET_RAW_OFF_FROM_CHUNK_OFF(1) + 1; /* round up */
				}
				((MHEG_DNP_USER_DATA_t *)s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData)->stData.uiContentDuration = pstMediaInfo->duration;
				((MHEG_DNP_USER_DATA_t *)s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData)->stData.bProbeDone = TRUE;
				if(((MHEG_DNP_USER_DATA_t *)s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData)->stData.bDNPNetworkError == TRUE)
				{
					MhegIcsError("%s (%d) Error> DI_MEDIA_Probe Network Error: %d\n",__FUNCTION__,__LINE__, nRet);
					nRet = ERR_FAIL;
				}
			}

			if(dnpUrl != NULL)
			{
				(void) DD_MEM_Free (dnpUrl);
				dnpUrl = NULL;
			}
		}
	}


	if(nRet != ERR_OK)
	{
		DI_MHEG_ICS_IPTUNER_UnderflowMonitorTerminateThread(ulHandle);
		(void)local_mheg_ics_iptuner_DnpStop(s_pstIpTuner[ulHandle]);		
		(void)VFIO_UnregisterCallback (VFIO_CALLBACK_TYPE_DNP);
		
	}
	MhegIcsFunctionExit;

	return nRet;
}

static DI_ERR_CODE 	local_mheg_ics_iptuner_DnpClose(HUINT32	ulHandle)
{
	DI_ERR_CODE	nRet = DI_ERR_OK;
	
	MhegIcsFunctionEnter(ulHandle);

	if(s_pstIpTuner[ulHandle]->bIsInitialized == FALSE)
	{
		return ERR_FAIL;
	}

	local_mheg_ics_iptuner_DnpStop(s_pstIpTuner[ulHandle]);
	s_pstIpTuner[ulHandle]->bDNPTaskQuit = TRUE;

#ifdef ENABLE_MAPPED_DNP
	//DI_MHEG_ICS_IPTUNER_UnderflowMonitorTerminateThread(ulHandle);
#endif

	/* instead task join, spin wait */
	while(s_pstIpTuner[ulHandle]->bDNPTaskFinished == FALSE)
	{
		VK_TASK_Sleep(100);
	}

	/* VK_TASK_Join may induce bus error. let destroy handle pthread join */
	VK_TASK_Destroy(s_pstIpTuner[ulHandle]->ulDNPTaskId);
	
	//UTIL_UrlClean (&stURL);

	s_ulRungDnpNumber--;
	if(s_ulRungDnpNumber ==0)
	{
		(void)VFIO_UnregisterCallback (VFIO_CALLBACK_TYPE_DNP);
	}
	
	(void) VK_SEM_Destroy (s_pstIpTuner[ulHandle]->ulDNPReadSema);


	VK_EVENT_Destroy(s_pstIpTuner[ulHandle]->ulTunerEventID);

	
	(void) VK_SEM_Destroy (s_pstIpTuner[ulHandle]->ulDNPSema);
	VK_MSG_Destroy(s_pstIpTuner[ulHandle]->ulDNPMsgQId);

 	if( local_mheg_ics_stream_HTTP_Close(ulHandle) != VFIO_ERROR_SUCCESS )
	{
		MhegIcsError("%s (%d) Error>  local_mheg_ics_stream_HTTP_Close Fail\n",__FUNCTION__,__LINE__);
		nRet = DI_ERR_ERROR;
	}	

	s_pstIpTuner[ulHandle]->bIsInitialized = FALSE;
	
	if(s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData != NULL)
	{
		DD_MEM_Free(s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData);
		s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData = NULL;
	}

#ifdef ENABLE_MAPPED_DNP
	if(s_pstIpTuner[ulHandle]->stPrdnInfo.pucChunkDownloadStatusArray != NULL)
	{
		MhegIcsDebug("@@@@@ [%s:%d] s_pstIpTuner[ulHandle]->stPrdnInfo.pucChunkDownloadStatusArray is Free\n", __func__, __LINE__);
		DD_MEM_Free(s_pstIpTuner[ulHandle]->stPrdnInfo.pucChunkDownloadStatusArray);
		s_pstIpTuner[ulHandle]->stPrdnInfo.pucChunkDownloadStatusArray = NULL;
	}
#endif

	MhegIcsFunctionExit;

	return nRet;
}

static void 	local_mheg_ics_iptuner_DnpStart(DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner)
{
	MhegIcsFunctionEnter((HUINT32) pMhegIpTuner);
	local_mheg_ics_stream_HTTP_DnpStartReceiving(pMhegIpTuner);
	MhegIcsFunctionExit;
}

static void 	local_mheg_ics_iptuner_DnpStop(DI_MHEG_ICS_IPTUNER_t	*pMhegIpTuner)
{
	MhegIcsFunctionEnter((HUINT32) pMhegIpTuner);
	local_mheg_ics_stream_HTTP_DnpStopReceiving(pMhegIpTuner);
	MhegIcsFunctionExit;
}


static DI_ERR_CODE local_mheg_ics_iptuner_DnpSetReadyStateCallback(HUINT32 ulHandle, fn_readystate_callback pFn)
{
	DI_ERR_CODE nRet=DI_ERR_OK;

	s_pstIpTuner[ulHandle]->stPrdnInfo.pReadyStateCallbackFunc = (fn_readystate_callback)pFn;
	s_pstIpTuner[ulHandle]->stPrdnInfo.nCBulDeviceId = ulHandle;
	s_pstIpTuner[ulHandle]->stPrdnInfo.nLastReadyStateSentTime = VK_TIMER_GetSystemTick() ; /* initial ready state callback must be sent 1 sec later */

	return nRet;
}

static DI_ERR_CODE local_mheg_ics_iptuner_DnpGetInfo (HUINT32 ulHandle, DI_IPTUNER_Info_t *pInfo)
{
	DI_ERR_CODE nRet=DI_ERR_OK;

	if(s_pstIpTuner[ulHandle] == NULL)	
	{
		MhegIcsError(" s_pstIpTuner[%d] isn't opened.!!! \n", ulHandle);
		return DI_ERR_NO_ALLOC;
	}
	
	MhegIcsFunctionEnter(ulHandle);

	pInfo->nDownloadLength = s_pstIpTuner[ulHandle]->nFileLength;

	pInfo->nContentLength = s_pstIpTuner[ulHandle]->nFileLength;
	/* MAXDOME INFO */
	pInfo->nBufferingPercent = s_pstIpTuner[ulHandle]->stPrdnInfo.nBufferingPercent;

	pInfo->nRemainBufferingSec = s_pstIpTuner[ulHandle]->stPrdnInfo.nBufferingLeftTime; /* MAXDOME want content sec to be buffered */
	pInfo->pDownloadedChunkArray = s_pstIpTuner[ulHandle]->stPrdnInfo.pucChunkDownloadStatusArray;
	pInfo->nLastChunkIndex = s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffPrdnEof;

	MhegIcsFunctionExit;

	return nRet;
}

static DI_ERR_CODE 	local_mheg_ics_iptuner_DnpControl (HUINT32 ulHandle, DI_IPTUNER_CMD_e cmd, HUINT64 val)
{
	DI_ERR_CODE nRet=DI_ERR_OK;

	if(s_pstIpTuner[ulHandle] == NULL)	
	{
		MhegIcsError(" s_pstIpTuner[%d] isn't opened.!!! \n", ulHandle);
		return DI_ERR_NO_ALLOC;
	}
	
	MhegIcsFunctionEnter(ulHandle);

	switch (cmd)
	{
		case CMD_CONTROL_SPEED :
			MhegIcsDebug("%s (%d) CMD_CONTROL_SPEED (val=%d)\n",__FUNCTION__,__LINE__,(HINT32 )val);

			if(DI_MEDIA_TRICK_1RWSTEP <= val && val <= DI_MEDIA_TRICK_16RWSTEP) /* rewind */
			{
				s_pstIpTuner[ulHandle]->stPrdnInfo.bForwardPlay = FALSE;
			}
			if(DI_MEDIA_TRICK_1FFSTEP <= val && val <= DI_MEDIA_TRICK_16FFSTEP) /* forward play */
			{
				s_pstIpTuner[ulHandle]->stPrdnInfo.bForwardPlay = TRUE;
			}
#if 1	/* JWKIM, workaround: for Maxdome Service */
			if (val >= DI_MEDIA_TRICK_2FFSTEP && val <= DI_MEDIA_TRICK_16FFSTEP)
			{
				s_pstIpTuner[ulHandle]->stPrdnInfo.bPlayFFTrick = TRUE;
			}
			else
			{
				s_pstIpTuner[ulHandle]->stPrdnInfo.bPlayFFTrick = FALSE;
			}
			break;
#endif
#if 1 /* Added becuase of warning: enumeration value 'xxxx' not handled in switch */
		case CMD_CONTROL_PAUSE  :
		case CMD_CONTROL_RESUME :
		case CMD_CONTROL_SEEK   :
		default :
			MhegIcsError("%s(%d) Error>  -  Unsupported\n",__FUNCTION__,__LINE__);
			break;
#endif
	}

	MhegIcsFunctionExit;

	return nRet;
}

static DI_ERR_CODE local_mheg_ics_iptuner_DnpUpdateDownloadSpeed(HUINT32 ulHandle, HULONG ulStartClock, HINT32 nDownloadBytes, HUINT32 ulLoopCount)
{
	DI_ERR_CODE nRet = DI_ERR_OK;
	HULONG ulElapsedMilliSec = 0;
	HINT64 llDownloadSpeed = 0;
	static	HINT64	llAveDownloadSpeed = 0;

	//MhegIcsFunctionEnter(ulHandle);
	
	ulElapsedMilliSec = VK_TIMER_GetSystemTick();
	ulElapsedMilliSec -= ulStartClock;

	if(ulElapsedMilliSec < DNP_DOWNLOAD_SPEED_CHECK_TIME_LIMIT)
	{
		//MhegIcsError("@@@@@ [%s:%d] ulElapsedMilliSec = %ld, can't divide\n", __func__, __LINE__, ulElapsedMilliSec);
		nRet = DI_ERR_INVALID_PARAM;
		goto exit;
	}

	//MhegIcsDebug("@@@@@ [%s:%d] ulLoopCount = %d, nDownloadBytes = %d, ulElapsedMilliSec = %ld\n", __func__, __LINE__, ulLoopCount, nDownloadBytes * ulLoopCount, ulElapsedMilliSec);

	llDownloadSpeed = ((HINT64)nDownloadBytes * ulLoopCount * 1000) / ulElapsedMilliSec;

	//MhegIcsDebug("@@@@@ [%s:%d] llDownloadSpeed = %lu\n", __func__, __LINE__, llDownloadSpeed);

	llAveDownloadSpeed = (llAveDownloadSpeed*6)/10 + (llDownloadSpeed*4)/10;

	//MhegIcsDebug("@@@@@ [%s:%d] llAveDownloadSpeed = %lu\n", __func__, __LINE__, llAveDownloadSpeed);

	s_pstIpTuner[ulHandle]->stPrdnInfo.nDownloadBytesPerSecond = llAveDownloadSpeed;

	if(s_pstIpTuner[ulHandle]->stPrdnInfo.pReadyStateCallbackFunc)
	{
		//MhegIcsDebug("@@@@@ [%s:%d] # Updating Buffering Point.. #\n", __func__, __LINE__);
		s_pstIpTuner[ulHandle]->stPrdnInfo.pReadyStateCallbackFunc(ulHandle, DI_MEDIA_EVENT_BUFFER_READY_STATE, DI_IPTUNER_DNP_READYSTATE_BUFFERING_POINT_UPDATE);
	}
exit:

	//MhegIcsFunctionExit;
	return nRet;
}


static DI_ERR_CODE local_mheg_ics_iptuner_DnpCalcBufferingInfo(HUINT32 ulHandle, HUINT32 unDuration)
{
	DI_ERR_CODE nRet = DI_ERR_OK;

	//MhegIcsFunctionEnter(ulHandle);
	
#ifdef ENABLE_MAPPED_DNP
	HUINT64 ullReferenceData = 0, ullBufferedData = 0, ullLeftDownloadData = 0;
	HUINT32 unVideoBufferDepth = 0, unAudioBufferDepth = 0;
	HINT32	nDownloadBytesPerSecond = 0;
	HBOOL	bIsFullChunk = FALSE;
	
	if(unDuration == 0)
	{
		MhegIcsError("@@@@@ [%s:%d] unDuration is %d\n", __func__, __LINE__, unDuration);
		nRet = DI_ERR_ERROR;
		goto exit;
	}

	if(s_pstIpTuner[ulHandle]->nFileLength == 0)
	{
		MhegIcsError("@@@@@ [%s:%d] s_nFileLength is %d\n", __func__, __LINE__, s_pstIpTuner[ulHandle]->nFileLength);
		nRet = DI_ERR_ERROR;
		goto exit;
	}

	ullReferenceData = (DNP_START_THRESHOLD + 1000) * (s_pstIpTuner[ulHandle]->nFileLength / unDuration);
	if(ullReferenceData == 0)
	{
		MhegIcsError("@@@@@ [%s:%d] ullReferenceData is equals to %llu\n", __func__, __LINE__, ullReferenceData);
		nRet = DI_ERR_ERROR;
		goto exit;
	}
	else
	{
		nRet = DI_MEDIA_GetVideoBufferDepth(&unVideoBufferDepth);
		if(nRet != DI_ERR_OK)
		{
			MhegIcsError("@@@@@ [%s:%d:%d] Getting VideoBufferDepth is Error\n", __func__, __LINE__, nRet);
			goto exit;
		}
		ullBufferedData += unVideoBufferDepth;

		nRet = DI_MEDIA_GetAudioBufferDepth(&unAudioBufferDepth);
		if(nRet != DI_ERR_OK)
		{
			MhegIcsError("@@@@@ [%s:%d:%d] Getting AudioBufferDepth is Error\n", __func__, __LINE__, nRet);
			goto exit;		
		}
		ullBufferedData += unAudioBufferDepth;

		bIsFullChunk = TRUE;
		nRet = local_mheg_ics_iptuner_DnpGetBufferedDataSize(ulHandle, &ullBufferedData, &bIsFullChunk, s_pstIpTuner[ulHandle]->nFileLength);
		if(nRet != DI_ERR_OK)
		{
			MhegIcsError("@@@@@ [%s:%d:%d] Getting BufferedData is Error\n", __func__, __LINE__, nRet);
			goto exit;
		}

		if(ullReferenceData < ullBufferedData)
		{
			ullLeftDownloadData = 0;
			ullBufferedData = ullReferenceData;
		}
		else
		{
			ullLeftDownloadData = ullReferenceData - ullBufferedData;
		}

		s_pstIpTuner[ulHandle]->stPrdnInfo.nBufferingPercent = ullBufferedData * 100000 / ullReferenceData;
		//MhegIcsDebug("@@@@@ [%s:%d] g_nPrdnInfoBufferingPercent = %d\n", __func__, __LINE__, s_pstIpTuner[ulHandle]->stPrdnInfo.nBufferingPercent);

		if(s_pstIpTuner[ulHandle]->stPrdnInfo.nBufferingPercent > MAX_PRDN_BUFFERING_PERCENT)
		{
			s_pstIpTuner[ulHandle]->stPrdnInfo.nBufferingLeftTime = 0;
		}
		else
		{
			nDownloadBytesPerSecond = s_pstIpTuner[ulHandle]->stPrdnInfo.nDownloadBytesPerSecond;
			if(nDownloadBytesPerSecond > 0)
			{
				s_pstIpTuner[ulHandle]->stPrdnInfo.nBufferingLeftTime = ullLeftDownloadData * 1000 / nDownloadBytesPerSecond;
				//MhegIcsDebug("@@@@@ [%s:%d] g_nPrdnInfoBufferingLeftTime = %d\n", __func__, __LINE__, s_pstIpTuner[ulHandle]->stPrdnInfo.nBufferingLeftTime);		
			}
			else
			{
				//MhegIcsDebug("@@@@@ [%s:%d] nDownloadBytesPerSecond is equal to 0\n", __func__, __LINE__);
			}
		}
	}

#else
	MhegIcsError("@@@@@ [%s:%d] Calcurating Buffering Information is NOT SUPPORT.(undefined ENABLE_MAPPED_DNP)\n", __func__, __LINE__);
	nRet = DI_ERR_ERROR;
#endif

exit:

	//MhegIcsFunctionExit;
	return nRet;
}

#if 0
static DI_ERR_CODE local_mheg_ics_iptuner_DnpGetDownloadedBytes(HUINT32 ulHandle, HUINT64 *pullDownloadedBytes)
{
	DI_ERR_CODE nRet = DI_ERR_OK;
	HINT32 nDownloadArraySize = 0, i = 0, nEndIndex = 0;
	HUINT32 ulDownloadedChunks = 0;
	HINT64 llFileLength = 0;

	MhegIcsFunctionEnter(ulHandle);

	if(pullDownloadedBytes == NULL)
	{
		MhegIcsError("@@@@@ [%s:%d] pullDownloadedBytes is NULL\n", __func__, __LINE__);
		nRet = DI_ERR_ERROR;
		goto exit;
	}

	if(s_pstIpTuner[ulHandle]->nFileLength == 0)
	{
		MhegIcsError("@@@@@ [%s:%d] s_nFileLength is 0\n", __func__, __LINE__);
		nRet = DI_ERR_ERROR;
		goto exit;
	}
	else
	{
		llFileLength = s_pstIpTuner[ulHandle]->nFileLength;
	}

	if(s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffPrdnEof == 0)
	{
		MhegIcsError("[%s:%d] g_nchunkoffPrdnEof == %llu\n", __func__, __LINE__, s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffPrdnEof);
		nRet = DI_ERR_ERROR;
		goto exit;
	}
	else
	{
		nDownloadArraySize = PRDN_GET_BYTE_OFF(s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffPrdnEof) + 1;
	}

	if(s_pstIpTuner[ulHandle]->stPrdnInfo.pucChunkDownloadStatusArray == NULL)
	{
		MhegIcsError("[%s:%d] pucChunkDownloadStatusArray is NULL\n", __func__, __LINE__);
		nRet = DI_ERR_ERROR;
		goto exit;
	}

	nEndIndex = (HINT32)((llFileLength - 1) >> PRDN_CHUNK_EXPONENT);

	for(i = 0; i <= nEndIndex; i++)
	{
		if(*((HUINT8 *)s_pstIpTuner[ulHandle]->stPrdnInfo.pucChunkDownloadStatusArray + (i >> 3)) & (1 << (i & 0x07)))
		{
			ulDownloadedChunks++;
		}
	}

	*pullDownloadedBytes = (HUINT64)ulDownloadedChunks << PRDN_CHUNK_EXPONENT;

exit:

	MhegIcsFunctionExit;
	return nRet;
}
#endif

static DI_ERR_CODE local_mheg_ics_iptuner_DnpGetBufferedDataSize(HUINT32 ulHandle, HUINT64 *pullBufferedData, HBOOL *bIsFullChunk, HINT64 llFileLength)
{
	DI_ERR_CODE nRet = DI_ERR_OK;
	HINT32 i = 0, nFirstIndex = 0, nEndIndex = 0, nDownloadArraySize = 0, nLastDataChunk = 0;
	HUINT64 ullCurrentDataReadOffset = 0;

	//MhegIcsFunctionEnter(ulHandle);
	
	if(pullBufferedData == NULL)
	{
		MhegIcsError("@@@@@ [%s:%d] pullBufferedData is NULL\n", __func__, __LINE__);
		nRet = DI_ERR_ERROR;
		goto exit;
	}

	if(bIsFullChunk == NULL)
	{
		MhegIcsError("@@@@@ [%s:%d] bIsFullChunk is NULL\n", __func__, __LINE__);
		nRet = DI_ERR_ERROR;
		goto exit;
	}

	nDownloadArraySize = PRDN_GET_BYTE_OFF(s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffPrdnEof) + 1;

	ullCurrentDataReadOffset = s_pstIpTuner[ulHandle]->stPrdnInfo.ullDataReadOffset;

	nFirstIndex = (HINT32)(ullCurrentDataReadOffset >> PRDN_CHUNK_EXPONENT);
	nEndIndex = (HINT32)((llFileLength - 1) >> PRDN_CHUNK_EXPONENT);

	for(i = nFirstIndex; i <= nEndIndex; i++)
	{
		if(!(*((HUINT8 *)s_pstIpTuner[ulHandle]->stPrdnInfo.pucChunkDownloadStatusArray + (i >> 3)) & (1 << (i & 0x07))))
		{
			*bIsFullChunk = FALSE;
			break;
		}
	}

	if(i > nEndIndex)
	{
		*pullBufferedData += (llFileLength - ullCurrentDataReadOffset);
	}
	else
	{
		nLastDataChunk = i - 1;
		if(nLastDataChunk < nFirstIndex)
		{
			*pullBufferedData += 0;
		}
		else
		{
			*pullBufferedData += ((nLastDataChunk - nFirstIndex) << PRDN_CHUNK_EXPONENT);
		}
	}

exit:
	//MhegIcsFunctionExit;
	return nRet;
}


static void IPTUNER_MHEG_ICS_DnpTask (void *pParam)
{
	DI_IPTUNER_Msg_t s_Msg;
	HINT32 nVKRet;

	HUINT32				ulHandle = (HUINT32)pParam;	

	MhegIcsFunctionEnter(ulHandle);

	if (s_pstIpTuner[ulHandle] == NULL)
	{
		MhegIcsError("%s (%d) : IPTUNER_MHEG_ICS_DnpTask unavailable (handle is invalid)!!!\n",__FUNCTION__,__LINE__);
		return;
	}

	s_pstIpTuner[ulHandle]->bDNPTaskFinished = FALSE;

	while ( s_pstIpTuner[ulHandle]->bDNPTaskQuit != TRUE )
	{
		nVKRet = VK_MSG_ReceiveTimeout (s_pstIpTuner[ulHandle]->ulDNPMsgQId, &s_Msg, sizeof(DI_IPTUNER_Msg_t), MHEG_ICS_IPTUNER_DNP_MSGQ_TIMEOUT);
		if ( nVKRet != VK_OK )
		{
			continue;
		}
		/* else { continue } */
		
		MhegIcsDebug("%s(%d) =================== RECEIVE START  ======================\n",__FUNCTION__,__LINE__);		

		if ( s_Msg.unMsg == TUNER_DNP_MSG_HTTP_PROBE )
		{
			/* for test */
			/* TODO :: */
			(void) VK_SEM_Get(s_pstIpTuner[ulHandle]->ulDNPSema);
			/* Data Read & Write */
			(void) local_mheg_ics_stream_HTTP_Receive (ulHandle);
			(void) VK_SEM_Release (s_pstIpTuner[ulHandle]->ulDNPSema );
		}
		/* else { continue } */
	}

	/*s_ucQuit = TRUE;*/
	s_pstIpTuner[ulHandle]->bDNPTaskFinished = TRUE;

	MhegIcsFunctionExit;
	return;
}



/*******************************************************************/
/********************   Global  Functions       *************************/
/*******************************************************************/

#define _____PUBLIC_APIs________________________________________________________________


DI_IPTUNER_Index_e DI_MHEG_ICS_IPTUNER_Open(HUINT32	ulHandle, HINT8 *url, DI_IPTUNER_DownloadType_e nDownloadType, DI_MEDIA_INFO_t *pstMediaInfo)
{
	DI_ERR_CODE 		nRet = DI_ERR_ERROR;
	DI_IPTUNER_Index_e 	nTunerIndex=DI_IPTUNER_MAX_NUM;

	MhegIcsFunctionEnter(ulHandle);

	if( (nDownloadType != DI_IPTUNER_PLAYABLE_DOWNLOAD)		
		&&  (nDownloadType != DI_IPTUNER_STREAMING) )
	{
		MhegIcsError("%s(%d) : Not supported Download Type %d.\n",__FUNCTION__,__LINE__, nDownloadType);
		return DI_IPTUNER_MAX_NUM;
	}

	if(url == NULL)
	{
		MhegIcsError("%s(%d) : Invalid URL Parameter.\n",__FUNCTION__,__LINE__);
		return DI_IPTUNER_MAX_NUM;
	}

	/* Release previouse IP_TUNER */
	if(s_pstIpTuner[ulHandle] != NULL)
	{
		MhegIcsError("\t %s(%d) ### s_pstIpTuner[%d] wasn't released, yet..!!! \n\n",__FUNCTION__, __LINE__, ulHandle);
		nRet = DI_MHEG_ICS_IPTUNER_Close(ulHandle);
		if(nRet != DI_ERR_OK)
		{
			return DI_IPTUNER_MAX_NUM;
		}
	}

	nTunerIndex = local_mheg_ics_iptuner_GetTunerIndex(nDownloadType, url);
	if ( DI_IPTUNER_MAX_NUM == nTunerIndex )
	{
		MhegIcsError("%s(%d) : Error> MAX Tuner number is %d.\n",__FUNCTION__,__LINE__,DI_IPTUNER_MAX_NUM);
		return DI_IPTUNER_MAX_NUM;
	}

	if ((pstMediaInfo != NULL) && (pstMediaInfo->isHttpChunked == TRUE))
	{
		/* Chante tunerIndex if HTTP chunked live streaming */
		nTunerIndex = DI_IPTUNER_STREAM_HTTP_CHNK;
		MhegIcsError("%s(%d) : Changed Tuner type:%d.\n",__FUNCTION__,__LINE__,nTunerIndex);
	}	

	MhegIcsDebug("%s(%d) Open Url %s\n",__FUNCTION__,__LINE__, url);
	MhegIcsDebug("%s(%d) nDownloadType :0x%X\n",__FUNCTION__,__LINE__, nDownloadType);

	s_pstIpTuner[ulHandle] = DD_MEM_Alloc(sizeof(DI_MHEG_ICS_IPTUNER_t));
	VK_MEM_Memset(s_pstIpTuner[ulHandle], 0, sizeof(DI_MHEG_ICS_IPTUNER_t));

	switch(nTunerIndex)
	{
		case DI_IPTUNER_DNP_HTTP:
			s_pstIpTuner[ulHandle]->pSaveFileName = DD_MEM_Alloc(128);
			snprintf(s_pstIpTuner[ulHandle]->pSaveFileName, 128, "%s%02d", PAL_MHEG_ICS_IPTUNER_DNP_FILE_PATH_PREFIX, ulHandle);
			
			MhegIcsDebug("%s(%d) pSaveFileName :%s\n",__FUNCTION__,__LINE__, s_pstIpTuner[ulHandle]->pSaveFileName);	

			DI_MHEG_ICS_INIT(ulHandle);
			
			nRet = local_mheg_ics_iptuner_DnpOpen(ulHandle, url, pstMediaInfo);
			break;

		case DI_IPTUNER_STREAM_HTTP_CHNK :
			DI_MHEG_ICS_INIT(ulHandle);
			nRet = DI_IPTUNER_StreamOpen (nTunerIndex, url, pstMediaInfo);
			if ( DI_ERR_OK != nRet)
			{
				MhegIcsError ("%s(%d) Error> STREAM Tuner Open Error.\n",__FUNCTION__,__LINE__);
				return DI_IPTUNER_MAX_NUM;
			}
			break;

		default:
			MhegIcsError("%s(%d) Error> nTunerIndex %d is not supported\n",__FUNCTION__,__LINE__, nTunerIndex);
			break;
	}

	
	
	/** store local */
	if( nRet == DI_ERR_OK)
	{
		MhegIcsDebug("%s(%d) Create Static IPTUNER Entry. index(%d) \n",__FUNCTION__,__LINE__, ulHandle);

		/* update static information */
		s_pstIpTuner[ulHandle]->stIptuner.isAvailable = TRUE;
		s_pstIpTuner[ulHandle]->stIptuner.url = (HINT8*) VK_StrDup((const char*)url);
		s_pstIpTuner[ulHandle]->stIptuner.downType = nDownloadType;
		s_pstIpTuner[ulHandle]->stIptuner.mediaInfo = *pstMediaInfo;
		s_pstIpTuner[ulHandle]->nTunerIndex = nTunerIndex;
	}
	else
	{
		DI_MHEG_ICS_IPTUNER_Close(ulHandle);
		nTunerIndex = DI_IPTUNER_MAX_NUM;
	}

	MhegIcsFunctionExit;

	return nTunerIndex;
}


DI_ERR_CODE DI_MHEG_ICS_IPTUNER_Close(HUINT32	ulHandle)
{
	DI_ERR_CODE nRet = DI_ERR_ERROR;
	
	MhegIcsFunctionEnter(ulHandle);

	if(s_pstIpTuner[ulHandle] == NULL)
	{
		MhegIcsError(" s_pstIpTuner[%d] isn't opened.!!! \n", ulHandle);
		goto exit; 
	}

	switch(s_pstIpTuner[ulHandle]->nTunerIndex)
	{
		case DI_IPTUNER_DNP_HTTP:
			nRet = local_mheg_ics_iptuner_DnpClose(ulHandle);
			break;

		case DI_IPTUNER_STREAM_HTTP_CHNK:
			nRet = DI_IPTUNER_StreamClose (s_pstIpTuner[ulHandle]->nTunerIndex);
			if ( DI_ERR_OK != nRet)
			{
				MhegIcsError ("%s(%d) Error> STREAM Tuner Close Error.\n",__FUNCTION__,__LINE__);
				return nRet;
			}
			break;
			
		default:
			MhegIcsError("%s(%d) Error> nTunerIndex %d is not supported\n",__FUNCTION__,__LINE__, s_pstIpTuner[ulHandle]->nTunerIndex);
			break;	
	}	
	
	if(s_pstIpTuner[ulHandle]->stIptuner.url != NULL)
	{
		DD_MEM_Free(s_pstIpTuner[ulHandle]->stIptuner.url);
		s_pstIpTuner[ulHandle]->stIptuner.url = NULL;
	}

	if(s_pstIpTuner[ulHandle]->pSaveFileName != NULL)
	{
		DD_MEM_Free(s_pstIpTuner[ulHandle]->pSaveFileName);
		s_pstIpTuner[ulHandle]->pSaveFileName = NULL;
	}

	DD_MEM_Free(s_pstIpTuner[ulHandle]);
	s_pstIpTuner[ulHandle] = NULL;

exit:	
	MhegIcsFunctionExit;

	return nRet;
}

DI_ERR_CODE DI_MHEG_ICS_IPTUNER_GetInfo(HUINT32 ulHandle, DI_IPTUNER_Info_t *pInfo)
{
	DI_ERR_CODE nRet = DI_ERR_OK;
	
	MhegIcsFunctionEnter(ulHandle);

	switch(s_pstIpTuner[ulHandle]->nTunerIndex)
	{
		case DI_IPTUNER_DNP_HTTP:
			nRet = local_mheg_ics_iptuner_DnpGetInfo(ulHandle, pInfo);	
			if ( DI_ERR_OK != nRet)
			{
				MhegIcsError("%s(%d) Error> MHEG DNP Tuner(%d) GetInfo Error.\n",__FUNCTION__,__LINE__, ulHandle);
				return nRet;
			}	
			/** tuner information */
			pInfo->ptIPTuner = &s_pstIpTuner[ulHandle]->stIptuner;
			break;

		case DI_IPTUNER_STREAM_HTTP_CHNK:
			/* specific information */
			nRet = DI_IPTUNER_StreamGetInfo(s_pstIpTuner[ulHandle]->nTunerIndex, pInfo);
			if ( DI_ERR_OK != nRet)
			{
				MhegIcsError ("%s(%d) Error> STREAM Tuner GetInfo Error.\n",__FUNCTION__,__LINE__);
				return nRet;
			}		
			/** tuner information */
			pInfo->ptIPTuner = &s_pstIpTuner[ulHandle]->stIptuner;
			break;
			
		default:
			MhegIcsError("%s(%d) Error> nTunerIndex %d is not supported\n",__FUNCTION__,__LINE__, s_pstIpTuner[ulHandle]->nTunerIndex);
			break;
	}
		
	MhegIcsFunctionExit;

	return nRet;
}

DI_ERR_CODE DI_MHEG_ICS_IPTUNER_Control(HUINT32 ulHandle, DI_IPTUNER_CMD_e cmd, HUINT64 val, HUINT64 val2)
{
	DI_ERR_CODE nRet = DI_ERR_OK;

	UNUSED_PARAM(val2);
	
	MhegIcsFunctionEnter(ulHandle);
	
	if(s_pstIpTuner[ulHandle]->nTunerIndex == DI_IPTUNER_DNP_HTTP)
	{
		nRet = local_mheg_ics_iptuner_DnpControl(ulHandle, cmd, val);
	}
	else
	{
		MhegIcsError("%s(%d) Error> nTunerIndex %d is not supported\n",__FUNCTION__,__LINE__, s_pstIpTuner[ulHandle]->nTunerIndex);
	}
	
	MhegIcsFunctionExit;

	return nRet;
}	


void DI_MHEG_ICS_IPTUNER_DnpPauseReceive(HUINT32	ulHandle)
{
	MhegIcsFunctionEnter(ulHandle);
	if(s_pstIpTuner[ulHandle] != NULL)
	{
		if(s_pstIpTuner[ulHandle]->nTunerIndex == DI_IPTUNER_DNP_HTTP)
		{
			local_mheg_ics_stream_HTTP_DnpPauseReceiving(s_pstIpTuner[ulHandle]);
		}
		else
		{
			MhegIcsError("%s(%d) Error> nTunerIndex %d is not supported\n",__FUNCTION__,__LINE__, s_pstIpTuner[ulHandle]->nTunerIndex);
		}
	}
	else
	{
		MhegIcsError(" s_pstIpTuner[%d] isn't opened.!!! \n", ulHandle);
	}
	MhegIcsFunctionExit;	
}

void DI_MHEG_ICS_IPTUNER_DnpResumeReceive(HUINT32	ulHandle)
{
	MhegIcsFunctionEnter(ulHandle);
	if(s_pstIpTuner[ulHandle] != NULL)
	{			
		if(s_pstIpTuner[ulHandle]->nTunerIndex == DI_IPTUNER_DNP_HTTP)
		{
			if(s_pstIpTuner[ulHandle]->bDiscarded == TRUE)
			{
				DI_IPTUNER_Msg_t s_Msg;
				
				MhegIcsDebug("\t @@@ [DI_MHEG_ICS_IPTUNER_DnpResumeReceive] Try to receive again discarded ICS[%d]\n", ulHandle);

				local_mheg_ics_stream_HTTP_DnpStartReceiving(s_pstIpTuner[ulHandle]);

				(void) VK_MEM_Memset(&s_Msg, 0x0, sizeof(s_Msg));
				s_Msg.unMsg = TUNER_DNP_MSG_HTTP_PROBE;
				(void) VK_MSG_Send ( s_pstIpTuner[ulHandle]->ulDNPMsgQId, (HUINT32 *)&s_Msg, sizeof(DI_IPTUNER_Msg_t) );

				s_pstIpTuner[ulHandle]->bDiscarded = FALSE;
			}
			else
			{
				if(s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffForcedStop != 0)
				{
					(void)local_mheg_ics_stream_HTTP_Seek(ulHandle, PRDN_GET_RAW_OFF_FROM_CHUNK_OFF(s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffForcedStop -1), SEEK_SET);
					s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffForcedStop = 0;
				}
				local_mheg_ics_stream_HTTP_DnpResumeReceiving(s_pstIpTuner[ulHandle]);
			}
		}
		else
		{
			MhegIcsError("%s(%d) Error> nTunerIndex %d is not supported\n",__FUNCTION__,__LINE__, s_pstIpTuner[ulHandle]->nTunerIndex);
		}		
	}
	else
	{
		MhegIcsError(" s_pstIpTuner[%d] isn't opened.!!! \n", ulHandle);
	}
	MhegIcsFunctionExit;	
}

HBOOL	DI_MHEG_ICS_IPTUNER_DnpPrdn_IsForwardPlay(HUINT32 ulHandle)
{
	if(s_pstIpTuner[ulHandle] != NULL)
	{
		return s_pstIpTuner[ulHandle]->stPrdnInfo.bForwardPlay;
	}
	else
	{
		return FALSE;
	}
}

HUINT64	DI_MHEG_ICS_IPTUNER_DnpPrdn_GetCurrentDataReadOffset(HUINT32 ulHandle)
{
	MHEG_DNP_USER_DATA_t	*pMhegDnpUserData;
	DNP_USER_DATA_t			*pDnpUserData;

	if(s_pstIpTuner[ulHandle] != NULL)
	{
		pMhegDnpUserData = (MHEG_DNP_USER_DATA_t*)s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData;
		pDnpUserData = &pMhegDnpUserData->stData;
		MhegVFIOError("%s (%d) \t @@@@ ICS[%d] cur(%"PRId64"), readCnt(%d) \n",__FUNCTION__, __LINE__, ulHandle, pDnpUserData->player_last_read_cursor, pDnpUserData->player_last_read_size);
		return (HUINT64)(pDnpUserData->player_last_read_cursor + pDnpUserData->player_last_read_size);
	}
	else
	{
		return 0;
	}
}

HBOOL		DI_MHEG_ICS_IPTUNER_DnpPrdn_IsReadCompleted(HUINT32 ulHandle)
{
	if(s_pstIpTuner[ulHandle] != NULL)
	{
		return s_pstIpTuner[ulHandle]->stPrdnInfo.bReadCompleted;
	}
	else
	{
		return FALSE;
	}
}

void		DI_MHEG_ICS_IPTUNER_UpdateEndPosition(HUINT32 ulHandle, HUINT32 ulPosPercent)
{
	HINT64 nEndPos;

	if((ulPosPercent == 100) && (s_pstIpTuner[ulHandle]->nEndPosition != 0))
	{
		s_pstIpTuner[ulHandle]->nEndPosition = 0;
		s_pstIpTuner[ulHandle]->stPrdnInfo.bReadCompleted = FALSE;
		s_pstIpTuner[ulHandle]->stPrdnInfo.bDownCompleted = FALSE;

		nEndPos = s_pstIpTuner[ulHandle]->nFileLength;
	}
	else
	{
		nEndPos = (HINT64)((s_pstIpTuner[ulHandle]->nFileLength / 100) * ulPosPercent);	
		s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffForcedStop = (HINT32)((nEndPos >> PRDN_CHUNK_EXPONENT) + 2); 		
		nEndPos = PRDN_GET_RAW_OFF_FROM_CHUNK_OFF(s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffForcedStop);

		s_pstIpTuner[ulHandle]->nEndPosition = nEndPos;
		s_pstIpTuner[ulHandle]->stPrdnInfo.bReadCompleted = FALSE;

		MhegIcsError(" [UpdateEndPosition] M[%d] EndPos(%"PRId64" : %d%%), nchunkoffForcedStop(%d) \n", 
						ulHandle, nEndPos, ulPosPercent, s_pstIpTuner[ulHandle]->stPrdnInfo.nchunkoffForcedStop);
	}

	// Update end position of Underflow monitor-task
	DI_MHEG_ICS_IPTUNER_UnderflowMonitorUpdateEndPostion(ulHandle, nEndPos);
}


void		DI_MHEG_ICS_IPTUNER_SetLastPosition(HUINT32 ulHandle)
{
	MHEG_DNP_USER_DATA_t	*pMhegDnpUserData;
	DNP_USER_DATA_t			*pDnpUserData;
	//off_t					cur=0;

	if(s_pstIpTuner[ulHandle] != NULL)
	{
		pMhegDnpUserData = (MHEG_DNP_USER_DATA_t*)s_pstIpTuner[ulHandle]->hVFIO.pDnpUserData;
		pDnpUserData = &pMhegDnpUserData->stData;		

		s_nllLastPosition[ulHandle] = pDnpUserData->player_last_read_cursor;
		//cur = lseek(pDnpUserData->unOpenFromNexusHandle, pDnpUserData->player_last_read_cursor, SEEK_SET);
		//MhegVFIOError("%s (%d) \t @@@@ ICS[%d] fd(0x%X) last-cur(%"PRId64"), cur(%"PRId64")\n",__FUNCTION__, __LINE__, ulHandle, pDnpUserData->unOpenFromNexusHandle, pDnpUserData->player_last_read_cursor, cur);
	}		
}



void		DI_MHEG_ICS_IPTUNER_DnpDiscardBufferedStream(HUINT32 ulHandle)
{
	MhegIcsFunctionEnter(ulHandle);
	
	s_pstIpTuner[ulHandle]->bDiscarded = TRUE;
	local_mheg_ics_stream_HTTP_DnpStopReceiving(s_pstIpTuner[ulHandle]);

	MhegIcsFunctionExit;	
}


HINT32 DI_MHEG_ICS_IPTUNER_GetUnderflowState(HUINT32 ulHandle)
{
	return DI_MHEG_ICS_IPTUNER_UnderflowGetReadyState(ulHandle);
}

void DI_MHEG_ICS_IPTUNER_SetUnderflowState(HUINT32 ulHandle, HINT32 eUnderflowState)
{
	DI_MHEG_ICS_IPTUNER_UnderflowSetReadyState(ulHandle, eUnderflowState);
}

DI_ERR_CODE DI_MHEG_ICS_IPTUNER_InstallReadyStateCallback(HUINT32 ulHandle, fn_readystate_callback pFn)
{
	local_mheg_ics_iptuner_DnpSetReadyStateCallback(ulHandle, pFn);
	return DI_MHEG_ICS_IPTUNER_SetUnderflowReadyStateCallback(ulHandle, pFn);
}


void DI_MHEG_ICS_IPTUNER_UnderflowMonitorDestroy(HUINT32 ulHandle)
{
	MhegIcsFunctionEnter(ulHandle);
	
	if(s_pstIpTuner[ulHandle]->nTunerIndex == DI_IPTUNER_STREAM_HTTP_CHNK)
	{
		DI_IPTUNER_UnderflowMonitorTerminateThread();
	}
	else
	{
		DI_MHEG_ICS_IPTUNER_UnderflowMonitorTerminateThread(ulHandle);
	}

	MhegIcsFunctionExit;	
}

void DI_MHEG_ICS_IPTUNER_UnderflowMonitorAwake(HUINT32 ulHandle)
{
	MhegIcsFunctionEnter(ulHandle);
	
	if(s_pstIpTuner[ulHandle]->nTunerIndex == DI_IPTUNER_STREAM_HTTP_CHNK)
	{
		DI_IPTUNER_UnderflowMonitorAwakeThread();
	}
	else
	{
		DI_MHEG_ICS_IPTUNER_UnderflowMonitorAwakeThread(ulHandle);
	}

	MhegIcsFunctionExit;	
}

void DI_MHEG_ICS_IPTUNER_UnderflowMonitorSleep(HUINT32 ulHandle)
{
	MhegIcsFunctionEnter(ulHandle);
	
	if(s_pstIpTuner[ulHandle]->nTunerIndex == DI_IPTUNER_STREAM_HTTP_CHNK)
	{
		DI_IPTUNER_UnderflowMonitorSleepThread();
	}
	else
	{
		DI_MHEG_ICS_IPTUNER_UnderflowMonitorSleepThread(ulHandle);
	}

	MhegIcsFunctionExit;	
}



