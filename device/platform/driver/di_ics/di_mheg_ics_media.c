//-------------------------------------------------------------------/
//
//	di_mheg_ics_media.c
//
//	Copyright (c) 2008 Valups Corp.
//
//-------------------------------------------------------------------/

//-------------------------------------------------------------------/
// Revision history
//   10/31/08  first generated by Whiterub
//-------------------------------------------------------------------/

#include <stdio.h>
#include <string.h>


#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <linux/sockios.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>	/** for 64bit MACRO ex>PRId64 */
#include <unistd.h>

#include "taskdef.h"

#include "di_mheg_ics.h"

#include "nexus_platform.h"
#include "nexus_platform_features.h"
#include "nexus_display.h"

//audio stream
#include "nexus_audio_playback.h"

//divx & mp3
#include "nexus_pid_channel.h"
#include "nexus_playpump.h"
#include "nexus_playback.h"
#include "nexus_file.h"

#include "nexus_security.h"

#include "di_video.h"
#include "di_audio.h"

#include "drv_media_10.h"
#include "drv_audio.h"
#include "drv_video.h"
#include "drv_pvr.h"

#define B_HAS_AVI 1
#define B_HAS_ASF 1
#include "bfifo.h"
#include "bfile_stdio.h"
#include "biobits.h"
#include "bioatom.h"
#include "bpool.h"
#include "barena.h"
#include "bpool.h"
#include "bmedia_filter.h"
#include "bmedia_player.h"
#include "bfile_stdio.h"
#include "bfile_buffer.h"
#include "bfile_async.h"
#include "bmedia_probe.h"
#include "bmp4_probe.h"
#include "bmkv_probe.h"
#include "bavi_probe.h"
#include "bmpeg2ts_parser.h"
#include "bmpeg2pes_parser.h"

#include "di_uart.h"
#include "di_mheg_ics_iptuner_underflow.h"

/*******************************************************************/
/********************      Global Variables     ********************/
/*******************************************************************/

/*******************************************************************/
/********************      Defines         *************************/
/*******************************************************************/


//#define DI_MHEG_ICS_DEBUG

#ifdef DI_MHEG_ICS_DEBUG
#define MhegIcsData		DI_UART_Print
#define MhegIcsDebug		DI_UART_Print
#define MhegIcsError		DI_UART_Print
#else
#define MhegIcsData		while (0) ((int (*)(char *, ...)) 0)
#define MhegIcsDebug		while (0) ((int (*)(char *, ...)) 0)
#define MhegIcsError		DI_UART_Print
#endif

#ifdef DI_MHEG_ICS_DEBUG
#define MhegIcsFunctionEnter(a)		DI_UART_Print("(+)%s[%d]\n", __FUNCTION__, a)
#define MhegIcsFunctionExit		DI_UART_Print("(-)%s\n", __FUNCTION__)
#else
#define MhegIcsFunctionEnter(a)
#define MhegIcsFunctionExit
#endif



#define UNUSED_PARAM(x)  ((void)x)


#define MAX_MHEG_ICS_NUM 							MAX_MHEG_ICS_IPTUNER_NUM	

//#define HUMAX_COOKIE_LINE_BUFFER_SIZE		(10240)
//#define HUMAX_COOKIE_FILE_FULL_PATH	"/mnt/hd3/cookie.txt"

//#define HUMAX_COOKIE_SEP "\t"
//#define MAXDOME_MAN_STRING		"MAN\t"
//#define MAXDOME_MANUSER_STRING 	"MANUser\t"

#define MEDIA_MPEG2TS_188PKT_LEN		(188)
#define MEDIA_MPEG2TS_192PKT_LEN		(192)
#define MEDIA_MPEG2TS_PKT_SYNC			(0x47)

//#define DI_MEDIA_MSG_SIZE			MSGQ_SIZE_NORMAL
//#define DI_MEDIA_INFINITIVE_LOOP	0

/** Define MFP Stream Url Length */
#define	MHEG_ICS_STREAM_URL_LEN			(2048)
/** Define MFP Feed Block Buffer Size */
//#define DI_MFP_FEED_BLOCK_BUF_SIZE			(4096*15)
/** Define MFP Feed Total(Block*Segment number)Buffer Size */
#define MHEG_MFP_FEED_TOTAL_BUF_SIZE			(4096*15*32)
#define	B_PUMP_DEMUX_FACTORY_ATOMS		(128)

/** Define Video Main Decoder */
//#define	DI_VIDEO_MAIN_DECODER			(0)

//#define DI_MEDIA_ENCRYPTION_KEY_LEN		(32)

#define MHEG_ICS_TSTYPE_SEARCH_LEN		(1024*3)
#define MHEG_ICS_TSINFO_LEN		(1024*2)

#if defined(HDR_FOX_T2) || defined(HD_FOX_T2)
#define SUPPORT_USE_STC_AUTOMODE_FIRSTAVAILABLE 1
#else
#define SUPPORT_USE_STC_AUTOMODE_FIRSTAVAILABLE 0
#endif

//#define MEDIA_PLAYPUMP_MAX_READ (32*1024)

/*
Summary:
Returns bits 'e'..'b' from word 'w',

Example:
	B_GET_BITS(0xDE,7,4)==0x0D
	B_GET_BITS(0xDE,3,0)=0x0E
*/
//#define B_GET_BITS(w,e,b)  (((w)>>(b))&(((unsigned)(-1))>>((sizeof(unsigned))*8-(e+1-b))))

//#define CONFIG_SEND_CHANGEPLAYTIME_PERIOD_300MS


/*******************************************************************/
/********************      Typedef         *************************/
/*******************************************************************/

typedef enum
{
	MHEG_ICS_STATE_NO_SETUP,
	MHEG_ICS_STATE_READY,
	MHEG_ICS_STATE_PLAY,
	MHEG_ICS_STATE_PAUSE,
	MHEG_ICS_STATE_STOP,
	MHEG_ICS_STATE_TRICK
} MHEG_ICS_STATE_e;

/*
typedef enum
{
	DI_MEDIA_PLAY_FROM_UNKNOWN,
	DI_MEDIA_PLAY_AUDIO_FROM_FILE,
	DI_MEDIA_PLAY_AUDIO_FROM_MEMORY,
	DI_MEDIA_PLAY_VIDEO_FROM_FILE,
	DI_MEDIA_PLAY_VIDEO_FROM_MEMORY,
	DI_MEDIA_PLAY_STREAM_FROM_PLAYPUMP
} DI_MEDIA_MSG_SENDER;

typedef enum
{
	DI_MEDIA_PLAYPUMPPLAY_NOT_READY,
	DI_MEDIA_PLAYPUMPPLAY_STOP,
	DI_MEDIA_PLAYPUMPPLAY_PLAY,
	DI_MEDIA_PLAYPUMPPLAY_SETUP,
	DI_MEDIA_PLAYPUMPPLAY_STOPWAITING
} DI_MEDIA_PLAYPUMP_STREAM_STATE;

typedef enum
{
	DI_MEDIA_STREAM_UNKNOWN,
	DI_MEDIA_FILE_STREAM_PLAY,
	DI_MEDIA_FILE_STREAM_STOP,
	DI_MEDIA_FILE_STREAM_PAUSE,
	DI_MEDIA_FILE_STREAM_RESUME,
	DI_MEDIA_FILE_STREAM_MONITOR,

	DI_MEDIA_MEMORY_STREAM_PLAY,
	DI_MEDIA_MEMORY_STREAM_STOP,
	DI_MEDIA_MEMORY_STREAM_PAUSE,
	DI_MEDIA_MEMORY_STREAM_RESUME,
	DI_MEDIA_MEMORY_STREAM_MONITOR,
} DI_MEDIA_STEAM_EVENT;

typedef struct
{
	NEXUS_FilePlayHandle 	file;
	unsigned long long		fileSize;
	unsigned char			*pbuffStartPoint;
	unsigned long			esDataSize;
	unsigned long long		playOffset;
	unsigned long long		remainDataSize;
	unsigned long			loopCount;
	unsigned char			pauseFlag;
	unsigned long			emptyChkCnt;
}DI_MEDIA_STREAM_PLAY_INFO;

typedef struct
{
	unsigned long		ulSender;
	unsigned long		ulStreamHandle;
	unsigned long	   	ulEvent;
	unsigned char		*pucParam;
	unsigned long		ulParam2;
	unsigned long		ulParam3;
	unsigned long		ulParam4;
	unsigned long		ulParam5;
	unsigned long		ulParam6;
}DI_MEDIA_MSG;
*/

typedef enum
{
	DI_MHEG_ICS_AUDIO_FREE=0,
	DI_MHEG_ICS_AUDIO_ALLOCATED,
	DI_MHEG_ICS_AUDIO_PAUSED,
	DI_MHEG_ICS_AUDIO_STOP,
	DI_MHEG_ICS_AUDIO_PLAY
}	DI_MHEG_ICS_AUDIO_STATUS;


typedef struct
{
#if defined (USE_DRM)
		bdrm_t tDrm;
		bdrm_cfg tDrm_cfg;
		bdrm_decryptor_t tDcryptor;
		bdrm_license_state tDrm_license_state;
		bdrm_http_state tDrm_http_state;
		HUINT8 aucEncryptionKey[DI_MEDIA_ENCRYPTION_KEY_LEN];
#endif
	HUINT8						valid;
	HUINT8						*mediaurl;
	MHEG_ICS_STATE_e			mediastate;
	DI_MEDIA_PLAYPUMP			mediaType;
	DI_MHEG_ICS_AUDIO_STATUS		audioStatus;
	NEXUS_AudioPlaybackHandle 	audioPlayback;
	NEXUS_PlaypumpHandle		playpump[DI_MEDIA_PLAYPUMP_MAX];
	NEXUS_PlaybackHandle		playback;
	NEXUS_PidChannelHandle		audioPidChannel;
	NEXUS_PidChannelHandle		audioSubPidChannel;
	NEXUS_PidChannelHandle		audioTrackPidChannels[DI_MEDIA_DIVX_MAX_AUDIO_TRACK];
	NEXUS_PidChannelHandle		videoPidChannel;
	// NEXUS_PidChannelHandle	videoTrackPidChannels[DI_MEDIA_DIVX_MAX_VIDEO_TRACK];
	NEXUS_PidChannelHandle		sectionPidChannel;
	NEXUS_PidChannelHandle      pcrPidChannel; /* pcr_pid */	
	NEXUS_FilePlayHandle 		file;
	NEXUS_VideoDecoderHandle	vDecoder;
	NEXUS_AudioDecoderHandle	aDecoder;
	DI_MEDIA_TrickSpeed_e		trickrate;

	HUINT32						unFirstPts; 
	HBOOL                       bPtsInstalled;

} DI_Mheg_Ics_MediaInstance_t;

typedef struct _stMediaInfo_t{
	HUINT8				opened;
	char				szStreamUrl[MHEG_ICS_STREAM_URL_LEN];

	batom_pipe_t		pipe_pes;
	bmedia_stream_t		video;
	bmedia_stream_t		audio;

#ifdef  CONFIG_VFIO
	VFIO_Handle_t		tHandle;
#else
	FILE				*fin;
#endif

	bmedia_filter_t		filter;
	batom_factory_t		factory;
	batom_pipe_t		pipe_media;
	size_t				alloc_cnt;
	size_t				free_cnt;

	batom_t				atom;

	bool				async;
	bmedia_player_pos	seek;
	bmedia_player_pos	seek2;
	bmedia_player_step	direction;
	bmedia_time_scale	time_scale;
	bool				key_frame_only;
	bmedia_player_decoder_mode	decoder_mode;

	bfile_io_read_t			fd;
	bmedia_player_t			player; /* media player is used to play various container formats */
	bmedia_player_stream	stream;
	bfile_buffer_t			buffer;
	bfile_buffer_cfg		buffer_cfg;

	bool					no_player;

	DI_MEDIA_INFO_t	StreamInfo;

	HUINT64		ullPrevPosition;
	HUINT64		ullEosPosition;

} stMhegIcsMediaInfo;


typedef struct b_test_pid {
        bmpeg2ts_parser_pid ts_pid;
        bmpeg2pes_parser pes;
        unsigned pcr_count;
        unsigned ts_bytes;
        unsigned pes_bytes;
        unsigned pts_count;
        void *mfp_pointer;
} b_test_pid;


/*******************************************************************/
/********************      Static Variables     ********************/
/*******************************************************************/

/* Start static variablee */

static HBOOL					s_bMhegIcsMediaInitialized[MAX_MHEG_ICS_NUM] = {FALSE, };

/** Static Media Semaphore Id */
static unsigned long			s_ulMhegIcsMediaSemId[MAX_MHEG_ICS_NUM];
/** Static Play Time Task Id */
static unsigned long 			s_ulMhegIcsMediaPlayTimeTaskId[MAX_MHEG_ICS_NUM] = {0, };

/** Static Stream Info */
static DI_MEDIA_INFO_t			s_tMhegIcsStreamInfo[MAX_MHEG_ICS_NUM];

/** Static Event Callback */
static DI_MEDIA_EventCallback_t	s_tMhegIcsEventCallback[MAX_MHEG_ICS_NUM];
static DI_MEDIA_FirstPtsCallback_t	s_tMhegIcsEventFirstPtsCallback[MAX_MHEG_ICS_NUM];

/** Static Media StreamInfo */
static stMhegIcsMediaInfo       		s_MhegIcsMfpInfo[MAX_MHEG_ICS_NUM];
/** Static Temp */
static const uint8_t      		s_eos_data[256] = {0xE0, 0x55};
/** Static Media Instance */
static DI_Mheg_Ics_MediaInstance_t		s_tMhegIcsMediaInstance[MAX_MHEG_ICS_NUM];

/** Static Stream Info */
static HUINT32					s_nMhegIcsCurrentPlayTime[MAX_MHEG_ICS_NUM];

/** Static Stream Info */
static DI_MEDIA_TIMERMODE_e			s_bMhegIcsPlayTimerMode[MAX_MHEG_ICS_NUM];

/** Static LicenseData Callback */
//static DI_MEDIA_LicenseDataCallback_t		s_tLicenseDataCallback=NULL;

static const uint8_t tTempWavHeader[] = {
        'R','I','F','F',
        0xFF,0xFF,0xFF,0xFF,     /* unbounded size */
        'W','A','V','E',
        'f','m','t',' ',
        0x12, 0x00, 0x00, 0x00, /* length of fmt block */
        0x01, 0x00,             /* FormatTag -> LPCM */
        0x00, 0x00,             /* Channels */
        0x00, 0x00, 0x00, 0x00, /* sample rate */
        0x00, 0x00, 0x00, 0x00, /* average byte rate */
        0x00, 0x00,             /* block align */
        0x00, 0x00,             /* bits per sample */
        0x00, 0x00,             /* size of extra block */
        'd','a','t','a',
        0xFF,0xFF,0xFF,0x00     /* unbounded size */
};

/** License Data(Ex> DRM) */
static char					*s_pcMhegIcsLisenceData = NULL;

/** Support DRV_MHEG_ICS_CheckStart() */
static HUINT32 s_ulMhegIcsMediaStart[MAX_MHEG_ICS_NUM] = {0, };

static HBOOL	s_bStopPlayTimeTask[MAX_MHEG_ICS_NUM] = {FALSE, };

/*******************************************************************/
/********************    Local  Functions       *************************/
/*******************************************************************/

#define _____Define_INTERNAL_APIs________________________________________________________________


static void		local_mheg_ics_media_InitTread(HUINT32	ulHandle);
static void		local_mheg_ics_media_DeinitTread(HUINT32	ulHandle);
static void		local_mheg_ics_media_PlayTimeTask(void *param);

/* b_play_getpts() is defined at nexus_playback_impl.h() with private internal function */
extern NEXUS_Error b_play_getpts(NEXUS_PlaybackHandle p, uint32_t *pts);


static bmpeg2ts_parser_action 	local_mheg_ics_media_GettingTSPayload (bmpeg2ts_parser_pid *pid, unsigned flags, batom_accum_t src, batom_cursor *cursor, size_t len);
static void 					local_mheg_ics_media_GettingPESPacket(void *packet_cnxt, batom_accum_t src, batom_cursor *payload, size_t len, const bmpeg2pes_atom_info *info);

static DI_ERR_CODE				local_mheg_ics_media_ProbeOpen (HUINT32 unMediaId, HUINT8 *pszStreamUrl, stMhegIcsMediaInfo *pMfpInfo);
static DI_ERR_CODE				local_mheg_ics_media_ProbeClose (stMhegIcsMediaInfo *pMfpInfo);
static void						local_mheg_ics_media_ProbeFreeAtom (batom_t atom, void *user);
static void						local_mheg_ics_media_ProbeAsync (void *cntx, bmedia_player_entry *entry);



#define _____INTERNAL_APIs________________________________________________________________


static void local_mheg_ics_media_AdjustTime(HUINT32 unMediaId, HUINT32 *pts)
{
	HUINT32 TrickSpeed;

	DI_MHEG_ICS_MP_GetSpeed(unMediaId, &TrickSpeed);

	switch(TrickSpeed)
	{
		case DI_MEDIA_TRICK_2RWSTEP:		// FR x2
			*pts = (HUINT32)((HINT32)*pts * (-1)) * 2;
			break;
		case DI_MEDIA_TRICK_4RWSTEP:		// FR x4
			*pts = (HUINT32)((HINT32)*pts * (-1)) * 4;
			break;
		case DI_MEDIA_TRICK_8RWSTEP:		// FR x8
			*pts = (HUINT32)((HINT32)*pts * (-1)) * 8;
			break;
		case DI_MEDIA_TRICK_14RWSTEP:		// FR x16
			*pts = (HUINT32)((HINT32)*pts * (-1)) * 16;
			break;
		case DI_MEDIA_TRICK_15RWSTEP:		// FR x32
			*pts = (HUINT32)((HINT32)*pts * (-1)) * 32;
			break;
		case DI_MEDIA_TRICK_PAUSE:			// pause
		case DI_MEDIA_TRICK_1FFSTEP:		// FF x1
		case DI_MEDIA_TRICK_2FFSTEP:		// FF x2
		case DI_MEDIA_TRICK_4FFSTEP:		// FF x4
			break;
		case DI_MEDIA_TRICK_8FFSTEP:		// FF x8
			*pts = *pts * 8;
			break;
		case DI_MEDIA_TRICK_14FFSTEP:		// FF x16
			*pts = *pts * 16;
			break;
		case DI_MEDIA_TRICK_15FFSTEP:		// FF x32
			*pts = *pts * 32;
			break;
		default :
			MhegIcsError("[%s] Not Supported Play Speed [%d][%d]\n", __func__, unMediaId, TrickSpeed);
			break;
	}
}

/*
 * @notes: CONFIG_SEND_CHANGEPLAYTIME_PERIOD_250MS (http://svn.humaxdigital.com:3000/issues/64851)
 * 	- change playtime event를 250 milli second마다(VK_TASK_Sleep(250)에 맞추어) 보낸다. (for HTML5 videobackend)
 *	- 기존 방식 호환을 위해 playtime param은 sec단위로 보내므로 browser_media에서 msec단위로 갱신
*/
static void local_mheg_ics_media_PlayTimeTask(void *param)
{
	NEXUS_Error				tNexusError = NEXUS_SUCCESS;
	HUINT32					nTempPlayTime[MAX_MHEG_ICS_NUM] = {0,};
	HUINT32					unPtsSnapShot[MAX_MHEG_ICS_NUM] = {0,};
	HUINT32					unMediaId = (HUINT32)param;

	while(s_bStopPlayTimeTask[unMediaId] != TRUE)
	{		
		if((s_tMhegIcsEventCallback[unMediaId] != NULL) &&
			((s_tMhegIcsMediaInstance[unMediaId].mediastate == MHEG_ICS_STATE_PLAY)
			 || (s_tMhegIcsMediaInstance[unMediaId].mediastate == MHEG_ICS_STATE_TRICK) || (s_tMhegIcsMediaInstance[unMediaId].mediastate == MHEG_ICS_STATE_PAUSE)))
		{
			if(s_tMhegIcsMediaInstance[unMediaId].playback == NULL)
			{
				VK_TASK_Sleep(250);
				continue;
			}
			else
			{
				tNexusError = b_play_getpts (s_tMhegIcsMediaInstance[unMediaId].playback, &unPtsSnapShot[unMediaId]);
				if(tNexusError != NEXUS_SUCCESS)
				{
					/* Nothing to do */
					VK_TASK_Sleep(10);
					continue;
				}
				else
				{
					local_mheg_ics_media_AdjustTime(unMediaId, &unPtsSnapShot[unMediaId]);
					/* firstStarted Stream */
					if(s_tMhegIcsMediaInstance[unMediaId].bPtsInstalled == FALSE)
					{
						MhegIcsDebug ("## NOT PREPARED PTS\n\n");
						if(s_tMhegIcsEventFirstPtsCallback[unMediaId] != NULL)
							s_tMhegIcsEventFirstPtsCallback[unMediaId] ((HUINT32)unMediaId, unPtsSnapShot[unMediaId]);
					}
					/* else : we had got a first pts for this stream */
					/* Get Playback Play Position */
					nTempPlayTime[unMediaId] = bmedia_pts2time(unPtsSnapShot[unMediaId] - s_tMhegIcsMediaInstance[unMediaId].unFirstPts, BMEDIA_TIME_SCALE_BASE);	
				}
			}
			/** Get Playback Play Position */			
#if defined(CONFIG_SEND_CHANGEPLAYTIME_PERIOD_300MS)
#else
			if(s_nMhegIcsCurrentPlayTime[unMediaId] != (nTempPlayTime[unMediaId]/1000))
#endif
			{
				if(s_tMhegIcsMediaInstance[unMediaId].bPtsInstalled == FALSE)
				{
					if(s_tMhegIcsEventFirstPtsCallback[unMediaId] != NULL)
						s_tMhegIcsEventFirstPtsCallback[unMediaId] ((HUINT32)unMediaId, nTempPlayTime[unMediaId]);
				}
					
				if((s_bMhegIcsPlayTimerMode[unMediaId] == DI_MEDIA_TIMERMODE_NONE)
					|| ((nTempPlayTime[unMediaId]  == 0) && (s_bMhegIcsPlayTimerMode[unMediaId] == DI_MEDIA_TIMERMODE_UPDATE_EXCEPT_0)))
				{
					MhegIcsDebug("[%s] Not Update Play Time\n", __func__);
				}
				else
				{
					s_nMhegIcsCurrentPlayTime[unMediaId] = (nTempPlayTime[unMediaId]/1000);
				}
				if((s_nMhegIcsCurrentPlayTime[unMediaId] != 0) && (s_tMhegIcsEventCallback[unMediaId] != NULL) &&
				((s_bMhegIcsPlayTimerMode[unMediaId] == DI_MEDIA_TIMERMODE_UPDATE_FULLTIME) || (s_bMhegIcsPlayTimerMode[unMediaId] == DI_MEDIA_TIMERMODE_UPDATE_EXCEPT_0)))
				{
					s_tMhegIcsEventCallback[unMediaId](unMediaId, DI_MEDIA_EVENT_CHANGEPLAYTIME, s_nMhegIcsCurrentPlayTime[unMediaId]);
				}
			}
		}		
		VK_TASK_Sleep(500);
	}

	s_bStopPlayTimeTask[unMediaId] = FALSE;
}


static void 	local_mheg_ics_media_InitTread(HUINT32	unMediaId)
{
	int result;

	if(s_bMhegIcsMediaInitialized[unMediaId] != FALSE)
	{
		MhegIcsError("%s (%d) Error>  MHEGMediaTread(%d) Already initialized !\n",__FUNCTION__,__LINE__, unMediaId);	
		return;
	}

	s_bStopPlayTimeTask[unMediaId] = FALSE;
		
	VK_memset(&s_tMhegIcsStreamInfo[unMediaId],0,sizeof(DI_MEDIA_INFO_t));
	s_bMhegIcsPlayTimerMode[unMediaId] = DI_MEDIA_TIMERMODE_NONE;

	result = VK_SEM_Create(&s_ulMhegIcsMediaSemId[unMediaId],"mheg_ics_media_sema", VK_SUSPENDTYPE_FIFO);
	if( result != VK_OK )
	{
		MhegIcsError("[%s] [%d] Error(0x%x) > create mheg_ics_media_sema  \n\r",__FUNCTION__,__LINE__, result);
		return;
	}

	result = VK_TASK_Create(local_mheg_ics_media_PlayTimeTask,
						MEDIA_TIME_TASK_PRIORITY,
						MEDIA_TIME_TASK_STACK_SIZE,
						"MhegIcsMediaPlayTime",
						(void*)unMediaId,
						&s_ulMhegIcsMediaPlayTimeTaskId[unMediaId],
						FALSE);
	if(result != VK_OK)
	{
		MhegIcsError("[DRV_PVR_PLAY_Init] Error(0x%x) in VK_TASK_Create()\n\r", result);
		result = VK_SEM_Destroy(s_ulMhegIcsMediaSemId[unMediaId]);
		s_ulMhegIcsMediaSemId[unMediaId] = 0;
		return;
	}

	VK_TASK_Start(s_ulMhegIcsMediaPlayTimeTaskId[unMediaId]);

	MhegIcsDebug("\t\t @@@ PlayTimeTask[%d] ID(0x%X) Create&Start..\n", unMediaId, s_ulMhegIcsMediaPlayTimeTaskId[unMediaId]);

	VK_MEM_Memset(&s_tMhegIcsMediaInstance[unMediaId], 0x0, sizeof(DI_Mheg_Ics_MediaInstance_t));
	s_bMhegIcsMediaInitialized[unMediaId] = TRUE;
	
}


static void 	local_mheg_ics_media_DeinitTread(HUINT32	unMediaId)
{
	int result;

	if(s_bMhegIcsMediaInitialized[unMediaId] != TRUE)
	{
		MhegIcsError("%s (%d) Error>  MHEGMediaTread(%d) Already deinitialized !\n",__FUNCTION__,__LINE__, unMediaId);	
		return;
	}

	s_bStopPlayTimeTask[unMediaId] = TRUE;

	while(s_bStopPlayTimeTask[unMediaId])
	{
		VK_TASK_Sleep(100);
	}

	result = VK_TASK_Destroy(s_ulMhegIcsMediaPlayTimeTaskId[unMediaId]);
	if(result != VK_OK)
	{
		MhegIcsError("[DRV_PVR_PLAY_Deinit] Error(0x%x) in VK_TASK_Destroy()\n\r", result);
		return;
	}

	MhegIcsDebug("\t\t @@@ PlayTimeTask[%d] ID(0x%X) Stop&Destroy..\n", unMediaId, s_ulMhegIcsMediaPlayTimeTaskId[unMediaId]);

	s_bMhegIcsMediaInitialized[unMediaId] = FALSE;
}


/**
 * @brief		Media Id가 유효한지 검사한다.
 *
 * @param[in]	unMediaId 	Media ID
 * @return		DI_ERR_CODE
 * @see
 */
static DI_ERR_CODE local_mheg_ics_media_CheckValidMediaId(HUINT32 unMediaId)
{
	DI_ERR_CODE		eDIError = DI_ERR_OK;
/*
	MhegIcsFunctionEnter(unMediaId);
*/
	if(unMediaId >= MAX_MHEG_ICS_NUM)
	{
		MhegIcsError("[%s] Invalid Media ID(%d).\n", __func__, unMediaId);
		eDIError = DI_ERR_ERROR;
	}
	else
	{
		if(s_tMhegIcsMediaInstance[unMediaId].valid != TRUE)
		{
			MhegIcsError("[%s] Media ID(%d) not initialized..!\n", __func__, unMediaId);
			eDIError = DI_ERR_ERROR;
		}
		else
		{
			eDIError = DI_ERR_OK;
		}
	}
/*
	MhegIcsFunctionExit;
*/
	return eDIError;
}


static DI_ERR_CODE local_mheg_ics_media_CreatePlayback(HUINT32 unMediaId)
{
	DI_ERR_CODE		eDIError = DI_ERR_OK;

	MhegIcsFunctionEnter(unMediaId);

	if(s_tMhegIcsMediaInstance[unMediaId].valid == FALSE)
	{
		MhegIcsError("[%s] Media isn't valid!!\n", __func__);
		eDIError = DI_ERR_ERROR;
	}
	else
	{
		s_tMhegIcsMediaInstance[unMediaId].playback = NEXUS_Playback_Create();
		if(s_tMhegIcsMediaInstance[unMediaId].playback == NULL)
		{
			MhegIcsError("[%s] Fail NEXUS_Playback_Create.\n", __func__);
			eDIError = DI_ERR_ERROR;
		}
	}

	MhegIcsFunctionExit;

	return eDIError;
}

static DI_ERR_CODE local_mheg_ics_media_DeletePlayback(HUINT32 unMediaId)
{
	DI_ERR_CODE		eDIError = DI_ERR_OK;

	MhegIcsFunctionEnter(unMediaId);

	if(s_tMhegIcsMediaInstance[unMediaId].valid == FALSE)
	{
		MhegIcsError("[%s] ICS Media isn't valid!!\n", __func__);
		eDIError = DI_ERR_ERROR;
	}
	else
	{
		(void)NEXUS_Playback_Destroy(s_tMhegIcsMediaInstance[unMediaId].playback);
		s_tMhegIcsMediaInstance[unMediaId].playback = NULL;
	}

	MhegIcsFunctionExit;

	return eDIError;
}

/**
 * @brief		Callback함수로 등록시 Stream 재생이 시작되면서 호출된다.
 *
 * @param[in]	context 	변경하고자 하는 배속 정보를 지정한다.
 * @param[in]	param 		변경하고자 하는 배속 정보를 지정한다.
 * @return		void
 * @see			DI_MEDIA_RegisterCallback
 */
static void local_mheg_ics_media_BeginOfStreamCallback(void *context, int param)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;

	MhegIcsFunctionEnter(param);

	BSTD_UNUSED(context);

	s_nMhegIcsCurrentPlayTime[param] = 0;

	if(s_tMhegIcsMediaInstance[param].playback == NULL)
	{
		MhegIcsError("[%s] Playback handle is null.\n", __func__);
		eDIError = DI_ERR_ERROR;
	}
	else
	{
		s_bMhegIcsPlayTimerMode[param] = DI_MEDIA_TIMERMODE_UPDATE_FULLTIME;

		if ( NULL != s_tMhegIcsEventCallback[param] )
		{
			s_tMhegIcsEventCallback[param] ((HUINT32)param, DI_MEDIA_EVENT_BEGINOFSTREAM, 0);
			s_tMhegIcsEventCallback[param]((HUINT32)param, DI_MEDIA_EVENT_CHANGEPLAYTIME, 0);
		}
		/* else - do nothing */

		if(s_tMhegIcsMediaInstance[param].mediastate == MHEG_ICS_STATE_TRICK)
		{
			if(NULL == strstr((char *)s_tMhegIcsMediaInstance[param].mediaurl, "mms://"))
			{
				(void)DI_MHEG_ICS_MP_SetPosition(param, 0, DI_MEDIA_TIME_SEC);
			}

			(void)DI_MHEG_ICS_MP_SetSpeed(param, DI_MEDIA_TRICK_PAUSE);
		}
	}

	MhegIcsFunctionExit;

	return;
}

/**
 * @brief		Callback함수로 등록시 Stream 재생에 문제가 발생하면 호출된다.
 *
 * @param[in]	context 	변경하고자 하는 배속 정보를 지정한다.
 * @param[in]	param 		변경하고자 하는 배속 정보를 지정한다.
 * @return		void
 * @see			DI_MEDIA_RegisterCallback
 */
static void local_mheg_ics_media_ErrorOfStreamCallback(void *context, int param)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;

	MhegIcsFunctionEnter(param);

	BSTD_UNUSED(context);

	if(s_tMhegIcsMediaInstance[param].playback == NULL)
	{
		MhegIcsError("[%s] Playback handle is null.\n", __func__);
		eDIError = DI_ERR_ERROR;
	}
	else
	{
		if ( NULL != s_tMhegIcsEventCallback[param] )
		{
			s_tMhegIcsEventCallback[param] ((HUINT32)param, DI_MEDIA_EVENT_ERROROFSTREAM, 0);
		}
		/* else - do nothing */
	}

	MhegIcsFunctionExit;

	return;
}

/**
 * @brief		Callback함수로 등록시 Stream 재생이 나면 호출된다.
 *
 * @param[in]	context 	변경하고자 하는 배속 정보를 지정한다.
 * @param[in]	param	 	변경하고자 하는 배속 정보를 지정한다.
 * @return		void
 * @see			DI_MEDIA_RegisterCallback
 */
static void local_mheg_ics_media_EndOfStreamCallback(void *context, int param)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;

	MhegIcsFunctionEnter(param);

	BSTD_UNUSED(context);

	if(s_tMhegIcsMediaInstance[param].playback == NULL)
	{
		MhegIcsError("[%s] Playback handle is null.\n", __func__);
		eDIError = DI_ERR_ERROR;
	}
	else
	{
		if ( NULL != s_tMhegIcsEventCallback[param] )
		{
			s_tMhegIcsEventCallback[param] ((HUINT32)param, DI_MEDIA_EVENT_ENDOFSTREAM, 0);
		}
		/* else - do nothing */
	}

	MhegIcsFunctionExit;

	return;
}

static DI_ERR_CODE local_mheg_ics_media_InstallFirstPts (HUINT32 unMediaId, HUINT32 unFirstPts)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;

	MhegIcsFunctionEnter(unMediaId);

	eDIError = local_mheg_ics_media_CheckValidMediaId(unMediaId);
	if(eDIError != DI_ERR_OK)
	{
		MhegIcsError("[%s] Error - Invalid Media Id.\n", __func__);
		return eDIError;
	}

	s_tMhegIcsMediaInstance[unMediaId].unFirstPts = unFirstPts;
	s_tMhegIcsMediaInstance[unMediaId].bPtsInstalled = TRUE;

	MhegIcsError("[%s] Debug - First Pts Installed : %u \n", __func__,unFirstPts);

	MhegIcsFunctionExit;

	return eDIError;
	
}



static void local_mheg_ics_media_FirstPtsCallback (HUINT32 unMediaId, HUINT32 unFirstPts)
{
	DI_ERR_CODE eDiRet = DI_ERR_OK;

	MhegIcsFunctionEnter(unMediaId);
	
	eDiRet = local_mheg_ics_media_CheckValidMediaId(unMediaId);
	if(eDiRet != DI_ERR_OK)
	{
		MhegIcsError("[%s] Error - Invalid Media Id.\n", __func__);
		return;
	}

	/****************************************************
	 * SEEK 이후에도 STARTED Event 는 emit 되어야 한다.
	 ****************************************************/
	if(s_tMhegIcsMediaInstance[unMediaId].bPtsInstalled == FALSE)
	{
		local_mheg_ics_media_InstallFirstPts(unMediaId, unFirstPts);
	}

	MhegIcsFunctionExit;
	return;
}


static DI_ERR_CODE local_mheg_ics_media_RegisterFirstPtsCB (HUINT32 unMediaId, DI_MEDIA_FirstPtsCallback_t firstPtsCallback)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;

	MhegIcsFunctionEnter(unMediaId);

	eDIError = local_mheg_ics_media_CheckValidMediaId(unMediaId);
	if(eDIError != DI_ERR_OK)
	{
		MhegIcsError("[%s] Error - Invalid Media Id.\n", __func__);
		return eDIError;
	}

	s_tMhegIcsEventFirstPtsCallback[unMediaId] = firstPtsCallback;

	MhegIcsFunctionExit;

	return eDIError;
	
}

static DI_ERR_CODE local_mheg_ics_media_UnregisterFirstPtsCB (HUINT32 unMediaId)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;

	MhegIcsFunctionEnter(unMediaId);

	eDIError = local_mheg_ics_media_CheckValidMediaId(unMediaId);
	if(eDIError != DI_ERR_OK)
	{
		MhegIcsError("[%s] Error - Invalid Media Id.\n", __func__);
		return eDIError;
	}

	s_tMhegIcsEventFirstPtsCallback[unMediaId] = NULL;

	MhegIcsFunctionExit;

	return eDIError;
	
}


/**
 * @brief		Nexus의 TrickSpeed를 DI에 정의된 Trick Speed로 변환한다.
 *
 * @param[in]	nTrickSpeed 			Nexus Trick Speed
 * @return		DI_MEDIA_TrickSpeed_t	Di Trick Speed
 * @see
 */
int local_mheg_ics_media_ConvertDITrickSpeedToNexus(DI_MEDIA_TrickSpeed_e nTrickSpeed)
{
	int eNexusTrickSpeed = 0;

	//MhegIcsFunctionEnter(nTrickSpeed);

	switch(nTrickSpeed)
	{
		case DI_MEDIA_TRICK_PAUSE:
			eNexusTrickSpeed = 0;
			break;
		/** Trick(Forward) */
		case DI_MEDIA_TRICK_1FFSTEP:
			eNexusTrickSpeed = 1000;
			break;
		case DI_MEDIA_TRICK_2FFSTEP:
			eNexusTrickSpeed = 2000;
			break;
		case DI_MEDIA_TRICK_3FFSTEP:
			eNexusTrickSpeed = 3000;
			break;
		case DI_MEDIA_TRICK_4FFSTEP:
			eNexusTrickSpeed = 4000;
			break;
		case DI_MEDIA_TRICK_5FFSTEP:
			eNexusTrickSpeed = 5000;
			break;
		case DI_MEDIA_TRICK_6FFSTEP:
			eNexusTrickSpeed = 6000;
			break;
		case DI_MEDIA_TRICK_7FFSTEP:
			eNexusTrickSpeed = 7000;
			break;
		case DI_MEDIA_TRICK_8FFSTEP:
			eNexusTrickSpeed = 8000;
			break;
		case DI_MEDIA_TRICK_9FFSTEP:
			eNexusTrickSpeed = 9000;
			break;
		case DI_MEDIA_TRICK_10FFSTEP:
			eNexusTrickSpeed = 10000;
			break;
		case DI_MEDIA_TRICK_11FFSTEP:
			eNexusTrickSpeed = 11000;
			break;
		case DI_MEDIA_TRICK_12FFSTEP:
			eNexusTrickSpeed = 12000;
			break;
		case DI_MEDIA_TRICK_13FFSTEP:
			eNexusTrickSpeed = 13000;
			break;
		case DI_MEDIA_TRICK_14FFSTEP:
			eNexusTrickSpeed = 16000;
			break;
		case DI_MEDIA_TRICK_15FFSTEP:
			eNexusTrickSpeed = 32000;
			break;
		case DI_MEDIA_TRICK_16FFSTEP:
			eNexusTrickSpeed = 64000;
			break;
		/** Trick(Rewind) */
		case DI_MEDIA_TRICK_1RWSTEP:
			eNexusTrickSpeed = -1000;
			break;
		case DI_MEDIA_TRICK_2RWSTEP:
			eNexusTrickSpeed = -2000;
			break;
		case DI_MEDIA_TRICK_3RWSTEP:
			eNexusTrickSpeed = -3000;
			break;
		case DI_MEDIA_TRICK_4RWSTEP:
			eNexusTrickSpeed = -4000;
			break;
		case DI_MEDIA_TRICK_5RWSTEP:
			eNexusTrickSpeed = -5000;
			break;
		case DI_MEDIA_TRICK_6RWSTEP:
			eNexusTrickSpeed = -6000;
			break;
		case DI_MEDIA_TRICK_7RWSTEP:
			eNexusTrickSpeed = -7000;
			break;
		case DI_MEDIA_TRICK_8RWSTEP:
			eNexusTrickSpeed = -8000;
			break;
		case DI_MEDIA_TRICK_9RWSTEP:
			eNexusTrickSpeed = -9000;
			break;
		case DI_MEDIA_TRICK_10RWSTEP:
			eNexusTrickSpeed = -10000;
			break;
		case DI_MEDIA_TRICK_11RWSTEP:
			eNexusTrickSpeed = -11000;
			break;
		case DI_MEDIA_TRICK_12RWSTEP:
			eNexusTrickSpeed = -12000;
			break;
		case DI_MEDIA_TRICK_13RWSTEP:
			eNexusTrickSpeed = -13000;
			break;
		case DI_MEDIA_TRICK_14RWSTEP:
			eNexusTrickSpeed = -16000;
			break;
		case DI_MEDIA_TRICK_15RWSTEP:
			eNexusTrickSpeed = -32000;
			break;
		case DI_MEDIA_TRICK_16RWSTEP:
			eNexusTrickSpeed = -64000;
			break;
		default:
			{
				MhegIcsError("[%s] Error - Invalid TrickSpeed:%d\n", __func__, nTrickSpeed);
				eNexusTrickSpeed = 0;
			}
			break;
	}

	//MhegIcsFunctionExit;

	return eNexusTrickSpeed;
}


static const batom_user s_MHEG_ICS_Probe_AtomUser =
{
	local_mheg_ics_media_ProbeFreeAtom,
	sizeof(void **)
};


static bmpeg2ts_parser_action
local_mheg_ics_media_GettingTSPayload(bmpeg2ts_parser_pid *pid, unsigned flags, batom_accum_t src, batom_cursor *cursor, size_t len)
{
	b_test_pid *test=(b_test_pid *)pid;

	if(flags&BMPEG2TS_PCR_FLAG) {
		test->pcr_count++;
	}
	test->ts_bytes += len;
	return bmpeg2pes_parser_feed(&test->pes, flags, src, cursor, len);
}

static void
local_mheg_ics_media_GettingPESPacket(void *packet_cnxt, batom_accum_t src, batom_cursor *payload, size_t len, const bmpeg2pes_atom_info *info)
{
	b_test_pid *test=(b_test_pid *)packet_cnxt;
	stMhegIcsMediaInfo *pMfp;

	pMfp = (stMhegIcsMediaInfo *)test->mfp_pointer;
	BSTD_UNUSED(src);
	test->pes_bytes += len;

	if(info->flags&BMPEG2PES_PTS_VALID) {
		test->pts_count++;
		if(pMfp)
		{
			if(test->pts_count==1)
			{
				pMfp->StreamInfo.bProbedFirstPts = TRUE;
				pMfp->StreamInfo.unProbeFirstPts = info->pts;
				MhegIcsDebug ("%s(%d) PES_ID %u pts_count %d ..... getting firstpts %u\n"
				,__FUNCTION__
				,__LINE__
				,info->pes_id
				,test->pts_count
				,pMfp->StreamInfo.unProbeFirstPts);
			}
		}
	}

	batom_cursor_skip(payload, len);
	return;
}


#ifdef DI_MHEG_ICS_DEBUG
static void local_mheg_ics_media_print_trackinfo(bmedia_probe_track		*track)
{
	HUINT32		 i;
	HUINT8 		*p = NULL;

	p = (HUINT8*)&track->info;

	DI_UART_Print("\n \t Track Info(Hexa) :");

	for(i = 0; i < sizeof(track->info); i++)
	{
		if((i % 16)== 0) DI_UART_Print("\n");
		DI_UART_Print(" %X", p[i]);			
	}	
	DI_UART_Print("\n");
}
#endif


/**
 * @brief		Stream Probe를 위해 Resource를 할당하고 Probe를 진행한다.
 *
 * @param[in]	pszStreamUrl 	Todo
 * @param[in]	pMfpInfo 		Todo
 * @return		void
 * @see			DI_MEDIA_Probe
 */
static DI_ERR_CODE local_mheg_ics_media_ProbeOpen (HUINT32 unMediaId, HUINT8 *pszStreamUrl, stMhegIcsMediaInfo *pMfpInfo)
{
	DI_ERR_CODE 				nRet = DI_ERR_OK;

	bmedia_probe_t 			probe = NULL;
	bmedia_probe_config 		probe_config;
#if 0	/* warning: assignment discards qualifiers from pointer target type */
	/* warning: cast discards qualifiers from pointer target type       */
	bmedia_probe_stream 		*stream = NULL;
	const bmedia_probe_track 	*track = NULL;
#else
	const bmedia_probe_stream 	*stream = NULL;
	bmedia_probe_track		*track = NULL;
#endif
	bfile_io_read_t  		fd=NULL;
	unsigned 			audio_track = 0, video_track = 0, track_no = 0;
	char 				stream_info[512] = {0,};
	bmedia_filter_cfg		filter_cfg;
	bstream_mpeg_type		stream_type = bstream_mpeg_type_unknown;
	bmedia_player_config		player_config;
	HUINT8				ucTotalAudioTrack=0;
	HUINT8				ucTotalVideoTrack=0;
	HUINT8				ucTotalSubtitleTrack = 0;
	HINT32				i=0, j=0;
	HUINT8				*pucData=NULL;
	HUINT32				Count_TS_192Type=0;
#ifdef CONFIG_VFIO
	int rc = 0;
	off_t lCurOffset = 0;
	size_t nReadSize = 0;
#else
    FILE				*pFile = NULL;
#endif
#if defined (USE_DRM)
	bool		bIsDrm = FALSE;
#endif

	MhegIcsFunctionEnter(unMediaId);

	pMfpInfo->fd			= NULL;
	pMfpInfo->seek			= BMEDIA_PLAYER_INVALID;
	pMfpInfo->seek2			= BMEDIA_PLAYER_INVALID;
	pMfpInfo->buffer		= NULL;
	pMfpInfo->buffer_cfg.buf	= NULL;

	/* normal decode */
	pMfpInfo->direction		= 0;
	pMfpInfo->time_scale		= BMEDIA_TIME_SCALE_BASE;

	pMfpInfo->StreamInfo.audio_codec = DI_MEDIA_AUDIO_FORMAT_NONE;
	pMfpInfo->StreamInfo.audio_stream_id = 0;
	pMfpInfo->StreamInfo.video_stream_id = 0;	/* VIDEO_STREAM_ID */
	pMfpInfo->StreamInfo.video_codec = DI_MEDIA_VIDEO_FORMAT_NONE;

	if(pszStreamUrl == NULL)
	{
		MhegIcsError ("[local_mheg_ics_media_ProbeOpen] Error - pszStreamUrl is null");
		goto error;
	}

	if((VK_strlen(pszStreamUrl) >MHEG_ICS_STREAM_URL_LEN) && (NULL == strstr((char *)pszStreamUrl,"/HMXCOOKIE=")))
	{
		MhegIcsError ("[local_mheg_ics_media_ProbeOpen] Error - pszStreamUrl Length is Over Stack[%d](%u)", MHEG_ICS_STREAM_URL_LEN, VK_strlen(pszStreamUrl));
		goto error;
	}
	else
	{
		MhegIcsData("[local_mheg_ics_media_ProbeOpen] pszStreamUrl=%s, Length[%u]\n", pszStreamUrl, VK_strlen(pszStreamUrl));
	}

#ifdef	CONFIG_VFIO
	{
		pMfpInfo->tHandle.pDnpUserData = (void*)unMediaId;
		rc = VFIO_Open ((char *)pszStreamUrl, "rb", &(pMfpInfo->tHandle));
		if (rc)
		{
			MhegIcsError ("[local_mheg_ics_media_ProbeOpen] Error - VFIO_Open()=%d", rc);
			goto error;
		}
		/* else { continue } */
	}
#else
	pMfpInfo->fin = fopen(pszStreamUrl, "rb");
	if (pMfpInfo->fin == NULL)
	{
		goto error;
	}
	/* else { continue } */
#endif

	pMfpInfo->factory = batom_factory_create(bkni_alloc, B_PUMP_DEMUX_FACTORY_ATOMS);
	if (pMfpInfo->factory == NULL)
	{
		goto error;
	}
	/* else { continue } */

	(void)bfile_async_init();

	/* search stream type */
	probe = bmedia_probe_create();
	if (probe == NULL)
	{
		goto error;
	}
	/* else { continue } */

#ifdef	CONFIG_VFIO
	fd = bfile_stdio_read_attach(pMfpInfo->tHandle);
#else
	fd = bfile_stdio_read_attach(pMfpInfo->fin);
#endif

	VK_MEM_Memset(&probe_config, 0, sizeof(probe_config));

	(void)bmedia_probe_default_cfg(&probe_config);
	probe_config.file_name		= (char *)pszStreamUrl;
	probe_config.type		= bstream_mpeg_type_unknown;
	probe_config.probe_es = false;
	probe_config.probe_payload = false;
	probe_config.probe_duration = false; /* ICS020 reduce request-times */

	/* Fixed warning: assignment discards qualifiers from pointer target type */
	/* const bmedia_probe_stream *bmedia_probe_parse(bmedia_probe_t probe, bfile_io_read_t fd, const bmedia_probe_config *config) */
	stream = bmedia_probe_parse(probe, fd, &probe_config);

	(void)bfile_stdio_read_detach(fd);

	if(stream == NULL)
	{
		if(NULL != strstr((char *)pszStreamUrl, "[DLNA]"))
		{
			pMfpInfo->opened	= true;
			(void)bmedia_probe_destroy(probe);
			return DI_ERR_OK;
		}

		MhegIcsError ("[%s] Error>> unknown stream format|\n",__FUNCTION__);
		if((NULL != strstr((char *)pszStreamUrl, ".mp3")) || (NULL != strstr((char *)pszStreamUrl, ".MP3")))
		{
			pMfpInfo->StreamInfo.stream_type = DI_MEDIA_MPEG_TYPE_ES;
			pMfpInfo->StreamInfo.nprograms = 1;
			pMfpInfo->StreamInfo.ntracks = 1;
			pMfpInfo->StreamInfo.video_pes_id = 0;
			pMfpInfo->StreamInfo.video_stream_id = 0;
			pMfpInfo->StreamInfo.video_codec = 0;
			pMfpInfo->StreamInfo.audio_pes_id = 192;
			pMfpInfo->StreamInfo.audio_stream_id = 1;
			pMfpInfo->StreamInfo.audio_codec = DI_MEDIA_AUDIO_FORMAT_MP3;
			pMfpInfo->StreamInfo.pcr_pid = 8191;

			pMfpInfo->opened	= true;
			(void)bmedia_probe_destroy(probe);
			return DI_ERR_OK;
		}
		else if((NULL != strstr((char *)pszStreamUrl, ".LPCM")) || (NULL != strstr((char *)pszStreamUrl, ".lpcm")))
		{
			pMfpInfo->StreamInfo.stream_type = DI_MEDIA_MPEG_TYPE_WAVE;
			pMfpInfo->StreamInfo.nprograms = 1;
			pMfpInfo->StreamInfo.ntracks = 1;
			pMfpInfo->StreamInfo.video_pes_id = 0;
			pMfpInfo->StreamInfo.video_stream_id = 0;
			pMfpInfo->StreamInfo.video_codec = 0;
			pMfpInfo->StreamInfo.audio_pes_id = 192;
			pMfpInfo->StreamInfo.audio_stream_id = 1;
			pMfpInfo->StreamInfo.audio_codec = DI_MEDIA_AUDIO_FORMAT_PCMWAVE;
			pMfpInfo->StreamInfo.pcr_pid = 8191;

			pMfpInfo->opened	= true;
			(void)bmedia_probe_destroy(probe);
			return DI_ERR_OK;
		}
		else if((NULL != strstr((char *)pszStreamUrl, ".PCM")) || (NULL != strstr((char *)pszStreamUrl, ".pcm")))
		{
			pMfpInfo->StreamInfo.stream_type = DI_MEDIA_MPEG_TYPE_WAVE;
			pMfpInfo->StreamInfo.nprograms = 1;
			pMfpInfo->StreamInfo.ntracks = 1;
			pMfpInfo->StreamInfo.video_pes_id = 0;
			pMfpInfo->StreamInfo.video_stream_id = 0;
			pMfpInfo->StreamInfo.video_codec = 0;
			pMfpInfo->StreamInfo.audio_pes_id = 192;
			pMfpInfo->StreamInfo.audio_stream_id = 1;
			pMfpInfo->StreamInfo.audio_codec = DI_MEDIA_AUDIO_FORMAT_PCMWAVE;
			pMfpInfo->StreamInfo.pcr_pid = 8191;

			pMfpInfo->opened	= true;
			(void)bmedia_probe_destroy(probe);
			return DI_ERR_OK;
		}

		goto error;
	}
	/* else { continue } */
//	int bmedia_stream_to_string_forDRM(const bmedia_probe_stream *stream, char *buf, size_t size, bool *pbIsDRM);
//(bool*)&pMfpInfo->StreamInfo.is_drm

#if defined (USE_DRM)
#if 1
	(void)bmedia_stream_to_string_forDRM(stream, stream_info, sizeof(stream_info), &bIsDrm);
	pMfpInfo->StreamInfo.is_drm = bIsDrm;
#else
	{
		// Pre-delivery license method with XML data.
		// Let's assume that the contents are always  encrypted. am i right?
		pMfpInfo->StreamInfo.is_drm = TRUE;
	}
#endif
#else
	(void)bmedia_stream_to_string(stream, stream_info, sizeof(stream_info));
#endif
	//MhegIcsData//
	MhegIcsError ("[%s] stream_info : %s|\n",__FUNCTION__,stream_info);
	MhegIcsError ("[%s] max_bitrate : %u|\n",__FUNCTION__,stream->max_bitrate);
	MhegIcsError ("[%s] index : %d|\n",__FUNCTION__,stream->index);
	MhegIcsError ("[%s] duration : %d|\n",__FUNCTION__,stream->duration);
	MhegIcsError ("[%s] nprograms : %d|\n",__FUNCTION__,stream->nprograms);
	MhegIcsError ("[%s] ntracks : %d|\n",__FUNCTION__,stream->ntracks);
	MhegIcsError ("[%s] type : %d|\n",__FUNCTION__,stream->type);
	MhegIcsError ("[%s] probe_id : %d|\n",__FUNCTION__,stream->probe_id);
	MhegIcsError ("[%s] is_drm : %d\n",__FUNCTION__, pMfpInfo->StreamInfo.is_drm);

	stream_type = stream->type;

	pMfpInfo->StreamInfo.max_bitrate	= stream->max_bitrate;
	pMfpInfo->StreamInfo.duration		= stream->duration;
	pMfpInfo->StreamInfo.nprograms		= stream->nprograms;
	pMfpInfo->StreamInfo.ntracks		= stream->ntracks;

	switch (stream_type)
	{
		case bstream_mpeg_type_avi:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_AVI;
			break;
		case bstream_mpeg_type_asf:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_ASF;
			break;
		case bstream_mpeg_type_vob:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_VOB;
			break;
		case bstream_mpeg_type_ts:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_TS;
			break;
		case bstream_mpeg_type_pes:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_PES;
			break;
		case bstream_mpeg_type_es:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_ES;
			break;
		case bstream_mpeg_type_bes:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_BES;
			break;
		case bstream_mpeg_type_dss_es:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_DSS_ES;
			break;
		case bstream_mpeg_type_dss_pes:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_DSS_PES;
			break;
		case bstream_mpeg_type_mpeg1:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_MPEG1;
			break;
		case bstream_mpeg_type_mp4:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_MP4;
			break;
		case bstream_mpeg_type_flv:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_FLV;
			break;
		case bstream_mpeg_type_mkv:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_MKV;
			break;
		case bstream_mpeg_type_wav:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_WAVE;
			break;
		default:
			pMfpInfo->StreamInfo.stream_type	= DI_MEDIA_MPEG_TYPE_UNKNOWN;
			break;
	}

#if defined(HDR_FOX_T2) || defined(HD_FOX_T2)
	if((pMfpInfo->StreamInfo.stream_type == DI_MEDIA_MPEG_TYPE_ASF) && (NULL != strstr((char *)pszStreamUrl, "http://")))
	{
		pMfpInfo->StreamInfo.duration		= stream->SendTime;
	}
#endif

	pMfpInfo->StreamInfo.pcr_pid	= 0x1fff; /* NULL_PID;*/

	for(audio_track=0,video_track=0,track_no=1,track=BLST_SQ_FIRST(&stream->tracks);track;track=BLST_SQ_NEXT(track, link),track_no++)
	{
		MhegIcsData ("track->number = %d\n", track->number);

		switch(track->type)
		{
			case bmedia_track_type_audio:
				if(ucTotalAudioTrack < DI_MEDIA_DIVX_MAX_AUDIO_TRACK)
				{
					MhegIcsData ("audio track %u codec:0x%x channel count %d sample size %d bitrate %d smaple rate %d, lang(%s)\n",
									track->number, track->info.audio.codec, track->info.audio.channel_count, track->info.audio.sample_size, 
									track->info.audio.bitrate, track->info.audio.sample_rate, track->info.audio.languageCode);
#ifdef DI_MHEG_ICS_DEBUG					
					local_mheg_ics_media_print_trackinfo(track);
#endif

					pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_pes_id = DI_MEDIA_AUDIO_PES_ID;
					pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_stream_id = track->number;
					VK_MEM_Memcpy(pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].uacAudioLang, track->info.audio.languageCode, sizeof(track->info.audio.languageCode));

					switch (track->info.audio.codec)
					{
						case baudio_format_mpeg:
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_MPEG;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_MPEG;
							audio_track = track->number;
							break;
						case baudio_format_mp3:
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_MP3;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_MP3;
							audio_track = track->number;
							break;
						case baudio_format_aac:
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_AAC;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_AAC;
							audio_track = track->number;
							break;
						case baudio_format_aac_plus:
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_AAC_PLUS;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_AAC_PLUS;
							audio_track = track->number;
							break;
						case baudio_format_aac_plus_adts:
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_AAC_PLUS_ADTS;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_AAC_PLUS_ADTS;
							audio_track = track->number;
							break;
						case baudio_format_ac3:
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_AC3;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_AC3;
							audio_track = track->number;
							break;
						case baudio_format_ac3_plus:
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_AC3_PLUS;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_AC3_PLUS;
							audio_track = track->number;
							break;
						case baudio_format_dts:
#if 0		/* 현재 DTS Codec은 지원하지 않습니다. */
							pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_DTS;
							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_DTS;
#else
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_NONE;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_NONE;
#endif
							break;
						case baudio_format_lpcm_hddvd:
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_LPCM_HD_DVD;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_LPCM_HD_DVD;
							audio_track = track->number;
							break;
						case baudio_format_lpcm_bluray:
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_LPCM_BLUERAY;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_LPCM_BLUERAY;
							audio_track = track->number;
							break;
						case baudio_format_dts_hd:
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_DTS_HD;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_DTS_HD;
							audio_track = track->number;
							break;
						case baudio_format_wma_std:
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_WMA_STD;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_WMA_STD;
							audio_track = track->number;
							break;
						case baudio_format_wma_pro:
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_WMA_PRO;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_WMA_PRO;
							audio_track = track->number;
							break;
						case baudio_format_lpcm_dvd:
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_LPCM_DVD;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_LPCM_DVD;
							audio_track = track->number;
							break;
						case baudio_format_pcm:
							if((ucTotalAudioTrack == 0) || ((ucTotalAudioTrack != 0) && (pMfpInfo->StreamInfo.audio_codec == DI_MEDIA_AUDIO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_PCM;
							}

							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_PCM;
							audio_track = track->number;
							break;
						default:
							if(ucTotalAudioTrack == 0)
							{
								pMfpInfo->StreamInfo.audio_codec	= DI_MEDIA_AUDIO_FORMAT_NONE;
							}
							pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].audio_codec = DI_MEDIA_AUDIO_FORMAT_NONE;
							break;
					}

					if((pMfpInfo->StreamInfo.audio_codec != DI_MEDIA_AUDIO_FORMAT_NONE) && (pMfpInfo->StreamInfo.audio_stream_id == 0))
					{
						pMfpInfo->StreamInfo.audio_stream_id	= audio_track;	/* AUDIO_STREAM_ID */
					}

					pMfpInfo->StreamInfo.audio_pes_id	= DI_MEDIA_AUDIO_PES_ID;

					if(pMfpInfo->StreamInfo.stream_type == DI_MEDIA_MPEG_TYPE_AVI)
					{
						/* Removed warning: cast discards qualifiers from pointer target type */
						/* Caution to const declared vars and casting */
						VK_strncpy(pMfpInfo->StreamInfo.stAudioTrack[ucTotalAudioTrack].uacAudioLang, ((bavi_probe_track *)track)->language, 16);
					}

					ucTotalAudioTrack++;
				}
				break;
			case bmedia_track_type_video:
				if(ucTotalVideoTrack < DI_MEDIA_DIVX_MAX_VIDEO_TRACK)
				{
					MhegIcsData ("video track %u codec:0x%x width %d height %d\n", track->number, track->info.video.codec, track->info.video.width, track->info.video.height);
#ifdef DI_MHEG_ICS_DEBUG					
					local_mheg_ics_media_print_trackinfo(track);
#endif
					

					pMfpInfo->StreamInfo.stVideoTrack[ucTotalVideoTrack].video_pes_id = DI_MEDIA_VIDEO_PES_ID;
					pMfpInfo->StreamInfo.stVideoTrack[ucTotalVideoTrack].video_stream_id = track->number;

					switch (track->info.video.codec)
					{
						case bvideo_codec_divx_311:
							if((ucTotalVideoTrack == 0) || ((ucTotalVideoTrack != 0) && (pMfpInfo->StreamInfo.video_codec == DI_MEDIA_VIDEO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.video_codec	= DI_MEDIA_VIDEO_FORMAT_DIVX_311;
							}
							pMfpInfo->StreamInfo.stVideoTrack[ucTotalVideoTrack].video_codec = DI_MEDIA_VIDEO_FORMAT_DIVX_311;
							video_track = track->number;
							break;
						case bvideo_codec_mpeg1:
							if((ucTotalVideoTrack == 0) || ((ucTotalVideoTrack != 0) && (pMfpInfo->StreamInfo.video_codec == DI_MEDIA_VIDEO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.video_codec	= DI_MEDIA_VIDEO_FORMAT_MPEG1;
							}
							pMfpInfo->StreamInfo.stVideoTrack[ucTotalVideoTrack].video_codec = DI_MEDIA_VIDEO_FORMAT_MPEG1;
							video_track = track->number;
							break;
						case bvideo_codec_mpeg2:
							if((ucTotalVideoTrack == 0) || ((ucTotalVideoTrack != 0) && (pMfpInfo->StreamInfo.video_codec == DI_MEDIA_VIDEO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.video_codec	= DI_MEDIA_VIDEO_FORMAT_MPEG2;
							}
							pMfpInfo->StreamInfo.stVideoTrack[ucTotalVideoTrack].video_codec = DI_MEDIA_VIDEO_FORMAT_MPEG2;
							video_track = track->number;
							break;
						case bvideo_codec_mpeg4_part2:
							if((ucTotalVideoTrack == 0) || ((ucTotalVideoTrack != 0) && (pMfpInfo->StreamInfo.video_codec == DI_MEDIA_VIDEO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.video_codec	= DI_MEDIA_VIDEO_FORMAT_MPEG4Part2;
							}
							pMfpInfo->StreamInfo.stVideoTrack[ucTotalVideoTrack].video_codec = DI_MEDIA_VIDEO_FORMAT_MPEG4Part2;
							video_track = track->number;
							break;
						case bvideo_codec_h263:
							if((ucTotalVideoTrack == 0) || ((ucTotalVideoTrack != 0) && (pMfpInfo->StreamInfo.video_codec == DI_MEDIA_VIDEO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.video_codec	= DI_MEDIA_VIDEO_FORMAT_H263;
							}
							pMfpInfo->StreamInfo.stVideoTrack[ucTotalVideoTrack].video_codec = DI_MEDIA_VIDEO_FORMAT_H263;
							video_track = track->number;
							break;
						case bvideo_codec_h264:
							if((ucTotalVideoTrack == 0) || ((ucTotalVideoTrack != 0) && (pMfpInfo->StreamInfo.video_codec == DI_MEDIA_VIDEO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.video_codec	= DI_MEDIA_VIDEO_FORMAT_H264;
							}
							pMfpInfo->StreamInfo.stVideoTrack[ucTotalVideoTrack].video_codec = DI_MEDIA_VIDEO_FORMAT_H264;
							video_track = track->number;
							break;
						case bvideo_codec_vc1:
							if((ucTotalVideoTrack == 0) || ((ucTotalVideoTrack != 0) && (pMfpInfo->StreamInfo.video_codec == DI_MEDIA_VIDEO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.video_codec	= DI_MEDIA_VIDEO_FORMAT_VC1;
							}
							pMfpInfo->StreamInfo.stVideoTrack[ucTotalVideoTrack].video_codec = DI_MEDIA_VIDEO_FORMAT_VC1;
							video_track = track->number;
							break;
						case bvideo_codec_vc1_sm:
							if((ucTotalVideoTrack == 0) || ((ucTotalVideoTrack != 0) && (pMfpInfo->StreamInfo.video_codec == DI_MEDIA_VIDEO_FORMAT_NONE)))
							{
								pMfpInfo->StreamInfo.video_codec	= DI_MEDIA_VIDEO_FORMAT_VC1SimpleMain;
							}
							pMfpInfo->StreamInfo.stVideoTrack[ucTotalVideoTrack].video_codec = DI_MEDIA_VIDEO_FORMAT_VC1SimpleMain;
							video_track = track->number;
							break;
						default:
							if(ucTotalVideoTrack == 0)
							{
								pMfpInfo->StreamInfo.video_codec	= DI_MEDIA_VIDEO_FORMAT_NONE;
							}
							pMfpInfo->StreamInfo.stVideoTrack[ucTotalVideoTrack].video_codec = DI_MEDIA_VIDEO_FORMAT_NONE;
							break;
					}

					if((pMfpInfo->StreamInfo.video_codec != DI_MEDIA_VIDEO_FORMAT_NONE) && (pMfpInfo->StreamInfo.video_stream_id == 0))
					{
						pMfpInfo->StreamInfo.video_stream_id	= video_track;	/* VIDEO_STREAM_ID */
					}

					pMfpInfo->StreamInfo.video_pes_id	= DI_MEDIA_VIDEO_PES_ID;

					if(pMfpInfo->StreamInfo.video_codec != DI_MEDIA_VIDEO_FORMAT_NONE)
					{
						pMfpInfo->StreamInfo.usVideoWidth = track->info.video.width;
						pMfpInfo->StreamInfo.usVideoHeight = track->info.video.height;
					}

					ucTotalVideoTrack++;
				}
				break;
			case bmedia_track_type_pcr:
				pMfpInfo->StreamInfo.pcr_pid	= track->number;
				break;

			case bmedia_track_type_dvb_subtitle:
				MhegIcsData ("dvb subtitle track %u type:0x%x compositionPageId %d ancillaryPageId %d, lang(%s)\n",
								track->number, track->info.dvb_subtitle.type, track->info.dvb_subtitle.compositionPageId,
								track->info.dvb_subtitle.ancillaryPageId, track->info.dvb_subtitle.languageCode);
#ifdef DI_MHEG_ICS_DEBUG					
				local_mheg_ics_media_print_trackinfo(track);
#endif			
				pMfpInfo->StreamInfo.stSubtitleTrack[ucTotalSubtitleTrack].subtitle_stream_id = track->number;
				pMfpInfo->StreamInfo.stSubtitleTrack[ucTotalSubtitleTrack].ucType = track->info.dvb_subtitle.type;				
				pMfpInfo->StreamInfo.stSubtitleTrack[ucTotalSubtitleTrack].usComposition_page_id = (HUINT16)track->info.dvb_subtitle.compositionPageId;				
				pMfpInfo->StreamInfo.stSubtitleTrack[ucTotalSubtitleTrack].usAncillary_page_id = (HUINT16)track->info.dvb_subtitle.ancillaryPageId;
				VK_MEM_Memcpy(pMfpInfo->StreamInfo.stSubtitleTrack[ucTotalSubtitleTrack].ucSubtitleLang, track->info.dvb_subtitle.languageCode, sizeof(track->info.dvb_subtitle.languageCode));
				ucTotalSubtitleTrack++;
				break;

			case bmedia_track_type_other:
#ifdef DI_MHEG_ICS_DEBUG					
				local_mheg_ics_media_print_trackinfo(track);
#endif			
				break;

			default:
				break;
		}
	}

	MhegIcsData ("[%s] Detected format:%u video:%u audio:%u|\n",__FUNCTION__, pMfpInfo->StreamInfo.stream_type, pMfpInfo->StreamInfo.video_stream_id, pMfpInfo->StreamInfo.audio_stream_id);
	MhegIcsData ("[%s] Total Audio Track:%u Total Video Track:%u|\n",__FUNCTION__, ucTotalAudioTrack, ucTotalVideoTrack);

	pMfpInfo->StreamInfo.ucTotalAudioTrack = ucTotalAudioTrack;
	pMfpInfo->StreamInfo.ucTotalVideoTrack = ucTotalVideoTrack;
	pMfpInfo->StreamInfo.ucTotalSubtitleTrack = ucTotalSubtitleTrack;

	(void)bmedia_probe_stream_free(probe, stream);
	(void)bmedia_probe_destroy(probe);
	stream	= NULL;
	probe	= NULL;

	if((pMfpInfo->StreamInfo.video_codec==DI_MEDIA_VIDEO_FORMAT_NONE ) && (ucTotalVideoTrack >0))
	{
		MhegIcsError ("Error>> Cannot support video format\n");
		goto error;
	}
	
	if((ucTotalAudioTrack == 0 ) && (ucTotalVideoTrack == 0))
	{
		MhegIcsError ("Error>> Cannot support video format\n");
		goto error;
	}
	
#ifdef	CONFIG_VFIO
	if(pMfpInfo->StreamInfo.stream_type == DI_MEDIA_MPEG_TYPE_TS) 
	{
		rc = VFIO_Tell(pMfpInfo->tHandle, &lCurOffset);
		rc |= VFIO_Seek(pMfpInfo->tHandle, 0, 0);
		if (rc)
		{
			MhegIcsError ("%s(%d) Error>	VFIO_Tell or VFIO_Seek()=%d",__FUNCTION__,__LINE__, rc);
			pMfpInfo->StreamInfo.stream_type = DI_MEDIA_MPEG_TYPE_TS;
		}
		else
		{
			pucData = DD_MEM_Alloc(MHEG_ICS_TSTYPE_SEARCH_LEN);
			if (pucData == NULL)
			{
				MhegIcsError ("Error>> Fail heap allocation (%s)\n", pszStreamUrl);

				pMfpInfo->StreamInfo.stream_type = DI_MEDIA_MPEG_TYPE_TS;
			}
			else
			{
				VK_MEM_Memset(pucData, 0x0, (MHEG_ICS_TSTYPE_SEARCH_LEN));
				(void)VFIO_Read(pMfpInfo->tHandle, pucData, 1, MHEG_ICS_TSTYPE_SEARCH_LEN, &nReadSize);
				if(nReadSize != MHEG_ICS_TSTYPE_SEARCH_LEN)
				{
					MhegIcsError ("Error>> Fail fread(%s)\n", pszStreamUrl);
					if(pucData != NULL)
					{
						DD_MEM_Free(pucData);
						pucData = NULL;
					}

					pMfpInfo->StreamInfo.stream_type = DI_MEDIA_MPEG_TYPE_TS;
				}
				else
				{
					/* TS파일에 앞에 정보가 들어간 경우를 판단하기 위해 2K는 TS Packet인지 검토합니다. */
					for(i=0; i<MHEG_ICS_TSINFO_LEN; i++)
					{
						if(pucData[i] == MEDIA_MPEG2TS_PKT_SYNC)
						{
							for(j=1;j<=5;j++)
							{
								/* TS파일이 192packet인지 188packet인지 검토합니다. */
								if(pucData[i+(j*MEDIA_MPEG2TS_192PKT_LEN)] == MEDIA_MPEG2TS_PKT_SYNC)
								{
									Count_TS_192Type = Count_TS_192Type + 1;
									if(Count_TS_192Type == 4)
									{
										break;
									}
								}
							}

							if(Count_TS_192Type == 4)
							{
								break;
							}
							else
							{
								Count_TS_192Type = 0;
								i = i + MEDIA_MPEG2TS_188PKT_LEN;
							}
						}
					}

					if(Count_TS_192Type == 4)
					{
						MhegIcsError ("##### [%s] DI_MEDIA_MPEG_TYPE_TS_192 #####\n", __FUNCTION__);
						pMfpInfo->StreamInfo.stream_type = DI_MEDIA_MPEG_TYPE_TS_192;
					}
					else
					{
						MhegIcsError ("##### [%s] DI_MEDIA_MPEG_TYPE_TS #####\n", __FUNCTION__);
						pMfpInfo->StreamInfo.stream_type = DI_MEDIA_MPEG_TYPE_TS;
					}

					if(pucData != NULL)
					{
						DD_MEM_Free(pucData);
						pucData = NULL;
					}

					(void)VFIO_Seek(pMfpInfo->tHandle, lCurOffset, 0);
				}
			}
		}	
	}
#else
	if((pMfpInfo->StreamInfo.stream_type == DI_MEDIA_MPEG_TYPE_TS) && (NULL == strstr((char *)pszStreamUrl, "http://")) && (NULL == strstr((char *)pszStreamUrl, "https://")) &&
			(NULL == strstr((char *)pszStreamUrl, "mms://")) && (NULL == strstr((char *)pszStreamUrl, "rtsp://")))
	{
		pFile = fopen((char *)pszStreamUrl, "rb");
	 	if(pFile == NULL)
		{
			MhegIcsError ("Error>> Fail fopen(%s)\n", pszStreamUrl);
			goto error;
		}

		pucData = DD_MEM_Alloc(MHEG_ICS_TSTYPE_SEARCH_LEN);
		if (pucData == NULL)
		{
			MhegIcsError ("Error>> Fail heap allocation (%s)\n", pszStreamUrl);

			fclose(pFile);

			goto error;
		}

		VK_MEM_Memset(pucData, 0x0, (MHEG_ICS_TSTYPE_SEARCH_LEN));
		if(fread(pucData, 1, MHEG_ICS_TSTYPE_SEARCH_LEN, pFile) != MHEG_ICS_TSTYPE_SEARCH_LEN)
		{
			MhegIcsError ("Error>> Fail fread(%s)\n", pszStreamUrl);
			if(pucData != NULL)
			{
				DD_MEM_Free(pucData);
				pucData = NULL;
			}

			fclose(pFile);

			goto error;
		}
		else
		{
			/* TS파일에 앞에 정보가 들어간 경우를 판단하기 위해 2K는 TS Packet인지 검토합니다. */
			for(i=0; i<MHEG_ICS_TSINFO_LEN; i++)
			{
				if(pucData[i] == MEDIA_MPEG2TS_PKT_SYNC)
				{
					for(j=1;j<=5;j++)
					{
						/* TS파일이 192packet인지 188packet인지 검토합니다. */
						if(pucData[i+(j*MEDIA_MPEG2TS_192PKT_LEN)] == MEDIA_MPEG2TS_PKT_SYNC)
						{
							Count_TS_192Type = Count_TS_192Type + 1;
							if(Count_TS_192Type == 4)
							{
								break;
							}
						}
					}

					if(Count_TS_192Type == 4)
					{
						break;
					}
					else
					{
						Count_TS_192Type = 0;
						i = i + MEDIA_MPEG2TS_188PKT_LEN;
					}
				}
			}

			if(Count_TS_192Type == 4)
			{
				MhegIcsError ("##### [%s] DI_MEDIA_MPEG_TYPE_TS_192 #####\n", __FUNCTION__);
				pMfpInfo->StreamInfo.stream_type = DI_MEDIA_MPEG_TYPE_TS_192;
			}
			else
			{
				MhegIcsError ("##### [%s] DI_MEDIA_MPEG_TYPE_TS #####\n", __FUNCTION__);
				pMfpInfo->StreamInfo.stream_type = DI_MEDIA_MPEG_TYPE_TS;
			}

			if(pucData != NULL)
			{
				DD_MEM_Free(pucData);
				pucData = NULL;
			}

			fclose(pFile);
		}
	}
#endif
	if (pMfpInfo->StreamInfo.stream_type == DI_MEDIA_MPEG_TYPE_UNKNOWN)
	{
		nRet = DI_ERR_INVALID_PARAM;
		goto error;
	}
#if 1 /* First PTS Detection */
	else if (pMfpInfo->StreamInfo.stream_type == DI_MEDIA_MPEG_TYPE_TS
	 || pMfpInfo->StreamInfo.stream_type == DI_MEDIA_MPEG_TYPE_TS_192 )
	{	
#if 1
#if 1 	/* workaround : junsy */
		/* 이 기능은 추후 DI_IPTUNER_Probe 에서 drm content 들에 대한 firstpts 추출이 완료되는대로
		 관련 함수 및 parameter 들 삭제 필요함.  */
		if(pMfpInfo->StreamInfo.ca_pid != 0)
		{
			MhegIcsDebug ("%s(%d) we can't extract the first pts about this stream because it is encrypted content."
			,__FUNCTION__,__LINE__);
		}
		else
#endif
		{
			b_test_pid test_pid;
			bmpeg2ts_parser_t parser;
			bmpeg2ts_parser_cfg parser_cfg;

			off_t bytes_parsed;
			off_t off;
//			unsigned i;
			const size_t block_size=4*BIO_BLOCK_SIZE;
			const size_t buf_size=128*block_size;

#ifdef CONFIG_VFIO
			fd = bfile_stdio_read_attach(pMfpInfo->tHandle);
#else
			fd = bfile_stdio_read_attach(pMfpInfo->fin);
#endif
			if(fd == NULL)
			{
				MhegIcsError ("%s(%d) Error> bfile_stdio_read_attach fail!\n",__FUNCTION__,__LINE__);
				goto error;
			}

			pMfpInfo->pipe_media= batom_pipe_create(pMfpInfo->factory);
			if (pMfpInfo->pipe_media == NULL)
			{
				MhegIcsError ("%s(%d) Error> batom_pipe_create fail!\n",__FUNCTION__,__LINE__);
				bfile_stdio_read_detach(fd);
				goto error;
			}

			bmpeg2ts_parser_default_cfg(&parser_cfg);
			if(pMfpInfo->StreamInfo.stream_type == DI_MEDIA_MPEG_TYPE_TS_192)
			{
				parser_cfg.header_size = 4;
			}
			parser = bmpeg2ts_parser_create(pMfpInfo->factory, &parser_cfg);	
			if(parser == NULL) 
			{
				MhegIcsError ("%s(%d) Error> bmpeg2ts_parser_create fail!\n",__FUNCTION__,__LINE__); 
				bfile_stdio_read_detach(fd); 
				goto error;
			}
			if(parser == NULL)
			{
				MhegIcsError ("%s(%d) Error> bmpeg2ts_parser_create fail!\n",__FUNCTION__,__LINE__);
				bfile_stdio_read_detach(fd);
				goto error;
			}
			test_pid.pcr_count = 0;
			test_pid.ts_bytes = 0;
			test_pid.pts_count = 0;
			test_pid.pes_bytes = 0;

#if 1
			bmpeg2ts_parser_pid_init (&test_pid.ts_pid, pMfpInfo->StreamInfo.video_stream_id);
#else
			bmpeg2ts_parser_pid_init (&test_pid.ts_pid, pMfpInfo->StreamInfo.audio_stream_id);
#endif

			bfile_buffer_default_cfg(&pMfpInfo->buffer_cfg);

			pMfpInfo->buffer_cfg.buf_len = buf_size;
			pMfpInfo->buffer_cfg.buf = DD_MEM_Alloc(pMfpInfo->buffer_cfg.buf_len);
			if (pMfpInfo->buffer_cfg.buf == NULL)
			{
				MhegIcsError ("%s(%d) Error>> DD_MEM_Alloc fail \n",__FUNCTION__,__LINE__);			
				bmpeg2ts_parser_destroy(parser); 
				bfile_stdio_read_detach(fd);
				goto error;
			}

			pMfpInfo->buffer_cfg.fd = fd;
			pMfpInfo->buffer_cfg.nsegs = buf_size/block_size;

			pMfpInfo->buffer = bfile_buffer_create(pMfpInfo->factory, &pMfpInfo->buffer_cfg);

			if (pMfpInfo->buffer == NULL)
			{
				MhegIcsError ("%s(%d) Error>> bfile_buffer_create fail \n",__FUNCTION__,__LINE__);			
				bmpeg2ts_parser_destroy(parser); 
				bfile_stdio_read_detach(fd); 
				goto error;
			}

			rc = bmpeg2pes_parser_init(pMfpInfo->factory, &test_pid.pes, BMPEG2PES_ID_ANY);
			if(rc!=0)
			{
				MhegIcsError ("%s(%d) Error>> bmpeg2pes_parser_init fail\n",__FUNCTION__,__LINE__);
				bmpeg2ts_parser_destroy(parser); 
				bfile_stdio_read_detach(fd);				
				goto error;
			}

			test_pid.mfp_pointer = (void*)pMfpInfo;
			test_pid.pes.packet_cnxt = &test_pid;
			test_pid.pes.packet = local_mheg_ics_media_GettingPESPacket;
			for(bytes_parsed=0,i=0;i<1;i++) 
			{
				test_pid.ts_pid.payload = local_mheg_ics_media_GettingTSPayload;
				bmpeg2ts_parser_add_pid(parser, &test_pid.ts_pid);
				for(off=0;/* off<1024*1024*1024 */;) {
					batom_t atom;
					bfile_buffer_result result;
					size_t atom_len;
					size_t feed_len;

					atom = bfile_buffer_read(pMfpInfo->buffer, off, block_size, &result);
					if(!atom) {
						break;
					}
					atom_len = batom_len(atom);
					off += atom_len;
					batom_pipe_push(pMfpInfo->pipe_media, atom);
					feed_len = bmpeg2ts_parser_feed(parser, pMfpInfo->pipe_media);
					if(feed_len!=atom_len) 
					{
						MhegIcsDebug ("%s(%d) Info> %u %u %lld",__FUNCTION__,__LINE__, feed_len, block_size, off);
					}

					BDBG_ASSERT(feed_len==atom_len);

					if(test_pid.pts_count>1) 
					{
						MhegIcsDebug(" First PTS installed successfully in MFP structure #1 \n");
						break;
					}

					if(pMfpInfo->StreamInfo.max_bitrate != 0)
					{
						if(off > (pMfpInfo->StreamInfo.max_bitrate/8)*5) /* Read한 Size가 Content bitrate 5초분량 보다 큰 경우 Fail로 Return함 */ 
						{
							break;	
						}
					}
					else
						break;						
				}

				if(test_pid.pts_count>1) 
				{
					MhegIcsDebug(" First PTS installed successfully in MFP structure #2\n");
					break;
				}

				bytes_parsed += off;
				batom_pipe_flush(pMfpInfo->pipe_media);
				bmpeg2ts_parser_reset(parser);
				bmpeg2pes_parser_reset(&test_pid.pes);
			}
			bmpeg2ts_parser_destroy(parser);
			bmpeg2pes_parser_shutdown(&test_pid.pes);
			bfile_stdio_read_detach(fd);
#if 0 /* release routine for reference */
			bfile_buffer_destroy(pMfpInfo->buffer);
			batom_pipe_destroy(pMfpInfo->pipe_media);
			bfile_stdio_read_detach(fd);
#ifdef	__USE_VFIO__
			if ( pMfpInfo->tHandle.ucAvailable )
			{
				(void)VFIO_Close (pMfpInfo->tHandle);
			}
			/* else { continue } */
#else
			if (pMfpInfo->fin != NULL)
			{
				(void)fclose (pMfpInfo->fin);
				pMfpInfo->fin	= NULL;
			}
			/* else { continue } */
#endif
			batom_factory_destroy(pMfpInfo->factory);
#endif /* for reference */
			/**************************************
			 * END OF FIRSTPTS Patch 
			 **************************************/
		}
#endif		
		pMfpInfo->no_player 			= true;
		pMfpInfo->StreamInfo.support_trick	= TRUE;
		/* 2008.07.08 - by Dylan, Check the seek support */
		pMfpInfo->StreamInfo.support_seek 	= TRUE;
	}
#endif
	else
	{
		pMfpInfo->pipe_media= batom_pipe_create(pMfpInfo->factory);
		if (pMfpInfo->pipe_media == NULL)
		{
			goto error;
		}
		/* else { continue } */

		(void)bmedia_filter_default_cfg(&filter_cfg);
		filter_cfg.eos_len	= sizeof(s_eos_data);
		filter_cfg.eos_data	= s_eos_data;
		pMfpInfo->filter	= bmedia_filter_create(pMfpInfo->factory, bkni_alloc, &filter_cfg);
		if (pMfpInfo->filter == NULL)
		{
			goto error;
		}
		/* else { continue } */

		if((stream_type == bstream_mpeg_type_mp4) || (stream_type == bstream_mpeg_type_mkv) || (stream_type == bstream_mpeg_type_es))
		{
			pMfpInfo->pipe_pes = bmedia_filter_start(pMfpInfo->filter, bstream_mpeg_type_pes);
		}
		else
		{
			pMfpInfo->pipe_pes = bmedia_filter_start(pMfpInfo->filter, stream_type);
		}

		if (pMfpInfo->pipe_pes == NULL)
		{
			goto error;
		}
		/* else { continue } */

		if(pMfpInfo->StreamInfo.video_stream_id)
		{
#if defined(NEXUS_VERSION) && NEXUS_VERSION >= 700
			bmedia_stream_cfg stream_cfg;
			bmedia_stream_default_cfg(&stream_cfg);
			pMfpInfo->video = bmedia_filter_stream_open (pMfpInfo->filter, pMfpInfo->StreamInfo.video_stream_id, pMfpInfo->StreamInfo.video_pes_id, &stream_cfg);
#else
			pMfpInfo->video = bmedia_filter_stream_open (pMfpInfo->filter, pMfpInfo->StreamInfo.video_stream_id, pMfpInfo->StreamInfo.video_pes_id);
#endif
			if (pMfpInfo->video == NULL)
			{
				goto error;
			}
			/* else { continue } */
		}
		/* else { continue } */

		if(pMfpInfo->StreamInfo.audio_stream_id)
		{
#if defined(NEXUS_VERSION) && NEXUS_VERSION >= 700
			bmedia_stream_cfg stream_cfg;
			bmedia_stream_default_cfg(&stream_cfg);
			pMfpInfo->audio = bmedia_filter_stream_open (pMfpInfo->filter, pMfpInfo->StreamInfo.audio_stream_id, pMfpInfo->StreamInfo.audio_pes_id, &stream_cfg);
#else
			pMfpInfo->audio = bmedia_filter_stream_open (pMfpInfo->filter, pMfpInfo->StreamInfo.audio_stream_id, pMfpInfo->StreamInfo.audio_pes_id);
#endif
			if (pMfpInfo->audio == NULL)
			{
				goto error;
			}
			/* else { continue } */
		}
		/* else { continue } */

#ifdef	CONFIG_VFIO
		pMfpInfo->fd = bfile_stdio_read_attach(pMfpInfo->tHandle);
#else
		pMfpInfo->fd = bfile_stdio_read_attach(pMfpInfo->fin);
#endif

		(void)bfile_buffer_default_cfg(&pMfpInfo->buffer_cfg);
#if 1	/* Nexus에서 사용하는 Buffer를 Check하여 적용해야함. 현재는 32*15*4096으로 됨. */
		/* buf_len은 조정가능한 사이즈로 현재는 Default를 활용함. */
		pMfpInfo->buffer_cfg.buf_len = MHEG_MFP_FEED_TOTAL_BUF_SIZE;
		pMfpInfo->buffer_cfg.buf = DD_MEM_Alloc(pMfpInfo->buffer_cfg.buf_len);
#else
		pMfpInfo->buffer_cfg.buf = DD_MEM_Alloc(DI_MFP_FEED_BLOCK_BUF_SIZE);
#endif
		if (pMfpInfo->buffer_cfg.buf == NULL)
		{
			MhegIcsError ("Error>> Cannot allocate memory\n");
			goto error;
		}

		pMfpInfo->async				= true;
		pMfpInfo->buffer_cfg.async		= true;
		pMfpInfo->buffer_cfg.async_read		= bfile_async_read;
		pMfpInfo->buffer_cfg.fd			= pMfpInfo->fd;
		pMfpInfo->buffer 			= bfile_buffer_create(pMfpInfo->factory, &pMfpInfo->buffer_cfg);

		if (pMfpInfo->buffer == NULL)
		{
			MhegIcsError ("Error>> bfile_buffer_create\n");
			goto error;
		}
		/* else { continue } */

		(void)bmedia_player_init_stream(&pMfpInfo->stream);
		pMfpInfo->stream.format		= stream_type;
		pMfpInfo->stream.master		= pMfpInfo->StreamInfo.video_stream_id;
		pMfpInfo->stream.other[0]	= pMfpInfo->StreamInfo.audio_stream_id;

		if(stream_type == bstream_mpeg_type_ts || (pMfpInfo->StreamInfo.video_stream_id && (stream_type == bstream_mpeg_type_vob || stream_type == bstream_mpeg_type_pes)))
		{
			/* 녹화한 Content에 대한 Index파일(Ex> ~~.nav)이 존재하는 경우 이 항목은 False가 되어야 함. */
			pMfpInfo->stream.without_index   = true;
		}
		else
		{
			pMfpInfo->stream.without_index	= false;
		}

		(void)bmedia_player_init_config(&player_config);
		player_config.buffer 		= pMfpInfo->buffer;

		if (pMfpInfo->async)
		{
			player_config.cntx		= pMfpInfo;
			player_config.atom_ready	= local_mheg_ics_media_ProbeAsync;
		}
		/* else { continue } */

		if(pMfpInfo->StreamInfo.video_stream_id && (stream_type == bstream_mpeg_type_vob || stream_type == bstream_mpeg_type_pes))
		{
			if(pMfpInfo->factory)
				player_config.factory = pMfpInfo->factory;
		}
		
		if(strstr((char *)pszStreamUrl,"[dnp]") && (stream_type == bstream_mpeg_type_asf))
		{
			pMfpInfo->no_player = true;
			pMfpInfo->StreamInfo.support_trick  = TRUE; /* progressive down */
			pMfpInfo->StreamInfo.support_seek   = TRUE;
		}
		else
		{
			pMfpInfo->player = bmedia_player_create(pMfpInfo->fd, &player_config, &pMfpInfo->stream);
			if(pMfpInfo->player == NULL)
			{
				MhegIcsError ("Can't use index for the media file\n");

				pMfpInfo->fd->seek(pMfpInfo->fd, 0, SEEK_SET);

				if (pMfpInfo->StreamInfo.stream_type == DI_MEDIA_MPEG_TYPE_TS)
				{
					pMfpInfo->no_player 			= true;
					pMfpInfo->StreamInfo.support_trick	= TRUE;
					/* 2008.07.08 - by Dylan, Check the seek support */
					pMfpInfo->StreamInfo.support_seek 	= TRUE;
				}
				else
				{
					pMfpInfo->no_player = true;
					pMfpInfo->StreamInfo.support_trick	= FALSE;
					/* 2008.07.08 - by Dylan, Check the seek support */
					pMfpInfo->StreamInfo.support_seek 	= pMfpInfo->fd->seek(pMfpInfo->fd, 0, SEEK_SET) != -1 ? TRUE : FALSE;
				}
			}
			else
			{
				if(pMfpInfo->seek!=BMEDIA_PLAYER_INVALID)
				{
					bmedia_player_seek(pMfpInfo->player, pMfpInfo->seek);
				}

				/* 2008.07.08 - by Dylan, Check the seek support */
				pMfpInfo->StreamInfo.support_seek = bmedia_player_seek(pMfpInfo->player, 0) != -1 ? TRUE : FALSE;

				/*if(pMfpInfo->seek2!=BMEDIA_PLAYER_INVALID)
				  {
				  bmedia_player_seek(pMfpInfo->player, pMfpInfo->seek2);
				  }*/

				if(pMfpInfo->direction != 0)
				{
					bmedia_filter_set_keyframeonly(pMfpInfo->filter, true);
				}
				/* else { continue } */

				(void)bmedia_player_set_direction(pMfpInfo->player, pMfpInfo->direction, pMfpInfo->time_scale, &pMfpInfo->decoder_mode);

				if (pMfpInfo->StreamInfo.stream_type == DI_MEDIA_MPEG_TYPE_TS)
				{
					pMfpInfo->no_player 			= true;
				}
				else
				{
					pMfpInfo->no_player = false;
				}

				pMfpInfo->StreamInfo.support_trick	= TRUE;
			}
		}
	}
	
	(void)strncpy (pMfpInfo->szStreamUrl, (char *)pszStreamUrl, MHEG_ICS_STREAM_URL_LEN-1);
	pMfpInfo->opened	= true;
	pMfpInfo->ullPrevPosition	= 0;
	pMfpInfo->ullEosPosition	= 0;

#if defined (CONFIG_PLAYREADY)
/*************************
*	Parse & get the WRM Header
************************/
	HBOOL bHeaderExist = FALSE;
	HBOOL bCocktail = FALSE;
	
	if(pMfpInfo->StreamInfo.stream_type == DI_MEDIA_MPEG_TYPE_ASF)
	{
		bHeaderExist = DI_STREAM_HTTP_GetASFWrmHeader(pszStreamUrl, &(pMfpInfo->StreamInfo.pucWrmHeader), (HUINT32*)&(pMfpInfo->StreamInfo.nWrmHeaderLen), &bCocktail);
		if(bHeaderExist == TRUE)
		{
			pMfpInfo->StreamInfo.is_drm = TRUE;
			if(bCocktail == TRUE)
			{
				pMfpInfo->StreamInfo.eDrmType = DI_MEDIA_DRM_TYPE_WMDRM;
			}
			else
			{
				pMfpInfo->StreamInfo.eDrmType = DI_MEDIA_DRM_TYPE_PLAYREADY;
			}
		}
	}
#endif

	MhegIcsFunctionExit;

	return nRet;

error:

	if (pMfpInfo->buffer != NULL)
	{
		(void)bfile_buffer_destroy(pMfpInfo->buffer);
		pMfpInfo->buffer = NULL;
	}
	/* else { continue } */

	if (pMfpInfo->buffer_cfg.buf != NULL)
	{
		(void) DD_MEM_Free (pMfpInfo->buffer_cfg.buf);
		pMfpInfo->buffer_cfg.buf = NULL;
	}
	/* else { continue } */

	if (pMfpInfo->fd != NULL)
	{
		(void)bfile_stdio_read_detach(pMfpInfo->fd);
		pMfpInfo->fd = NULL;
	}
	/* else { continue } */

	if (probe != NULL)
	{
		if (stream != NULL)
		{
			(void)bmedia_probe_stream_free (probe, stream);
		}
		/* else { continue } */

		(void)bmedia_probe_destroy(probe);
	}
	/* else { continue } */

	if (pMfpInfo->filter != NULL)
	{
		if(pMfpInfo->audio != NULL)
		{
			(void)bmedia_filter_stream_close (pMfpInfo->filter, pMfpInfo->audio);
			pMfpInfo->audio	= NULL;
		}
		/* else { continue } */

		if(pMfpInfo->video != NULL)
		{
			(void)bmedia_filter_stream_close (pMfpInfo->filter, pMfpInfo->video);
			pMfpInfo->video	= NULL;
		}
		/* else { continue } */

		(void)bmedia_filter_stop (pMfpInfo->filter);
		(void)bmedia_filter_destroy (pMfpInfo->filter);
		pMfpInfo->filter	= NULL;
	}
	/* else { continue } */

	if (pMfpInfo->pipe_media != NULL)
	{
		(void)batom_pipe_destroy (pMfpInfo->pipe_media);
		pMfpInfo->pipe_media	= NULL;
	}
	/* else { continue } */

	if (pMfpInfo->factory != NULL)
	{
		(void)batom_factory_destroy (pMfpInfo->factory);
		pMfpInfo->factory	= NULL;
	}
	/* else { continue } */

	(void)bfile_async_shutdown();
#ifdef	CONFIG_VFIO
	if ( pMfpInfo->tHandle.ucAvailable )
	{
		(void)VFIO_Close (pMfpInfo->tHandle);
	}
	/* else { continue } */
#else
	if (pMfpInfo->fin != NULL)
	{
		(void)fclose (pMfpInfo->fin);
		pMfpInfo->fin	= NULL;
	}
	/* else { continue } */
#endif

	if (nRet == DI_ERR_OK)
	{
		nRet = DI_ERR_ERROR;
	}
	/* else { continue } */

	MhegIcsFunctionExit;

	return nRet;
}

/**
 * @brief		Stream Probe를 위해 할당한 Resource를 해제한다.
 *
 * @param[in]	pMfpInfo 	Todo
 * @return		void
 * @see			DI_MEDIA_Probe
 */
static DI_ERR_CODE local_mheg_ics_media_ProbeClose (stMhegIcsMediaInfo *pMfpInfo)
{
	DI_ERR_CODE nRet = DI_ERR_OK;

	MhegIcsFunctionEnter(-1);

	if (!pMfpInfo->opened)
	{
		MhegIcsFunctionExit;

		return DI_ERR_OK;
	}
	/* else { continue } */

	if (pMfpInfo->atom != NULL)
	{
		(void)batom_release (pMfpInfo->atom);
		pMfpInfo->atom = NULL;
	}
	/* else { continue } */

	if (pMfpInfo->buffer != NULL)
	{
		(void)bfile_buffer_destroy(pMfpInfo->buffer);
		pMfpInfo->buffer = NULL;
	}
	/* else { continue } */

	if (pMfpInfo->buffer_cfg.buf != NULL)
	{
		(void) DD_MEM_Free (pMfpInfo->buffer_cfg.buf);
		pMfpInfo->buffer_cfg.buf = NULL;
	}
	/* else { continue } */

	if (pMfpInfo->player != NULL)
	{
		bmedia_player_destroy(pMfpInfo->player);
		pMfpInfo->player = NULL;
	}
	/* else { continue } */

	if (pMfpInfo->fd != NULL)
	{
		(void)bfile_stdio_read_detach(pMfpInfo->fd);
		pMfpInfo->fd = NULL;
	}
	/* else { continue } */

	if (pMfpInfo->filter != NULL)
	{
		if(pMfpInfo->audio != NULL)
		{
			(void)bmedia_filter_stream_close (pMfpInfo->filter, pMfpInfo->audio);
			pMfpInfo->audio	= NULL;
		}
		/* else { continue } */

		if(pMfpInfo->video != NULL)
		{
			(void)bmedia_filter_stream_close (pMfpInfo->filter, pMfpInfo->video);
			pMfpInfo->video	= NULL;
		}
		/* else { continue } */

		(void)bmedia_filter_stop (pMfpInfo->filter);
		(void)bmedia_filter_destroy (pMfpInfo->filter);
		pMfpInfo->filter	= NULL;
	}
	/* else { continue } */

	if (pMfpInfo->pipe_media != NULL)
	{
		(void)batom_pipe_destroy (pMfpInfo->pipe_media);
		pMfpInfo->pipe_media	= NULL;
	}
	/* else { continue } */

	if (pMfpInfo->factory != NULL)
	{
		(void)batom_factory_destroy (pMfpInfo->factory);
		pMfpInfo->factory	= NULL;
	}
	/* else { continue } */

	(void)bfile_async_shutdown();

#ifdef	CONFIG_VFIO
	if ( pMfpInfo->tHandle.ucAvailable )
	{
		(void)VFIO_Close (pMfpInfo->tHandle);
	}
	/* else { continue } */
#else
	if (pMfpInfo->fin != NULL)
	{
		(void)fclose (pMfpInfo->fin);
		pMfpInfo->fin	= NULL;
	}
	/* else { continue } */
#endif

	/* 2008.12.01 by Dylan - struct should be cleared, this is the static define !!! */
	VK_memset(pMfpInfo, 0x0, sizeof(stMhegIcsMediaInfo));
	pMfpInfo->szStreamUrl[0]	= 0;
	pMfpInfo->opened			= FALSE;

	MhegIcsFunctionExit;

	return nRet;
}

/**
 * @brief		Todo
 *
 * @param[in]	atom 	Todo
 * @param[in]	user 	Todo
 * @return		void
 * @see			DI_MEDIA_Probe
 */
static void local_mheg_ics_media_ProbeFreeAtom (batom_t atom, void *user)
{
	void *ptr = *(void **)user;

	//MhegIcsFunctionEnter;

	MhegIcsData("Free Media %#lx|\n", (unsigned long)atom);

	/* s_MfpInfo.free_cnt++ */;
	BSTD_UNUSED(atom);

	if(ptr != NULL)
	{
		(void) DD_MEM_Free (ptr);
		ptr = NULL;
	}

	//MhegIcsFunctionExit;

	return;
}


/**
 * @brief		Todo
 *
 * @param[in]	cntx 	Todo
 * @param[in]	entry 	Todo
 * @return		void
 * @see			DI_MEDIA_Probe
 */
static void local_mheg_ics_media_ProbeAsync (void *cntx, bmedia_player_entry *entry)
{
	stMhegIcsMediaInfo *pMfpInfo = cntx;
	void *b;
	batom_t atom;

	//MhegIcsFunctionEnter;

	if (pMfpInfo == NULL || entry == NULL)
	{
		return;
	}

	b = DD_MEM_Alloc(entry->length);
	if (b == NULL)
	{
		return;
	}

	pMfpInfo->alloc_cnt++;

	if(entry->atom)
	{
		batom_cursor cursor;
		int rc;

		batom_cursor_from_atom(&cursor, entry->atom);
		rc = batom_cursor_copy(&cursor, b, entry->length);
		if (rc != (int)entry->length)
		{
		}
		/* else { continue } */

		batom_release(entry->atom);
	}
	/* else { continue } */

	atom = batom_from_range(pMfpInfo->factory, b, entry->length, &s_MHEG_ICS_Probe_AtomUser, &b);
	if (atom != NULL)
	{
		batom_pipe_push(pMfpInfo->pipe_media, atom);
	}
	/* else { continue } */

	//MhegIcsFunctionExit;

	return;
}


/**
 * @brief		DI Transport Type을 Nexus의 Transport Type으로 변환한다.
 *
 * @param[in]	eTransportType 		Di Transport Type
 * @return		NEXUS_TransportType	Nexus Transport Type
 * @see			DRV_MHEG_ICS_GetPlaybackAudioPidChannel
 */
NEXUS_TransportType local_mheg_ics_media_ConvertTransportTypeToNexus(DI_MEDIA_STREAM_TYPE_e eTransportType)
{
	NEXUS_TransportType eNexusTrasportType = NEXUS_TransportType_eUnknown;

	MhegIcsFunctionEnter(eTransportType);

	switch (eTransportType)
	{
		case DI_MEDIA_MPEG_TYPE_ES:
			eNexusTrasportType = NEXUS_TransportType_eEs;
			break;
		case DI_MEDIA_MPEG_TYPE_BES:
			eNexusTrasportType = NEXUS_TransportType_eEs;
			break;
		case DI_MEDIA_MPEG_TYPE_PES:
			eNexusTrasportType = NEXUS_TransportType_eMpeg2Pes;
			break;
		case DI_MEDIA_MPEG_TYPE_TS:
		case DI_MEDIA_MPEG_TYPE_TS_192:
			eNexusTrasportType = NEXUS_TransportType_eTs;	//load???? adts????
			break;
		case DI_MEDIA_MPEG_TYPE_DSS_ES:
			eNexusTrasportType = NEXUS_TransportType_eDssEs;
			break;
		case DI_MEDIA_MPEG_TYPE_DSS_PES:
			eNexusTrasportType = NEXUS_TransportType_eDssPes;
			break;
		case DI_MEDIA_MPEG_TYPE_VOB:
			eNexusTrasportType = NEXUS_TransportType_eVob;//pcm???
			break;
		case DI_MEDIA_MPEG_TYPE_ASF:
			eNexusTrasportType = NEXUS_TransportType_eAsf;
			break;
		case DI_MEDIA_MPEG_TYPE_AVI:
			eNexusTrasportType = NEXUS_TransportType_eAvi;
			break;
		case DI_MEDIA_MPEG_TYPE_MPEG1:
			eNexusTrasportType = NEXUS_TransportType_eMpeg1Ps;
			break;
		case DI_MEDIA_MPEG_TYPE_MP4:
			eNexusTrasportType = NEXUS_TransportType_eMp4;
			break;
#ifdef CONFIG_MEDIA_SSTR
		case DI_MEDIA_MPEG_TYPE_MP4FRAGMENT: /* for SSTR */
			eNexusTrasportType = NEXUS_TransportType_eMp4Fragment; /* Fragmented MP4 Container */
			break;						
#endif
		case DI_MEDIA_MPEG_TYPE_FLV:
			eNexusTrasportType = NEXUS_TransportType_eFlv;
			break;
		case DI_MEDIA_MPEG_TYPE_MKV:
			eNexusTrasportType = NEXUS_TransportType_eMkv;
			break;
		case DI_MEDIA_MPEG_TYPE_WAVE:
			eNexusTrasportType = NEXUS_TransportType_eWav;
			break;
		default:
			eNexusTrasportType = NEXUS_TransportType_eUnknown;
			break;
	}

	MhegIcsFunctionExit;

	return eNexusTrasportType;
}

#ifdef DI_MHEG_ICS_DEBUG
void	local_mheg_ics_media_PrintMediaInstanceInfo(HUINT32 unMediaId)
{
	MhegIcsDebug("\n\t @@@ MhegIcsMediaInstance[%d] : \n", unMediaId);
	MhegIcsDebug("  \t\t valid(%d), state(0x%X), type(%d) \n", s_tMhegIcsMediaInstance[unMediaId].valid, s_tMhegIcsMediaInstance[unMediaId].mediastate, s_tMhegIcsMediaInstance[unMediaId].mediaType);
	MhegIcsDebug("  \t\t url(%s)\n", s_tMhegIcsMediaInstance[unMediaId].mediaurl);
	MhegIcsDebug("  \t\t playback(0x%X), A-PidCH(0x%X), V-PidCH(0x%X)\n", (HUINT32)s_tMhegIcsMediaInstance[unMediaId].playback, (HUINT32)s_tMhegIcsMediaInstance[unMediaId].audioPidChannel, (HUINT32)s_tMhegIcsMediaInstance[unMediaId].videoPidChannel);	
	MhegIcsDebug("  \t\t P-PidCH(0x%X), V-Decoder(0x%X), A-Decoder(0x%X)\n", (HUINT32)s_tMhegIcsMediaInstance[unMediaId].pcrPidChannel, (HUINT32)s_tMhegIcsMediaInstance[unMediaId].vDecoder, (HUINT32)s_tMhegIcsMediaInstance[unMediaId].aDecoder);	
	MhegIcsDebug("  \t\t file(0x%X), trick-rate(0x%X)\n", (HUINT32)s_tMhegIcsMediaInstance[unMediaId].file, s_tMhegIcsMediaInstance[unMediaId].trickrate);	
	MhegIcsDebug("  \t\t First-PTS(%d), PTS-Install(%d)\n", s_tMhegIcsMediaInstance[unMediaId].unFirstPts, s_tMhegIcsMediaInstance[unMediaId].bPtsInstalled);	

	MhegIcsDebug("\n\t @@@ MhegIcsStream[%d] : \n", unMediaId);
	MhegIcsDebug("  \t\t Video(0x%X:0x%X), Audio(0x%X:0x%X), PCR(0x%X)\n"
			, s_tMhegIcsStreamInfo[unMediaId].video_stream_id, s_tMhegIcsStreamInfo[unMediaId].video_codec
			, s_tMhegIcsStreamInfo[unMediaId].audio_stream_id, s_tMhegIcsStreamInfo[unMediaId].audio_codec, s_tMhegIcsStreamInfo[unMediaId].pcr_pid);
}
#endif


#if 0
/**
 * @brief		DI Video Codec을 Nexus의 Video Codec Type으로 변환한다.
 *
 * @param[in]	eVideoCodec 		Di Media Video Codec Type
 * @return		NEXUS_VideoCodec	Nexus Video Codec Type
 * @see			DRV_MHEG_ICS_GetPlaybackVideoPidChannel
 */
static NEXUS_VideoCodec local_mheg_ics_media_ConvertMediaVideoCodecToNexus(DI_MEDIA_VIDEO_FORMAT_e eVideoCodec)
{
	NEXUS_VideoCodec nexusVideoCodec;

	MhegIcsFunctionEnter(eVideoCodec);

	switch(eVideoCodec)
	{
		case DI_MEDIA_VIDEO_FORMAT_MPEG1:
			nexusVideoCodec = NEXUS_VideoCodec_eMpeg1;
			break;
		case DI_MEDIA_VIDEO_FORMAT_MPEG2:
			nexusVideoCodec = NEXUS_VideoCodec_eMpeg2;
			break;
		case DI_MEDIA_VIDEO_FORMAT_MPEG4Part2:
			nexusVideoCodec = NEXUS_VideoCodec_eMpeg4Part2;
			break;
		case DI_MEDIA_VIDEO_FORMAT_H261:
			nexusVideoCodec = NEXUS_VideoCodec_eDivx311; /*seemed to be unsupported in Nexus platform, but can be modified.*/
			break;
		case DI_MEDIA_VIDEO_FORMAT_H263:
			nexusVideoCodec = NEXUS_VideoCodec_eH263;
			break;
		case DI_MEDIA_VIDEO_FORMAT_H264:
			nexusVideoCodec = NEXUS_VideoCodec_eH264;
			break;
		case DI_MEDIA_VIDEO_FORMAT_VC1SimpleMain:
			nexusVideoCodec = NEXUS_VideoCodec_eVc1SimpleMain;
			break;
		case DI_MEDIA_VIDEO_FORMAT_VC1:
			nexusVideoCodec = NEXUS_VideoCodec_eVc1;
			break;
		case DI_MEDIA_VIDEO_FORMAT_AVS:
			nexusVideoCodec = NEXUS_VideoCodec_eAvs;
			break;
		case DI_MEDIA_VIDEO_FORMAT_DIVX_311:
			nexusVideoCodec = NEXUS_VideoCodec_eDivx311;
			break;
		default:
			nexusVideoCodec = NEXUS_VideoCodec_eUnknown;
			break;
	}

	MhegIcsFunctionExit;

	return nexusVideoCodec;
}
#endif

/**
 * @brief		DI Audio Codec을 Nexus의 Audio Codec Type으로 변환한다.
 *
 * @param[in]	eAudioCodec 	Di Media Audio Codec Type
 * @return		NEXUS_AudioCodec	Nexus Audio Codec Type
 * @see			DRV_MHEG_ICS_GetPlaybackAudioPidChannel
 */
NEXUS_AudioCodec local_mheg_ics_media_ConvertMediaAudioCodecToNexus(DI_MEDIA_AUDIO_FORMAT_e eAudioCodec)
{
	NEXUS_AudioCodec nexusCodec = NEXUS_AudioCodec_eUnknown;

	MhegIcsFunctionEnter(eAudioCodec);

	switch (eAudioCodec)
	{
		case DI_MEDIA_AUDIO_FORMAT_MPEG:
			nexusCodec = NEXUS_AudioCodec_eMpeg;
			break;
		case DI_MEDIA_AUDIO_FORMAT_MP3:
			nexusCodec = NEXUS_AudioCodec_eMp3;
			break;
		case DI_MEDIA_AUDIO_FORMAT_AAC:
			nexusCodec = NEXUS_AudioCodec_eAac;
			break;
		case DI_MEDIA_AUDIO_FORMAT_AAC_PLUS:
			nexusCodec = NEXUS_AudioCodec_eAacPlus;	//load???? adts????
			break;
		case DI_MEDIA_AUDIO_FORMAT_AC3:
			nexusCodec = NEXUS_AudioCodec_eAc3;
			break;
		case DI_MEDIA_AUDIO_FORMAT_AC3_PLUS:
			nexusCodec = NEXUS_AudioCodec_eAc3Plus;
			break;
		case DI_MEDIA_AUDIO_FORMAT_PCM:
			nexusCodec = NEXUS_AudioCodec_ePcm;//pcm???
			break;
		case DI_MEDIA_AUDIO_FORMAT_PCMWAVE:
			nexusCodec = NEXUS_AudioCodec_ePcmWav;//pcm???
			break;
		case DI_MEDIA_AUDIO_FORMAT_AAC_PLUS_ADTS:
			nexusCodec = NEXUS_AudioCodec_eAacPlusAdts;
			break;
		case DI_MEDIA_AUDIO_FORMAT_AAC_PLUS_LOAS:
			nexusCodec = NEXUS_AudioCodec_eAacPlusLoas;
			break;
		case DI_MEDIA_AUDIO_FORMAT_DTS:
			nexusCodec = NEXUS_AudioCodec_eDts;
			break;
		case DI_MEDIA_AUDIO_FORMAT_LPCM_HD_DVD:
			nexusCodec = NEXUS_AudioCodec_eLpcmHdDvd;
			break;
		case DI_MEDIA_AUDIO_FORMAT_LPCM_BLUERAY:
			nexusCodec = NEXUS_AudioCodec_eLpcmBluRay;
			break;
		case DI_MEDIA_AUDIO_FORMAT_DTS_HD:
			nexusCodec = NEXUS_AudioCodec_eDtsHd;
			break;
		case DI_MEDIA_AUDIO_FORMAT_WMA_STD:
			nexusCodec = NEXUS_AudioCodec_eWmaStd;
			break;
		case DI_MEDIA_AUDIO_FORMAT_WMA_PRO:
			nexusCodec = NEXUS_AudioCodec_eWmaPro;
			break;
		case DI_MEDIA_AUDIO_FORMAT_LPCM_DVD:
			nexusCodec = NEXUS_AudioCodec_eLpcmDvd;
			break;
		default:
			nexusCodec = NEXUS_AudioCodec_eUnknown;
			break;
	}

	MhegIcsFunctionExit;

	return nexusCodec;
}


#ifdef DI_MHEG_ICS_DEBUG
static void local_mheg_ics_media_print_trackinfo(bmedia_probe_track		*track);
#endif

/*******************************************************************/
/********************   Global  Functions       *************************/
/*******************************************************************/

#define _____PUBLIC_APIs________________________________________________________________


#define __________DRV__________

/**
 * @brief		Open된 Stc Channel을 Media Type에 맞게 설정 후 얻는다.
 *
 * @param[in]	unMediaId	media Id
 * @param[in]	mediaType	media type
 * @return		NEXUS_StcChannelHandle
 * @see
 */
NEXUS_StcChannelHandle DRV_MHEG_ICS_MP_GetPlaybackStcChannelHandle(HUINT32 unMediaId, DI_MEDIA_VIDEO_TYPE_e eVideoDecoderType, DI_MEDIA_AUDIO_TYPE_e eAudioDecoderType, DI_MEDIA_PLAYPUMP mediaType)
{
	NEXUS_StcChannelSettings stcSettings;
	//DI_MEDIA_AUDIO_TYPE_e eTempAudioDecoderType = DI_MEDIA_AUDIO_DECODER_NONE;
	NEXUS_PlaybackPidChannelSettings openPidSettings;

	UNUSED_PARAM(eVideoDecoderType);
	UNUSED_PARAM(eAudioDecoderType);

	MhegIcsFunctionEnter(unMediaId);

	NEXUS_Playback_GetDefaultPidChannelSettings(&openPidSettings);
#if (NEXUS_VERSION >= 1250)
	openPidSettings.pidSettings.pidSettings.pidChannelIndex = NEXUS_PID_CHANNEL_OPEN_NOT_MESSAGE_CAPABLE ;
#endif
	
	if(unMediaId >= MAX_MHEG_ICS_NUM)	
	{
		MhegIcsError("[%s:%d] invalid MediaID(%d).\n", __func__, __LINE__, unMediaId);
	}
	else
	{

		NEXUS_StcChannel_GetSettings(DRV_DEMUX_GetStcChannelHandle(), &stcSettings);
		stcSettings.timebase = NEXUS_Timebase_e0;
		stcSettings.mode = NEXUS_StcChannelMode_eAuto;
		stcSettings.modeSettings.pcr.pidChannel = NULL;

		if((mediaType == DI_MEDIA_PLAYPUMP_AUDIO_MAIN) && (s_tMhegIcsMediaInstance[unMediaId].mediaType != DI_MEDIA_PLAYPUMP_DIVX))
		{
			NEXUS_StcChannel_SetSettings(DRV_DEMUX_GetStcChannelHandle(), &stcSettings);
			return NULL;
		}

		if(s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_WAVE)
		{
			NEXUS_StcChannel_SetSettings(DRV_DEMUX_GetStcChannelHandle(), &stcSettings);
			return NULL;
		}

		/* pcr_pid */
		if( s_tMhegIcsMediaInstance[unMediaId].pcrPidChannel != NULL ) /* duplication check */
		{
			stcSettings.modeSettings.pcr.pidChannel = s_tMhegIcsMediaInstance[unMediaId].pcrPidChannel;
		}
#if 1
		/** 
			pcr pid 와 video/audio pid 가 동일한 경우는 제외함.
		    stcChannel 에 pidChannel Setting 시 Video/Audio PID와 PCR PID 가 동일 한경우
			nexus_playback.c 의 NEXUS_Playback_OpenPidChannel 에서 PID 중복 처리 코드 내에서
			play_pid->cfg.pidSettings.pidType = pSettings->pidSettings.pidType; (기존 코드) 가 아닌
			play_pid->cfg = *pSettings; (변경 코드) 로의 변경이 필요.
			현재 모든 BRCM Driver 반영에 어려움이 있으므로 Workaround 처리함.
		*/
		else if(s_tMhegIcsStreamInfo[unMediaId].pcr_pid != 0x1fff && 
		s_tMhegIcsStreamInfo[unMediaId].pcr_pid != s_tMhegIcsStreamInfo[unMediaId].video_stream_id &&  
		s_tMhegIcsStreamInfo[unMediaId].pcr_pid != s_tMhegIcsStreamInfo[unMediaId].audio_stream_id)
    	{
	        stcSettings.modeSettings.pcr.pidChannel =
				NEXUS_Playback_OpenPidChannel (s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsStreamInfo[unMediaId].pcr_pid, &openPidSettings);
			s_tMhegIcsMediaInstance[unMediaId].pcrPidChannel = stcSettings.modeSettings.pcr.pidChannel;
		}
#else
        else if( s_tMhegIcsStreamInfo[unMediaId].pcr_pid == s_tMhegIcsStreamInfo[unMediaId].video_stream_id )
        {
            if (s_tMhegIcsMediaInstance[unMediaId].videoPidChannel)
				stcSettings.modeSettings.pcr.pidChannel = s_tMhegIcsMediaInstance[unMediaId].videoPidChannel;
            else
           	{
				stcSettings.modeSettings.pcr.pidChannel = 
					NEXUS_Playback_OpenPidChannel (s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsStreamInfo[unMediaId].pcr_pid, &openPidSettings);
				s_tMhegIcsMediaInstance[unMediaId].pcrPidChannel = stcSettings.modeSettings.pcr.pidChannel;
            } 
        }
		else if ( s_tMhegIcsStreamInfo[unMediaId].pcr_pid == s_tMhegIcsStreamInfo[unMediaId].audio_stream_id )
        {
            if (s_tMhegIcsMediaInstance[unMediaId].audioPidChannel)
				stcSettings.modeSettings.pcr.pidChannel = s_tMhegIcsMediaInstance[unMediaId].audioPidChannel;
            else
            {
				stcSettings.modeSettings.pcr.pidChannel =
					NEXUS_Playback_OpenPidChannel (s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsStreamInfo[unMediaId].pcr_pid, &openPidSettings);
				s_tMhegIcsMediaInstance[unMediaId].pcrPidChannel = stcSettings.modeSettings.pcr.pidChannel;	
            }
        }
        else
        {
        	if(s_tMhegIcsStreamInfo[unMediaId].pcr_pid != 0x1fff)
        	{
		        stcSettings.modeSettings.pcr.pidChannel =
					NEXUS_Playback_OpenPidChannel (s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsStreamInfo[unMediaId].pcr_pid, &openPidSettings);
				s_tMhegIcsMediaInstance[unMediaId].pcrPidChannel = stcSettings.modeSettings.pcr.pidChannel;
			}
        }
#endif        

#if SUPPORT_USE_STC_AUTOMODE_FIRSTAVAILABLE
		if(s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_ASF)
		{
			switch(stcSettings.modeSettings.Auto.behavior)
			{
				case NEXUS_StcChannelAutoModeBehavior_eFirstAvailable:
					{
						stcSettings.modeSettings.Auto.behavior = NEXUS_StcChannelAutoModeBehavior_eFirstAvailable;
						MhegIcsData("[%s] Current Mode: FirstAvailable, Modify Mode: FirstAvailable\n", __func__);
						break;
					}
				case NEXUS_StcChannelAutoModeBehavior_eVideoMaster:
					{
						stcSettings.modeSettings.Auto.behavior = NEXUS_StcChannelAutoModeBehavior_eFirstAvailable;
						MhegIcsData("[%s] Current Mode: Video Master, Modify Mode: FirstAvailable\n", __func__);
						break;
					}
				case NEXUS_StcChannelAutoModeBehavior_eAudioMaster:
					{
						stcSettings.modeSettings.Auto.behavior = NEXUS_StcChannelAutoModeBehavior_eFirstAvailable;
						MhegIcsData("[%s] Current Mode: Audio Master, Modify Mode: FirstAvailable\n", __func__);
						break;
					}
				default:
					MhegIcsError("[%s] unknown mode %d\n", __func__, stcSettings.modeSettings.Auto.behavior);
					break;
			}
		}
		else
		{
			stcSettings.modeSettings.Auto.behavior = NEXUS_StcChannelAutoModeBehavior_eVideoMaster;
			MhegIcsData("[%s] Modify Mode: Video Master\n", __func__);
		}
#endif
		stcSettings.modeSettings.Auto.transportType = local_mheg_ics_media_ConvertTransportTypeToNexus(s_tMhegIcsStreamInfo[unMediaId].stream_type);
#ifdef CONFIG_MEDIA_SSTR
		if(stcSettings.modeSettings.Auto.transportType == NEXUS_TransportType_eMp4Fragment) /* for SSTR */	
		{
			stcSettings.modeSettings.Auto.transportType = NEXUS_TransportType_eTs;
		}
#endif
		NEXUS_StcChannel_SetSettings(DRV_DEMUX_GetStcChannelHandle(), &stcSettings);
	}

	MhegIcsFunctionExit;

	return DRV_DEMUX_GetStcChannelHandle();
}

#if 0
/**
 * @brief 		media 재생을 위해 Video Pid Channel을 얻는다.
 *
 * @param[in]	unMediaId				media Id
 * @param[in]	eVideoCodec				Video Codec
 * @param[in]	VideoDecoderHandle		Video Decoder Handle
 * @return		NEXUS_PidChannelHandle
 * @see			DRV_MHEG_ICS_GetPlaybackAudioPidChannel
 */
NEXUS_PidChannelHandle DRV_MHEG_ICS_GetPlaybackVideoPidChannel(HUINT32 unMediaId, DI_MEDIA_VIDEO_TYPE_e eVideoDecoderType, DI_MEDIA_VIDEO_FORMAT_e eVideoCodec, void *VideoDecoderHandle)
{
	NEXUS_PlaybackPidChannelSettings openPidSettings;

	UNUSED_PARAM(eVideoDecoderType);

	MhegIcsFunctionEnter(unMediaId);

	if(VideoDecoderHandle == NULL)
	{
		MhegIcsError("[%s] VideoDecoderHandle is null.\n", __func__);
		return NULL;
	}

	if(unMediaId >= MAX_MHEG_ICS_NUM)	
	{
		MhegIcsError("[%s:%d] invalid MediaID(%d).\n", __func__, __LINE__, unMediaId);
	}
	else
	{
		if(s_tMhegIcsMediaInstance[unMediaId].videoPidChannel != NULL)
		{
			(void)NEXUS_Playback_ClosePidChannel(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].videoPidChannel);
			s_tMhegIcsMediaInstance[unMediaId].videoPidChannel = NULL;
		}

		/** Nexus Pid Channel을 Open한다. */
		NEXUS_Playback_GetDefaultPidChannelSettings(&openPidSettings);
		openPidSettings.pidSettings.pidType = NEXUS_PidType_eVideo;
#if (NEXUS_VERSION >= 1250)
		openPidSettings.pidSettings.pidSettings.pidChannelIndex = NEXUS_PID_CHANNEL_OPEN_NOT_MESSAGE_CAPABLE ;
#endif
		openPidSettings.pidTypeSettings.video.codec = local_mheg_ics_media_ConvertMediaVideoCodecToNexus(eVideoCodec);
		openPidSettings.pidTypeSettings.video.decoder = (NEXUS_VideoDecoderHandle)VideoDecoderHandle;
		openPidSettings.pidTypeSettings.video.index = true;
		s_tMhegIcsMediaInstance[unMediaId].videoPidChannel = NEXUS_Playback_OpenPidChannel(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsStreamInfo[unMediaId].video_stream_id, &openPidSettings);
		s_tMhegIcsMediaInstance[unMediaId].vDecoder = (NEXUS_VideoDecoderHandle)VideoDecoderHandle;
	}

	MhegIcsFunctionExit;

	return s_tMhegIcsMediaInstance[unMediaId].videoPidChannel;
}

/**
 * @brief		media 재생을 위해 Audio Pid Channel을 얻는다.
 *
 * @param[in]	unMediaId				media Id
 * @param[in]	eAudioCodec				Audio Codec
 * @param[in]	eDecoderType			Audio Decoder Handle Type
 * @param[in]	AudioDecoderHandle		Audio Decoder Handle
 * @return		NEXUS_PidChannelHandle
 * @see			DRV_MHEG_ICS_GetPlaybackVideoPidChannel
 */
NEXUS_PidChannelHandle DRV_MHEG_ICS_GetPlaybackAudioPidChannel(HUINT32 unMediaId, DI_MEDIA_AUDIO_FORMAT_e eAudioCodec, DI_MEDIA_AUDIO_TYPE_e eAudioDecoderType, void *AudioDecoderHandle)
{
	NEXUS_PlaybackPidChannelSettings openPlaybackPidSettings;
	NEXUS_PlaypumpOpenPidChannelSettings openPlaypumpPidSettings;

	DI_MEDIA_AUDIO_TYPE_e eTempAudioDecoderType = DI_MEDIA_AUDIO_DECODER_NONE;
	NEXUS_PidChannelHandle audioPidChannel = NULL;
#if 0				/* Di audio module요청사항에 의해 사용하지 않음. secondary setting은 이후에 audio pid channel setting함수를 통해 Setting함. */
	NEXUS_Error		nNexusError = NEXUS_SUCCESS;
#endif

	HUINT32			i=0;
		
	MhegIcsFunctionEnter(unMediaId);

	NEXUS_Playback_GetDefaultPidChannelSettings(&openPlaybackPidSettings);
	NEXUS_Playpump_GetDefaultOpenPidChannelSettings(&openPlaypumpPidSettings);
#if (NEXUS_VERSION >= 1250)
	openPlaybackPidSettings.pidSettings.pidSettings.pidChannelIndex = NEXUS_PID_CHANNEL_OPEN_NOT_MESSAGE_CAPABLE ;
	openPlaypumpPidSettings.pidSettings.pidChannelIndex = NEXUS_PID_CHANNEL_OPEN_NOT_MESSAGE_CAPABLE ;
#endif

	if(AudioDecoderHandle == NULL)
	{
		MhegIcsError("[%s] AudioDecoderHandle is null.\n", __func__);
		return NULL;
	}

	if(eAudioDecoderType != DI_MEDIA_AUDIO_DECODER_NONE)
	{
		eTempAudioDecoderType = DI_MEDIA_AUDIO_DECODER_MAIN;
	}
	
	if(unMediaId >= MAX_MHEG_ICS_NUM)	
	{
		MhegIcsError("[%s:%d] invalid MediaID(%d).\n", __func__, __LINE__, unMediaId);
	}
	else
	{
		if(eAudioDecoderType == DI_MEDIA_AUDIO_DECODER_MAIN)
		{
			/** Nexus Pid Channel을 Open한다. */		
			for(i = 0; i < s_tMhegIcsStreamInfo[unMediaId].ucTotalAudioTrack ; i++)
			{
				/*if(s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i] != NULL)
				{
					(void)NEXUS_Playback_ClosePidChannel(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i]);
					s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i] = NULL;
				}*/
				openPlaybackPidSettings.pidSettings.pidType = NEXUS_PidType_eAudio;
				openPlaybackPidSettings.pidSettings.pidTypeSettings.audio.codec = local_mheg_ics_media_ConvertMediaAudioCodecToNexus(s_tMhegIcsStreamInfo[unMediaId].stAudioTrack[i].audio_codec);
				openPlaybackPidSettings.pidTypeSettings.audio.primary = (NEXUS_AudioDecoderHandle)AudioDecoderHandle;
				if(s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i] == NULL)
				{
					if((eAudioCodec == DI_MEDIA_AUDIO_FORMAT_PCMWAVE) && (s_tMhegIcsStreamInfo[unMediaId].video_codec == DI_MEDIA_VIDEO_FORMAT_NONE))
					{
							s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i] = NEXUS_Playpump_OpenPidChannel(s_tMhegIcsMediaInstance[unMediaId].playpump[DI_MEDIA_PLAYPUMP_DIVX], s_tMhegIcsStreamInfo[unMediaId].stAudioTrack[i].audio_stream_id, &openPlaypumpPidSettings);
					}
					else
					{
							s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i] = NEXUS_Playback_OpenPidChannel(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsStreamInfo[unMediaId].stAudioTrack[i].audio_stream_id, &openPlaybackPidSettings);
					}
				}
				if(s_tMhegIcsStreamInfo[unMediaId].audio_stream_id == s_tMhegIcsStreamInfo[unMediaId].stAudioTrack[i].audio_stream_id)
				{
					audioPidChannel = s_tMhegIcsMediaInstance[unMediaId].audioPidChannel = s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i];
				}
			}
		}
		else if(eAudioDecoderType == DI_MEDIA_AUDIO_DECODER_SUB)
		{
			/** Nexus Pid Channel을 Open한다. */		
			for(i = 0; i < s_tMhegIcsStreamInfo[unMediaId].ucTotalAudioTrack ; i++)
			{
				/*if(s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i] != NULL)
				{
					(void)NEXUS_Playback_ClosePidChannel(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i]);
					s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i] = NULL;
				}*/
				openPlaybackPidSettings.pidSettings.pidType = NEXUS_PidType_eAudio;
				openPlaybackPidSettings.pidSettings.pidTypeSettings.audio.codec = local_mheg_ics_media_ConvertMediaAudioCodecToNexus(s_tMhegIcsStreamInfo[unMediaId].stAudioTrack[i].audio_codec);
				openPlaybackPidSettings.pidTypeSettings.audio.primary = (NEXUS_AudioDecoderHandle)AudioDecoderHandle;
				if(s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i] == NULL)
				{
					s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i] = NEXUS_Playback_OpenPidChannel(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsStreamInfo[unMediaId].stAudioTrack[i].audio_stream_id, &openPlaybackPidSettings);
				}
				if(s_tMhegIcsStreamInfo[unMediaId].audio_stream_id == s_tMhegIcsStreamInfo[unMediaId].stAudioTrack[i].audio_stream_id)
				{
					audioPidChannel = s_tMhegIcsMediaInstance[unMediaId].audioSubPidChannel = s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i];
				}	
			}
		}
		else
		{
#if 0				/* Di audio module요청사항에 의해 사용하지 않음. secondary setting은 이후에 audio pid channel setting함수를 통해 Setting함. */
			/** Open된 Pid Channel에 secondary Audio Handle을 추가한다. */
			nNexusError = NEXUS_Playback_GetPidChannelSettings(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].audioPidChannel, &pidSettings);
			if(nNexusError != NEXUS_SUCCESS)
			{
				MhegIcsError("[%s] Error > Fail NEXUS_Playback_GetPidChannelSettings.\n", __func__);
				MhegIcsFunctionExit;
				return NULL;
			}			
			pidSettings.pidTypeSettings.audio.secondary = (NEXUS_AudioDecoderHandle)AudioDecoderHandle;
			nNexusError = NEXUS_Playback_SetPidChannelSettings(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].audioPidChannel, &pidSettings);
			if(nNexusError != NEXUS_SUCCESS)
			{
				MhegIcsError("[%s] Error > Fail NEXUS_Playback_SetPidChannelSettings.\n", __func__);
			}
#endif
			audioPidChannel = s_tMhegIcsMediaInstance[unMediaId].audioPidChannel;
		}
		s_tMhegIcsMediaInstance[unMediaId].aDecoder = (NEXUS_AudioDecoderHandle)AudioDecoderHandle;
	}
	MhegIcsDebug("%s(%d) Info> Created audioPidChannel (0x%x) pid(0x%x)\n",__FUNCTION__,__LINE__,audioPidChannel,s_tMhegIcsStreamInfo[unMediaId].audio_stream_id);

	MhegIcsFunctionExit;

	return audioPidChannel;
}


DRV_Error DRV_MHEG_ICS_SetAudioPidChannel(HUINT32 unMediaId, NEXUS_PidChannelHandle ulPidChannelHandle, NEXUS_AudioDecoderHandle ulAudioDecHandle,
														NEXUS_AudioDecoderHandle ulAudioPassThroughDecHandle)
{
	NEXUS_PlaybackPidChannelSettings pidSettings;
	DI_MEDIA_AUDIO_TYPE_e eTempAudioDecoderType = DI_MEDIA_AUDIO_DECODER_NONE;
	NEXUS_Error		nNexusError = NEXUS_SUCCESS;
		
	MhegIcsFunctionEnter(unMediaId);
	
	if(ulPidChannelHandle == NULL)
	{
		MhegIcsError("[%s] ulPidChannelHandle is null.\n", __func__);

		MhegIcsFunctionExit;

		return DRV_ERR;
	}
	
	if(ulAudioDecHandle == NULL)
	{
		MhegIcsError("[%s] AudioDecoderHandle is null.\n", __func__);

		MhegIcsFunctionExit;

		return DRV_ERR;
	}
	
	if(ulAudioPassThroughDecHandle == NULL)
	{
		MhegIcsError("[%s] ulAudioPassThroughDecHandle is null.\n", __func__);

		MhegIcsFunctionExit;

		return DRV_ERR;
	}

	eTempAudioDecoderType = DI_MEDIA_AUDIO_DECODER_MAIN;

	if(unMediaId >= MAX_MHEG_ICS_NUM)	
	{
		MhegIcsError("[%s:%d] invalid MediaID(%d).\n", __func__, __LINE__, unMediaId);
		
		MhegIcsFunctionExit;

		return DRV_ERR;
	}
		
	nNexusError = NEXUS_Playback_GetPidChannelSettings(s_tMhegIcsMediaInstance[unMediaId].playback, ulPidChannelHandle, &pidSettings);
	if(nNexusError != NEXUS_SUCCESS)
	{
		MhegIcsError("[%s] Error > Fail NEXUS_Playback_GetPidChannelSettings.\n", __func__);

		MhegIcsFunctionExit;

		return DRV_ERR;
	}	

	pidSettings.pidTypeSettings.audio.primary = (NEXUS_AudioDecoderHandle)ulAudioDecHandle;
	pidSettings.pidTypeSettings.audio.secondary = (NEXUS_AudioDecoderHandle)ulAudioPassThroughDecHandle;
	nNexusError = NEXUS_Playback_SetPidChannelSettings(s_tMhegIcsMediaInstance[unMediaId].playback, ulPidChannelHandle, &pidSettings);
	if(nNexusError != NEXUS_SUCCESS)
	{
		MhegIcsError("[%s] Error > Fail NEXUS_Playback_SetPidChannelSettings.\n", __func__);

		MhegIcsFunctionExit;

		return DRV_ERR;
	}	
	
	MhegIcsFunctionExit;

	return DRV_OK;
}

/**
 * @brief		Demux에서 TS에 대한 PAT, PMT Parsing을 위해 Playback Pid Channel을 Open한다.
 *
 * @param[in]	nDemuxId				Demux Id
 * @param[in]	nPid					Pid Number
 * @param[in]	nChannelType			Channel Type
 * @param[out]	phPidChannel			Pid Channel Handle
 * @return		DRV_Error
 * @see			DRV_MHEG_ICS_ClosePlaybackPidChannel
 */
DRV_Error DRV_MHEG_ICS_OpenPlaybackPidChannel(HUINT32 unMediaId, HINT32 nDemuxId, DI_DEMUX_CHANNELTYPE nChannelType, HINT32 nPid, NEXUS_PidChannelHandle *phPidChannel)
{
	DRV_Error nDrvRet = DRV_OK;
	NEXUS_PlaybackPidChannelSettings pidSettings;
	NEXUS_Error	neResult;

	MhegIcsFunctionEnter(unMediaId);

	MhegIcsDebug("%s(%d) Info> unMediaId(%d) , nDemuxId(%d) , nChannelType(%d) , nPid(0x%x)\n",__FUNCTION__,__LINE__, unMediaId, nDemuxId, nChannelType, nPid);
		
	if(unMediaId >= MAX_MHEG_ICS_NUM)	
	{
		MhegIcsError("[%s:%d] invalid MediaID(%d).\n", __func__, __LINE__, unMediaId);
		nDrvRet = DRV_ERR;
	}
	else
	{
		/* validation checking */
		if(s_tMhegIcsMediaInstance[unMediaId].mediastate < MHEG_ICS_STATE_READY)
		{
			MhegIcsError("[%s] Media doesn't ready.)\n", __func__);
			MhegIcsFunctionExit;
			return DRV_ERR;
		}

		NEXUS_Playback_GetDefaultPidChannelSettings(&pidSettings);
		switch(nChannelType)
		{
			case DI_DEMUX_CHANNELTYPE_VIDEO:
				if(!s_tMhegIcsMediaInstance[unMediaId].videoPidChannel)
				{
					pidSettings.pidSettings.pidType = NEXUS_PidType_eVideo;
					pidSettings.pidTypeSettings.video.codec = NEXUS_VideoCodec_eUnknown;
					pidSettings.pidTypeSettings.video.decoder = NULL; /* Decode will set this later */
				}
				else
				{
					MhegIcsError("[%s] Media video PID channel is already opened!\n\r",__FUNCTION__);
					return DRV_ERR;
				}
				break;
			case DI_DEMUX_CHANNELTYPE_AUDIO:
			case DI_DEMUX_CHANNELTYPE_AUDIO_SPDIF:
				if(!s_tMhegIcsMediaInstance[unMediaId].audioPidChannel)
				{
					pidSettings.pidSettings.pidType = NEXUS_PidType_eAudio;
					pidSettings.pidSettings.pidTypeSettings.audio.codec = NEXUS_AudioCodec_eUnknown; /* audio.codec is required for VOB substream id remapping. So ignored. */
					pidSettings.pidTypeSettings.audio.primary = NULL;/* Decode will set this later */
					pidSettings.pidTypeSettings.audio.secondary = NULL; /* Decode will set this later */
				}
				else
				{
					MhegIcsError("[%s] Media audio PID channel is already opened!\n\r",__FUNCTION__);
					return DRV_ERR;
				}
				break;
			case DI_DEMUX_CHANNELTYPE_RECORD:
				{
					MhegIcsError("[%s] Not Support Type\n", __func__);
					MhegIcsFunctionExit;
					return DRV_ERR;
				}
			case DI_DEMUX_CHANNELTYPE_PCR:
					*phPidChannel = DRV_DEMUX_GetPcrPidChannel();
					return DRV_OK;
			default:
					/* audio/video PID 와 동일한 경우 설정이 바뀌지 않도록 함 */
					if( s_tMhegIcsStreamInfo[unMediaId].video_stream_id == (HUINT32)nPid && s_tMhegIcsMediaInstance[unMediaId].videoPidChannel)
					{
						neResult = NEXUS_Playback_GetPidChannelSettings(s_tMhegIcsMediaInstance[unMediaId].playback
						, s_tMhegIcsMediaInstance[unMediaId].videoPidChannel, &pidSettings);
				        if(neResult != NEXUS_SUCCESS)
						{
							MhegIcsError("[%s] Error(0x%x) in NEXUS_Playback_GetPidChannelSettings()\n\r",__FUNCTION__, neResult);
							return DRV_ERR;
					    }
					}
					else if(s_tMhegIcsStreamInfo[unMediaId].audio_stream_id == (HUINT32)nPid && s_tMhegIcsMediaInstance[unMediaId].audioPidChannel)
					{
						neResult = NEXUS_Playback_GetPidChannelSettings(s_tMhegIcsMediaInstance[unMediaId].playback
						, s_tMhegIcsMediaInstance[unMediaId].audioPidChannel, &pidSettings);
				        if(neResult != NEXUS_SUCCESS)
						{
							MhegIcsError("[%s] Error(0x%x) in NEXUS_Playback_GetPidChannelSettings()\n\r",__FUNCTION__, neResult);
							return DRV_ERR;
					    }
					}

					pidSettings.pidSettings.pidType = NEXUS_PidType_eUnknown;
					*phPidChannel = NEXUS_Playback_OpenPidChannel(s_tMhegIcsMediaInstance[unMediaId].playback, nPid, &pidSettings);
					if(*phPidChannel == NULL)
					{
						MhegIcsError("[%s] Error in NEXUS_Playback_OpenPidChannel\n\r",__FUNCTION__);
						return DRV_ERR;
					}

					break;
		}

	}

	MhegIcsFunctionExit;

	return nDrvRet;
}

/**
 * @brief		Demux에서 TS에 대한 PAT, PMT Parsing을 위해 Open한 Playback Pid Channel을 Close한다.
 *
 * @param[in]	nDemuxId				Demux Id
 * @param[in]	nChannelType			Channel Type
 * @param[in]	hPidChannel				Pid Channel Handle
 * @return		DRV_Error
 * @see			DRV_MHEG_ICS_OpenPlaybackPidChannel
 */
DRV_Error DRV_MHEG_ICS_ClosePlaybackPidChannel(HUINT32 unMediaId, HINT32 nDemuxId, DI_DEMUX_CHANNELTYPE nChannelType, NEXUS_PidChannelHandle hPidChannel)
{
	DRV_Error nDrvRet = DRV_OK;
	
	MhegIcsFunctionEnter(unMediaId);
	
	MhegIcsDebug("%s(%d) Info> unMediaId(%d) , nDemuxId(%d) , nChannelType(%d) \n",__FUNCTION__,__LINE__, unMediaId, nDemuxId, nChannelType);

	if(unMediaId >= MAX_MHEG_ICS_NUM)	
	{
		MhegIcsError("[%s:%d] invalid MediaID(%d).\n", __func__, __LINE__, unMediaId);
		nDrvRet = DRV_ERR;
	}
	else
	{
		switch(nChannelType)
		{
			case DI_DEMUX_CHANNELTYPE_VIDEO:
			case DI_DEMUX_CHANNELTYPE_AUDIO:
			case DI_DEMUX_CHANNELTYPE_AUDIO_SPDIF:
				{
					MhegIcsError("[%s] Not Support Type (Please Use GetPlaybackVideoPidChannel or GetPlaybackAudioPidChannel.)\n", __func__);
					return DRV_ERR;
				}
			case DI_DEMUX_CHANNELTYPE_PCR:
			case DI_DEMUX_CHANNELTYPE_RECORD:
				{
					MhegIcsError("[%s] Not Support Type\n", __func__);
					return DRV_ERR;
				}
			default:
				{
					/** Nexus Pid Channel을 Close한다. */
					if(s_tMhegIcsMediaInstance[unMediaId].sectionPidChannel != NULL)
					{
						(void)NEXUS_Playback_ClosePidChannel(s_tMhegIcsMediaInstance[unMediaId].playback, hPidChannel);
						s_tMhegIcsMediaInstance[unMediaId].sectionPidChannel = NULL;
					}
				}
		}
	}

	MhegIcsFunctionExit;

	return nDrvRet;
}

HBOOL DRV_MHEG_ICS_CheckStart(HUINT32 unMediaId)
{
	return s_ulMhegIcsMediaStart[unMediaId]==0 ? FALSE : TRUE;
}
#endif

#define __________DI__________

void		DI_MHEG_ICS_INIT(HUINT32 unMediaId)
{
	MhegIcsFunctionEnter(unMediaId);	
	local_mheg_ics_media_InitTread(unMediaId);	
	MhegIcsFunctionExit;
}

void		DI_MHEG_ICS_DEINIT(HUINT32 unMediaId)
{
	MhegIcsFunctionEnter(unMediaId);	
	local_mheg_ics_media_DeinitTread(unMediaId);	
	MhegIcsFunctionExit;
}

DI_ERR_CODE DI_MHEG_ICS_MP_Setup(HUINT32 unMediaId, HUINT8 *pucStreamUrl, DI_MEDIA_INFO_t *ptStreamInfo)
{
	DI_ERR_CODE		eDIError = DI_ERR_OK;
	DRV_VIDEO_PRESET_DATA_t tVideoPresetData;
	NEXUS_Error		tNexusError = NEXUS_SUCCESS;
	NEXUS_PlaybackSettings playbackSettings;
	//HUINT8			*pucURI_Data = NULL;
	//HUINT8			*pucURI_Index = NULL;
	HINT32			nMediaCount=0;
	HBOOL			bUseIndex = FALSE; /* FirstPts 보정 사용 여부를 Index Open 여부로 구분 (Index Open 시 FirstPts 보정 사용 X ) */
	MhegIcsFunctionEnter(unMediaId);

	if(ptStreamInfo == NULL)
	{
		MhegIcsError("[%s] Error - ptStreamInfo is null\n", __func__);
		return DI_ERR_ERROR;
	}

	if(unMediaId >= MAX_MHEG_ICS_NUM)
	{
		MhegIcsError("[%s] Error - Media is full\n", __func__);
		return DI_ERR_ERROR;
	}

	s_bMhegIcsPlayTimerMode[unMediaId] = DI_MEDIA_TIMERMODE_NONE;	

	if(ptStreamInfo->ucTotalVideoTrack>0)
	{
		for(nMediaCount=0;nMediaCount<ptStreamInfo->ucTotalVideoTrack;nMediaCount++)
		{
			if(ptStreamInfo->stVideoTrack[nMediaCount].video_codec != DI_MEDIA_VIDEO_FORMAT_NONE)
			{
				MhegIcsData("[%s] video_codec=%d\n", __func__, ptStreamInfo->stVideoTrack[nMediaCount].video_codec);
				break;
			}
		}

		if(nMediaCount == ptStreamInfo->ucTotalVideoTrack)
		{
			MhegIcsError("Fail Video Codec is Unknown!\n");
			return DI_ERR_ERROR;
		}

		for(nMediaCount=0;nMediaCount<ptStreamInfo->ucTotalVideoTrack;nMediaCount++)
		{
			if(ptStreamInfo->stVideoTrack[nMediaCount].video_stream_id != 0)
			{
				MhegIcsData("[%s] video_stream_id=%d\n", __func__, ptStreamInfo->stVideoTrack[nMediaCount].video_stream_id);
				break;
			}
		}

		if(nMediaCount == ptStreamInfo->ucTotalVideoTrack)
		{
			MhegIcsError("Fail Video Stream Id is Unknown!\n");
			return DI_ERR_ERROR;
		}
	}

	if(VK_SEM_Get(s_ulMhegIcsMediaSemId[unMediaId]) != VK_OK)
	{
		MhegIcsError("VK_SEM_Get failed!\n");
		return DI_ERR_ERROR;
	}

	if(s_tMhegIcsMediaInstance[unMediaId].valid == TRUE)
	{
		MhegIcsError("[%s] Error - Fail MEDIA(%d) already setuped..!! \n", __func__, unMediaId);
		(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);
		return DI_ERR_INVALID_PARAM;
	}	

	s_tMhegIcsMediaInstance[unMediaId].valid = TRUE;

	VK_MEM_Memset(&s_tMhegIcsStreamInfo[unMediaId], 0x0, sizeof(DI_MEDIA_INFO_t));
	s_tMhegIcsMediaInstance[unMediaId].mediaurl = DD_MEM_Alloc(VK_strlen((char *)pucStreamUrl)+1);
	VK_MEM_Memset(s_tMhegIcsMediaInstance[unMediaId].mediaurl, 0x0, VK_strlen((char *)pucStreamUrl)+1);
	s_tMhegIcsMediaInstance[unMediaId].mediastate=MHEG_ICS_STATE_NO_SETUP;
	s_tMhegIcsMediaInstance[unMediaId].mediaType=DI_MEDIA_PLAYPUMP_DIVX;
	s_tMhegIcsMediaInstance[unMediaId].audioStatus=DI_MHEG_ICS_AUDIO_FREE;
	s_tMhegIcsMediaInstance[unMediaId].audioPlayback=NULL;
	s_tMhegIcsMediaInstance[unMediaId].playback=NULL;
	s_tMhegIcsMediaInstance[unMediaId].audioPidChannel=NULL;
	s_tMhegIcsMediaInstance[unMediaId].videoPidChannel=NULL;
	s_tMhegIcsMediaInstance[unMediaId].sectionPidChannel=NULL;
	s_tMhegIcsMediaInstance[unMediaId].pcrPidChannel=NULL; /* pcr_pid */
	s_tMhegIcsMediaInstance[unMediaId].file=NULL;
	s_tMhegIcsMediaInstance[unMediaId].trickrate=DI_MEDIA_TRICK_PAUSE;

	VK_memcpy(&s_tMhegIcsStreamInfo[unMediaId], ptStreamInfo, sizeof(DI_MEDIA_INFO_t));
	VK_memcpy(s_tMhegIcsMediaInstance[unMediaId].mediaurl, pucStreamUrl, VK_strlen((char *)pucStreamUrl));

	eDIError = local_mheg_ics_media_CreatePlayback(unMediaId);
	if(eDIError != DI_ERR_OK)
	{
		MhegIcsError("[%s] Error - Fail local_mheg_ics_media_CreatePlayback(%d)\n", __func__, eDIError);
		s_tMhegIcsMediaInstance[unMediaId].valid = FALSE;
		if(s_tMhegIcsMediaInstance[unMediaId].mediaurl != NULL)
		{
			DD_MEM_Free(s_tMhegIcsMediaInstance[unMediaId].mediaurl);
			s_tMhegIcsMediaInstance[unMediaId].mediaurl = NULL;
		}

		(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);
		return eDIError;
	}

	/** Set Media Type */
	if((s_tMhegIcsStreamInfo[unMediaId].audio_stream_id != 0) && (s_tMhegIcsStreamInfo[unMediaId].audio_codec != 0) &&
		(s_tMhegIcsStreamInfo[unMediaId].video_stream_id != 0) && (s_tMhegIcsStreamInfo[unMediaId].video_codec != 0))
	{
		s_tMhegIcsMediaInstance[unMediaId].mediaType = DI_MEDIA_PLAYPUMP_DIVX;
	}
	else if((s_tMhegIcsStreamInfo[unMediaId].audio_stream_id != 0) && (s_tMhegIcsStreamInfo[unMediaId].audio_codec != 0))
	{
		s_tMhegIcsMediaInstance[unMediaId].mediaType = DI_MEDIA_PLAYPUMP_AUDIO_MAIN;
	}
	else if((s_tMhegIcsStreamInfo[unMediaId].video_stream_id != 0) && (s_tMhegIcsStreamInfo[unMediaId].video_codec != 0))
	{
		s_tMhegIcsMediaInstance[unMediaId].mediaType = DI_MEDIA_PLAYPUMP_VIDEO;
	}
	else
	{
		MhegIcsError("[%s] Error - Not exist Video & Audio Pid\n", __func__);
		eDIError = DI_ERR_ERROR;
		(void)local_mheg_ics_media_DeletePlayback(unMediaId);
		if(s_tMhegIcsMediaInstance[unMediaId].mediaurl != NULL)
		{
			DD_MEM_Free(s_tMhegIcsMediaInstance[unMediaId].mediaurl);
			s_tMhegIcsMediaInstance[unMediaId].mediaurl = NULL;
		}

		s_tMhegIcsMediaInstance[unMediaId].valid = FALSE;
		(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);
		return eDIError;
	}

	/** Open File Posix */
	if((NULL != strstr((char *)pucStreamUrl, "http://")) || (NULL != strstr((char *)pucStreamUrl, "https://"))
		|| (NULL != strstr((char *)pucStreamUrl, "mms://")) || (NULL != strstr((char *)pucStreamUrl, "rtsp://")))
	{

		/* DNP Player looks like Local file Play */
		if (NULL != strstr((char*)pucStreamUrl,"[dnp]"))
		{
			if(s_tMhegIcsStreamInfo[unMediaId].stream_type != DI_MEDIA_MPEG_TYPE_ASF)
			{
				MhegIcsData("IPTUNER (DNP:%d) Play(%s)\n", unMediaId, pucStreamUrl);
				s_tMhegIcsMediaInstance[unMediaId].file = NEXUS_FilePlay_OpenPosix((char *)pucStreamUrl, (char *)pucStreamUrl);
				bUseIndex = TRUE;
			}
			else
			{
				MhegIcsData("IPTUNER (DNP-progressive down) Play(%s)\n", pucStreamUrl);
				s_tMhegIcsMediaInstance[unMediaId].file = NEXUS_FilePlay_OpenPosix((char *)pucStreamUrl, (char *)pucStreamUrl); /* progressive down */
				bUseIndex = TRUE;
			}
		}
		/* DLNA Player looks like Local file Play */
		else if (NULL != strstr((char*)pucStreamUrl,"[DLNA]"))
		{			
			MhegIcsData("DLNA Play(%s)\n", pucStreamUrl);			
		}
		/* Streaming IPTUNER MUST be opend as Sing File for VFIO Operation.*/
		else
		{
			MhegIcsData("IPTUNER (Streaming) Play(%s)\n", pucStreamUrl);

			if((s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_TS) ||
				(s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_TS_192) ||
				(s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_PES) ||
				(s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_MP4FRAGMENT) || /* for SSTR */
				((s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_ASF)&&(NULL != strstr((char *)pucStreamUrl, "mms://"))) ||
				((s_tMhegIcsMediaInstance[unMediaId].mediaType == DI_MEDIA_PLAYPUMP_AUDIO_MAIN)&&(s_tMhegIcsStreamInfo[unMediaId].audio_codec == DI_MEDIA_AUDIO_FORMAT_MP3)))
			{
				s_tMhegIcsMediaInstance[unMediaId].file = NEXUS_FilePlay_OpenPosix ((char *)pucStreamUrl, NULL);
			}
			else
			{
				s_tMhegIcsMediaInstance[unMediaId].file = NEXUS_FilePlay_OpenPosix ((char *)pucStreamUrl, (char *)pucStreamUrl);
				bUseIndex = TRUE;
			}
		}
	}
	else
	{
		MhegIcsData("Local File Play(%s)\n", pucStreamUrl);
	}

	if (!s_tMhegIcsMediaInstance[unMediaId].file)
	{
		MhegIcsError("[%s] Error - can't open file:%s\n", __func__, pucStreamUrl);
		eDIError = DI_ERR_ERROR;
		(void)local_mheg_ics_media_DeletePlayback(unMediaId);
		if(s_tMhegIcsMediaInstance[unMediaId].mediaurl != NULL)
		{
			DD_MEM_Free(s_tMhegIcsMediaInstance[unMediaId].mediaurl);
			s_tMhegIcsMediaInstance[unMediaId].mediaurl = NULL;
		}

		s_tMhegIcsMediaInstance[unMediaId].valid = FALSE;
	}
	else
	{
//		s_tMhegIcsMediaInstance[unMediaId].playpump[DI_MEDIA_PLAYPUMP_DIVX] = stMediaInstance.playpump[DI_MEDIA_PLAYPUMP_DIVX];

		/** Set Playback Option */
		(void)NEXUS_Playback_GetSettings(s_tMhegIcsMediaInstance[unMediaId].playback, &playbackSettings);
		if(s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_MP4FRAGMENT)
		{
			DRV_PVR_GetPlaypumpHandleByClass(&s_tMhegIcsMediaInstance[unMediaId].playpump[DI_MEDIA_PLAYPUMP_DIVX],BUFF_GROUP_1);
		}
		else
		{
			DRV_PVR_GetPlaypumpHandle(&s_tMhegIcsMediaInstance[unMediaId].playpump[DI_MEDIA_PLAYPUMP_DIVX]);
		}
		playbackSettings.playpump = s_tMhegIcsMediaInstance[unMediaId].playpump[DI_MEDIA_PLAYPUMP_DIVX];
		playbackSettings.playpumpSettings.transportType = local_mheg_ics_media_ConvertTransportTypeToNexus(s_tMhegIcsStreamInfo[unMediaId].stream_type);

		if(s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_TS_192)
		{
			playbackSettings.playpumpSettings.timestamp.type = NEXUS_TransportTimestampType_eMod300;
			playbackSettings.playpumpSettings.timestamp.timebase = NEXUS_Timebase_eInvalid;
			playbackSettings.playpumpSettings.timestamp.pacing = FALSE;
			playbackSettings.playpumpSettings.timestamp.pacingMaxError = 2048;
		}
		else
		{
			playbackSettings.playpumpSettings.timestamp.type = NEXUS_TransportTimestampType_eNone;
		}

		playbackSettings.startPaused = true;

		playbackSettings.endOfStreamAction = NEXUS_PlaybackLoopMode_ePause;
		playbackSettings.beginningOfStreamAction = NEXUS_PlaybackLoopMode_ePause;

		if((s_tMhegIcsStreamInfo[unMediaId].video_stream_id == 0) && (s_tMhegIcsStreamInfo[unMediaId].audio_stream_id != 0)
			&& ((s_tMhegIcsStreamInfo[unMediaId].audio_codec == DI_MEDIA_AUDIO_FORMAT_MP3) ||
 (s_tMhegIcsStreamInfo[unMediaId].audio_codec == DI_MEDIA_AUDIO_FORMAT_PCM)))
		{
			playbackSettings.playpumpSettings.mode = NEXUS_PlaybackMode_eAutoBitrate;
			playbackSettings.enableStreamProcessing = TRUE;
		}
		else
		{
			playbackSettings.playpumpSettings.mode = NEXUS_PlaybackMode_eIndexed;
		}

		playbackSettings.endOfStreamCallback.callback = local_mheg_ics_media_EndOfStreamCallback;
		playbackSettings.endOfStreamCallback.context = NULL;
		playbackSettings.endOfStreamCallback.param= unMediaId;
		playbackSettings.beginningOfStreamCallback.callback = local_mheg_ics_media_BeginOfStreamCallback;
		playbackSettings.beginningOfStreamCallback.context = NULL;
		playbackSettings.beginningOfStreamCallback.param= unMediaId;
		playbackSettings.errorCallback.callback = local_mheg_ics_media_ErrorOfStreamCallback;
		playbackSettings.errorCallback.context = NULL;
		playbackSettings.errorCallback.param= unMediaId;
#if 0  /* Nexus Phase 6.5이상에서 사용될 부분 */
		playbackSettings.playErrorHandling = NEXUS_PlaybackErrorHandlingMode_eEndOfStream;
		playbackSettings.seekErrorHandling = NEXUS_PlaybackErrorHandlingMode_eIgnore;
		playbackSettings.trickErrorHandling = NEXUS_PlaybackErrorHandlingMode_eIgnore;
		playbackSettings.ioTimeout = 5000; /* 5 sec */
#endif
		tNexusError = NEXUS_Playback_SetSettings(s_tMhegIcsMediaInstance[unMediaId].playback, &playbackSettings);
		(void)NEXUS_Playback_GetSettings(s_tMhegIcsMediaInstance[unMediaId].playback, &playbackSettings);
		if(s_tMhegIcsMediaInstance[unMediaId].mediaType == DI_MEDIA_PLAYPUMP_AUDIO_MAIN)
		{
			playbackSettings.stcTrick = false;
		}
		else
		{
			/* WMV PAUSE/RESUME Patch */
			playbackSettings.stcChannel = DRV_MHEG_ICS_MP_GetPlaybackStcChannelHandle(unMediaId, s_tMhegIcsStreamInfo[unMediaId].videodecodertype, s_tMhegIcsStreamInfo[unMediaId].audiodecodertype, DI_MEDIA_PLAYPUMP_DIVX);
			playbackSettings.stcTrick = true;
		}
		tNexusError = NEXUS_Playback_SetSettings(s_tMhegIcsMediaInstance[unMediaId].playback, &playbackSettings);
		
		if(NEXUS_SUCCESS != tNexusError)
		{
			MhegIcsError("[%s] Error - Fail NEXUS_PlaybackSetSetting:%d\n", __func__,tNexusError);
			(void)NEXUS_FilePlay_Close(s_tMhegIcsMediaInstance[unMediaId].file);
			(void)local_mheg_ics_media_DeletePlayback(unMediaId);
			if(s_tMhegIcsMediaInstance[unMediaId].mediaurl != NULL)
			{
				DD_MEM_Free(s_tMhegIcsMediaInstance[unMediaId].mediaurl);
				s_tMhegIcsMediaInstance[unMediaId].mediaurl = NULL;
			}

			s_tMhegIcsMediaInstance[unMediaId].valid = FALSE;
			eDIError = DI_ERR_ERROR;
	/* else { continue; } */
		}
		else
		{
			s_tMhegIcsMediaInstance[unMediaId].mediastate = MHEG_ICS_STATE_READY;
			s_bMhegIcsPlayTimerMode[unMediaId] = DI_MEDIA_TIMERMODE_UPDATE_FULLTIME;
		}

		/* VIDEO Setting for Smooth Streaming */
		if(s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_MP4FRAGMENT)
		{
			VK_MEM_Memset(&tVideoPresetData,0x00,sizeof(DRV_VIDEO_PRESET_DATA_t));
			tVideoPresetData.bOnOff = true;
			DRV_VIDEO_SetPresetProperties(DI_VIDEO_DECODER_MAIN, DRV_VIDEO_PRESET_SSTR ,&tVideoPresetData); // TODO: Decoder Setting 확인
		}

		if((s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_TS 
				|| s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_VOB
				|| s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_TS_192)
				&& bUseIndex == FALSE)
		{
			if(s_tMhegIcsStreamInfo[unMediaId].bProbedFirstPts == TRUE)
			{
				local_mheg_ics_media_InstallFirstPts(unMediaId, s_tMhegIcsStreamInfo[unMediaId].unProbeFirstPts);
			}
			else
				(void) local_mheg_ics_media_RegisterFirstPtsCB (unMediaId, (DI_MEDIA_FirstPtsCallback_t) &local_mheg_ics_media_FirstPtsCallback);
		}
		else
		{
			local_mheg_ics_media_InstallFirstPts(unMediaId, 0);
		}
	}

	/* s_ulMhegIcsMediaStart for DI_AUDIO, DI_VIDEO : DRV_MHEG_ICS_CheckStart() */
	++s_ulMhegIcsMediaStart[unMediaId];

/* Success: */
	(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);

	MhegIcsFunctionExit;

	return eDIError;
}

/**
 * @brief 		Media file 재생을 위해 설정된 환경설정을 종료한다.
 *
 * @param[in]	unMediaId			Di Media ID
 * @return		DI Error Code
 * @see
 */
DI_ERR_CODE DI_MHEG_ICS_MP_Release(HUINT32 unMediaId)
{
	DI_ERR_CODE		eDIError = DI_ERR_OK;
	DRV_VIDEO_PRESET_DATA_t tVideoPresetData;
	NEXUS_StcChannelSettings stcSettings;

	MhegIcsFunctionEnter(unMediaId);

	if(VK_SEM_Get(s_ulMhegIcsMediaSemId[unMediaId]) != VK_OK)
	{
		MhegIcsError("VK_SEM_Get failed!\n");
		eDIError = DI_ERR_ERROR;
	}
	else
	{
		eDIError = local_mheg_ics_media_CheckValidMediaId(unMediaId);
		if(eDIError != DI_ERR_OK)
		{
			MhegIcsError("[%s] Error - Invalid Media Id.\n", __func__);
			eDIError = DI_ERR_ERROR;
		}
		else
		{
			DI_MHEG_ICS_DEINIT(unMediaId);
			DI_MHEG_ICS_IPTUNER_UnderflowMonitorDestroy(unMediaId);
		
#if SUPPORT_USE_STC_AUTOMODE_FIRSTAVAILABLE
			(void)NEXUS_StcChannel_GetSettings(DRV_DEMUX_GetStcChannelHandle(), &stcSettings);
			if((s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_ASF)
				&& (stcSettings.modeSettings.Auto.behavior == NEXUS_StcChannelAutoModeBehavior_eFirstAvailable))
			{
				stcSettings.modeSettings.Auto.behavior = NEXUS_StcChannelAutoModeBehavior_eVideoMaster;
				NEXUS_StcChannel_SetSettings(DRV_DEMUX_GetStcChannelHandle(), &stcSettings);
			}
#endif
			if(s_tMhegIcsMediaInstance[unMediaId].mediaType == DI_MEDIA_PLAYPUMP_DIVX)
			{				
				if(s_tMhegIcsMediaInstance[unMediaId].videoPidChannel != NULL)
				{
					MhegIcsDebug("[%s:%d] call NEXUS_Playback_ClosePidChannel(0x%X:0x%X) 4V.\n", 
								__func__, __LINE__, s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].videoPidChannel);
					(void)NEXUS_Playback_ClosePidChannel(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].videoPidChannel);
					s_tMhegIcsMediaInstance[unMediaId].videoPidChannel = NULL;
				}
				
				for(HUINT32 i = 0; i < s_tMhegIcsStreamInfo[unMediaId].ucTotalAudioTrack ; i++)
				{					
					if(s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i] != NULL)
					{
						MhegIcsDebug("[%s:%d] call NEXUS_Playback_ClosePidChannel(0x%X:0x%X) 4A(%d).\n", 
										__func__, __LINE__, s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i], i);
						(void)NEXUS_Playback_ClosePidChannel(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i]);
						s_tMhegIcsMediaInstance[unMediaId].audioTrackPidChannels[i] = NULL;
					}		
				}
				s_tMhegIcsMediaInstance[unMediaId].audioPidChannel = NULL;
				s_tMhegIcsMediaInstance[unMediaId].audioSubPidChannel = NULL;
			}
			else if(s_tMhegIcsMediaInstance[unMediaId].mediaType == DI_MEDIA_PLAYPUMP_VIDEO)
			{				
				if(s_tMhegIcsMediaInstance[unMediaId].videoPidChannel != NULL)
				{
					MhegIcsDebug("[%s:%d] call NEXUS_Playback_ClosePidChannel(0x%X:0x%X) 4V.\n", 
								__func__, __LINE__, s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].videoPidChannel);
					(void)NEXUS_Playback_ClosePidChannel(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].videoPidChannel);
					s_tMhegIcsMediaInstance[unMediaId].videoPidChannel = NULL;
				}
			}
			else if(s_tMhegIcsMediaInstance[unMediaId].mediaType == DI_MEDIA_PLAYPUMP_AUDIO_MAIN)
			{				
				if(s_tMhegIcsMediaInstance[unMediaId].videoPidChannel != NULL)
				{
					MhegIcsDebug("[%s:%d] call NEXUS_Playback_ClosePidChannel(0x%X:0x%X) 4A.\n", 
								__func__, __LINE__, s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].audioPidChannel);
					(void)NEXUS_Playback_ClosePidChannel(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].audioPidChannel);
					s_tMhegIcsMediaInstance[unMediaId].audioPidChannel = NULL;
				}
			}
			
			if( (s_tMhegIcsStreamInfo[unMediaId].pcr_pid != 0x1fff) 
				&& (s_tMhegIcsStreamInfo[unMediaId].pcr_pid != s_tMhegIcsStreamInfo[unMediaId].video_stream_id)
				&& (s_tMhegIcsStreamInfo[unMediaId].pcr_pid != s_tMhegIcsStreamInfo[unMediaId].audio_stream_id)
				&& (s_tMhegIcsMediaInstance[unMediaId].pcrPidChannel != NULL) )
			{
				MhegIcsDebug("[%s:%d] call NEXUS_Playback_ClosePidChannel(0x%X:0x%X) 4PCR.\n",
							__func__, __LINE__, s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].pcrPidChannel);				
				(void)NEXUS_Playback_ClosePidChannel(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].pcrPidChannel);									
			}
			s_tMhegIcsMediaInstance[unMediaId].pcrPidChannel = NULL;

			NEXUS_StcChannel_GetSettings(DRV_DEMUX_GetStcChannelHandle(), &stcSettings);
			stcSettings.timebase = NEXUS_Timebase_e0;
			stcSettings.mode = NEXUS_StcChannelMode_eAuto;
			stcSettings.modeSettings.pcr.pidChannel = NULL;
			NEXUS_StcChannel_SetSettings(DRV_DEMUX_GetStcChannelHandle(), &stcSettings);
			
			(void)NEXUS_FilePlay_Close(s_tMhegIcsMediaInstance[unMediaId].file);		
						
			(void)local_mheg_ics_media_DeletePlayback(unMediaId);				
			
			DRV_PVR_ReleasePlaypumpHandle(s_tMhegIcsMediaInstance[unMediaId].playpump[DI_MEDIA_PLAYPUMP_DIVX]);
			s_tMhegIcsMediaInstance[unMediaId].playpump[DI_MEDIA_PLAYPUMP_DIVX] = NULL;

			if(s_tMhegIcsEventCallback[unMediaId] != NULL)
			{
				s_tMhegIcsEventCallback[unMediaId] = NULL;
			}

			if(s_tMhegIcsMediaInstance[unMediaId].mediaurl != NULL)
			{
				DD_MEM_Free(s_tMhegIcsMediaInstance[unMediaId].mediaurl);
				s_tMhegIcsMediaInstance[unMediaId].mediaurl = NULL;
			}

			if(s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_MP4FRAGMENT)
			{
				VK_MEM_Memset(&tVideoPresetData,0x00,sizeof(DRV_VIDEO_PRESET_DATA_t));
				tVideoPresetData.bOnOff = false;
				DRV_VIDEO_SetPresetProperties(DI_VIDEO_DECODER_MAIN, DRV_VIDEO_PRESET_SSTR ,&tVideoPresetData); // TODO: Decoder Setting 확인
			}
			
			if(s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_TS ||
			s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_TS_192 )
			{
				(void)local_mheg_ics_media_UnregisterFirstPtsCB(unMediaId);
			}
			
			VK_MEM_Memset(&s_tMhegIcsMediaInstance[unMediaId], 0x0, sizeof(DI_Mheg_Ics_MediaInstance_t));
			VK_MEM_Memset(&s_tMhegIcsStreamInfo[unMediaId], 0x0, sizeof(DI_MEDIA_INFO_t));
		}

		if( VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]) != VK_OK )
		{
			MhegIcsError("[%s] VK_SEM_Release failed\n\r",__FUNCTION__);
			eDIError = DI_ERR_ERROR;
		}
	}

	if( VK_SEM_Destroy(s_ulMhegIcsMediaSemId[unMediaId]) != VK_OK )
	{
		MhegIcsError("[%s] [%d] Error > destroy mheg_ics_media_sema  \n\r",__FUNCTION__,__LINE__);		
		eDIError = DI_ERR_ERROR;
	}
	
	s_ulMhegIcsMediaSemId[unMediaId] = 0;

	s_bMhegIcsPlayTimerMode[unMediaId] = DI_MEDIA_TIMERMODE_NONE;
	s_pcMhegIcsLisenceData = NULL;

	/* s_ulMhegIcsMediaStart for DI_AUDIO, DI_VIDEO : DRV_MHEG_ICS_CheckStart() */
	if(s_ulMhegIcsMediaStart[unMediaId] > 0)
		--s_ulMhegIcsMediaStart[unMediaId];

	MhegIcsFunctionExit;

	return eDIError;
}


/**
 * @brief		media를 재생한다.
 *
 * @param[in]	unMediaId			Di Media ID
 * @return		DI Error Code
 * @see			DI_MEDIA_Stop
 */
DI_ERR_CODE DI_MHEG_ICS_MP_Start (HUINT32 unMediaId, HBOOL bPause)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;
	NEXUS_Error tNexusError = NEXUS_SUCCESS;
	NEXUS_PlaybackStartSettings playbackstartSettings;
	HUINT8			*pucURI_Data = NULL;

	MhegIcsFunctionEnter(unMediaId);

	if(VK_SEM_Get(s_ulMhegIcsMediaSemId[unMediaId]) != VK_OK)
	{
		MhegIcsError("VK_SEM_Get failed!\n");
		return DI_ERR_ERROR;
	}

	eDIError = local_mheg_ics_media_CheckValidMediaId(unMediaId);
	if(eDIError != DI_ERR_OK)
	{
		MhegIcsError("[%s] Error - Invalid Media Id.\n", __func__);
		(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);
		return eDIError;
	}

	if((s_tMhegIcsMediaInstance[unMediaId].playback == NULL) || (s_tMhegIcsMediaInstance[unMediaId].mediastate == MHEG_ICS_STATE_NO_SETUP))
	{
		MhegIcsError("[%s] Error - Not initialized Media.\n", __func__);
		eDIError = DI_ERR_ERROR;
	}
	else
	{
		if((s_tMhegIcsMediaInstance[unMediaId].mediastate == MHEG_ICS_STATE_READY) || (s_tMhegIcsMediaInstance[unMediaId].mediastate == MHEG_ICS_STATE_STOP))
		{
			if(s_tMhegIcsEventCallback[unMediaId] != NULL)
			{
				s_tMhegIcsEventCallback[unMediaId](unMediaId, DI_MEDIA_EVENT_CHANGEPLAYTIME, 0);
			}

			/** Start & Play Playback */
			(void)NEXUS_Playback_GetDefaultStartSettings(&playbackstartSettings);

			if((s_tMhegIcsStreamInfo[unMediaId].video_stream_id == 0) && (s_tMhegIcsStreamInfo[unMediaId].audio_stream_id != 0)
				&& (s_tMhegIcsStreamInfo[unMediaId].audio_codec == DI_MEDIA_AUDIO_FORMAT_MP3))
			{
				playbackstartSettings.indexFileIo.mode = NEXUS_PlaybackIndexFileIo_eModule;
				playbackstartSettings.mode = NEXUS_PlaybackMode_eAutoBitrate;
			}
			else
			{
				playbackstartSettings.mode = NEXUS_PlaybackMode_eIndexed;
			}

			playbackstartSettings.bitrate = s_tMhegIcsStreamInfo[unMediaId].max_bitrate;

			/* Force the bitrate value if we can't get it under HTTP chunked live streaming */
			/* because of nexus_playback failture */
			if ((s_tMhegIcsStreamInfo[unMediaId].isHttpChunked == TRUE) && (s_tMhegIcsStreamInfo[unMediaId].max_bitrate == 0))
			{
				playbackstartSettings.bitrate = (1*1024*1024);
			}
			tNexusError = NEXUS_Playback_Start(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].file, &playbackstartSettings);
			if (tNexusError != NEXUS_SUCCESS)
			{
				MhegIcsData("[%s] Error - (1) Fail NEXUS_Playback_Start:%d\n", __func__,tNexusError);
				/* NEXUS_Playback_Start may fail if the AVI file has no index. If so, reopen without an index and try again. */
				(void)NEXUS_FilePlay_Close(s_tMhegIcsMediaInstance[unMediaId].file);
				MhegIcsData("[%s] NEXUS_FilePlay_Close:%d\n", __func__,tNexusError);
				s_tMhegIcsMediaInstance[unMediaId].file = NULL;

				if((NULL != strstr((char *)s_tMhegIcsMediaInstance[unMediaId].mediaurl, "[DLNA]")) && (VK_strlen((char *)s_tMhegIcsMediaInstance[unMediaId].mediaurl) > 12))
				{					
					MhegIcsData("IPTUNER (DLNA) url(%s)\n", pucURI_Data);
				}
				else
				{
					MhegIcsData("IPTUNER url(%s)\n", s_tMhegIcsMediaInstance[unMediaId].mediaurl);
					
					if((s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_TS) ||
						(s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_TS_192) ||
						(s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_PES) ||
						(s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_MP4FRAGMENT) || /* for SSTR */
						((s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_ASF)&&(NULL != strstr((char *)s_tMhegIcsMediaInstance[unMediaId].mediaurl, "mms://"))) ||
						((s_tMhegIcsMediaInstance[unMediaId].mediaType == DI_MEDIA_PLAYPUMP_AUDIO_MAIN)&&(s_tMhegIcsStreamInfo[unMediaId].audio_codec == DI_MEDIA_AUDIO_FORMAT_MP3)))
					{
						s_tMhegIcsMediaInstance[unMediaId].file = NEXUS_FilePlay_OpenPosix ((char *)s_tMhegIcsMediaInstance[unMediaId].mediaurl, NULL);
					}
					else
					{
						s_tMhegIcsMediaInstance[unMediaId].file = NEXUS_FilePlay_OpenPosix ((char *)s_tMhegIcsMediaInstance[unMediaId].mediaurl, (char *)s_tMhegIcsMediaInstance[unMediaId].mediaurl);
					}
				}

				tNexusError = NEXUS_Playback_Start(s_tMhegIcsMediaInstance[unMediaId].playback, s_tMhegIcsMediaInstance[unMediaId].file, &playbackstartSettings);
				if (tNexusError != NEXUS_SUCCESS)
				{
					MhegIcsError("[%s] Error - (2) Fail NEXUS_Playback_Start:%d\n", __func__,tNexusError);
					eDIError = DI_ERR_ERROR;
				}
				else
				{
					s_tMhegIcsStreamInfo[unMediaId].support_trick = FALSE;
				}

				MhegIcsData("[%s] Exit NEXUS_Playback_Start Set:%d\n", __func__,tNexusError);
				/*
				* NEXUS_Playback_GetStatus의 Mp3 Position Patching (PH 5.0 이후로 지속 반영됨)으로 인해
				* bmpeg2ts_player 사용 시 Position을 Decoder의 pts 정보가 아닌 playback position으로
				* Play Time을 사용하고 있기 때문에 bmpeg2ts_player가 열리는 경우(Index Open)에는 FirstPts
				* 보정을 하지 않도록 수정함.
				*/
				if(s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_TS ||
				s_tMhegIcsStreamInfo[unMediaId].stream_type == DI_MEDIA_MPEG_TYPE_TS_192)
				{
					if(s_tMhegIcsStreamInfo[unMediaId].bProbedFirstPts == TRUE)
					{
						local_mheg_ics_media_InstallFirstPts(unMediaId, s_tMhegIcsStreamInfo[unMediaId].unProbeFirstPts);
					}
					else
						(void) local_mheg_ics_media_RegisterFirstPtsCB (unMediaId, (DI_MEDIA_FirstPtsCallback_t) &local_mheg_ics_media_FirstPtsCallback);
				}
			}

			if(eDIError == DI_ERR_OK)
			{				
				/** Start Playback */
				if(bPause != TRUE)
				{
					tNexusError = NEXUS_Playback_Play(s_tMhegIcsMediaInstance[unMediaId].playback);
					if(tNexusError != NEXUS_SUCCESS)
					{
						MhegIcsError("[%s] Error - Fail NEXUS_Playback_Play:%d\n", __func__, tNexusError);
						eDIError = DI_ERR_ERROR;
					}
					else
					{
						if(s_tMhegIcsEventCallback[unMediaId] != NULL)
						{
							s_tMhegIcsEventCallback[unMediaId](unMediaId, DI_MEDIA_EVENT_START, 0);
						}
						else
						{
							MhegIcsDebug("event callback is NULL\n");
						}
#if defined(CONFIG_IPTUNER) 
						if(DI_MHEG_ICS_IPTUNER_GetUnderflowState(unMediaId) != 33)
						{
							DI_MHEG_ICS_IPTUNER_SetUnderflowState(unMediaId, 33);
						}
#endif
						s_tMhegIcsMediaInstance[unMediaId].mediastate = MHEG_ICS_STATE_PLAY;
						s_tMhegIcsMediaInstance[unMediaId].trickrate = DI_MEDIA_TRICK_1FFSTEP;
					}
				}
				else
				{
					tNexusError = NEXUS_Playback_Play(s_tMhegIcsMediaInstance[unMediaId].playback);
					if(tNexusError != NEXUS_SUCCESS)
					{
						MhegIcsError("[%s] Error - Fail NEXUS_Playback_Play:%d\n", __func__, tNexusError);
						eDIError = DI_ERR_ERROR;
					}
					else
					{
						(void)NEXUS_Playback_Pause(s_tMhegIcsMediaInstance[unMediaId].playback);

						if(s_tMhegIcsEventCallback[unMediaId] != NULL)
						{
							s_tMhegIcsEventCallback[unMediaId](unMediaId, DI_MEDIA_EVENT_PAUSE, 0);
						}
						else
						{
							MhegIcsDebug("event callback is NULL\n");
						}

						s_tMhegIcsMediaInstance[unMediaId].mediastate = MHEG_ICS_STATE_PAUSE;
						s_tMhegIcsMediaInstance[unMediaId].trickrate = DI_MEDIA_TRICK_PAUSE;
					}
				}

				
				if((s_tMhegIcsStreamInfo[unMediaId].eStartCondition == DI_MEDIA_PLAY_START_MODE_LASTVIEW)
					&& (s_tMhegIcsStreamInfo[unMediaId].support_seek == TRUE))
				{
					/** Set Playback Play Position */
					while(1)
					{
						if(NEXUS_Playback_Seek(s_tMhegIcsMediaInstance[unMediaId].playback, (NEXUS_PlaybackPosition)s_tMhegIcsStreamInfo[unMediaId].ulStartTime) == NEXUS_SUCCESS)
						{
							MhegIcsError("[%s:%d] NEXUS_Playback_Seek success..\n", __func__, __LINE__);
							break;
						}
						
						VK_TASK_Sleep(100);
					}
				}
			}
		}
		else if(s_tMhegIcsMediaInstance[unMediaId].mediastate == MHEG_ICS_STATE_PAUSE)
		{
			/** Start Playback */
			tNexusError = NEXUS_Playback_Play(s_tMhegIcsMediaInstance[unMediaId].playback);
			if(tNexusError != NEXUS_SUCCESS)
			{
				MhegIcsError("[%s] Error - Fail NEXUS_Playback_Play:%d\n", __func__, tNexusError);
				eDIError = DI_ERR_ERROR;
			}
			else
			{
				if(s_tMhegIcsEventCallback[unMediaId] != NULL)
				{
					s_tMhegIcsEventCallback[unMediaId](unMediaId, DI_MEDIA_EVENT_START, 0);
				}
#if defined(CONFIG_IPTUNER) 				
				if(DI_MHEG_ICS_IPTUNER_GetUnderflowState(unMediaId) != 33)
				{
					DI_MHEG_ICS_IPTUNER_SetUnderflowState(unMediaId, 33);
				}
#endif
				s_tMhegIcsMediaInstance[unMediaId].mediastate = MHEG_ICS_STATE_PLAY;
				s_tMhegIcsMediaInstance[unMediaId].trickrate = DI_MEDIA_TRICK_1FFSTEP;
			}
		}
		else
		{
			MhegIcsError("[%s] Error - Already Playback is start state.:%d\n", __func__, tNexusError);
			eDIError = DI_ERR_ERROR;
		}
	}

/* Success: */
	(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);

	MhegIcsFunctionExit;

	return eDIError;
}

/**
 * @brief		media 재생을 Stop한다.
 *
 * @param[in]	unMediaId			Di Media ID
 * @return		DI Error Code
 * @see			DI_MEDIA_Play
 */
DI_ERR_CODE DI_MHEG_ICS_MP_Stop(HUINT32 unMediaId)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;

	MhegIcsFunctionEnter(unMediaId);

	if(s_tMhegIcsMediaInstance[unMediaId].playback == NULL)
	{
		MhegIcsError("[%s] Error - Playback handle is null.\n", __func__);
		return DI_ERR_ERROR;
	}

	if(VK_SEM_Get(s_ulMhegIcsMediaSemId[unMediaId]) != VK_OK)
	{
		MhegIcsError("VK_SEM_Get failed!\n");
		return DI_ERR_ERROR;
	}

	eDIError = local_mheg_ics_media_CheckValidMediaId(unMediaId);
	if(eDIError != DI_ERR_OK)
	{
		MhegIcsError("[%s] Error - Invalid Media Id.\n", __func__);
		(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);
		return eDIError;
	}

	if((s_tMhegIcsMediaInstance[unMediaId].mediastate == MHEG_ICS_STATE_PAUSE) ||
		(s_tMhegIcsMediaInstance[unMediaId].mediastate == MHEG_ICS_STATE_TRICK) || (s_tMhegIcsMediaInstance[unMediaId].mediastate == MHEG_ICS_STATE_PLAY))
	{
		/** Stop Playback */
		(void)NEXUS_Playback_Stop(s_tMhegIcsMediaInstance[unMediaId].playback);

		if(s_tMhegIcsEventCallback[unMediaId] != NULL)
		{
			s_tMhegIcsEventCallback[unMediaId](unMediaId, DI_MEDIA_EVENT_STOP, 0);
		}

		s_nMhegIcsCurrentPlayTime[unMediaId] = 0;
		s_tMhegIcsMediaInstance[unMediaId].mediastate = MHEG_ICS_STATE_STOP;
	}
	else
	{
		MhegIcsError("[%s] Error - Not Play Media.\n", __func__);
		eDIError = DI_ERR_ERROR;
	}

/* Success:*/

	(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);

	MhegIcsFunctionExit;

	return eDIError;
}

/**
 * @brief		재생 속도를 변경한다.
 *
 * @param[in]	unMediaId			Di Media ID
 * @param[in]	eTrickSpeed 		변경하고자 하는 배속 정보를 지정한다.
 * @return		DI Error Code
 * @see			DI_MEDIA_GetSpeed
 */
DI_ERR_CODE DI_MHEG_ICS_MP_SetSpeed(HUINT32 unMediaId, DI_MEDIA_TrickSpeed_e eTrickSpeed)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;
	NEXUS_Error tNexusError = NEXUS_SUCCESS;
	NEXUS_PlaybackTrickModeSettings tTrickModeSettings;

	MhegIcsFunctionEnter(unMediaId);

	if(s_tMhegIcsMediaInstance[unMediaId].playback == NULL)
	{
		MhegIcsError("[%s] Error - Playback handle is null.\n", __func__);
		return DI_ERR_ERROR;
	}

	if(VK_SEM_Get(s_ulMhegIcsMediaSemId[unMediaId]) != VK_OK)
	{
		MhegIcsError("VK_SEM_Get failed!\n");
		return DI_ERR_ERROR;
	}

	eDIError = local_mheg_ics_media_CheckValidMediaId(unMediaId);
	if(eDIError != DI_ERR_OK)
	{
		MhegIcsError("[%s] Error - Invalid Media Id.\n", __func__);
		(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);
		return eDIError;
	}

	/** Set Trick Rate */
	(void)NEXUS_Playback_GetDefaultTrickModeSettings(&tTrickModeSettings);

	{
		//(void)NEXUS_Playback_TrickMode(s_tMhegIcsMediaInstance[unMediaId].playback, &tTrickModeSettings);
		tTrickModeSettings.rate = local_mheg_ics_media_ConvertDITrickSpeedToNexus(eTrickSpeed);
	}

	switch(eTrickSpeed)
	{
		case DI_MEDIA_TRICK_PAUSE:
			tNexusError = NEXUS_Playback_Pause(s_tMhegIcsMediaInstance[unMediaId].playback);
			if(NEXUS_SUCCESS != tNexusError)
			{
				MhegIcsError("[%s] Error - Fail NEXUS_Playback_Pause:%d\n", __func__, tNexusError);
				eDIError = DI_ERR_ERROR;
			}
			else
			{
				if(s_tMhegIcsEventCallback[unMediaId] != NULL)
				{
					s_tMhegIcsEventCallback[unMediaId](unMediaId, DI_MEDIA_EVENT_PAUSE, 0);
				}

				s_tMhegIcsMediaInstance[unMediaId].mediastate = MHEG_ICS_STATE_PAUSE;
			}
			break;
		case DI_MEDIA_TRICK_1FFSTEP:
			/** Start Playback */
			tNexusError = NEXUS_Playback_Play(s_tMhegIcsMediaInstance[unMediaId].playback);
			if(tNexusError != NEXUS_SUCCESS)
			{
				MhegIcsError("[%s] Error - Fail NEXUS_Playback_Play:%d\n", __func__, tNexusError);
				eDIError = DI_ERR_ERROR;
			}
			else
			{
#if defined(CONFIG_IPTUNER) 
				/* 위에서 Play 요청이 들어오면 Ready State를 강제로 BUFFERING COMPLETE로 바꿉니다. Underflow로 빠지게 하기 위함입니다.
				33번은 DI_IPTUNER_UNDERFLOW_READYSTATE_BUFFERING_COMPLETED 입니다. Header Include를 정리하면서 수정이 필요합니다. */
				if(DI_MHEG_ICS_IPTUNER_GetUnderflowState(unMediaId) != 33)
				{
					DI_MHEG_ICS_IPTUNER_SetUnderflowState(unMediaId, 33);
				}
#endif
				if(s_tMhegIcsEventCallback[unMediaId] != NULL)
				{
					s_tMhegIcsEventCallback[unMediaId](unMediaId, DI_MEDIA_EVENT_PLAYING, 0);
				}

				s_tMhegIcsMediaInstance[unMediaId].trickrate = DI_MEDIA_TRICK_1FFSTEP;
				s_tMhegIcsMediaInstance[unMediaId].mediastate = MHEG_ICS_STATE_PLAY;
			}
			break;
		/** Trick(Forward) */
		case DI_MEDIA_TRICK_2FFSTEP:
		case DI_MEDIA_TRICK_3FFSTEP:
		case DI_MEDIA_TRICK_4FFSTEP:
		case DI_MEDIA_TRICK_5FFSTEP:
		case DI_MEDIA_TRICK_6FFSTEP:
		case DI_MEDIA_TRICK_7FFSTEP:
		case DI_MEDIA_TRICK_8FFSTEP:
		case DI_MEDIA_TRICK_9FFSTEP:
		case DI_MEDIA_TRICK_10FFSTEP:
		case DI_MEDIA_TRICK_11FFSTEP:
		case DI_MEDIA_TRICK_12FFSTEP:
		case DI_MEDIA_TRICK_13FFSTEP:
		case DI_MEDIA_TRICK_14FFSTEP:
		case DI_MEDIA_TRICK_15FFSTEP:
		case DI_MEDIA_TRICK_16FFSTEP:
		/** Trick(Rewind) */
		case DI_MEDIA_TRICK_1RWSTEP:
		case DI_MEDIA_TRICK_2RWSTEP:
		case DI_MEDIA_TRICK_3RWSTEP:
		case DI_MEDIA_TRICK_4RWSTEP:
		case DI_MEDIA_TRICK_5RWSTEP:
		case DI_MEDIA_TRICK_6RWSTEP:
		case DI_MEDIA_TRICK_7RWSTEP:
		case DI_MEDIA_TRICK_8RWSTEP:
		case DI_MEDIA_TRICK_9RWSTEP:
		case DI_MEDIA_TRICK_10RWSTEP:
		case DI_MEDIA_TRICK_11RWSTEP:
		case DI_MEDIA_TRICK_12RWSTEP:
		case DI_MEDIA_TRICK_13RWSTEP:
		case DI_MEDIA_TRICK_14RWSTEP:
		case DI_MEDIA_TRICK_15RWSTEP:
		case DI_MEDIA_TRICK_16RWSTEP:
			if(s_tMhegIcsStreamInfo[unMediaId].support_trick != TRUE)
			{
				MhegIcsError("[%s] Error - Not Support Trick in The Media Stream.\n", __func__);
				eDIError = DI_ERR_ERROR;
			}
			else
			{
				if((s_nMhegIcsCurrentPlayTime[unMediaId] == 0) && ((eTrickSpeed <= DI_MEDIA_TRICK_16RWSTEP) && (eTrickSpeed >= DI_MEDIA_TRICK_1RWSTEP)))
				{
					MhegIcsError("[%s] Error - When current Position is 0, Fast Rewind is not supported\n", __func__);
					eDIError = DI_ERR_ERROR;
				}
				else
				{
					tNexusError = NEXUS_Playback_TrickMode(s_tMhegIcsMediaInstance[unMediaId].playback, &tTrickModeSettings);
					if(NEXUS_SUCCESS != tNexusError)
					{
						MhegIcsError("[%s] Error - Fail NEXUS_Playback_TrickMode:%d\n", __func__, tNexusError);
						eDIError = DI_ERR_ERROR;
					}
					else
					{
						if(s_tMhegIcsEventCallback[unMediaId] != NULL)
						{
							s_tMhegIcsEventCallback[unMediaId](unMediaId, DI_MEDIA_EVENT_PLAYING, s_nMhegIcsCurrentPlayTime[unMediaId]);
						}

						if(s_tMhegIcsEventCallback[unMediaId] != NULL)
						{
							s_tMhegIcsEventCallback[unMediaId](unMediaId, DI_MEDIA_EVENT_TRICK, s_nMhegIcsCurrentPlayTime[unMediaId]);
						}

						s_tMhegIcsMediaInstance[unMediaId].trickrate = eTrickSpeed;
						s_tMhegIcsMediaInstance[unMediaId].mediastate = MHEG_ICS_STATE_TRICK;
					}
				}
			}
			break;
		default:
			{
				MhegIcsError("[%s] Error - Invalid Type:%d\n", __func__, eTrickSpeed);
				eDIError = DI_ERR_ERROR;
			}
			break;
	}

	(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);

	MhegIcsFunctionExit;

	return eDIError;
}

/**
 * @brief		현재 재생 속도를 반환한다.
 *
 * @param[in]	unMediaId			Di Media ID
 * @param[out]	eTrickSpeed			현재 배속 정보를 담는다.
 * @return		DI Error Code
 * @see			DI_MEDIA_SetSpeed
 */
DI_ERR_CODE DI_MHEG_ICS_MP_GetSpeed(HUINT32 unMediaId, DI_MEDIA_TrickSpeed_e *peTrickSpeed)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;
	NEXUS_Error tNexusError = NEXUS_SUCCESS;
	NEXUS_PlaybackStatus tPlaybackStatus;

	//MhegIcsFunctionEnter(unMediaId);

	if(s_tMhegIcsMediaInstance[unMediaId].playback == NULL)
	{
		MhegIcsError("[%s] Error - Playback handle is null.\n", __func__);
		return DI_ERR_ERROR;
	}

	if(VK_SEM_Get(s_ulMhegIcsMediaSemId[unMediaId]) != VK_OK)
	{
		MhegIcsError("VK_SEM_Get failed!\n");
		return DI_ERR_ERROR;
	}

	eDIError = local_mheg_ics_media_CheckValidMediaId(unMediaId);
	if(eDIError != DI_ERR_OK)
	{
		MhegIcsError("[%s] Error - Invalid Media Id.\n", __func__);
		(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);
		return eDIError;
	}

	(void)VK_memset(&tPlaybackStatus, 0x0, sizeof(tPlaybackStatus));
	/** Get Playback Status */
	tNexusError = NEXUS_Playback_GetStatus(s_tMhegIcsMediaInstance[unMediaId].playback, &tPlaybackStatus);
	if(tNexusError != NEXUS_SUCCESS)
	{
		MhegIcsError("[%s] Error - Fail NEXUS_Playback_GetStatus:%d\n", __func__, tNexusError);
		eDIError = DI_ERR_ERROR;
	}
	else
	{
		/** Get Trick Rate */
		if(tPlaybackStatus.state == NEXUS_PlaybackState_eTrickMode)
		{
			*peTrickSpeed = s_tMhegIcsMediaInstance[unMediaId].trickrate;
		}
		else if(tPlaybackStatus.state == NEXUS_PlaybackState_ePaused)
		{
			*peTrickSpeed = DI_MEDIA_TRICK_PAUSE;
		}
		else if(tPlaybackStatus.state == NEXUS_PlaybackState_ePlaying)
		{
			*peTrickSpeed = DI_MEDIA_TRICK_1FFSTEP;
		}
		else
		{
			MhegIcsError("[%s] Error - Not start Playback.\n", __func__);
			eDIError = DI_ERR_ERROR;
		}
	}

	(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);

	//MhegIcsFunctionExit;

	return eDIError;
}

/**
 * @brief		millisecond 단위로 지정되는 position으로 재생 위치를 변경한다.
 *
 * @param[in]	unMediaId			Di Media ID
 * @param[in]	ullTime 			이동하고자 하는 위치를 millisecond 단위로 지정한다.
 * @return		DI Error Code
 * @see			DI_MEDIA_GetPosition
 */
DI_ERR_CODE DI_MHEG_ICS_MP_SetPosition(HUINT32 unMediaId, HUINT32 ulTime, DI_MEDIA_TIME_TYPE eTimeType)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;
	NEXUS_Error tNexusError = NEXUS_SUCCESS;
	HUINT32 ulSetTime = 0;

	MhegIcsFunctionEnter(unMediaId);

	if(s_tMhegIcsMediaInstance[unMediaId].playback == NULL)
	{
		MhegIcsError("[%s] Error - Playback handle is null.\n", __func__);
		return DI_ERR_ERROR;
	}

	if(VK_SEM_Get(s_ulMhegIcsMediaSemId[unMediaId]) != VK_OK)
	{
		MhegIcsError("VK_SEM_Get failed!\n");
		return DI_ERR_ERROR;
	}

	eDIError = local_mheg_ics_media_CheckValidMediaId(unMediaId);
	if(eDIError != DI_ERR_OK)
	{
		MhegIcsError("[%s] Error - Invalid Media Id.\n", __func__);
		(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);
		return eDIError;
	}

	if(s_tMhegIcsStreamInfo[unMediaId].support_seek != TRUE)
	{
		MhegIcsError("[%s] Error - Not Support Seek in The Media Stream.\n", __func__);
		eDIError = DI_ERR_ERROR;
	}
	else
	{
		/** Set Playback Play Position */
		if(eTimeType == DI_MEDIA_TIME_SEC)
		{
			ulSetTime = ulTime * 1000;
		}
		else if(eTimeType == DI_MEDIA_TIME_MSEC)
		{
			ulSetTime = ulTime;
		}
		else
		{
			MhegIcsError("[%s] Error - Not Support Time Type:%d\n", __func__, eTimeType);
			eDIError = DI_ERR_ERROR;
		}

		tNexusError = NEXUS_Playback_Seek(s_tMhegIcsMediaInstance[unMediaId].playback, (NEXUS_PlaybackPosition)ulSetTime);
		if(NEXUS_SUCCESS != tNexusError)
		{
			MhegIcsError("[%s] Error - Fail NEXUS_Playback_Seek:%d\n", __func__, tNexusError);
			eDIError = DI_ERR_ERROR;
		}
	}

	(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);

	MhegIcsFunctionExit;

	return eDIError;
}

/**
 * @brief		현재 재생 중인 위치를 millisecond 단위로 반환한다.
 *
 * @param[in]	unMediaId			Di Media ID
 * @param[out]	pullTime			현재 재생 중인 위치 정보를 담는다.
 * @return		DI Error Code
 * @see			DI_MEDIA_SetPosition
 */
DI_ERR_CODE DI_MHEG_ICS_MP_GetPosition(HUINT32 unMediaId, HUINT32 *pulTime, DI_MEDIA_TIME_TYPE eTimeType)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;
	NEXUS_Error tNexusError = NEXUS_SUCCESS;
	NEXUS_PlaybackStatus tPlaybackStatus;
	HUINT64 ullPosition = 0;
	HUINT32 unPtsSnapShot = 0;
	MhegIcsFunctionEnter(unMediaId);

	if(s_tMhegIcsMediaInstance[unMediaId].playback == NULL)
	{
		MhegIcsError("[%s] Playback handle is null.\n", __func__);
		return DI_ERR_ERROR;
	}

	if(VK_SEM_Get(s_ulMhegIcsMediaSemId[unMediaId]) != VK_OK)
	{
		MhegIcsError("VK_SEM_Get failed!\n");
		return DI_ERR_ERROR;
	}

	eDIError = local_mheg_ics_media_CheckValidMediaId(unMediaId);
	if(eDIError != DI_ERR_OK)
	{
		MhegIcsError("[%s] Error - Invalid Media Id.\n", __func__);
		(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);
		return eDIError;
	}

	if(s_bMhegIcsPlayTimerMode[unMediaId] == DI_MEDIA_TIMERMODE_NONE)
	{
		MhegIcsData("[%s] TimeMode=FALSE, s_nMhegIcsCurrentPlayTime=%d\n", __func__, s_nMhegIcsCurrentPlayTime[unMediaId]);
		if(eTimeType == DI_MEDIA_TIME_SEC)
		{
			*pulTime = s_nMhegIcsCurrentPlayTime[unMediaId];
		}
		else if(eTimeType == DI_MEDIA_TIME_MSEC)
		{
			*pulTime = s_nMhegIcsCurrentPlayTime[unMediaId]*1000;
		}
	}
	else
	{
#if 0 /* Play Time은 Index가 없어도 동작하도록 Patch */
		if(s_tMhegIcsStreamInfo[unMediaId].support_seek != TRUE)
		{
			MhegIcsError("[%s] Error - Not Support Seek in The Media Stream.\n", __func__);
			eDIError = DI_ERR_ERROR;
		}
		else
		{
			(void)VK_memset(&tPlaybackStatus, 0x0, sizeof(tPlaybackStatus));
			/** Get Playback Status */
			tNexusError = NEXUS_Playback_GetStatus(s_tMhegIcsMediaInstance[unMediaId].playback, &tPlaybackStatus);
			if(tNexusError != NEXUS_SUCCESS)
			{
				MhegIcsError("[%s] Error - Fail NEXUS_Playback_GetStatus:%d\n", __func__, tNexusError);
				eDIError = DI_ERR_ERROR;
			}
			else
			{
				/** Get Playback Play Position */
				*pulTime = ((HUINT32)tPlaybackStatus.position/1000);
				MhegIcsData("position = %d\n", *pulTime);
			}
		}
#else
		(void)VK_memset(&tPlaybackStatus, 0x0, sizeof(tPlaybackStatus));
		/** Get Playback Status */
		if((s_tMhegIcsMediaInstance[unMediaId].trickrate > DI_MEDIA_TRICK_4FFSTEP)||
			   (s_tMhegIcsMediaInstance[unMediaId].trickrate < DI_MEDIA_TRICK_16RWSTEP))
		{
			tNexusError= NEXUS_Playback_GetStatus(s_tMhegIcsMediaInstance[unMediaId].playback, &tPlaybackStatus);
			if(tNexusError != NEXUS_SUCCESS)
			{
				MhegIcsError("NEXUS_Playback_GetStatus failed\n");
				(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);
				return DI_ERR_ERROR;
			}
			ullPosition = tPlaybackStatus.position;
		}
		else
		{
			tNexusError = b_play_getpts (s_tMhegIcsMediaInstance[unMediaId].playback, &unPtsSnapShot);
			if(tNexusError != NEXUS_SUCCESS)
			{
				/* workaournd */
				if(eTimeType == DI_MEDIA_TIME_SEC)
				{
					ullPosition = s_nMhegIcsCurrentPlayTime[unMediaId];
				}
				else if(eTimeType == DI_MEDIA_TIME_MSEC)
				{
					ullPosition = s_nMhegIcsCurrentPlayTime[unMediaId];
					ullPosition *= 1000;
				}
			}
			else
			{
				ullPosition = bmedia_pts2time(unPtsSnapShot-s_tMhegIcsMediaInstance[unMediaId].unFirstPts, BMEDIA_TIME_SCALE_BASE);		
				if (ullPosition > s_tMhegIcsStreamInfo[unMediaId].duration)
				{
					ullPosition = s_tMhegIcsStreamInfo[unMediaId].duration;
				}
			}
		}
		if((s_bMhegIcsPlayTimerMode[unMediaId] == DI_MEDIA_TIMERMODE_UPDATE_EXCEPT_0) && ((HUINT32)ullPosition == 0))
		{
			MhegIcsData("[%s] TimeMode=FALSE, s_nMhegIcsCurrentPlayTime=%d\n", __func__, s_nMhegIcsCurrentPlayTime[unMediaId]);
			if(eTimeType == DI_MEDIA_TIME_SEC)
			{
				*pulTime = s_nMhegIcsCurrentPlayTime[unMediaId];
			}
			else if(eTimeType == DI_MEDIA_TIME_MSEC)
			{
				*pulTime = s_nMhegIcsCurrentPlayTime[unMediaId]*1000;
			}
		}
		else
		{
			/** Get Playback Play Position */
			if(eTimeType == DI_MEDIA_TIME_SEC)
			{
				*pulTime = ((HUINT32)ullPosition/1000);
			}
			else if(eTimeType == DI_MEDIA_TIME_MSEC)
			{
				*pulTime = ((HUINT32)ullPosition);
			}
			else
			{
				MhegIcsError("[%s] Error - Not Support Time Type:%d\n", __func__, eTimeType);
				eDIError = DI_ERR_ERROR;
			}
		}
#if 0	// Playback 은 보정할 필요 없음. decoder 에서 가져온 pts 는 bmedia_pts2time 로 이미 보정되었음. 관련 redmine : #71821
		if( s_tMhegIcsMediaInstance[unMediaId].bPtsInstalled == TRUE)
		{
			if(((HUINT32)ullPosition) > s_tMhegIcsMediaInstance[unMediaId].unFirstPts)
			{
				if(eTimeType == DI_MEDIA_TIME_SEC)
				{
					*pulTime = ((HUINT32)ullPosition/1000) - s_tMhegIcsMediaInstance[unMediaId].unFirstPts / 1000;
				}
				else if(eTimeType == DI_MEDIA_TIME_MSEC)
				{					
					*pulTime = ((HUINT32)ullPosition) - s_tMhegIcsMediaInstance[unMediaId].unFirstPts;												
				}
				else
				{
					MhegIcsError("[%s] Error - Not Support Time Type:%d\n", __func__, eTimeType);
					eDIError = DI_ERR_ERROR;
				}
			}
			else
			{
				*pulTime = 0;
			}
		}
#endif
		MhegIcsData("position = %d\n", *pulTime);
#endif		
	}

	(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);

	MhegIcsFunctionExit;

	return eDIError;
}


/**
 * @brief		callback 함수를 등록한다.
 *
 * @param[in]	unMediaId			Di Media ID
 * @param[in]	callback	BOS(Begin of Stream), EOS(End of Stream) event를 받기 위한 Callback
 * @return		DI Error Code
 * @see
 */
DI_ERR_CODE DI_MHEG_ICS_MP_RegisterCallback(HUINT32 unMediaId, DI_MEDIA_EventCallback_t MediaEventcallback)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;

	MhegIcsFunctionEnter(unMediaId);

	if(MediaEventcallback == NULL)
	{
		MhegIcsError("[%s] Error - MediaEventcallback is null.\n", __func__);
		return DI_ERR_ERROR;
	}

	if(VK_SEM_Get(s_ulMhegIcsMediaSemId[unMediaId]) != VK_OK)
	{
		MhegIcsError("VK_SEM_Get failed!\n");
		return DI_ERR_ERROR;
	}

	eDIError = local_mheg_ics_media_CheckValidMediaId(unMediaId);
	if(eDIError != DI_ERR_OK)
	{
		MhegIcsError("[%s] Error - Invalid Media Id.\n", __func__);
		(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);
		return eDIError;
	}

	s_tMhegIcsEventCallback[unMediaId] = MediaEventcallback;

	(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);

	MhegIcsFunctionExit;

	return eDIError;
}

/**
 * @brief		등록된 callback 함수를 해제한다.
 *
 * @param[in]	unMediaId			Di Media ID
 * @return		DI Error Code
 * @see
 */
DI_ERR_CODE DI_MHEG_ICS_MP_UnregisterCallback(HUINT32 unMediaId)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;

	MhegIcsFunctionEnter(unMediaId);

	if(VK_SEM_Get(s_ulMhegIcsMediaSemId[unMediaId]) != VK_OK)
	{
		MhegIcsError("VK_SEM_Get failed!\n");
		return DI_ERR_ERROR;
	}

	eDIError = local_mheg_ics_media_CheckValidMediaId(unMediaId);
	if(eDIError != DI_ERR_OK)
	{
		MhegIcsError("[%s] Error - Invalid Media Id.\n", __func__);
		(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);
		return eDIError;
	}

	if(s_tMhegIcsEventCallback[unMediaId] != NULL)
	{
		s_tMhegIcsEventCallback[unMediaId] = NULL;
	}

	(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);

	MhegIcsFunctionExit;

	return eDIError;
}



/**
 * @brief		Playback Buffer의 정보를 반환한다.
 *
 * @param[in]	unMediaId				Media Device Id
 * @param[out]	pnCurrentUsedBufferSize	Playback Current Buffer
 * @param[out]	pnMaxBufferSize			Playback Max Buffer
 * @return		DI Error Code
 * @see
 */
DI_ERR_CODE DI_MHEG_ICS_GetPlaybackBuffer(HUINT32 unMediaId, HUINT32 *pnCurrentUsedBufferSize,HUINT32 *pnMaxBufferSize)
{
	DI_ERR_CODE		eDIError = DI_ERR_OK;
	NEXUS_PlaybackStatus tPlaybackStatus;

	VK_MEM_Memset(&tPlaybackStatus, 0x0, sizeof(tPlaybackStatus));

	MhegIcsFunctionEnter(unMediaId);

	(void)NEXUS_Playback_GetStatus(s_tMhegIcsMediaInstance[unMediaId].playback, &tPlaybackStatus);
	*pnCurrentUsedBufferSize = tPlaybackStatus.fifoDepth;
	*pnMaxBufferSize = tPlaybackStatus.fifoSize;

	MhegIcsFunctionExit;

	return eDIError;
}

/**
 * @brief		Current Time기능을 설정한다.
 *
 * @param[in]		unMediaId		Media Id
 * @param[in]		bTimerMode		Time Mode
 * @return			HERROR
 * @date 			2010/10/13
 * @author 			kimdh1@humaxdigital.com
 * @see
 */
DI_ERR_CODE DI_MHEG_ICS_SetPlayTimer(HUINT32 unMediaId, DI_MEDIA_TIMERMODE_e	bTimerMode)
{
	DI_ERR_CODE		eDIError = DI_ERR_OK;

	MhegIcsFunctionEnter(unMediaId);

	s_bMhegIcsPlayTimerMode[unMediaId] = bTimerMode;

	MhegIcsFunctionExit;

	return eDIError;
}


/**
 * @brief		Stream의 Path를 이용하여 Probe를 한다.
 *
 * @param[in]	url 				Stream의 Path
 * @param[out]	stMediaFileInfo 	Probe된 Stream의 정보
 * @return		DI Error Code
 * @see			DI_MEDIA_PrintProbeInfo
 */
DI_ERR_CODE DI_MHEG_ICS_Probe (HUINT32 unMediaId, HUINT8 *url, DI_MEDIA_INFO_t *stMediaFileInfo)
{
	DI_ERR_CODE nRet = DI_ERR_OK;
	stMhegIcsMediaInfo  *pMfpInfo = NULL;

	MhegIcsFunctionEnter(unMediaId);

	if(VK_SEM_Get(s_ulMhegIcsMediaSemId[unMediaId] ) != VK_OK)
	{
		MhegIcsError("VK_SEM_Get failed!\n");
		return DI_ERR_ERROR;
	}
	
	if (!s_MhegIcsMfpInfo[unMediaId].opened)
	{
		pMfpInfo = &s_MhegIcsMfpInfo[unMediaId];
	}
	/* else { continue } */

	if (pMfpInfo == NULL)
	{
		nRet = DI_ERR_NO_RESOURCE;
	}
	else
	{
		nRet = local_mheg_ics_media_ProbeOpen (unMediaId, url, pMfpInfo);
		if (nRet == DI_ERR_OK)			
		{			
			VK_memcpy(stMediaFileInfo, &pMfpInfo->StreamInfo, sizeof(DI_MEDIA_INFO_t));
		}
		else
		{
			MhegIcsError ("[%s] Error - Fail in local_mheg_ics_media_ProbeOpen\n",__FUNCTION__);
		}
		(void) local_mheg_ics_media_ProbeClose (pMfpInfo);
	}

	(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);

	MhegIcsFunctionExit;

	return nRet;

}

#if 0
DI_ERR_CODE DI_MHEG_ICS_GetPumpBufferDepth(HUINT32 unMediaId, HUINT32 *ulSize)
{
	DI_ERR_CODE nRet = DI_ERR_OK;
	NEXUS_Error nNexusError = NEXUS_SUCCESS;
	NEXUS_PlaybackStatus tPlaybackStatus;
	
	if(ulSize == NULL)
	{
		MhegIcsError("@@@@@ [%s:%d] ulSize is NULL\n", __func__, __LINE__);
		nRet = DI_ERR_ERROR;
		goto exit;
	}

	if(s_tMhegIcsMediaInstance[unMediaId].playback != NULL)
	{
		nNexusError = NEXUS_Playback_GetStatus(s_tMhegIcsMediaInstance[unMediaId].playback, &tPlaybackStatus);
		if(nNexusError == NEXUS_SUCCESS)
		{
			*ulSize = tPlaybackStatus.fifoDepth;
		}
	}
	
exit:
	return nRet;
}

DI_ERR_CODE DI_MHEG_ICS_GetVideoBufferDepth(HUINT32 unMediaId, HUINT32 *ulSize)
{
	DI_ERR_CODE nRet = DI_ERR_OK;
	NEXUS_Error nNexusError = NEXUS_SUCCESS;
	NEXUS_VideoDecoderStatus tDecoderStatus;
	
	if(ulSize == NULL)
	{
		MhegIcsError("@@@@@ [%s:%d] ulSize is NULL\n", __func__, __LINE__);
		nRet = DI_ERR_ERROR;
		goto exit;
	}

	if(s_tMhegIcsMediaInstance[unMediaId].vDecoder != NULL)
	{
		nNexusError = NEXUS_VideoDecoder_GetStatus(s_tMhegIcsMediaInstance[unMediaId].vDecoder, &tDecoderStatus);
		if(nNexusError == NEXUS_SUCCESS)
		{
			*ulSize = tDecoderStatus.fifoDepth;			/* size in bytes of the compressed buffer */
		//	*ulSize += tDecoderStatus.queueDepth;		/* the number of decoded pictures currently ready to be displayed */
		//	*ulSize += tDecoderStatus.cabacBinDepth;	/* depth in bytes of the cabac bin buffer */
			/* *ulSize += tDecoderStatus.enhancementFifoDepth; */	/* 이 버전 NEXUS에는 없는 멤버, depth in bytes of the enhancement compressed buffer */
		}
	}
	
exit:
	return nRet;
}

DI_ERR_CODE DI_MHEG_ICS_GetAudioBufferDepth(HUINT32 unMediaId, HUINT32 *ulSize)
{
	DI_ERR_CODE nRet = DI_ERR_OK;
	NEXUS_Error nNexusError = NEXUS_SUCCESS;
	NEXUS_AudioDecoderStatus tDecoderStatus;
	
	if(ulSize == NULL)
	{
		MhegIcsError("@@@@@ [%s:%d] ulSize is NULL\n", __func__, __LINE__);
		nRet = DI_ERR_ERROR;
		goto exit;
	}

	VK_memset(&tDecoderStatus, 0x00, sizeof(NEXUS_AudioDecoderStatus));

	if(s_tMhegIcsMediaInstance[unMediaId].aDecoder != NULL)
	{
		nNexusError = NEXUS_AudioDecoder_GetStatus(s_tMhegIcsMediaInstance[unMediaId].aDecoder, &tDecoderStatus);
		if(nNexusError == NEXUS_SUCCESS)
		{
			*ulSize = tDecoderStatus.fifoDepth;			/* depth in bytes of the compressed buffer */
		}
	}
	
exit:
	return nRet;
}
#endif

/**
 * @brief			multi track audio의 경우 track을 변경한다.
 *
 * @param[in]		pcMediaPath		Media Path
 * @param[out]		ptMediaInfo		Media Info
 * @return			HERROR
 * @date 			2010/08/16
 * @author 			kimdh1@humaxdigital.com
 * @see
 */
DI_ERR_CODE DI_MHEG_ICS_SetAudioTrack(HUINT32 unMediaId, HUINT8	ucAudioTrack)
{
	DI_ERR_CODE		eDIError = DI_ERR_OK;

	MhegIcsFunctionEnter(unMediaId);

	s_tMhegIcsStreamInfo[unMediaId].audio_pes_id = s_tMhegIcsStreamInfo[unMediaId].stAudioTrack[ucAudioTrack].audio_pes_id;
	s_tMhegIcsStreamInfo[unMediaId].audio_stream_id = s_tMhegIcsStreamInfo[unMediaId].stAudioTrack[ucAudioTrack].audio_stream_id;
	s_tMhegIcsStreamInfo[unMediaId].audio_codec = s_tMhegIcsStreamInfo[unMediaId].stAudioTrack[ucAudioTrack].audio_codec;

	MhegIcsDebug("\t [%s:%d] ICS[%d][Setted Audio PID(0x%X)\n", __FUNCTION__, __LINE__, unMediaId, s_tMhegIcsStreamInfo[unMediaId].audio_stream_id);

	MhegIcsFunctionExit;

	return eDIError;
}


void		DI_MHEG_ICS_SetStartTimeSec(HUINT32 ulMhegIcsMediaId, HUINT32 ulStartTime)
{
	s_tMhegIcsStreamInfo[ulMhegIcsMediaId].eStartCondition = DI_MEDIA_PLAY_START_MODE_LASTVIEW;
	s_tMhegIcsStreamInfo[ulMhegIcsMediaId].ulStartTime = (ulStartTime * 1000);
}


/**
 * @brief		media file의 정보를 반환한다.
 *
 * @param[in]	unMediaId			Di Media ID
 * @param[out]	pStreamInfo			media file의 정보를 포함하는 구조체 pointer
 * @return		DI Error Code
 * @see
 */
DI_ERR_CODE DI_MHEG_ICS_MP_GetStreamInfo(HUINT32 unMediaId, DI_MEDIA_INFO_t *pStreamInfo)
{
	DI_ERR_CODE eDIError = DI_ERR_OK;

	MhegIcsFunctionEnter(unMediaId);

	if(pStreamInfo == NULL)
	{
		MhegIcsError("[%s] Error - pStreamInfo is null.\n", __func__);
		return DI_ERR_ERROR;
	}

	if(VK_SEM_Get(s_ulMhegIcsMediaSemId[unMediaId]) != VK_OK)
	{
		MhegIcsError("VK_SEM_Get failed!\n");
		return DI_ERR_ERROR;
	}

	eDIError = local_mheg_ics_media_CheckValidMediaId(unMediaId);
	if(eDIError != DI_ERR_OK)
	{
		MhegIcsError("[%s] Error - Invalid Media Id.\n", __func__);
		(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);
		return eDIError;
	}

	/** Get Stream Info */
	*pStreamInfo = s_tMhegIcsStreamInfo[unMediaId];

	(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);
	
	MhegIcsFunctionExit;

	return eDIError;
}


void		DI_MHEG_ICS_SetPlaybackMedia(HUINT32 unMediaId)
{
	MhegIcsFunctionEnter(unMediaId);
		
	(void)VK_SEM_Get(s_ulMhegIcsMediaSemId[unMediaId]);

#ifdef DI_MHEG_ICS_DEBUG
	local_mheg_ics_media_PrintMediaInstanceInfo(unMediaId);
#endif
	
	DI_MEDIA_SetPlayback_IcsMedia((void*)&s_tMhegIcsMediaInstance[unMediaId], (void*)&s_tMhegIcsStreamInfo[unMediaId]);

	(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);

	MhegIcsFunctionExit;
}


void 		DI_MHEG_ICS_RestorePlaybackMedia(HUINT32 unMediaId)
{
	MhegIcsFunctionEnter(unMediaId);
		
	(void)VK_SEM_Get(s_ulMhegIcsMediaSemId[unMediaId]);
	
	DI_MEDIA_RestorePlayback_IcsMedia((void*)&s_tMhegIcsMediaInstance[unMediaId], (void*)&s_tMhegIcsStreamInfo[unMediaId]);

#ifdef DI_MHEG_ICS_DEBUG
	local_mheg_ics_media_PrintMediaInstanceInfo(unMediaId);
#endif

	(void)VK_SEM_Release(s_ulMhegIcsMediaSemId[unMediaId]);

	MhegIcsFunctionExit;
}

