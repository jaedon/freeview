/*
 * Copyright (c) 2006 HUMAX Co., Ltd. All rights reserved.
 *
 * This is very confidential.
 * This code must not distributed outside.
 *
 * Author : Dongseok, Shin (dsshin)
 * File : vk_sig.c
 */

/*----------------------------------------------------------------------------------
** Headers
**--------------------------------------------------------------------------------*/
#include <stdio.h>
#include <unistd.h>
#include <stdarg.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/syscall.h>

#include "htype.h"
#include "vkernel.h"
#include "file_map.h"
#include "inc/vk_p_common_api.h"

/*----------------------------------------------------------------------------------
** Defines
**--------------------------------------------------------------------------------*/
#ifdef KERNEL_DEBUG
#define PrintDebug(fmt, ...) 		VK_DBG_Print (fmt, ## __VA_ARGS__)
#define PrintError(fmt, ...)    	VK_DBG_Print (fmt, ## __VA_ARGS__)
#define PrintEnter(...)				VK_DBG_Print("(+)%s\n", __FUNCTION__)
#define PrintExit(...)				VK_DBG_Print("(-)%s\n", __FUNCTION__)
#else 
#define PrintDebug(fmt, ...)    	while (0) ((int (*)(char *, ...)) 0)
#define PrintError(fmt, ...)		VK_DBG_Print (fmt, ## __VA_ARGS__)
#define PrintEnter(...) 			while (0) ((int (*)(char *, ...)) 0)
#define PrintExit(...)				while (0) ((int (*)(char *, ...)) 0)
#endif /* KERNEL_DEBUG */

/* 	now we consider signal value has 1~31.
	figure out that in kernel/arch/mips/include/asm/signal.h */
#define VK_SIG_MAX	32

/*----------------------------------------------------------------------------------
** Typedefs
**--------------------------------------------------------------------------------*/
typedef struct {
	int 	sig;
	int		bHooked;
	void	(*pfn)(int sig, VK_SIG_INFO_t *siginfo, void *context);
} VK_SIGTABLE_t;

/*----------------------------------------------------------------------------------
** Variables
**--------------------------------------------------------------------------------*/
static VK_SIGTABLE_t 	st_sigtbl[VK_SIG_MAX];
static int				bVkSigInitialized;

/*----------------------------------------------------------------------------------
** Function Declaration
**--------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------
** Functions
**--------------------------------------------------------------------------------*/
#if defined(CONFIG_DEBUG)
static inline char *P_StrSigCode(int sig, int code)
{
	switch(code)
	{
		case SI_USER:
			return "Signal sent by kill(), pthread_kill(), raise(), abort() or alarm()";
		case SI_QUEUE:
			return "Signal was sent by sigqueue()";
		case SI_TIMER:
			return "Signal was generated by expiration of a timer set by timer_settimer()";
		case SI_ASYNCIO:
			return "Signal was generated by completion of an asynchronous I/O request";
		case SI_MESGQ:
			return "Signal was generated by arrival of a message on an empty message queue";
		case SI_KERNEL:
			return "sent by the kernel from somewhere";
		default:
			break;
	}

	switch(sig)
	{
		case SIGILL:
			switch(code) {
				case ILL_ILLOPC:
					return "Illegal opcode";
				case ILL_ILLOPN:
					return "Illegal operand";
				case ILL_ILLADR:
					return "Illegal addressing mode";
				case ILL_ILLTRP:
					return "Illegal trap";
				case ILL_PRVOPC:
					return "Privileged opcode";
				case ILL_PRVREG:
					return "Privileged register";
				case ILL_COPROC:
					return "Coprocessor error";
				case ILL_BADSTK:
					return "Internal stack error";
				default:
					break;
			}
			break;
		case SIGFPE:
			switch(code) {
				case FPE_INTDIV:
					return "Integer divide-by-zero";
				case FPE_INTOVF:
					return "Integer overflow";
				case FPE_FLTDIV:
					return "Floating point divide-by-zero";
				case FPE_FLTOVF:
					return "Floating point overflow.";
				case FPE_FLTUND:
					return "Floating point underflow";
				case FPE_FLTRES:
					return "Floating point inexact result";
				case FPE_FLTINV:
					return "Invalid floating point operation";
				case FPE_FLTSUB:
					return "Subscript out of range";
				default:
					break;
			}
			break;
		case SIGSEGV:
			switch(code) {
				case SEGV_MAPERR:
					return "Address not mapped";
				case SEGV_ACCERR:
					return "Invalid permissions";
				default:
					break;
			}
			break;
		case SIGBUS:
			switch(code) {
				case BUS_ADRALN:
					return "Invalid address alignment";
				case BUS_ADRERR:
					return "Non-existent physical address";
				case BUS_OBJERR:
					return "Object-specific hardware error";
				default:
					break;
			}
			break;
		case SIGTRAP:
			switch(code) {
				case TRAP_BRKPT:
					return "Process breakpoint";
				case TRAP_TRACE:
					return "Process trace trap";
				default:
					break;
			}
			break;
		case SIGCHLD:
			switch(code) {
				case CLD_EXITED:
					return "Child has exited";
				case CLD_KILLED:
					return "Child has terminated abnormally and did not create a core file";
				case CLD_DUMPED:
					return "Child has terminated abnormally and created a core file";
				case CLD_TRAPPED:
					return "Traced child has trapped";
				case CLD_STOPPED:
					return "Child has stopped";
				case CLD_CONTINUED:
					return "Stopped child has continued";
				default:
					break;
			}
			break;
		case SIGIO:
			switch(code) {
				case POLL_IN:
					return "Data input available";
				case POLL_OUT:
					return "Output buffers available";
				case POLL_MSG:
					return "Input message available";
				case POLL_ERR:
					return "I/O error";
				case POLL_PRI:
					return "High priority input available";
				case POLL_HUP:
					return "Device disconnected";
				default:
					break;
			}
			break;
		default:
			break;
	}

	return "Unknown";
}
#endif

static void P_SignalHandler(int sig, siginfo_t *si, void *unused)
{
	VK_SIG_INFO_t	tSigInfo;
#if defined(CONFIG_DEBUG)
	char thread_name[32] = {0,};
	char process_name[32] = {0,};
	int pid = vk_p_common_GetPid();
	int tid = vk_p_common_GetTid();
	unsigned char ucCmdBuf[1024];
#endif

#if defined(CONFIG_DEBUG)
	switch(sig)
	{
		case SIGHUP:
		case SIGILL:
		case SIGFPE:
		case SIGSEGV:
		case SIGBUS:
			/* get process name from /proc */
			(void)vk_p_common_GetProcessName(pid, process_name, sizeof(process_name));
			(void)vk_p_common_GetThreadName(pid, tid, thread_name, sizeof(thread_name));
			
			VK_snprintf(ucCmdBuf, sizeof(ucCmdBuf),
				        "echo \""
				        "\n**********************************************************************"
				        "\n*                      EXCEPTIONS(vkernel)                           *"
				        "\n**********************************************************************"
				        "\n** pid (%3d), name(%s)"
				        "\n** tid (%3d), name(%s)"
				        "\n** signal (%s)"
				        "\n** reason (%s)"
				        "\n** fault addr (%p)"
				        "\n** signal err (%s)"
				        "\n**********************************************************************"
				        "\n"
				        "\" > "VK_SIG_LOGFILE,
				        pid, (char*)process_name,
				        tid, (char*)thread_name,
				        strsignal(sig),
				        P_StrSigCode(sig, si->si_code),
				        si->si_addr,
				        strerror(si->si_errno)
				        );
			VK_SYSTEM_Command(ucCmdBuf);

#if defined(CONFIG_ARM)
			vk_p_common_ShowBackTrace(process_name, NULL);
#else
			vk_p_common_ShowBackTrace(process_name, unused);
#endif
			break;
		default:
			break;
	}
#endif

	if (st_sigtbl[sig].pfn)
	{
		/* set info */
		tSigInfo.sig_signo = si->si_signo;
		tSigInfo.sig_code = si->si_code;
		tSigInfo.sig_errno = si->si_errno;
		tSigInfo.sig_pid = (unsigned long)si->si_pid;
		tSigInfo.sig_uid = (unsigned long)si->si_uid;
		tSigInfo.sig_addr = si->si_addr;
		tSigInfo.sig_status = si->si_status;
		tSigInfo.sig_band = si->si_band;

		/* call registered user handler */
		(st_sigtbl[sig].pfn)(sig, &tSigInfo, unused);

		if (st_sigtbl[sig].bHooked)
		{
			/* in this case, user handler will do post-processing.
			   ignore default post-processing */
			return;
		}
	}
	
#if defined(CONFIG_DEBUG)
	switch(sig)
	{
		case SIGHUP:
		case SIGILL:
		case SIGFPE:
		case SIGSEGV:
		case SIGBUS:
			abort();
			break;
		default:
			break;
	}
#endif
}

int VK_SIG_SetSigAction(int sig, void (*pfnSignalUserHandler)(int sig, VK_SIG_INFO_t *siginfo_t, void *context))
{
	struct sigaction 	sa;

	if (sig >= VK_SIG_MAX || sig < 1)
	{
		PrintError("[%s] Unknown signal value. sig(%d)\n", __FUNCTION__, sig);
		return VK_ERROR;
	}

	if (st_sigtbl[sig].pfn) {
		/* print warning message */
		PrintError("[%s] user handler for signal was overwritten!!(%s)\n", __FUNCTION__, strsignal(sig));
	}
	
	/* register default signal handler */
	sa.sa_flags = SA_SIGINFO;
	sigemptyset(&sa.sa_mask);
	sa.sa_sigaction = P_SignalHandler; //default handler

	st_sigtbl[sig].sig = sig;
	st_sigtbl[sig].pfn = pfnSignalUserHandler;
	
	if (sigaction(sig, &sa, NULL) < 0)
	{
		PrintError("[%s] Error! fail to set sigaction. signal(%s)\n", __FUNCTION__, strsignal(sig));
		return VK_ERROR;
	}

	return VK_OK;
}

int VK_SIG_SetSigHooking(int sig)
{
	if (sig >= VK_SIG_MAX || sig < 1)
	{
		PrintError("[%s] Unknown signal value. sig(%d)\n", __FUNCTION__, sig);
		return VK_ERROR;
	}

	st_sigtbl[sig].bHooked = 1;
	
	return VK_OK;
}

int VK_SIG_Init(void)
{
	if (bVkSigInitialized) {
		PrintError("[%s] vKerenl(SIG) was already initialized! \n", __FUNCTION__);
		return VK_OK;
	}
	
	/* Initialze */
	VK_memset(st_sigtbl, 0, sizeof(VK_SIGTABLE_t)*VK_SIG_MAX);

#if defined(CONFIG_DEBUG)
	/* default setaction in vkernel */
	VK_SIG_SetSigAction(SIGHUP, NULL);
	VK_SIG_SetSigAction(SIGILL, NULL);
	VK_SIG_SetSigAction(SIGFPE, NULL);
	VK_SIG_SetSigAction(SIGSEGV, NULL);
	VK_SIG_SetSigAction(SIGBUS, NULL);
#endif

	//	Ignore BROKEN PIPE signal.
	signal(SIGPIPE, SIG_IGN);

	bVkSigInitialized = 1;
	return VK_OK;
}
