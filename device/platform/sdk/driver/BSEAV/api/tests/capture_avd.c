/***************************************************************************
 *     Copyright (c) 2005-2011, Broadcom Corporation
 *     All Rights Reserved
 *     Confidential Property of Broadcom Corporation
 *
 *  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
 *  AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
 *  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
 *
 * $brcm_Workfile: capture_avd.c $
 * $brcm_Revision: 38 $
 * $brcm_Date: 1/25/11 3:53p $
 *
 * Module Description:
 * capture_avd - Capture CRC for AVD (video decoder) verification. The CRC
 * are computed by MFD and ready the VDC and then forwarded to upper layer
 * of software code.
 *
 * Revision History:
 *
 * $brcm_Log: /BSEAV/api/tests/capture_avd.c $
 * 
 * 38   1/25/11 3:53p davidp
 * SW7422-22: Add support for SVC and MVC protocols.
 * 
 * 37   1/18/11 10:22a erickson
 * SWDEPRECATED-1581: add comment block re: internal design of CRC capture
 *
 * 36   1/27/10 4:35p otao
 * SW7403-907:Set window size and position of 0,0,32,32, this is mainly
 * needed for BVN bandwidth and also resoved the duplicated CRC observed
 * in 7403 regression.
 *
 * 35   10/13/09 5:54p gauravs
 * DVTARCHIVE-311: Added check for repeated CRCs.
 *
 * 34   4/9/09 5:27p gauravs
 * PR 44911: Merged back to the main line.
 *
 * captureavd_devel/3   4/6/09 4:35p gauravs
 * PR 44911: Added back the unitialization calls and removed debug prints.
 *
 * captureavd_devel/2   2/25/09 8:09p gauravs
 * PR 44911: Removed all the unitialization calls to debug an issue.
 *
 * captureavd_devel/1   2/25/09 2:48p gauravs
 * PR 44911: Added support to detect missing CRCs as opposed to labelling
 * missing CRCs as mismatches. Refactored the code.
 *
 * 33   2/11/09 11:00p gauravs
 * PR 44911: Added debug prints.
 *
 * 32   1/23/09 12:50a gauravs
 * PR 44911: Added support to print file sizes for captured and golden CRC
 * files. Also ignore first frame where the captured CRCs are 0xFFFFFFFF
 * .
 *
 * 31   10/10/08 10:53a gauravs
 * PR 44911: Changed printf to specify if the captured CRC file is empty.
 *
 * 30   8/21/08 11:39a gauravs
 * PR 44911: Change printf to include CRC values when there is a mismatch.
 *
 * 29   8/20/08 11:11a gauravs
 * PR 44911: Change the return value when captured CRCs match the golden
 * CRCs to zero. Add check for invalid format of captured CRCs.
 *
 * 28   7/17/08 3:55p gauravs
 * PR 44911: Added support to compare CRCs in capture_avd. capture_avd has
 * two new command-line options, "compareCRC" and "goldenfile", which can
 * be used to enable CRC comparison and to specify the golden-CRC file.
 *
 * 27   7/17/08 10:42a gaurava
 * PR 44072: Fix CRC capture issues by setting up VDC correct. Do live
 * feed and avoid DRAM capture and video feed since that causes BVN
 * reconfiguration which leads to loss of 2-3 CRC
 *
 ***********************************************************************/
#include "bstd.h"
#include "bsettop.h"
BDBG_MODULE(capture_avd);
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <sys/times.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

/**
The following is an overview of CRC capture through the SW layers:

NOTE: This test will be re-written to go straight to nexus. This is required for SVC/MVC support. The
settop api test has been used for all AVD chips prior to SVC/MVC.

CRC capture is enabled with a compile-time macro.
For Settop API it is #define B_DECODE_CRC_CAPTURE and is enabled with export B_DECODE_CRC_CAPTURE=y.
For nexus, it is #define NEXUS_CRC_CAPTURE and is enabled with export NEXUS_CRC_CAPTURE=y.
The Settop API setting with automatically enable the Nexus setting.

When enabled, a special decoder and display configuration is made.

The Display configuration is:
- NEXUS_VideoWindowSettings.forceCapture = true;
- NEXUS_VideoWindowScalerSettings.scalerSettings = NEXUS_ScalerCaptureBias_eScalerBeforeCapture;
- BVDC_Window_SetScaleFactorRounding(window,0,0)

The Decoder configuration is:
- BXVD_DecodeSettings.bCrcMode = true;

This causes the decoder to send picture ID's along with the picture data. It also tells AVD/XVD to
process pictures not for ideal display but for correct CRC capture.
The actual CRC's are generated by the MFD HW block. They are captured by VDC and sent to Nexus
is the source isr callback (NEXUS_VideoInput_P_SourceCallback_isr). Nexus stores the CRC's in a queue.

They are retrieved from the nexus queue using NEXUS_VideoInput_GetCrcData. They are retrieved from Settop API using bdecode_read_metadata.

The application stores the CRC's to a file using a fixed file format for comparison with a set of golden CRC's.
**/

#include "argenv.h"

#define ATOM_SIZE (sizeof(uint32_t)*5)

#define CRCBUF_SIZE (ATOM_SIZE * 1024)

#define FILE_NAME_SIZE 1024

#define BAT_FAILURE "@BAT_FAILURE@"
#define BAT_SUCCESS "@BAT_SUCCESS@"
#define BAT_FAILURE_ALL_FF "@BAT_FAILURE_CAT_ALL_FF@"
#define BAT_FAILURE_MISSING "@BAT_FAILURE_CAT_MISSING@"
#define BAT_FAILURE_ZERO_CAP "@BAT_FAILURE_CAT_ZERO_CAP@"
#define BAT_FAILURE_BIGGER_GOLDEN "@BAT_FAILURE_CAT_BIGGER_GOLDEN@"
#define BAT_FAILURE_BIGGER_CAP "@BAT_FAILURE_CAT_BIGGER_CAP@"
#define BAT_FAILURE_REPEAT "@BAT_FAILURE_CAT_REPEAT@"


unsigned char crcbuf[CRCBUF_SIZE];
unsigned crcbuf_wptr = 0;
unsigned crcbuf_rptr = 0;
char *g_cmdname;
int g_crc_count;
/* enable g_debug to print debug messages*/
static int g_debug = 0;

struct crc {
    uint32_t idr_pic_id, pic_order_cnt, luma, chroma, field;
};

struct handles
{
    bdecode_t h_decode;
    bdisplay_t h_display;
    bdecode_window_t h_window;
} g_handles;

struct arguments
{
    char playbackfile[FILE_NAME_SIZE];
    char resultfile[FILE_NAME_SIZE];
    char goldenfile[FILE_NAME_SIZE];
    bstream_mpeg mpeg;
    long loop;
    long wait;
    long compareCRC;
};


bplayback_loopmode b_no_loop(void *context) {

    bplayback_loopmode loopmode = bplayback_loopmode_pause;
    return loopmode;
}

#define CRCBUF_DEPTH() ((crcbuf_wptr >= crcbuf_rptr)?crcbuf_wptr-crcbuf_rptr:CRCBUF_SIZE-(crcbuf_rptr-crcbuf_wptr))

uint32_t read32()
{
    uint32_t value;

    /* requiring atomic reads keeps the app simple. the large crcbuf makes this reasonable. */
    assert(CRCBUF_DEPTH() >= sizeof(uint32_t));

    if (crcbuf_wptr > crcbuf_rptr) {
        value = *(uint32_t *)&crcbuf[crcbuf_rptr];
        crcbuf_rptr += sizeof(uint32_t);
    }
    else {
        /* simplify: don't deal with read32 wraparounds */
        assert(0);
        value = 0;
    }
    return value;
}

/* return 0 if good. return -1 if wrap around CRC detected. */
static int process_crcs(FILE *crcfile, const bstream_mpeg *mpeg)
{
    if (crcfile == 0)
        return 0;

    while (crcbuf_rptr != crcbuf_wptr) {
        uint32_t type, payload_size;

        type = read32();
        payload_size = read32();

        /* simplify: requiring atomic reads keeps the app simple. the large crcbuf makes this reasonable. */
        assert(CRCBUF_DEPTH() >= payload_size);

        while (payload_size >= ATOM_SIZE) {
            struct crc crc;

            crc.idr_pic_id = read32();
            crc.pic_order_cnt = read32();
            crc.luma = read32();
            crc.chroma = read32();
            crc.field = read32();

            /* skip all zero crcs */
            if (crc.luma || crc.chroma) {
                g_crc_count++;
                if ((mpeg->video[0].format == bvideo_codec_h264) ||
                    (mpeg->video[0].format == bvideo_codec_h264_svc) ||
                    (mpeg->video[0].format == bvideo_codec_h264_mvc)    )
                    fprintf(crcfile, "CRC_TEST: %u %d %u %u%s\r", crc.idr_pic_id, crc.pic_order_cnt, crc.luma, crc.chroma, crc.field?" F":"");
                else
                    fprintf(crcfile, "CRC_TEST: %u %u%s\r", crc.luma, crc.chroma, crc.field?" F":"");
                fflush(crcfile);
            }
            payload_size -= ATOM_SIZE;
        }
        assert(!payload_size);
    }
    return 0;
}


int gettime()
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return tv.tv_sec * 1000 + tv.tv_usec / 1000;
}

int initialize()
{
    bdisplay_settings ds;
    bdecode_window_settings ws;
    bvideo_format_settings fs;

    g_handles.h_decode = bdecode_open(B_ID(0));
    g_handles.h_display = bdisplay_open(B_ID(0));
    g_handles.h_window = bdecode_window_open(B_ID(0), g_handles.h_display);

    /* Display settings */
    /* get the default display setting */
    bdisplay_get(g_handles.h_display, &ds);

    if (getenv("support_1080p")) {
        ds.format = bvideo_format_1080p_30hz;
    }

    /* Component only */
    ds.svideo = NULL;
    ds.composite = NULL;
    ds.composite2 = NULL;
    ds.rf = NULL;
    ds.dvi = NULL;
    /* No aspect ratio correction */
    ds.content_mode = bdisplay_content_mode_full;
    bdisplay_set(g_handles.h_display, &ds);

    /* Window settings */
    /* get the default window setting */
    bdecode_window_get(g_handles.h_window, &ws);
    bdisplay_get_video_format_settings(&ds, &fs);

    /* No MAD */
    ws.deinterlacer = false;
    /* No letter box detection */
    ws.box_detect = false;
    /* Full screen */
    ws.position.x = 0;
    ws.position.y = 0;
    /* window size and position of 0,0,32,32 is needed for BVN bandwidth.
    be aware that on most TV's, this will fall into the overscan area and you won't be able to see the picture. */
    /* this changes resolve duplicate CRC issue observed in 7403 single decode regression */
    ws.position.width = 32;
    ws.position.height = 32;
    ws.cliprect.x = 0;
    ws.cliprect.y = 0;
    ws.cliprect.width = 0;
    ws.cliprect.height = 0;
    /* No DNR */
    ws.bnr_level = bwindow_dnr_level_off;
    ws.dcr_level = bwindow_dnr_level_off;
    ws.mnr_level = bwindow_dnr_level_off;
    /* Turn on display */
    ws.visible = true;
    ws.zorder = 1;
    bdecode_window_set(g_handles.h_window, &ws);

    return 1;
}


void uninitialize()
{
    bdecode_window_close(g_handles.h_window);
    bdecode_close(g_handles.h_decode);
    bdisplay_close(g_handles.h_display);
    bsettop_uninit();
}

int get_crcs(const char *crcfilename, const bstream_mpeg *mpeg,
    const char *pvr_filename, long loop, long wait)
{
    bstream_t stream;
    FILE *crcfile = 0;
    bplaypump_t playpump = 0;
    bplayback_t playback = 0;
    bplayback_file_t file;
    bplayback_params playback_params;
    int ii;
    char filename[80];
    int lasttime;

    if (loop == 0)
        loop = 99999;

    for (ii = 0; ii < loop; ii++)
    {
        crcbuf_wptr = 0;
        crcbuf_rptr = 0;
        g_crc_count = 0;

        if (strlen(crcfilename))
        {
            crcfile = fopen(crcfilename, "w");

            if (!crcfile)
            {
                printf("Unable to open %s\n", crcfilename);
                return -1;
            }
        }

        if (pvr_filename) {
            playpump = bplaypump_open(B_ID(0), NULL);
            playback = bplayback_open();

            BDBG_WRN(("playing %s", pvr_filename));
            file = bplayback_file_open(pvr_filename, NULL);
            bplayback_params_init(&playback_params, playback);
            playback_params.index_format = bindex_format_none;
            playback_params.end_of_stream = b_no_loop;
            playback_params.loopmode.end_of_stream = bplayback_loopmode_pause;

            stream = bplayback_start(playback, playpump, mpeg, file, &playback_params);
            if (!stream) goto error;
        }
        else {
            bband_t band;
            band = bstreamer_attach(B_ID(0), bstream_mpeg_type_ts);
            if (!band) goto error;

            stream = bstream_open(band, mpeg);
            if (!stream) goto error;
        }

        if (bdecode_start(g_handles.h_decode, stream, g_handles.h_window))
            goto error;

        lasttime = gettime();

        while (1) {
            bresult result;
            unsigned n;

            /* simplify: we always process everything, so we can always start at the end.  */
            if (crcbuf_rptr == crcbuf_wptr) {
                crcbuf_rptr = crcbuf_wptr = 0;
            }

            /* simplify: this call does not allow wrapping in crcbuf */
            result = bdecode_read_metadata(g_handles.h_decode, &crcbuf[crcbuf_wptr], CRCBUF_SIZE - crcbuf_wptr, &n);
            assert(!result);
            crcbuf_wptr += n;

            /* simplify: if we filled the crcbuf, all our assumptions fall apart. plus, we would likely lose CRC's anyway. */
            assert(crcbuf_wptr < CRCBUF_SIZE);

            /* don't start post processing before Settop API's internal buffer is empty. this prevents overflow. */
            if (n == 0) {
                int curtime = gettime();
                if (curtime - lasttime > wait * 1000) {
                    BDBG_WRN(("No CRC received for %d seconds. %d CRCs captured. Terminating.",
                                       wait, g_crc_count));
                    break;
                }

                if (process_crcs(crcfile, mpeg))
                    break;


                BKNI_Sleep(1);
                continue;
            }
            else {
                lasttime = gettime();
            }
        }
        process_crcs(crcfile, mpeg);

        bdecode_stop(g_handles.h_decode);

        if (playback)
            bplayback_close(playback);

        if (playpump)
            bplaypump_close(playpump);

        if (crcfile)
            fclose(crcfile);

        sleep(1);
    }


    return 0;
error:
    printf("failed\n");
    return 1;
}


void display_usage()
{
    printf("Usage: %s -in=streamfile -type=type \n", g_cmdname);
    printf("  where type= svc, avc, mpeg, mpeg1, h263, mp4, divx, divx311, avs or vc1\n");
    printf("Optional:\n");
    printf("-out=filename - grab crcs\n");
    printf("-vidpid=n - needed for non-es streams\n");
    printf("-pcrpid=n \n");
    printf("-streamtype=es, pes, ts, dss_es, dss_pes, bes, vob, avi or asf\n");
    printf("-loop=n - repeat stream n types\n");
    printf("-wait=n - seconds to wait for crcs before exiting\n");
    printf("-compareCRC=[1 or 0]. 1 = compare captured CRC with golden CRC. 0 = don't compare CRCs\n");
    printf("-goldenfile = path to the golden CRC file\n");
    printf("  or      %s -commandfile=filename\n", g_cmdname);
}


/* Find a string argument in the command line arguments
 * returns zero for error or not found
 */
int GetStringArg (const char *name, int required, char *buf, unsigned long bufsize)
{
    if (ArgExist (name))
    {
        char *p = ArgValue (name);
        if ((NULL == p) || (*p == '\0'))
        {
            printf ("Error: no value for %s\n", name);
            return 0;
        }

        if (strlen (p) >= bufsize)
        {
            return 0;
        }

        strcpy (buf, p);
        return 1;
    }
    else
    {
        if (required)
        {
            printf ("Error: %s switch required\n", name);
            return 0;
        }
    }
    return 0;
}


/* Find a long argument in the command line arguments
 * if the switch does not exist, num is not updated.
 * returns: 0:not found, 1:success, -1:error
 */
int GetDecLongArg (const char *name, long *num)
{
    int rc = 0;

    if (ArgExist (name))
    {
        char *str = ArgValue (name);
        if ((NULL == str) || (*str == '\0'))
        {
            printf ("Error: no value for %s\n", name);
            rc = -1;
        }
        else
        {
            char *stop;
            unsigned long value = strtoul (str, &stop, 10);
            if ((*stop != 0) || (stop == str))
            {
                printf ("Invalid number %s for %s\n", str, name);
                rc = -1;
            }
            else
            {
                *num = value;
                rc = 1;
            }
        }
    }

    return rc;
}


/* Get the needed arguments to run one file
 * return 0 on error
 *           1 on success
 */
GetArguments(struct arguments *arg)
{
    long pid, pcrpid;
    char type[50];
    char streamtype[50];

    /* get default values for the mpeg structure */
    bstream_mpeg_init(&(arg->mpeg));

    if (!GetStringArg ("-in", 1 /* required */, arg->playbackfile,
        sizeof arg->playbackfile)   )
    {
        display_usage();
        return 0;
    }

    GetStringArg ("-out", 0 /* required */, arg->resultfile,
        sizeof arg->resultfile);

    if (! GetDecLongArg ("-loop", &(arg->loop)) )
    {
        arg->loop = 1; /*default */
    }

    if (! GetDecLongArg ("-wait", &(arg->wait)) )
    {
        arg->wait = 5; /*default */
    }

    if (! GetDecLongArg ("-vidpid", &pid) )
    {
        /* if pid isn't present set it to 1.  */
        pid = 1;
    }

    /* don't pass a 0 pid into the stack */
    if (pid == 0) {
        pid = 1;
    }
    arg->mpeg.video[0].pid = pid;

    if (! GetDecLongArg ("-pcrpid", &pcrpid) )
    {
        /* if pcrpid isn't present set it to vidpid.  */
        pcrpid = pid;
    }
    arg->mpeg.pcr_pid = pcrpid;

    if (!GetStringArg("-type", 1 /* required */, type, sizeof type) )
    {
        display_usage();
        return 0;
    }

    /* modify values based on command line arguments */
    arg->mpeg.video[0].pid = pid;
    if (arg->mpeg.video[0].pid == 0) {
        arg->mpeg.video[0].pid = 1;
        arg->mpeg.mpeg_type = bstream_mpeg_type_es;
    }
    else {
        arg->mpeg.pcr_pid = arg->mpeg.video[0].pid;
    }

    if (!strcasecmp("mpeg", type))
        arg->mpeg.video[0].format = bvideo_codec_mpeg2;
    else if (!strcasecmp("avc", type))
        arg->mpeg.video[0].format = bvideo_codec_h264;
    else if (!strcasecmp("svc", type))
        arg->mpeg.video[0].format = bvideo_codec_h264_svc;
    else if (!strcasecmp("h263", type))
        arg->mpeg.video[0].format = bvideo_codec_h263;
    else if (!strcasecmp("mp4", type))
        arg->mpeg.video[0].format = bvideo_codec_mpeg4_part2;
    else if (!strcasecmp("divx", type))
        arg->mpeg.video[0].format = bvideo_codec_mpeg4_part2;
    else if (!strcasecmp("vc1", type))
        arg->mpeg.video[0].format = bvideo_codec_vc1;
    else if (!strcasecmp("mpeg1", type))
        arg->mpeg.video[0].format = bvideo_codec_mpeg1;
    else if (!strcasecmp("vc1_sm", type))
        arg->mpeg.video[0].format = bvideo_codec_vc1_sm;
    else if (!strcasecmp("divx311", type))
        arg->mpeg.video[0].format = bvideo_codec_divx_311;
    else if (!strcasecmp("avs", type))
        arg->mpeg.video[0].format = bvideo_codec_avs;
    else {
        printf("unknown argument for -type\n");
        display_usage();
        return 0;
    }

       /* process -streamtype arguments */
    if (!GetStringArg("-streamtype", 0 /* not required */, streamtype, sizeof streamtype) )
    {
        arg->mpeg.mpeg_type = bstream_mpeg_type_es;
    }
    else
    {
        if (!strcasecmp("0", streamtype))
            arg->mpeg.mpeg_type = bstream_mpeg_type_es;
        else if (!strcasecmp("es", streamtype))
            arg->mpeg.mpeg_type = bstream_mpeg_type_es;
        else if (!strcasecmp("pes", streamtype))
            arg->mpeg.mpeg_type = bstream_mpeg_type_pes;
        else if (!strcasecmp("dss_pes", streamtype))
            arg->mpeg.mpeg_type = bstream_mpeg_type_dss_pes;
        else if (!strcasecmp("ts", streamtype))
            arg->mpeg.mpeg_type = bstream_mpeg_type_ts;
        else if (!strcasecmp("bes", streamtype))
            arg->mpeg.mpeg_type = bstream_mpeg_type_bes;
        else if (!strcasecmp("dss_es", streamtype))
            arg->mpeg.mpeg_type = bstream_mpeg_type_dss_es;
        else if (!strcasecmp("vob", streamtype))
            arg->mpeg.mpeg_type = bstream_mpeg_type_vob;
        else if (!strcasecmp("asf", streamtype))
            arg->mpeg.mpeg_type = bstream_mpeg_type_asf;
        else if (!strcasecmp("avi", streamtype))
            arg->mpeg.mpeg_type = bstream_mpeg_type_avi;
        else {
            printf("unknown argument for -streamtype\n");
            display_usage();
            return 0;
        }
    }

    /* Get -goldenfile argument which represents the path to the golden CRC file */
    GetStringArg("-goldenfile", 0 /* not required */, arg->goldenfile, sizeof(arg->goldenfile));

    /* Get -compareCRC argument which represents whether or not to compare captured CRC with the golden CRC */
    if (! GetDecLongArg ("-compareCRC", &(arg->compareCRC)) )
    {
        arg->compareCRC = 0;
    }

    return 1;
}


int main(int argc, char **argv)
{
    struct arguments args;
    char buf[4096];
    int listflag = 0;
    const char *commandfile = NULL;
    FILE *fp = NULL;
    int ret = -1;

    bresult rc;
    /* init before any settop api call */
    rc = bsettop_init(BSETTOP_VERSION);
    if (rc)
        return 0;
    /* printf("\n%s built %s %s\n", argv[0], __DATE__, __TIME__); */
    g_cmdname = argv[0];

    ArgEnvInit (argc, argv, NULL);

    if ( !GetArguments(&args))
        return 1;

    /* Initialize the various layers in the stack.*/
    initialize();

    /* enable debug prints if the environment variable is set */
    if(getenv("capavddbg"))
    {
       g_debug=1;
    }

    /* Play various streams */
    while(1)
    {
        /* play a stream */
        FILE *fp_stream;
        if ((fp_stream=fopen(args.playbackfile, "rb"))!=NULL)
        {
            fclose(fp_stream);
            ret = get_crcs(args.resultfile, &(args.mpeg), args.playbackfile, args.loop, args.wait);
        }
        else
        {
            printf("unable to open stream for reading %s\n", args.playbackfile);
        }

        if (listflag)
        {
            fgets(buf, sizeof buf, fp);
            /* place it into the command line arguments */
            ArgEnvSetup(buf);
            /* parse the arguments */
            if ( !GetArguments(&args))
                break;

            ArgFreeMemory();
        }
        else
            break; /* the file specified on command line only run once */

    }
    /* compare the captured CRC with golden CRC  */
    if(args.compareCRC)
    {
      ret = compareCRCs(args);
    }

    /* Close Down */
    if (fp)
        fclose(fp);
    uninitialize();

    return ret;

}

int compareCRCs(struct arguments args)
{
  FILE *goldencrc_file, *crcfile;
  int file_content_correct = 0;
  int count_entries_crcfile = 0;
  int num_gld_crcs, num_cap_crcs;

  if(args.goldenfile == NULL)
  {
    display_usage();
    return -1;
  }

   num_gld_crcs = getNumberOfFrames(args.goldenfile);
   num_cap_crcs = getNumberOfFrames(args.resultfile);

   /* check if the golden crc file exists and compare CRCs */
   if ((goldencrc_file=fopen(args.goldenfile, "rb"))!=NULL)
   {
    int frame_num=1;
    char *input_format;
    char crc_line[200], golden_line[200];
    struct crc prev_cap_crc; /* captured CRC of the previous frame */

    prev_cap_crc.luma = 0;
    prev_cap_crc.chroma = 0;

    /* format string to read the entire line of a CRC file */
    input_format = "%[0-9a-zA-Z _:-]\r";

     /* captured-CRC file is guaranteed to exist as main() checked it */
     crcfile = fopen(args.resultfile, "rb");
     if(crcfile == NULL)
     {
        printf("%s Unable to open captured-CRC file: %s\n", BAT_FAILURE, args.resultfile);
        return -1;
     }

     while( (fscanf(crcfile, input_format, crc_line) != EOF) && (fscanf(goldencrc_file, input_format, golden_line) != EOF))
     {
       struct crc cap_crc;
       struct crc golden_crc;
       file_content_correct = 0; /* assume the file contents are not correct. This will help in error-handling. */

       file_content_correct = extractCRCs(&cap_crc, crc_line, args);
       file_content_correct = extractCRCs(&golden_crc, golden_line, args);

       if( (cap_crc.luma != golden_crc.luma) || (cap_crc.chroma != golden_crc.chroma) )
        {
          /* Ignore all 0xFFs if it's the first frame as it's a known problem */
          if( (frame_num ==1) && (cap_crc.luma == 0xffffffff) && (cap_crc.chroma == 0xffffffff))
          {
            printf("%s First frame in the captured CRC file is 0xFFFFFFFF. Golden frames: %d Captured frames: %d\n", BAT_FAILURE_ALL_FF, num_gld_crcs, num_cap_crcs);
          }
          else
          {
            /* Check if CRC for a frame is missing */
            if(checkMissingCRC(goldencrc_file, num_gld_crcs, num_cap_crcs, input_format, cap_crc, args))
            {
                printf("%s Missing CRC on frame %d. golden luma: %u golden chroma: %u captured luma: %u captured chroma: %u. Golden frames: %d Captured frames: %d\n", BAT_FAILURE_MISSING, frame_num, golden_crc.luma, golden_crc.chroma, cap_crc.luma, cap_crc.chroma, num_gld_crcs, num_cap_crcs);
            }
            else if( (prev_cap_crc.luma == cap_crc.luma) && (prev_cap_crc.chroma == cap_crc.chroma) )
            {
                /* Check if it's a repeated CRC */
                printf("%s Repeated CRC on captured frame %d. golden luma: %u golden chroma: %u captured luma: %u captured chroma: %u. Golden frames: %d Captured frames: %d\n", BAT_FAILURE_REPEAT, frame_num, golden_crc.luma, golden_crc.chroma, cap_crc.luma, cap_crc.chroma, num_gld_crcs, num_cap_crcs);
            }
            else
            {
              /* Actual CRC mismatch*/
              printf("%s Mismatched CRC on frame %d. golden luma: %u golden chroma: %u captured luma: %u captured chroma: %u. Golden frames: %d Captured frames: %d\n", BAT_FAILURE, frame_num, golden_crc.luma, golden_crc.chroma, cap_crc.luma, cap_crc.chroma, num_gld_crcs, num_cap_crcs);
            }
            /* return -1 for all failures */
            return -1;
          }
        }

        prev_cap_crc.luma = cap_crc.luma;
        prev_cap_crc.chroma = cap_crc.chroma;
        frame_num++;
        count_entries_crcfile++;
     }

     /* Check if the number of CRCs is greater in either the input file or the golden file */
     if( feof(crcfile) && !feof(goldencrc_file) )
     {
        if(count_entries_crcfile == 0)
          printf("%s 0 CRCs captured.\n", BAT_FAILURE_ZERO_CAP);
        else
          printf("%s CRC mismatch on frame: %d. Captured CRC file has fewer entries than golden CRC file. Golden frames: %d Captured frames: %d\n", BAT_FAILURE_BIGGER_GOLDEN, frame_num, num_gld_crcs, num_cap_crcs);
        /* return -1 for all failures */
        return -1;
     }
     else if( !feof(crcfile) && feof(goldencrc_file) )
     {
        printf("%s CRC mismatch on frame: %d. Captured CRC file has more entries than golden CRC file. Golden frames: %d Captured frames: %d\n", BAT_FAILURE_BIGGER_CAP, frame_num, num_gld_crcs, num_cap_crcs);
        return -1;
     }
     else if(file_content_correct)
     {
        printf("%s CRCs match.\n", BAT_SUCCESS);
        /* return 0 on success */
        return 0;
     }
     else
     {
        printf("%s File format invalid for captured CRC file or golden CRC file.\n", BAT_FAILURE);
        return -1;
     }
   }
   else
   {
      printf("%s unable to open golden CRC file for reading %s\n", BAT_FAILURE, args.goldenfile);
      return -1;
   }

}

int extractCRCs(struct crc *cap_crc, char *crc_line, struct arguments args)
{
  int count;
  char *crc_token, *temp1;
  int file_content_correct = 0;

  crc_token = strtok_r(crc_line, " ", &temp1);
  count = 1;
  while(  ((crc_token = strtok_r(NULL, " ", &temp1)) != NULL) )
  {
     count++;

    /* AVC CRCs have a different format */
    if ((args.mpeg.video[0].format == bvideo_codec_h264) ||
        (args.mpeg.video[0].format == bvideo_codec_h264_svc) ||
        (args.mpeg.video[0].format == bvideo_codec_h264_mvc)    )
    {
        /* luma values in AVC CRC files */
        if(count == 4)
        {
           cap_crc->luma = strtoul(crc_token, (char **)NULL, 10);
        }
        /* chroma values in AVC CRC files */
        if(count == 5)
        {
           cap_crc->chroma = strtoul(crc_token, (char **)NULL, 10);
           /* If we have reached this point, we read some luma/chroma values and the file contents are as expected */
           file_content_correct = 1;
           break;
        }
     }
     /* Non-AVC CRCs */
     else
      {
        /* luma values in non-AVC CRC files */
        if(count == 2)
         {
           cap_crc->luma = strtoul(crc_token, (char **)NULL, 10);
         }
         /* chroma values in non-AVC CRC files */
        if(count == 3)
         {
           cap_crc->chroma = strtoul(crc_token, (char **)NULL, 10);
           /* If we have reached this point, we read some luma/chroma values and the file contents are as expected */
           file_content_correct = 1;
           break;
         }
      }
  }
  return file_content_correct;
}

int getNumberOfFrames(char *filename)
{
   int num_of_crcs = 0;
   FILE *crc_file;

   if ((crc_file=fopen(filename, "rb"))!=NULL)
   {
     char *input_format;
     char crc_line[200];

     /* format string to read the entire line of a CRC file */
     input_format = "%[0-9a-zA-Z _:-]\r";

     while (fscanf(crc_file, input_format, crc_line) != EOF)
     {
        num_of_crcs++;
     }

   }

   fclose(crc_file);
   return num_of_crcs;

}

int checkMissingCRC(FILE *filename, int num_gld_crcs, int num_cap_crcs, char *input_format, struct crc cap_crc, struct arguments args)
{
   char line[200];
   struct crc golden_crc;
   int fileformat = 0;

   if( fscanf(filename, input_format, line) == EOF)
   {
     /* EOF reached so it must be a CRC mismatch and not a missing CRC */
     return 0;
   }
   else
   {
      fileformat = extractCRCs(&golden_crc, line, args);
      if( (num_cap_crcs > 0) && (num_cap_crcs < num_gld_crcs) && (golden_crc.luma == cap_crc.luma) && (golden_crc.chroma == cap_crc.chroma) )
      {
        /* The CRC of the next frame in the golden file matches the current CRC in the captured file so assume that captured file is missing a CRC */
        return 1;
      }
      else
        return 0;
   }
}
