/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.brcm.scalar.conf $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "docsDevServer.h"

/*
 * Define the OID pointer to the top of the mib tree that we're
 * registering underneath
 */
oid             docsDevServer_module_oid[] =
    { 1, 3, 6, 1, 2, 1, 69, 1, 4 };
int             docsDevServer_module_oid_len =
    sizeof(docsDevServer_module_oid) / sizeof(oid);
int             docsDevServer_module_count = 0;


/** Initializes the docsDevServer module */
void
init_docsDevServer(void)
{
    static oid      docsDevServerTime_oid[] =
        { 1, 3, 6, 1, 2, 1, 69, 1, 4, 3, 0 };
    static oid      docsDevServerTftp_oid[] =
        { 1, 3, 6, 1, 2, 1, 69, 1, 4, 4, 0 };
    static oid      docsDevServerConfigFile_oid[] =
        { 1, 3, 6, 1, 2, 1, 69, 1, 4, 5, 0 };
    static oid      docsDevServerBootState_oid[] =
        { 1, 3, 6, 1, 2, 1, 69, 1, 4, 1, 0 };
    static oid      docsDevServerDhcp_oid[] =
        { 1, 3, 6, 1, 2, 1, 69, 1, 4, 2, 0 };

    DEBUGMSGTL(("docsDevServer", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("docsDevServerTime",
                                         get_docsDevServerTime,
                                         docsDevServerTime_oid,
                                         OID_LENGTH(docsDevServerTime_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("docsDevServerTftp",
                                         get_docsDevServerTftp,
                                         docsDevServerTftp_oid,
                                         OID_LENGTH(docsDevServerTftp_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("docsDevServerConfigFile",
                                         get_docsDevServerConfigFile,
                                         docsDevServerConfigFile_oid,
                                         OID_LENGTH
                                         (docsDevServerConfigFile_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("docsDevServerBootState",
                                         get_docsDevServerBootState,
                                         docsDevServerBootState_oid,
                                         OID_LENGTH
                                         (docsDevServerBootState_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("docsDevServerDhcp",
                                         get_docsDevServerDhcp,
                                         docsDevServerDhcp_oid,
                                         OID_LENGTH(docsDevServerDhcp_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_docsDevServerTime(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    int             retVal = SNMP_ERR_NOERROR;

    u_char          docsDevServerTime_var[STRINGMAX];
    size_t          docsDevServerTime_varLen;

    switch (reqinfo->mode) {

    case MODE_GET:
        retVal =
            v2Get(requests->requestvb->name,
                  requests->requestvb->name_length, docsDevServerTime_var,
                  &docsDevServerTime_varLen, reqinfo);
        if (retVal == SNMP_ERR_NOERROR)
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                                     docsDevServerTime_var,
                                     docsDevServerTime_varLen);
        else
            netsnmp_set_request_error(reqinfo, requests, retVal);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return retVal;
}

int
get_docsDevServerTftp(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    int             retVal = SNMP_ERR_NOERROR;

    u_char          docsDevServerTftp_var[STRINGMAX];
    size_t          docsDevServerTftp_varLen;

    switch (reqinfo->mode) {

    case MODE_GET:
        retVal =
            v2Get(requests->requestvb->name,
                  requests->requestvb->name_length, docsDevServerTftp_var,
                  &docsDevServerTftp_varLen, reqinfo);
        if (retVal == SNMP_ERR_NOERROR)
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                                     docsDevServerTftp_var,
                                     docsDevServerTftp_varLen);
        else
            netsnmp_set_request_error(reqinfo, requests, retVal);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return retVal;
}

int
get_docsDevServerConfigFile(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    int             retVal = SNMP_ERR_NOERROR;

    u_char          docsDevServerConfigFile_var[STRINGMAX];
    size_t          docsDevServerConfigFile_varLen;

    switch (reqinfo->mode) {

    case MODE_GET:
        retVal =
            v2Get(requests->requestvb->name,
                  requests->requestvb->name_length,
                  docsDevServerConfigFile_var,
                  &docsDevServerConfigFile_varLen, reqinfo);
        if (retVal == SNMP_ERR_NOERROR)
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     docsDevServerConfigFile_var,
                                     docsDevServerConfigFile_varLen);
        else
            netsnmp_set_request_error(reqinfo, requests, retVal);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return retVal;
}

int
get_docsDevServerBootState(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    int             retVal = SNMP_ERR_NOERROR;

    u_char          docsDevServerBootState_var[STRINGMAX];
    size_t          docsDevServerBootState_varLen;

    switch (reqinfo->mode) {

    case MODE_GET:
        retVal =
            v2Get(requests->requestvb->name,
                  requests->requestvb->name_length,
                  docsDevServerBootState_var,
                  &docsDevServerBootState_varLen, reqinfo);
        if (retVal == SNMP_ERR_NOERROR)
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     docsDevServerBootState_var,
                                     docsDevServerBootState_varLen);
        else
            netsnmp_set_request_error(reqinfo, requests, retVal);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return retVal;
}

int
get_docsDevServerDhcp(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    int             retVal = SNMP_ERR_NOERROR;

    u_char          docsDevServerDhcp_var[STRINGMAX];
    size_t          docsDevServerDhcp_varLen;

    switch (reqinfo->mode) {

    case MODE_GET:
        retVal =
            v2Get(requests->requestvb->name,
                  requests->requestvb->name_length, docsDevServerDhcp_var,
                  &docsDevServerDhcp_varLen, reqinfo);
        if (retVal == SNMP_ERR_NOERROR)
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                                     docsDevServerDhcp_var,
                                     docsDevServerDhcp_varLen);
        else
            netsnmp_set_request_error(reqinfo, requests, retVal);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return retVal;
}
