/***************************************************************************
 *	   Copyright (c) 2007-2009, Broadcom Corporation
 *	   All Rights Reserved
 *	   Confidential Property of Broadcom Corporation
 *
 *	THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
 *	AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
 *	EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
 *
 * $brcm_Workfile: botf.h $
 * $brcm_Revision: 8 $
 * $brcm_Date: 7/10/09 5:27p $
 *
 * Module Description:
 *   OTF highlevel API
 *
 * Revision History:
 *
 * $brcm_Log: /BSEAV/lib/otfpvr/botf.h $
 * 
 * 8   7/10/09 5:27p vsilyaev
 * PR 56736: Added use decoder status to help detect livelock in the OTF
 * engine
 * 
 * 7   7/8/09 11:54a vsilyaev
 * PR 55989: Added handling of special EOS marker
 * 
 * 6   3/31/09 7:29p vsilyaev
 * PR 50887: OTFPVR support for the Nexus video decoder
 * 
 * 5   2/11/09 3:37p vsilyaev
 * PR 50887: Further reworked OTF pvr
 * 
 * 4   2/4/09 4:53p vsilyaev
 * PR 50887: Unwrapped main processing thread, removed dependencies on XVD
 * and RAVE handles
 * 
 * 3   2/4/09 2:33p vsilyaev
 * PR 50887: Removed globals and unneded functions. Demoted functions to
 * static. Rearrange structure members to allow compaction. Used const
 * modifier where appropriate.
 * 
 * 2   2/3/09 4:07p vsilyaev
 * PR 50887: Cleaned code, fixed warnings, reduced typecasts
 * 
 **************************************************************************/

/*=************************ Module Overview ********************************

OTF(On The Fly) module implements the required functionality to perform PVR
trick modes on streams recorded with no ES or PES start code information and 
optionally with network encryption.

The ability of a particular trick mode implementation by OTF depends on 
decoder's bandwidth, disk bandwidth, GOP structure, stream bit rate and 
resolution. Based on these parameters, customers should find out which 
trick modes are possible on their platform.

Data flow with one pass OTF implementation is shown below.

Playback0 ---> IP Parser ---> OTF ----> OP Parser ---> Decoder

OTF parses the CDB and ITB buffers generated by IP Parser, prepares the 
ITB entries based on trick mode and feeds ITB data to XVD via OP parser. Copying 
just the ITB entries to OP parser avoids second pass through OP parser, 
thus saving transport bandwidth. OP parser doesn't actually parse the stream.
It is used as an interface to the decoder.

OTF assumes that Playback0, IP Parser are configured before calling BOTF_Start.
Also, OTF assumes that OP Parser context is allocated with CDB and ITB buffer sizes
set to 0 and OP parser is attached to the decoder. Once 
OTF is started, OTF takes control of Input parser, OP Parser and Decoder using 
Magnum calls. Since Magnum is not re-entrant, other modules should access 
these modules only after taking locks shared with OTF. 

Usage

During system initialization, BOTF_Init() and BOTF_Open() routines
 should be called. BOTF_Open returns OTF handle for a specific OTF channel.

Trick mode configuration should be set using BOTF_ConfigSet API 
 before starting OTF.

Application can start and stop OTF using BOTF_Start and BOTF_Stop API.

Any time application can change the OTF configuration with the 
 call sequence BOTF_Stop, BOTF_ConfigSet, BOTF_Start.

In chunk backward and interleaved modes, the input parser must be configured
 in such a way that it can hold atleast two chunks including the marker 
 packets. If the input parser buffers can't hold two chunks, then OTF may
 drop some frames or GOPS.

In chunk forward mode, the input parser must be configured in such a way that
 it can hold atleast one complete chunk + 1 GOP.

If the input data is corrupted or in unknown format, OTF may get stuck. In
 such cases OTF will reset input parser, output parser, XVD and recover. If the
 XVD watchdog triggers then BOTF_Reset should be called to flush the pipeline 
 and restart.

Recommended minimum size for output RAVE ITB is double the size of input RAVE ITB. 

Displaying last or first I-frame in Chunk forward or Chunk backward mode: 
 OTF allows application to specify to display only the last or first I-frame 
 in a chunk and discarding the rest of the frames in the chunk. This flag is valid only in 
 chunk forward and backward modes. Results are unpredicatble if used in other
 modes. This flag is received by OTF in the Picture tag BTP. This flag helps 
 application to display the last I-frame in the recorded file in chunk forward mode 
 and the first I-frame in the recorded file in chunk backward mode.

 In chunk forward mode, to display last frame in the chunk, data should be sent in 
 the following sequence :
    ...<Marker> <Pic tag BTP> <TS chunk> <Marker> ..

 In chunk rewind mode, to display first frame in the chunk, data should be sent in 
 the following sequence :
    ...<Marker> <Pic tag BTP> <TS chunk> <Marker> ..

 The application may insert more picture tag packets in the TS chunk, but the 
 last/first I-frame flag must be same in the chunk. Results are unpredictable when
 different last/first I-frame flag was sent within a chunk.

 Following is the BTP command ITB entry format :

 Word0:

    Bits[31:24]  Entry type, for BTP entries, it is set to 0x5

    Bits[23:16]  Reserved

    Bits[15:8]  Mode[7:0], for picture tag it is set to 0xD

    Bits[7:1]  Reserved

    Bits[0]  if set to 1, indicates OTF to display only the last/first I-frame 
              in the Gops between this BTP and next marker. For chunk forward mode, 
              last I-frame is displayed and for chunk backward mode first I-frame is displayed. 

    Word1: Reserved

    Word2: Reserved

    Word3: picture tag

Important Notes:
 OTF doesn't guarantee the final speed accuracy because the final speed is heavliy dependant
  on the decoder and transport bandwidth. OTF only implements the frame decimation.
  The application/moddleware must implement pacing mechanism which will check
  the actual speed acheived and adjusts accordingly.
***************************************************************************/
#ifndef BOTF_H_
#define BOTF_H_

#include "bxpt.h"
#include "bxpt_rave.h"

#include "botf_marker.h"

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


/***************************************************************************
Summary:
OTF task sleep time between data processing iterations
****************************************************************************/
#define BOTF_TASK_SLEEPMS   25

/***************************************************************************
Summary:
OTF frame count per chunk callback type.

Parameters:
hOtf - OTF handle
chunk_no - Chunk number passed as part of marker
frame_cnt - Number of frames presented in this chunk
****************************************************************************/
typedef void (*BOTF_FrameCountCallBack_t) (void *hOtf, uint32_t chunk_no, uint32_t frame_cnt);

#ifdef OTF_CDI_SPECIFIC
/***************************************************************************
Summary:
OTF PTS value callback type.

Parameters:
MonitorCntx - Handle of the client
pictag - Picture Tag
codedPTS - PTS value
****************************************************************************/
typedef void (*BOTF_PTSValueCallBack_t) (void *MonitorCntx, uint32_t pictag, uint32_t codedPTS);
#endif

/***************************************************************************
Summary:
OTF channel parameters. 
****************************************************************************/
typedef struct BOTF_Params
{
    BMEM_Handle hBMem;                   /* Memory handle used to allocate memory */
    BREG_Handle hBReg;                   /* Register handle */
    uint32_t InputParserCDBSize;        /* CDB size for input parser */
    uint32_t InputParserITBSize;        /* ITB size for input parser */
    /* Input parser CDB will be used by output parser as well */
    /* Recommended minimum size for output RAVE ITB is double the size of input RAVE ITB */
    uint32_t OutputParserITBSize;       /* ITB size for output parser, allocated and freed by OTF */    
    uint32_t OutputParserITBAlign;      /* ITB alignment for output parser */
    bool     bUsePtsAsTag;              /* If true, use PTS as picture tag, otherwise uses the tag specified in stream
                                         * using pictag BTP command */
    BAVC_XptContextMap       inputContext;      /* Input Parser register map */
    BAVC_XptContextMap       outputContext;      /* Output Parser register map */

} BOTF_Params;

/***************************************************************************
Summary:
Input feeder mode.
****************************************************************************/
typedef enum BOTF_FeederMode {
	BOTF_FeederMode_eSequential,    /* data feed in continious stream, used for forward direction only */
    BOTF_FeederMode_eGop,           /* data feed in the gop boundaries with marking between each chunk */
    BOTF_FeederMode_eInterleaved,   /* data feed is in a chunks in a reverse order, possibly not GOP alligned, 
                                     * each chunk contains at least one complete GOP, each chunk has its mark, 
                                     * chunks has to be overlapped to allow complete recovery of the MPEG stream */	
	BOTF_FeederMode_eChunkForward,  /* data feed is in a chunks in a normal order, possible not GOP alligned, 
                                     * chunks shall not be overlapped, complete stream recovery shall not be expected */
	BOTF_FeederMode_eChunkBackward  /* data feed is in a chunks in a reverse order, possible not GOP alligned, 
                                     * chunks shall not be overlapped, complete stream recovery shall not be expected */
} BOTF_FeederMode;

/***************************************************************************
Summary:
Frame filter
****************************************************************************/
typedef enum BOTF_FrameFilter {
    BOTF_FrameFilter_eIFrames,       /* Filter only I frames */
    BOTF_FrameFilter_eIPFrames,      /* Filter I & P frames */
    BOTF_FrameFilter_eIPBFrames     /* Filter I,P & B frames */
}BOTF_FrameFilter;

#define BOTF_PLAY_RATE_MODULO    100
/***************************************************************************
Summary:
OTF configuration settings.
****************************************************************************/
typedef struct BOTF_Config
{
    bool    IsRewind;                 /* Set to true for rewind */    
    BOTF_FeederMode FeederMode;       /* Input data feed mode */
    BOTF_FrameFilter FrameFilter;     /* Frame filter */
    unsigned FrameRate;              /* Frame rate, Modulo 100 based, 200 -> 2xplayback, 150 1.5xplayback, 
                                       * 133 1.33xplayback, 400 4xplayback, slow motion is not supported */
    BOTF_FrameCountCallBack_t FrameCountCbck;
#ifdef OTF_CDI_SPECIFIC
	BOTF_PTSValueCallBack_t PTSValueCbck;
	void *MonitorCntx;                /* Handle of the client for the callback */
#endif
} BOTF_Config ;



/***************************************************************************
Summary:
Opaque handle for OTF module
****************************************************************************/
typedef struct BOTF_OpsData *BOTF_OpsHandle;

/***************************************************************************
Summary:
Opaque handle for OTF channel
****************************************************************************/
typedef struct BOTF_Data *BOTF_Handle;

/***************************************************************************
Summary:
    OTF PVR status;
****************************************************************************/
typedef struct BOTF_StepStatus {
    bool flush;
    bool stop;
    bool eos; /* EOS detected */
    bool referencePtsValid; /* set to roe if referencePts is valid */
    uint32_t referencePts; /* reference PTS */
} BOTF_StepStatus;

typedef struct BOTF_VideoDecoderStatus {
    unsigned pictureDepth; /* number of frames in the decoded picture buffer */
    uint32_t pts; /* PTS value */
    bool    ptsValid; /* validator for PTS */
} BOTF_VideoDecoderStatus;

typedef struct BOTF_Status {
    unsigned inputCdb;
    unsigned inputItb;
    unsigned unconsumedInputItb;
    unsigned outputItb;
} BOTF_Status;

void 
BOTF_GetDefaultParams(BOTF_Params *Params);

BERR_Code 
BOTF_PlayStep(BOTF_Handle hOtf, const BOTF_VideoDecoderStatus  *videoDecoderStatus, unsigned timeout, BOTF_StepStatus *status);

BERR_Code 
BOTF_GetStatus(BOTF_Handle hOtf, BOTF_Status *status);

/***************************************************************************
Summary:
Open a specific OTF channel

Description:
Allocates all the resources required for a specific OTF channel. Caller should
allocate CDB and ITB for input parser and should not allocate for output parser.
Output parser doesn't require allocation of CDB because input parser's CDB is used.
ITB for output parser is allocated by OTF.

Parameters:
hOtfOps - OTF module handle
Params - OTF channel parameters
hOtf - Pointer to OTF channel handle

Returns:
    BERR_SUCCESS                - OTF channel opened succssfully
    BERR_INVALID_PARAMETER      - Bad input parameter
****************************************************************************/
BERR_Code BOTF_Open(const BOTF_Params *Params, BOTF_Handle *hOtf);

/***************************************************************************
Summary:
Close a specific OTF channel

Description:
Frees all the resources allocated by BOTF_Open for this channel

Parameters:
hOtf - OTF channel handle

Returns:
    BERR_SUCCESS                - OTF channel opened succssfully
    BERR_INVALID_PARAMETER      - Bad input parameter
****************************************************************************/
void BOTF_Close(BOTF_Handle hOtf);

/***************************************************************************
Summary:
Start OTF channel

Description:
BOTF_ConfigSet should have been called before calling this routine. If locks
are not used i.e BOTF_LOCK_MAGNUMHANDLE is not defined to protect hInputParser, 
hOutputParser and hDec, after calling this routine application 
should not access these resources.
In case the application want to change the OTF configuration, 
it should follow the call sequence stop, set new configuration and then start.

Parameters:
hOtf - OTF channel handle
TaskEntry - Return value contains the OTF task entry point

Returns:
    BERR_SUCCESS                - OTF channel closed succssfully
    BERR_INVALID_PARAMETER      - Bad input parameter
****************************************************************************/
BERR_Code BOTF_Start(BOTF_Handle hOtf);



/***************************************************************************
Summary:
Stop OTF channel

Description:
Makes OTF task to exit, flushes the entire OTF pipeline OTF task will not access  
hInputParser, hOutputParser and hDec after this routine returns. Since OTF
task exited, application should release any resources allocated during OTF 
task spawn after callig BOTF_Stop.

Parameters:
hOtf - OTF channel handle

Returns:
    BERR_SUCCESS                - OTF channel stopped succssfully
    BERR_INVALID_PARAMETER      - Bad input parameter
****************************************************************************/
void BOTF_Stop(BOTF_Handle hOtf);

/***************************************************************************
Summary:
Flush OTF pipeline

Description:
This routine should be used as part of flush routine

Parameters:
hOtf - OTF channel handle

****************************************************************************/
void BOTF_DisableForFlush(BOTF_Handle hOtf);

/***************************************************************************
Summary:
Flush OTF pipeline

Description:
This routine flushes the OTF pipeline including input parser, output parser
and decoder.

Parameters:
hOtf - OTF channel handle

****************************************************************************/
void BOTF_Flush(BOTF_Handle hOtf);

/***************************************************************************
Summary:
Get OTF configuration settings

Description:
Get the current OTF configuration.

Parameters:
hOtf - OTF channel handle
Config - BOTF channel trick mode parameters

Returns:
    BERR_SUCCESS                - OTF configuration got succssfully
    BERR_INVALID_PARAMETER      - Bad input parameter
****************************************************************************/
void BOTF_ConfigGet( BOTF_Handle hOtf, BOTF_Config *Config);

/***************************************************************************
Summary:
Set OTF configuration settings

Description:
Set the OTF configuration based on the trick mode speed and direction

Parameters:
hOtf - OTF channel handle
Config - BOTF channel trick mode parameters

Returns:
    BERR_SUCCESS                - OTF configuration set succssfully
    BERR_INVALID_PARAMETER      - Bad input parameter
****************************************************************************/
BERR_Code BOTF_ConfigSet( BOTF_Handle hOtf, const BOTF_Config *Config);


/***************************************************************************
Summary:
Get reference PTS.

Description:
Caller should make sure to feed enough data (few GOPs) and then stop pumping data 
before calling this routine.
Also, caller should remember the stream time or file offset associated with the 
last data feed to OTF. When this routine is called, it will activate acqusition 
process that looks for interruption in data. 
Then caller should monitor data returned by the BOTF_PlayStep in the BOTF_Step 
structure associate this PTS with the stream time or file offset of data sent before calling
this routine. Caller can resume data pumping after this routine returns.
The PTS value returned is PTS[32:1] for MPEG stream or PTS[31:0] for DSS streams.

Parameters:
hOtf - OTF channel handle

****************************************************************************/
void BOTF_RequestReferencePTS( BOTF_Handle hOtf);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* BOTF_H_ */

