/**@@@+++@@@@******************************************************************
**
** Microsoft (r) PlayReady (r)
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <stdafx.h>
#include <DrmManagerTestAPI.h>
#include <drmxmlparser.h>
#include <drmrevocation.h>
#include <PKCommonTestAPI.h>

#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_WM7
#include <windows.h>
#include <shellapi.h>
#include <drmmodelrevocation.h>
#endif /* DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_WM7 */

ENTER_PKTEST_NAMESPACE_CODE

/*****************************************************************************
** Function:    TestManagerSetRevocationInfo
**
** Synopsis:    Read in Revocation Info from file (wide char b64 encoded)
**
** Arguments:   argv[0]: file path
**
** Returns:     DRM_SUCCESS                  - on success
**
** Note:
**
******************************************************************************/
DRM_RESULT DRM_CALL TestManagerSetRevocationInfo(long argc, __in_ecount(argc) char **argv)
{
    DRM_RESULT   dr                 = DRM_SUCCESS;
    DRM_STRING  *pRevocationInfo    = NULL;
    _XMBContext *pbResponseContext  = NULL;

    ChkArg( argc == 1 );

    /*
    ** Get Shared variables
    */
    MAP_TO_GLOBAL_TEST_VAR( pRevocationInfo, REV_INFO_VAR );
    if ( DRM_FAILED( DRM_TST_GetTestVar( RESPONSE_CONTEXT_VAR, ( DRM_VOID ** ) &pbResponseContext, NULL ) ) )
    {
        pbResponseContext = NULL;
    }

    FREEDRMSTRINGPOINTER( pRevocationInfo );

    if ( argv[0] )
    {
        ChkArg( LoadTestFile( NULL,
                              argv[0],
                              (DRM_BYTE**)(&(pRevocationInfo->pwszString)),
                              &pRevocationInfo->cchString ) );
    }
    pRevocationInfo->cchString = ( DRM_DWORD ) DRMCRT_wcslen( pRevocationInfo->pwszString );
    ChkDR( TestResponseAddRevocationInfo( pbResponseContext, (DRM_CONST_STRING *) pRevocationInfo ) );

ErrorExit:
    return dr;
}

/*****************************************************************************
** Function:    TestManagerSetRevocation
**
** Synopsis:    Read in Revocation from file (wide char b64 encoded)
**
** Arguments:   argv[0] : GUID
**              argv[1] : file path
**
** Returns:     DRM_SUCCESS                  - on success
**
** Note:
**
******************************************************************************/
DRM_RESULT DRM_CALL TestManagerSetRevocation(long argc, __in_ecount(argc) char **argv)
{
    DRM_RESULT   dr                 = DRM_SUCCESS;
    DRM_STRING  *pRevocation        = NULL;
    _XMBContext *pbResponseContext  = NULL;
    DRM_CONST_STRING dstrGUID       = {NULL, 0};

    ChkArg( argc == 2 );

    MAP_TO_GLOBAL_TEST_VAR( pRevocation, REVOCATION_STRING_VAR );
    if ( DRM_FAILED( DRM_TST_GetTestVar( RESPONSE_CONTEXT_VAR, ( DRM_VOID ** ) &pbResponseContext, NULL ) ) )
    {
        pbResponseContext = NULL;
    }


#if SIXTEEN_BIT_ADDRESSING
    /*
    ** Using MakeDRMString rather than TST_UTL_mbstowcs, since it is the prefered way of conversion to wide
    ** char. Eventually, all TST_UTL_mbstowcs will be replaced even on 32-bit
    */
    ChkDR( MakeDRMString( &dstrGUID, argv[0] ) );
#else
    dstrGUID.cchString = DRMCRT_strlen( argv[0] );
    dstrGUID.pwszString = (DRM_WCHAR *) Oem_MemAlloc( SIZEOF(DRM_WCHAR) * ( dstrGUID.cchString + 1 ) );
    ChkMem( dstrGUID.pwszString );
    ZEROMEM( ( DRM_BYTE * )dstrGUID.pwszString, SIZEOF(DRM_WCHAR) * ( dstrGUID.cchString + 1 ) );
    TST_UTL_mbstowcs( (DRM_WCHAR *) dstrGUID.pwszString, argv[0], dstrGUID.cchString + 1 );
#endif

    FREEDRMSTRINGPOINTER( pRevocation );

    if ( argv[1] )
    {
        ChkArg( LoadTestFile( NULL,
                              argv[1],
                              ((DRM_BYTE**)&(pRevocation->pwszString)),
                              &pRevocation->cchString ) );
    }

    pRevocation->cchString = ( DRM_DWORD ) DRMCRT_wcslen( pRevocation->pwszString );

    ChkDR( TestResponseAddRevocation( pbResponseContext, &dstrGUID, (DRM_CONST_STRING *)pRevocation ) );

 ErrorExit:
    FREEDRMSTRING( dstrGUID );

    return dr;
}

/*****************************************************************************
** Function:    TestManagerSetPRRevDataFromFile
**
** Synopsis:    Read in PlayReady revocation data(CRLs) from a file (same format as that 
**              of the RevocationData.xml file on PlayReady server, but Unicode, and without 
**              the root level tag of <RefInfo>), and put it into global REV_INFO_VAR of 
**              so that it could be included in the XMR License response generated by PK test 
**              code later.
**
** Arguments:   argv[0]: file path
**
** Returns:     DRM_SUCCESS                  - on success
**
** Note:
**
******************************************************************************/
DRM_RESULT DRM_CALL TestManagerSetPRRevDataFromFile(long argc, __in_ecount(argc) char **argv)
{
    DRM_RESULT   dr                 = DRM_SUCCESS;
    DRM_STRING  *pRevocationInfo    = NULL;

    ChkArg( argc == 1 );

    /*
    ** Get Shared variables
    */
    MAP_TO_GLOBAL_TEST_VAR( pRevocationInfo, REV_INFO_VAR );

    FREEDRMSTRINGPOINTER( pRevocationInfo );

    if ( argv[0] )
    {
        ChkArg( LoadTestFile( NULL,
                              argv[0],
                              (DRM_BYTE**)(&(pRevocationInfo->pwszString)),
                              &pRevocationInfo->cchString ) );
    }
    pRevocationInfo->cchString = ( DRM_DWORD ) DRMCRT_wcslen( pRevocationInfo->pwszString );

ErrorExit:
    return dr;
}


/*****************************************************************************
** Function:    TestManagerGetRevocationList
**
** Synopsis:    Get Revocation List
**
** Arguments:   argv[0]: GUID to retrieve
**
** Returns:     DRM_SUCCESS                  - on success
**
** Note:
**
******************************************************************************/
DRM_RESULT DRM_CALL TestManagerGetRevocationList(long argc, __in_ecount(argc) char **argv)
{
    DRM_RESULT               dr                 = DRM_SUCCESS;
    DRM_REVOCATION_TYPE_ENUM eRevType           = DRM_REVOCATION_TYPE_WMDRM_ND;
    DRM_BYTE                 *pbBuffer          = NULL;
    DRM_DWORD                cbBuffer           = 0;
    DRM_BYTE                 *pbExpected        = NULL;
    DRM_DWORD                cbExpected         = 0;
    DRM_DWORD                dwVersion          = 0;
    DRM_BYTE *pbDecoded = NULL;
    DRM_DWORD                cbDecoded          = 0;
    DRM_STRING               dstrEncodedData    = EMPTY_DRM_STRING;
    DRM_STRING               dstrRevocationList = EMPTY_DRM_STRING;
    DRM_STRING               dstrTemplate       = EMPTY_DRM_STRING;
    DRM_CONST_STRING         *buff              = {0};
    const DRM_DWORD          level              = 0;
    DRM_DWORD                level1             = 1;
    DRM_APP_CONTEXT         *poManagerContext   = NULL;

    GET_SHARED_APP_CONTEXT( poManagerContext );

    ChkArg( argc >= 1 );

    if ( 0 == strcmp( argv[0], "{90A37313-0ECF-4CAA-A906-B188F6129300}" )
     ||  0 == strcmp( argv[0], "DRM_REVOCATION_TYPE_WMDRM_APP" ))
    {
        eRevType =  DRM_REVOCATION_TYPE_WMDRM_APP;
    }
    else if ( 0 == strcmp( argv[0], "{3129E375-CEB0-47D5-9CCA-9DB74CFD4332}" )
           || 0 == strcmp( argv[0], "DRM_REVOCATION_TYPE_WMDRM_DEVICE" ) )
    {
        eRevType = DRM_REVOCATION_TYPE_WMDRM_DEVICE;
    }
    else if ( 0 == strcmp( argv[0], "{CD75E604-543D-4A9C-9F09-FE6D24E8BF90}" )
           || 0 == strcmp( argv[0], "DRM_REVOCATION_TYPE_WMDRM_ND" ) )
    {
        eRevType = DRM_REVOCATION_TYPE_WMDRM_ND;
    }
    else if ( 0 == strcmp( argv[0], "DRM_REVOCATION_TYPE_WMDRM_REVINFO" ) )
    {
        eRevType = DRM_REVOCATION_TYPE_WMDRM_REVINFO;
    }
    else if ( 0 == strcmp( argv[0], "DRM_REVOCATION_TYPE_PLAYREADY_RUNTIME" ) )
    {
        eRevType = DRM_REVOCATION_TYPE_PLAYREADY_RUNTIME;
    }
    else if ( 0 == strcmp( argv[0], "DRM_REVOCATION_TYPE_PLAYREADY_APP" ) )
    {
        eRevType = DRM_REVOCATION_TYPE_PLAYREADY_APP;
    }
    else if ( 0 == strcmp( argv[0], "DRM_REVOCATION_TYPE_PLAYREADY_REVINFO2" ) )
    {
        eRevType = DRM_REVOCATION_TYPE_PLAYREADY_REVINFO2;
    }
    else
    {
        /*
        ** Not a recognized GUID
        */
        ChkArg( FALSE );
    }

    dr = Drm_Revocation_GetList( poManagerContext,
                                    eRevType,
                                    pbBuffer,
                                    &cbBuffer,
                                    &dwVersion );

    if ( DRM_E_BUFFERTOOSMALL == dr )
    {
        pbBuffer = (DRM_BYTE *) Oem_MemAlloc( cbBuffer );
        ChkMem( pbBuffer );
        ZEROMEM( pbBuffer, cbBuffer );
        dr = Drm_Revocation_GetList( poManagerContext,
                                        eRevType,
                                        pbBuffer,
                                        &cbBuffer,
                                        &dwVersion );
    }
    ChkDR(dr);

    if ( 2 <= argc )
    {
        if ( NULL == argv[1] )
        {
            ChkArg( 0 == cbBuffer );
        }
        else
        {
            DRM_BOOL fCompareRaw = FALSE;

            if( argc >= 3 && argv[2] != NULL )
            {
                ChkDR( StringToBool( argv[2], &fCompareRaw ) );
            }

            ChkArg( LoadTestFile( NULL, argv[1], &pbExpected, &cbExpected ) );

            if( !fCompareRaw )
            {
                /*
                ** decode the XML for the new exclusion list
                */
                cbDecoded = cbExpected;
                pbDecoded = (DRM_BYTE *) Oem_MemAlloc( cbDecoded );
                ChkMem( pbDecoded );
                ZEROMEM( pbDecoded, cbDecoded );
                DSTR_FROM_PB( &dstrEncodedData, pbExpected, cbExpected );
                ChkDR( DRM_B64_DecodeW( (DRM_CONST_STRING *) &dstrEncodedData, &cbDecoded, pbDecoded, 0 ) );

                if ( DRM_REVOCATION_TYPE_WMDRM_ND == eRevType )
                {
                    DSTR_FROM_PB( &dstrRevocationList, pbDecoded, cbDecoded );

                    /*
                    ** find the <TEMPLATE> tag and base64 decode its delicious contents
                    ** Note that the parameter buff is used to pass NULL. It is used here instead
                    ** of actually passing NULL for making it work on 16-bit TI emulator
                    */
                    ChkDR( DRM_XML_GetSubNode(  (DRM_CONST_STRING*)&dstrRevocationList,
                                                &g_dstrTemplate,
                                                buff,
                                                buff,
                                                level,
                                                buff,
                                                (DRM_CONST_STRING*)&dstrTemplate,
                                                level1 ) );

                    ChkDR( DRM_B64_DecodeW( (DRM_CONST_STRING*)&dstrTemplate,
                                             &cbDecoded,
                                             NULL,
                                             DRM_BASE64_DECODE_IN_PLACE ) );

                    ChkBOOL( cbDecoded == cbBuffer, DRM_E_FAIL );
                    ChkBOOL( 0 == MEMCMP( dstrTemplate.pwszString, pbBuffer, cbBuffer ), DRM_E_FAIL );
                }
                else
                {
                    ChkBOOL( cbDecoded == cbBuffer, DRM_E_FAIL );
                    ChkBOOL( 0 == MEMCMP( pbDecoded, pbBuffer, cbBuffer ), DRM_E_FAIL );
                }
            }
            else
            {
                ChkBOOL( cbExpected == cbBuffer, DRM_E_FAIL );
                ChkBOOL( 0 == MEMCMP( pbExpected, pbBuffer, cbBuffer ), DRM_E_FAIL );
            }
        }
    }

 ErrorExit:
    SAFE_OEM_FREE( pbExpected );
    SAFE_OEM_FREE( pbBuffer );
    SAFE_OEM_FREE( pbDecoded );

    return dr;
}

/*****************************************************************************
** Function:    TestManagerCheckRevCRLVersion
**
** Synopsis:    Get the version of a CRL and confirm the value is as expected
**
** Arguments:   argv[0]: GUID for this CRL
** Arguments:   argv[1]: Expected version
**
** Returns:     DRM_SUCCESS                  - on success
**              DRM_E_NOT_FOUND              - on CRL not found for this GUID
**              DRM_E_FAIL                   - on fail
** Note:
**
******************************************************************************/
DRM_RESULT DRM_CALL TestManagerCheckRevCRLVersion(long argc, __in_ecount(argc) char **argv)
{
    DRM_RESULT               dr                 = DRM_SUCCESS;
    DRM_REVOCATION_TYPE_ENUM eRevType           = DRM_REVOCATION_TYPE_WMDRM_ND;
    DRM_BYTE                 *pbBuffer          = NULL;
    DRM_DWORD                cbBuffer           = 0;
    DRM_DWORD                dwVersion          = 0;
    DRM_DWORD                dwVersionExpected  = 0;
    DRM_APP_CONTEXT         *poManagerContext   = NULL;

    GET_SHARED_APP_CONTEXT( poManagerContext );

    ChkArg( argc >= 2 );

    if ( 0 == strcmp( argv[0], "{90A37313-0ECF-4CAA-A906-B188F6129300}" )
     ||  0 == strcmp( argv[0], "DRM_REVOCATION_TYPE_WMDRM_APP" ))
    {
        eRevType =  DRM_REVOCATION_TYPE_WMDRM_APP;
    }
    else if ( 0 == strcmp( argv[0], "{3129E375-CEB0-47D5-9CCA-9DB74CFD4332}" )
           || 0 == strcmp( argv[0], "DRM_REVOCATION_TYPE_WMDRM_DEVICE" ) )
    {
        eRevType = DRM_REVOCATION_TYPE_WMDRM_DEVICE;
    }
    else if ( 0 == strcmp( argv[0], "{CD75E604-543D-4A9C-9F09-FE6D24E8BF90}" )
           || 0 == strcmp( argv[0], "DRM_REVOCATION_TYPE_WMDRM_ND" ) )
    {
        eRevType = DRM_REVOCATION_TYPE_WMDRM_ND;
    }
    else if ( 0 == strcmp( argv[0], "DRM_REVOCATION_TYPE_WMDRM_REVINFO" ) )
    {
        eRevType = DRM_REVOCATION_TYPE_WMDRM_REVINFO;
    }
    else if ( 0 == strcmp( argv[0], "DRM_REVOCATION_TYPE_PLAYREADY_RUNTIME" ) )
    {
        eRevType = DRM_REVOCATION_TYPE_PLAYREADY_RUNTIME;
    }
    else if ( 0 == strcmp( argv[0], "DRM_REVOCATION_TYPE_PLAYREADY_APP" ) )
    {
        eRevType = DRM_REVOCATION_TYPE_PLAYREADY_APP;
    }
    else if ( 0 == strcmp( argv[0], "DRM_REVOCATION_TYPE_PLAYREADY_REVINFO2" ) )
    {
        eRevType = DRM_REVOCATION_TYPE_PLAYREADY_REVINFO2;
    }
    else
    {
        /*
        ** Not a recognized GUID
        */
        ChkArg( FALSE );
    }

    dwVersionExpected = ( DRM_DWORD )strtoul( argv[1], NULL, 0 );

    dr = Drm_Revocation_GetList( poManagerContext,
                                    eRevType,
                                    pbBuffer,
                                    &cbBuffer,
                                    &dwVersion );

    if ( DRM_E_BUFFERTOOSMALL == dr )
    {
        pbBuffer = (DRM_BYTE *) Oem_MemAlloc( cbBuffer );
        ChkMem( pbBuffer );
        ZEROMEM( pbBuffer, cbBuffer );
        dr = Drm_Revocation_GetList( poManagerContext,
                                        eRevType,
                                        pbBuffer,
                                        &cbBuffer,
                                        &dwVersion );
    }
    ChkDR(dr);

    ChkBOOL( cbBuffer > 0, DRM_E_NOT_FOUND);
    ChkBOOL( dwVersion == dwVersionExpected, DRM_E_TEST_UNEXPECTED_REVINFO_RESULT);

ErrorExit:
    SAFE_OEM_FREE(pbBuffer);
    return dr;
}


/*****************************************************************************
** Function:    TestManagerCheckRevCRLVersionWM7
**              
** Synopsis:    Get the version of a CRL and confirm the value is as expected, only for WM7. 
**
** Arguments:   argv[0]: GUID for this CRL
** Arguments:   argv[1]: Expected version
**
** Returns:     DRM_SUCCESS                  - on success
**                 DRM_E_FAIL                      - on fail
**
** Note:         If non-WM7 platform call this function, it will always return DRM_SUCCESS without checking anything.
**
******************************************************************************/
DRM_RESULT DRM_CALL TestManagerCheckRevCRLVersionWM7(long argc, __in_ecount(argc) char **argv)
{
    DRM_RESULT        dr               = DRM_SUCCESS;

#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_WM7

    dr = TestManagerCheckRevCRLVersion(argc, argv);

#endif //endif: DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_WM7

    return dr;
}


/*****************************************************************************
** Function:    TestManagerStoreRevocationLists
**
** Synopsis:    sets several revocation lists to the store at once from an
**              array of DRM_RVK_LIST structures.  argv contains a list of an
**              arbitrary set of GUID/data file pairs.  This API builds a set
**              of revocation lists from the specified args.
**
** Arguments:   argv[0] : flag indicating if NULL context should be used (FALSE means use global test context)
**              argv[1] : number of rev lists to store.
**              argv[2+]: Data to store
**                            Even argvs are GUIDs.  
**                            Odd argvs are file paths for the rev lists to use.
**
** Returns:     DRM_SUCCESS                  - on success
**
** Note:
**
******************************************************************************/
DRM_RESULT DRM_CALL TestManagerStoreRevocationLists(long argc, __in_ecount(argc) char **argv)
{
    DRM_RESULT        dr               = DRM_SUCCESS;
    DRM_DWORD         dwRevLists       = 0;
    DRM_LONG          i                = 0;
    DRM_RVK_LIST  *pRevLists        = NULL;
    DRM_RVK_LIST  *pTemp            = NULL;
    DRM_CONST_STRING  dstrGUID         = EMPTY_DRM_STRING;
    DRM_BYTE         *pbRevList        = NULL;
    DRM_DWORD         cbRevList        = 0;
    DRM_BOOL          fUseNullContext  = FALSE;
    DRM_APP_CONTEXT  *poManagerContext = NULL;

    GET_SHARED_APP_CONTEXT( poManagerContext );

    ChkArg( argc >= 2 );
    ChkArg( argc % 2 == 0 );
    ChkDR( StringToBool( argv[0], &fUseNullContext ) );

    dwRevLists = strtoul( argv[1], NULL, 0 );

    /*
    ** allocate enough space for all the revlist/GUID pairs passed as arguments
    */
    ChkMem( pRevLists = (DRM_RVK_LIST *)Oem_MemAlloc( SIZEOF( DRM_RVK_LIST ) * ( argc - 2 ) ) );
    ZEROMEM( (DRM_BYTE*)pRevLists, SIZEOF( DRM_RVK_LIST ) * ( argc - 2 ) );
    pTemp = pRevLists;

    /*
    ** iterate through argvs, filling out the DRM_RVK_LIST
    ** structure for each GUID/RL pair.
    */
    for ( i = 2; i+1 < argc ; i = i+2)
    {

        /*
        ** Get the GUID from the command line and set it in the DRM_RVK_LIST struct.
        */
        if (argv[i])
        {
            ChkDR( MakeDRMString( &dstrGUID, argv[i] ) );
            ChkDR( DRM_UTL_StringToGuid( &dstrGUID, &pTemp->guidRevocationList ) );
        }

        /*
        ** Get the rev list and store it.
        */
        if ( argv[i+1] )
        {
            Log( "", "argv[%d+1]=%s", i, argv[i+1] );
            ChkArg( LoadTestFile( NULL, argv[i+1], &pbRevList, &cbRevList ) == TRUE );
            pTemp->pbRevocationList = pbRevList;
            pTemp->cbRevocationList = cbRevList;

        }
        pTemp++;

    }

    ChkDR( Drm_Revocation_StoreRevListArray ( fUseNullContext? NULL : poManagerContext, dwRevLists, pRevLists ) );

ErrorExit:
    SAFE_OEM_FREE( pRevLists );
    return dr;
}

/*****************************************************************************
** Function:    TestManagerGetLicenseRevInfoVersion
**
** Synopsis:    This method is used to verify the rev info returned by
**              Drm_License_GetProperty for RevInfoVersion
**
** Arguments:   argv[0] : revinfo version which is expcted to be present in drm manager context.
**              argv[1] : Flag indicating whether NULL should be passed for DRM Manager Context.
**              argv[2] : Flag indicating whether NULL should be passed for the variable holding the rev info
**                        result from the API
**
** Returns:     DRM_SUCCESS                  - on success
**
** Note:
**
******************************************************************************/
DRM_RESULT DRM_CALL TestManagerGetLicenseRevInfoVersion(long argc, __in_ecount(argc) char **argv)
{
    DRM_RESULT       dr                     = DRM_SUCCESS;
    DRM_DWORD        dwRevInfoVer           = 0;
    DRM_APP_CONTEXT *pContext               = NULL;
    DRM_DWORD        dwReturnedRevInfoVer   = 0;
    DRM_DWORD       *pdwReturnedRevInfoVer  = NULL;

    ChkArg( argc == 3 );

    dwRevInfoVer = atoi( argv[0] );

    if ( atol( argv[1] ) != 0 )
    {
        GET_SHARED_APP_CONTEXT( pContext );
    }

    if ( atol( argv[2] ) != 0 )
    {
        pdwReturnedRevInfoVer = &dwReturnedRevInfoVer;
    }

    ChkDR( Drm_License_GetProperty( pContext,
                                    DRM_LGP_REVINFO_VERSION,
                                    NULL,
                                    NULL,
                                    pdwReturnedRevInfoVer ) );

    if ( dwReturnedRevInfoVer != dwRevInfoVer )
    {
        Log("Trace", "\t\tFrom TestManagerGetLicenseRevInfoVersion: Rev Info Version Mismatch");
        ChkDR( DRM_E_TEST_RIV_MISMATCH );
    }
ErrorExit:
    return dr;
}

/*****************************************************************************
** Function:    TestManagerStoreRevocationPackage
**
** Synopsis:    sets several revocation lists to the store at once from a
**              revocation package
**
** Arguments:   argv[0] : flag indicating if NULL context should be used (FALSE means use global test context)
**              argv[1] : filename of revocation package
**
** Returns:     DRM_SUCCESS                  - on success
**
** Note:
**
******************************************************************************/
DRM_RESULT DRM_CALL TestManagerStoreRevocationPackage(long argc, __in_ecount(argc) char **argv)
{
    DRM_RESULT        dr               = DRM_SUCCESS;
    DRM_BYTE         *pbRevPackage     = NULL;
    DRM_DWORD         cbRevPackage     = 0;
    DRM_BOOL          fUseNullContext  = FALSE;
    DRM_APP_CONTEXT  *poManagerContext = NULL;

    GET_SHARED_APP_CONTEXT( poManagerContext );

    ChkArg( argc == 2 );
    ChkArg( argv[1] != NULL );
    ChkDR( StringToBool( argv[0], &fUseNullContext ) );

    /*
    ** load the revocation package from the file
    */
    ChkArg( LoadTestFile( NULL, argv[1], &pbRevPackage, &cbRevPackage ) == TRUE );

    ChkDR( Drm_Revocation_StorePackage( fUseNullContext? NULL : poManagerContext, ( DRM_CHAR * )pbRevPackage, cbRevPackage ) );

ErrorExit:
    SAFE_OEM_FREE( pbRevPackage );
    return dr;
}

/*****************************************************************************
** Function:    TestManagerSetModelNamefromReg
**
** Synopsis:    Set device model name to registry, any apply to WM7 now. Be used for model revocation API test
**
** Arguments:   argv[0]   : String, new device model name to be set
**
** Returns:     DRM_SUCCESS             - on success
**              DRM_E_TEST_INCOMPLETE   - on error
**
******************************************************************************/
DRM_RESULT DRM_CALL TestManagerSetModelNamefromReg(long argc, __in_ecount(argc) char **argv)
{
#define MAX_TEST_DEVICE_MODEL_NAME  256   /* 256 WCHAR, 512 bytes */

    DRM_RESULT                    dr                         = DRM_SUCCESS;

#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_WM7

    DRM_CONST_STRING              dstrDeviceModel            = EMPTY_DRM_STRING;
    DRM_LONG                      i                          = 0;
    HKEY                          hkWM7Model                 = NULL;
    BOOL                          bSetRegSuccess             = FALSE;
    WCHAR                         pwszParameters[200]        = {0};
    SHELLEXECUTEINFO              ShellInfo                  = {0};

    ChkArg( argc == 1 );
    ChkArg(argv[0]);

    DRMASSERT(DRM_MODELREVOCATION_IsModelRevocationSupported());

    for( i = 0; i < argc; i++ )
    {
        Log("Trace", "\t\tFrom TestManagerSetModelNamefromReg: argv[%d]=%s", i, argv[i]);
    }

    // Check if the registry entry for model name exist. If not, print a warning and create it:
    if(RegOpenKeyExW( HKEY_LOCAL_MACHINE, REG_SUBKEY_WM7_MODEL_STRING, 0, 0, &hkWM7Model ) != ERROR_SUCCESS || hkWM7Model == NULL)
    {
        Log("Warning:", "\t\tFrom TestManagerSetModelNameFromReg: reg entry for model name not exist.");
        wcscat(pwszParameters, L"HKLM\\");
        wcscat(pwszParameters, REG_SUBKEY_WM7_MODEL_STRING);
        wcscat(pwszParameters, L" ");
        wcscat(pwszParameters, REG_VALUENAME_WM7_MODEL_STRING);
        wcscat(pwszParameters, L"=\"\"");

        bSetRegSuccess = LaunchDRMHelperRoutine(L"regcreatekey", pwszParameters);
        ChkBOOL(bSetRegSuccess, DRM_E_FAIL);

        _wcsset(pwszParameters, L'\0');
        bSetRegSuccess = FALSE;
    }

    ChkDR( MakeDRMString( &dstrDeviceModel, argv[0] ) );

    ChkBOOL( dstrDeviceModel.cchString < MAX_TEST_DEVICE_MODEL_NAME + 1, DRM_E_BCERT_MANUFACTURER_STRING_TOO_LONG);

    wcscat(pwszParameters, L"-r HKEY_LOCAL_MACHINE -p ");
    wcscat(pwszParameters, REG_SUBKEY_WM7_MODEL_STRING);
    wcscat(pwszParameters, L" -n ");
    wcscat(pwszParameters, REG_VALUENAME_WM7_MODEL_STRING);
    wcscat(pwszParameters, L" -v \"");
    wcscat(pwszParameters, dstrDeviceModel.pwszString);
    wcscat(pwszParameters, L"\"");

    bSetRegSuccess = LaunchDRMHelperRoutine(L"SetRegValue", pwszParameters);
    ChkBOOL(bSetRegSuccess, DRM_E_FAIL);

    dr = DRM_SUCCESS;
   
ErrorExit:
    FREEDRMSTRING( dstrDeviceModel );
    return dr;
#else //else: DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_WM7
    return dr;
#endif //endif: DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_WM7
}

/**********************************************************************
**
** Function: TestSetCrl
**
** Synopsis: Set different CRL types
**
**
** Arguments: IN argc           -    number of arguments
**            IN argv[0]        -    GUID Value
**            IN argv[1]        -    CRL file
**
** Returns:   DRM_SUCCESS on success.
**            DRM_E_FILENOTFOUND if the file is not found
**            DRM_E_INVALIDARG if invalid arguments supplied
**            DRM_E_FILEREADERROR if reading the file failed
**            errors returned by DRM_UTL_StringToGuid
**            one of errors return by DRM_RVS_StoreRevocationData.
**            other errors found in drmresults.h
**
**********************************************************************/
DRM_RESULT DRM_CALL TestSetCrl
(
    __in              DRM_LONG    argc,
    __in_ecount(argc) DRM_CHAR  **argv
)
{
    DRM_RESULT                dr                   = DRM_SUCCESS;
    DRM_CONST_STRING          dstrGUID             = EMPTY_DRM_STRING;
    DRM_CONST_STRING          dstrCRLFile          = EMPTY_DRM_STRING;
    DRM_GUID                  oGUID                = {0};
    DRM_BYTE                 *pData                = NULL;
    DRM_DWORD                 dwCRLData            = 0;
    OEM_FILEHDL               FileHdl              = OEM_INVALID_HANDLE_VALUE;
    DRM_APP_CONTEXT          *poAppContext         = NULL;
    DRM_BOOL                  fUpdated             = FALSE;
    DRM_APP_CONTEXT_INTERNAL *poAppContextInternal = NULL;
    DRM_CRYPTO_CONTEXT       *poCryptoContext      = NULL;

    if ( argc < 2 )
    {
        Log( "Trace", "\t\tFrom TestSetCrl: error in number of arguments." );
        ChkDR ( DRM_E_TEST_INVALIDARG );
    }

    ChkArg( argv[0] != NULL );
    ChkArg( argv[1] != NULL );

    GET_SHARED_APP_CONTEXT( poAppContext );
    poAppContextInternal = (DRM_APP_CONTEXT_INTERNAL*)poAppContext;

    ChkMem( poCryptoContext = ( DRM_CRYPTO_CONTEXT * ) Oem_MemAlloc( SIZEOF( DRM_CRYPTO_CONTEXT ) ) );
    ZEROMEM( poCryptoContext, SIZEOF( DRM_CRYPTO_CONTEXT ) );

    /*
    ** Parse the GUID value
    */
    ChkDR( MakeDRMString ( &dstrGUID , argv[0] ) );
    ChkDR ( DRM_UTL_StringToGuid ( &dstrGUID , &oGUID ) );

    /*
    ** Parse the CRL file parameter and load it
    */
    ChkDR( MakeDRMString ( &dstrCRLFile , argv[1] ) );
    FileHdl = Oem_File_Open(  NULL,
                             dstrCRLFile.pwszString ,
                             OEM_GENERIC_READ ,
                             OEM_FILE_SHARE_NONE ,
                             OEM_OPEN_EXISTING ,
                             OEM_ATTRIBUTE_NORMAL );

    if ( FileHdl == OEM_INVALID_HANDLE_VALUE )
    {
        ChkDR ( DRM_E_FILENOTFOUND );
    }

    /*
    ** Get the size of CRL file to allocate memory
    */
    ChkBOOL( Oem_File_GetSize( FileHdl , &dwCRLData ), DRM_E_FILEREADERROR );

    ChkMem( pData = ( DRM_BYTE* )Oem_MemAlloc( dwCRLData ) );
    ZEROMEM( pData , dwCRLData );
    /*
    ** Read the data
    */
    ChkBOOL( Oem_File_Read( FileHdl , pData , dwCRLData , &dwCRLData ), DRM_E_FILEREADERROR );
    /*
    ** Set the CRL data.
    */
    if ( dwCRLData > 0 )
    {
        ChkDR( DRM_RVK_SetCRL(  poCryptoContext,
                               &poAppContextInternal->oRevContext, 
                               &oGUID, 
                                pData, 
                                dwCRLData, 
                                poAppContextInternal->pbRevocationBuffer, 
                                poAppContextInternal->cbRevocationBuffer, 
                               &fUpdated ) );    
     }

ErrorExit:
    if ( FileHdl != OEM_INVALID_HANDLE_VALUE )
    {
        Oem_File_Close( FileHdl ) ;
    }
    SAFE_OEM_FREE( poCryptoContext );
    FREEDRMSTRING( dstrGUID );
    FREEDRMSTRING( dstrCRLFile );
    SAFE_OEM_FREE( pData );
    return dr;
}

EXIT_PKTEST_NAMESPACE_CODE
