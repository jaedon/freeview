/***************************************************************
*
* This file maps the power resource control to register writes.
* The templates are auto-generated by generate_chp_pwr.pl,
* but must be filled-in manually.
*
***************************************************************/

#include "bchp.h"
#include "bchp_priv.h"
#include "bdbg.h"
#include "bkni.h"

#include "bchp_clkgen.h"
#include "bchp_hdmi_rx_fe_0.h"
#include "bchp_rfm_sysclk.h"

BDBG_MODULE(BCHP_PWR_IMPL);

void BCHP_PWR_P_HW_SVD0_CORE_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SVD0_CORE_CLK: %s", activate?"on":"off"));

    /* SVD0 Core clock */
    mask = BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE_SVD_CORE_CLOCK_ENABLE_MASK;	 
    	   
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

void BCHP_PWR_P_HW_SVD0_CPU_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SVD0_CPU_CLK: %s", activate?"on":"off"));

    /* SVD0 CPU clock */
    mask = BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE_SVD_CPU_CLOCK_ENABLE_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);	
}

void BCHP_PWR_P_HW_SVD0_SCB_108_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SVD0_SCB_108_CLK: %s", activate?"on":"off"));

    /* SVD0 SCB and 108M clock */
    if(activate) {
	mask = BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE_SVD_108_CLOCK_ENABLE_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE, mask, mask);
	mask = BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE_SVD_SCB_CLOCK_ENABLE_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE, mask, mask);
	mask = BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE_SVD_ALTERNATE_SCB_CLOCK_ENABLE_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE, mask, mask);
    } else {
	mask = BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE_SVD_108_CLOCK_ENABLE_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE, mask, 0);
	mask = BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE_SVD_SCB_CLOCK_ENABLE_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE, mask, 0);
	mask = BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE_SVD_ALTERNATE_SCB_CLOCK_ENABLE_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SVD0_TOP_INST_CLOCK_ENABLE, mask, 0);
    }
}

void BCHP_PWR_P_HW_SVD0_PWR_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SVD0_PWR: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_SVD0_TOP_INST_POWER_SWITCH_MEMORY_SVD_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SVD0_TOP_INST_POWER_SWITCH_MEMORY, mask, 2);
	BKNI_Sleep(1);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SVD0_TOP_INST_POWER_SWITCH_MEMORY, mask, 0);
	BKNI_Sleep(1);
    } else {
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SVD0_TOP_INST_POWER_SWITCH_MEMORY, mask, mask);
    }
}

void BCHP_PWR_P_HW_AIO_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AIO: %s", activate?"on":"off"));
    
    mask = (BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_AIO_AIO_ALTERNATE_SCB_CLOCK_ENABLE_AIO_MASK |
	    BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_AIO_AIO_ALTERNATE2_216_CLOCK_ENABLE_AIO_MASK |
	    BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_AIO_AIO_ALTERNATE2_108_CLOCK_ENABLE_AIO_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_AIO, mask, activate?mask:0);
}

void BCHP_PWR_P_HW_AIO_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AIO_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_VEC_AIO_TOP_INST_POWER_SWITCH_MEMORY_AIO_AIO_POWER_SWITCH_MEMORY_AIO_MASK;

    if(activate) {
	   BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_POWER_SWITCH_MEMORY_AIO, mask, 2);
	   BKNI_Sleep(1);
	   BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_POWER_SWITCH_MEMORY_AIO, mask, 0);
	   BKNI_Sleep(1);
    } else {
	   BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_POWER_SWITCH_MEMORY_AIO, mask, mask);
    }
}

void BCHP_PWR_P_HW_RAAGA0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA0: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_RAAGA_DSP_TOP_INST_CLOCK_ENABLE_RAAGA_SCB_CLOCK_ENABLE_MASK |
	    BCHP_CLKGEN_RAAGA_DSP_TOP_INST_CLOCK_ENABLE_RAAGA_DSP_CLOCK_ENABLE_MASK |
	    BCHP_CLKGEN_RAAGA_DSP_TOP_INST_CLOCK_ENABLE_RAAGA_216_CLOCK_ENABLE_MASK |
	    BCHP_CLKGEN_RAAGA_DSP_TOP_INST_CLOCK_ENABLE_RAAGA_108_CLOCK_ENABLE_MASK);

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

void BCHP_PWR_P_HW_RAAGA0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA0_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_RAAGA_DSP_TOP_INST_POWER_SWITCH_MEMORY_RAAGA_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_INST_POWER_SWITCH_MEMORY, mask, 2);
	BKNI_Sleep(1);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_INST_POWER_SWITCH_MEMORY, mask, 0);
	BKNI_Sleep(1);
    } else {
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_INST_POWER_SWITCH_MEMORY, mask, mask);
    }    
}

void BCHP_PWR_P_HW_BVN_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_BVN: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE_BVN_SCB_CLOCK_ENABLE_MASK;
    
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

void BCHP_PWR_P_HW_BVN_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_BVN_108M: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE_BVN_216_CLOCK_ENABLE_MASK | 
	    BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE_BVN_108_CLOCK_ENABLE_MASK);
    
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

void BCHP_PWR_P_HW_BVN_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_BVN_SRAM: %s", activate?"on":"off"));
    
    mask = BCHP_CLKGEN_BVN_TOP_INST_POWER_SWITCH_MEMORY_BVN_POWER_SWITCH_MEMORY_MASK;

    if(activate) {  
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_INST_POWER_SWITCH_MEMORY, mask, 2);
	BKNI_Sleep(1);  
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_INST_POWER_SWITCH_MEMORY, mask, 0);
	BKNI_Sleep(1);
    } else {    
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_INST_POWER_SWITCH_MEMORY, mask, mask);
    }
}

void BCHP_PWR_P_HW_VDC_DAC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VDC_DAC: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_DISABLE_DISABLE_VEC_DACADC_CLOCK_MASK; 
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_DISABLE, mask, activate?0:mask);

    mask = BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_VEC_QDAC_216_CLOCK_ENABLE_VEC_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC, mask, activate?mask:0);
}

void BCHP_PWR_P_HW_VEC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VEC: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_VEC_324_CLOCK_ENABLE_VEC_MASK |
	    BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_VEC_216_CLOCK_ENABLE_VEC_MASK |
	    BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_VEC_ALTERNATE_216_CLOCK_ENABLE_VEC_MASK |
	    BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_VEC_SCB_CLOCK_ENABLE_VEC_MASK |
	    BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_VEC_108_CLOCK_ENABLE_VEC_MASK  );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC, mask, activate?mask:0);
}

void BCHP_PWR_P_HW_VEC_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VEC_SRAM: %s", activate?"on":"off"));
    
    mask = BCHP_CLKGEN_VEC_AIO_TOP_INST_POWER_SWITCH_MEMORY_VEC_VEC_POWER_SWITCH_MEMORY_VEC_MASK;

    if(activate) {
	   BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_POWER_SWITCH_MEMORY_VEC, mask, 2);
	   BKNI_Sleep(1);
	   BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_POWER_SWITCH_MEMORY_VEC, mask, 0);
	   BKNI_Sleep(1);
    } else {
	   BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_POWER_SWITCH_MEMORY_VEC, mask, mask);
    }
}

void BCHP_PWR_P_HW_VDC_656_OUT_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VDC_656_OUT: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_DISABLE_DISABLE_VEC_ITU656_0_CLOCK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_DISABLE, mask, activate?0:mask);
}

void BCHP_PWR_P_HW_XPT_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_108M: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE_XPT_108_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

void BCHP_PWR_P_HW_XPT_XMEMIF_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_XMEMIF: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE_XPT_216_CLOCK_ENABLE_MASK |
	    BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE_XPT_SCB_CLOCK_ENABLE_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

void BCHP_PWR_P_HW_XPT_RMX_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_RMX: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_81_CLOCK_MASK |
	    BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_54_CLOCK_MASK |
	    BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_40P5_CLOCK_MASK |
	    BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_27_CLOCK_MASK |
	    BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_20P25_CLOCK_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE, mask, activate?0:mask);
}

void BCHP_PWR_P_HW_XPT_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_CORE_XPT_INST_POWER_SWITCH_MEMORY_XPT_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_POWER_SWITCH_MEMORY, mask, 2);
	BKNI_Sleep(1);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_POWER_SWITCH_MEMORY, mask, 0);
	BKNI_Sleep(1);
    } else {
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_POWER_SWITCH_MEMORY, mask, mask);
    }
}

void BCHP_PWR_P_HW_XPT_WAKEUP_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_WAKEUP: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_PM_CLOCK_216_ALIVE_SEL_CLOCK_216_CG_XPT_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PM_CLOCK_216_ALIVE_SEL, mask, activate?mask:0);

    mask = BCHP_CLKGEN_PM_PLL_ALIVE_SEL_PLL_SYS0_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PM_PLL_ALIVE_SEL, mask, activate?mask:0);
}

void BCHP_PWR_P_HW_HDMI_TX_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_TX_CLK: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_DVP_HT_INST_ENABLE_DVPHT_CLK_VEC_ENABLE_MASK |
	    BCHP_CLKGEN_DVP_HT_INST_ENABLE_DVPHT_CLK_MAX_ENABLE_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_INST_ENABLE, mask, activate?mask:0);  
}

void BCHP_PWR_P_HW_HDMI_TX_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_TX_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_DVP_HT_INST_POWER_SWITCH_MEMORY_DVPHT_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_INST_POWER_SWITCH_MEMORY, mask, 2);
	BKNI_Sleep(1);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_INST_POWER_SWITCH_MEMORY, mask, 0);
	BKNI_Sleep(1);
    } else {
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_INST_POWER_SWITCH_MEMORY, mask, mask);
    }
}

void BCHP_PWR_P_HW_HDMI_TX_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_TX_108M: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_DVP_HT_INST_CLOCK_ENABLE_DVPHT_ALTERNATE_216_CLOCK_ENABLE_MASK |
	    BCHP_CLKGEN_DVP_HT_INST_CLOCK_ENABLE_DVPHT_216_CLOCK_ENABLE_MASK |	   
	    BCHP_CLKGEN_DVP_HT_INST_CLOCK_ENABLE_DVPHT_108_CLOCK_ENABLE_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

void BCHP_PWR_P_HW_HDMI_TX_CEC_Control(BCHP_Handle handle, bool activate)
{
    BDBG_MSG(("HW_HDMI_TX_CEC: %s", activate?"on":"off"));

    BSTD_UNUSED(handle);

#if 0 /* Edit the register read/modify/write below */
    BREG_AtomicUpdate32(handle->regHandle, BCHP_REGISTERNAME,
        BCHP_REGISTERNAME_HDMI_TX_CEC_MASK,
        activate ? 0 : 0xFFFFFFFFFF);
#endif
}

void BCHP_PWR_P_HW_HDMI_RX0_ALT_216M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_RX0_ALT_216M: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE_DVPHR_ALTERNATE_216_CLOCK_ENABLE_MASK |
	    BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE_DVPHR_ALTERNATE2_108_CLOCK_ENABLE_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

void BCHP_PWR_P_HW_HDMI_RX0_216M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_RX0_216M: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE_DVPHR_CLK_MAX_CLOCK_ENABLE_MASK |
	    BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE_DVPHR_216_CLOCK_ENABLE_MASK |
	    BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE_DVPHR_108_CLOCK_ENABLE_MASK);
    BREG_AtomicUpdate32(handle->regHandle,  BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE, mask, activate?mask:0);    
}

void BCHP_PWR_P_HW_HDMI_RX0_FE_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, val;

    BDBG_MSG(("HW_HDMI_RX0_FE: %s", activate?"on":"off"));

    val = BREG_Read32(handle->regHandle, BCHP_HDMI_RX_FE_0_RESET_CONTROL);
    mask = (BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_ADC_POWER_DOWN_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_BIAS_POWER_DOWN_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_CHANNEL_0_POWER_DOWN_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_CHANNEL_1_POWER_DOWN_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_CHANNEL_2_POWER_DOWN_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_CHANNEL_CLOCK_POWER_DOWN_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_PLL_POWER_DOWN_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_CHANNEL_0_RESET_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_CHANNEL_1_RESET_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_CHANNEL_2_RESET_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_PLL_RESET_MASK);
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_RX_FE_0_RESET_CONTROL, val);
}

void BCHP_PWR_P_HW_HDMI_RX0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_RX0_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_DVP_HR_INST_POWER_SWITCH_MEMORY_DVPHR_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_POWER_SWITCH_MEMORY, mask, 2);
	BKNI_Sleep(1);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_POWER_SWITCH_MEMORY, mask, 0);
	BKNI_Sleep(1);
    } else {
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_POWER_SWITCH_MEMORY, mask, mask);
    }
}

void BCHP_PWR_P_HW_HDMI_RX0_CEC_HOTPLUG_Control(BCHP_Handle handle, bool activate)
{
    BDBG_MSG(("HW_HDMI_RX0_CEC_HOTPLUG: %s", activate?"on":"off"));

    BSTD_UNUSED(handle);

#if 0 /* Edit the register read/modify/write below */
    BREG_AtomicUpdate32(handle->regHandle, BCHP_REGISTERNAME,
        BCHP_REGISTERNAME_HDMI_RX0_CEC_HOTPLUG_MASK,
        activate ? 0 : 0xFFFFFFFFFF);
#endif
}

void BCHP_PWR_P_HW_M2MC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_M2MC: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_GFX_M2MC_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE, mask, activate ? mask : 0);
}

void BCHP_PWR_P_HW_V3D_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_V3D: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_V3D_V3D_V3D_CLOCK_ENABLE_V3D_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_V3D, mask, activate ? mask : 0);    
}

void BCHP_PWR_P_HW_M2MC_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_M2MC_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_GRAPHICS_INST_POWER_SWITCH_MEMORY_GFX_POWER_SWITCH_MEMORY_MASK;
    if(activate) {
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_POWER_SWITCH_MEMORY, mask, 2);
	BKNI_Sleep(1);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_POWER_SWITCH_MEMORY, mask, 0);
	BKNI_Sleep(1);
    } else {
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_POWER_SWITCH_MEMORY, mask, mask);
    }
}

void BCHP_PWR_P_HW_GFX_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_GFX_108M: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_GFX_SCB_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_GFX_ALTERNATE_216_CLOCK_ENABLE_MASK |            
            BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_GFX_216_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_GFX_108_CLOCK_ENABLE_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE, mask, activate ? mask : 0);
}

void BCHP_PWR_P_HW_RFM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, val;
    BDBG_MSG(("HW_RFM: %s", activate?"on":"off"));
    
    if(activate) {
	/* 1 */
	mask = BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE_RFM_108_CLOCK_ENABLE_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE, mask, mask);		
    
	/* 2 */
	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
	val &= ~( BCHP_RFM_SYSCLK_CLKCTL_RFMCLK_OFF_MASK | 
			BCHP_RFM_SYSCLK_CLKCTL_BGCORE_OFF_MASK );
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

	/* 3 */
	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_DPLL_MISC1);
	val &= ~( BCHP_RFM_SYSCLK_DPLL_MISC1_ARESET_MASK |
		  BCHP_RFM_SYSCLK_DPLL_MISC1_DRESET_MASK |
		  BCHP_RFM_SYSCLK_DPLL_MISC1_REFCOMP_PWRDN_MASK |
		  BCHP_RFM_SYSCLK_DPLL_MISC1_PWRDN_MASK );
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_DPLL_MISC1, val);

	/* 4 */
	BKNI_Sleep(1); /* wait 50us for RFM PLL to lock */

	/* 5 */
	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
	val &= ~(BCHP_RFM_SYSCLK_CLKCTL_CLK_OFF_MASK);
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

	/* 6 */
	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL);
	val &= ~(BCHP_RFM_SYSCLK_DACCTL_DAC_PWRDN_MASK);
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL, val);	
    } else {
	/* 1 */
	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL);
	val |= BCHP_RFM_SYSCLK_DACCTL_DAC_PWRDN_MASK;
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL, val);

	/* 2 */
	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
	val |= BCHP_RFM_SYSCLK_CLKCTL_CLK_OFF_MASK;
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);
	
	/* 3 */
	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_DPLL_MISC1);
	val |= ( BCHP_RFM_SYSCLK_DPLL_MISC1_ARESET_MASK |
		 BCHP_RFM_SYSCLK_DPLL_MISC1_DRESET_MASK |
		 BCHP_RFM_SYSCLK_DPLL_MISC1_REFCOMP_PWRDN_MASK |
		 BCHP_RFM_SYSCLK_DPLL_MISC1_PWRDN_MASK );
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_DPLL_MISC1, val);
	
	/* 4 */
	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
	val |= ( BCHP_RFM_SYSCLK_CLKCTL_RFMCLK_OFF_MASK |
		       BCHP_RFM_SYSCLK_CLKCTL_BGCORE_OFF_MASK );
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

	/* 5 */
	mask = BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE_RFM_108_CLOCK_ENABLE_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE, mask, 0);
    }    
}

void BCHP_PWR_P_HW_DMA_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_DMA: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_SECTOP_INST_CLOCK_ENABLE_SEC_ALTERNATE_SCB_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SECTOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

void BCHP_PWR_P_HW_SCD0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SCD0: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_SYS_CTRL_INST_CLOCK_DISABLE_DISABLE_SC0_CLOCK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SYS_CTRL_INST_CLOCK_DISABLE, mask, activate?0:mask);
}

void BCHP_PWR_P_HW_SCD1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SCD1: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_SYS_CTRL_INST_CLOCK_DISABLE_DISABLE_SC1_CLOCK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SYS_CTRL_INST_CLOCK_DISABLE, mask, activate?0:mask);
}

void BCHP_PWR_P_HW_MDM_Control(BCHP_Handle handle, bool activate)
{
    BDBG_MSG(("HW_MDM: %s", activate?"on":"off"));

    BSTD_UNUSED(handle);

#if 0 /* Edit the register read/modify/write below */
    BREG_AtomicUpdate32(handle->regHandle, BCHP_REGISTERNAME,
        BCHP_REGISTERNAME_MDM_MASK,
        activate ? 0 : 0xFFFFFFFFFF);
#endif
}

void BCHP_PWR_P_HW_PLL_AVD_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_AVD_CH0: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0, mask, 0);
	mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0, mask, mask);
	mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }
}

void BCHP_PWR_P_HW_PLL_AVD_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_AVD_CH1: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1, mask, 0);
	mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1, mask, mask);
	mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1, mask, mask);
    }
}

void BCHP_PWR_P_HW_PLL_AVD_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_AVD: %s", activate?"on":"off"));

    if (activate) {
	uint32_t reg, cnt=50;
	/* power up PLL_AVD */
	mask = BCHP_CLKGEN_PLL_AVD_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_PWRDN , mask, 0);

	mask = (BCHP_CLKGEN_PLL_AVD_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_AVD_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_AVD_PLL_LOCK_STATUS, LOCK))
		break;
	}

	/* Release clock isolation */
	mask = BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_AVD_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, mask, mask);

	if(!cnt)
	    BDBG_ERR(("AVD PLL Lock Timeout"));
    } else {
	mask = BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_AVD_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, mask, 0);
	/* power down PLL_AVD */
	mask = (BCHP_CLKGEN_PLL_AVD_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_AVD_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_RESET, mask, mask);

	mask = BCHP_CLKGEN_PLL_AVD_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_PWRDN , mask, mask);
    }
}

void BCHP_PWR_P_HW_AUD_PLL0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AUD_PLL0: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;
	mask = BCHP_CLKGEN_PLL_AUDIO0_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_PWRDN, mask, 0);

	mask = (BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_AUDIO0_PLL_LOCK_STATUS, LOCK))
		break;
	}
	if(!cnt)
	    BDBG_ERR(("Audio0 PLL Lock Timeout"));
    } else {
	mask = (BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET, mask, mask);

	mask = BCHP_CLKGEN_PLL_AUDIO0_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_PWRDN, mask, mask);
    }
}

void BCHP_PWR_P_HW_AUD_PLL1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AUD_PLL1: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;
	mask = BCHP_CLKGEN_PLL_AUDIO1_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_PWRDN, mask, 0);

	mask = (BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_AUDIO1_PLL_LOCK_STATUS, LOCK))
		break;
	}
	if(!cnt)
	    BDBG_ERR(("Audio1 PLL Lock Timeout"));
    } else {
	mask = (BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET, mask, mask);

	mask = BCHP_CLKGEN_PLL_AUDIO1_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_PWRDN, mask, mask);
    }
}

void BCHP_PWR_P_HW_PLL_VCXO_PLL0_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL0_CH0: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0, mask, 0);
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0, mask, mask);
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }
}

void BCHP_PWR_P_HW_PLL_VCXO_PLL0_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL0_CH2: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2, mask, 0);
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2, mask, mask);
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2, mask, mask);
    }
}

void BCHP_PWR_P_HW_PLL_VCXO_PLL0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL0: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_PWRDN, mask, 0);

	mask = (BCHP_CLKGEN_PLL_VCXO0_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_VCXO0_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_RESET, mask, 0);


	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_VCXO0_PLL_LOCK_STATUS, LOCK))
		break;
	}
	if(!cnt)
	    BDBG_ERR(("VCXO 0 PLL Lock Timeout"));
    } else {
	mask = (BCHP_CLKGEN_PLL_VCXO0_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_VCXO0_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_RESET, mask, mask);

	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_PWRDN, mask, mask);
    }
}

void BCHP_PWR_P_HW_PLL_VCXO_PLL1_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL1_CH0: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0, mask, 0);
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0, mask, mask);
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }
}

void BCHP_PWR_P_HW_PLL_VCXO_PLL1_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL1_CH2: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2, mask, 0);
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2, mask, mask);
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2, mask, mask);
    }
}

void BCHP_PWR_P_HW_PLL_VCXO_PLL1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL1: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_PWRDN, mask, 0);

	mask = (BCHP_CLKGEN_PLL_VCXO1_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_VCXO1_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_VCXO1_PLL_LOCK_STATUS, LOCK))
		break;
	}
	if(!cnt)
	    BDBG_ERR(("VCXO 1 PLL Lock Timeout"));
    } else {
	mask = (BCHP_CLKGEN_PLL_VCXO1_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_VCXO1_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_RESET, mask, mask);

	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_PWRDN, mask, mask);
    }
}

void BCHP_PWR_P_HW_PLL_SCD0_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_SCD0_CH0: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0, mask, 0);
	mask = BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0, mask, mask);
	mask = BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }
}

void BCHP_PWR_P_HW_PLL_SCD0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_SCD0: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;
	mask = BCHP_CLKGEN_PLL_SC0_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_PWRDN, mask, 0);

	mask = (BCHP_CLKGEN_PLL_SC0_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_SC0_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_SC0_PLL_LOCK_STATUS, LOCK))
		break;
	}	

	if(!cnt)
	    BDBG_ERR(("SmartCard PLL Lock Timeout"));
    } else {	
	mask = (BCHP_CLKGEN_PLL_SC0_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_SC0_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_RESET, mask, mask);

	mask = BCHP_CLKGEN_PLL_SC0_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_PWRDN, mask, mask);
    }
}

void BCHP_PWR_P_HW_PLL_SCD1_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_SCD1_CH0: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0, mask, 0);
	mask = BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0, mask, mask);
	mask = BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }
}

void BCHP_PWR_P_HW_PLL_SCD1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_SCD1: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;
	mask = BCHP_CLKGEN_PLL_SC1_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_PWRDN, mask, 0);

	mask = (BCHP_CLKGEN_PLL_SC1_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_SC1_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_SC1_PLL_LOCK_STATUS, LOCK))
		break;
	}	

	if(!cnt)
	    BDBG_ERR(("SmartCard PLL Lock Timeout"));
    } else {	
	mask = (BCHP_CLKGEN_PLL_SC1_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_SC1_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_RESET, mask, mask);

	mask = BCHP_CLKGEN_PLL_SC1_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_PWRDN, mask, mask);
    }
}

void BCHP_PWR_P_HW_PLL_RAAGA_PLL_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_RAAGA_PLL_CH0: %s", activate?"on":"off"));

    if(activate) {
	mask = (BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0, mask, 0);
	mask = (BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
	mask = (BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0, mask, mask);
	mask = (BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }

}

void BCHP_PWR_P_HW_PLL_RAAGA_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_RAAGA: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;

	mask = BCHP_CLKGEN_PLL_RAAGA_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_PWRDN, mask, 0);

	mask = (BCHP_CLKGEN_PLL_RAAGA_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_RAAGA_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_RAAGA_PLL_LOCK_STATUS, LOCK))
		break;
	}

	/* Release clock isolation */
	mask = BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_RAAGA_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, mask, mask);

	if(!cnt)
	    BDBG_ERR(("RAAGA PLL Lock Timeout"));
    }
	else {
	mask = BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_RAAGA_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, mask, 0);

	mask = (BCHP_CLKGEN_PLL_RAAGA_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_RAAGA_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_RESET, mask, mask);

	mask = BCHP_CLKGEN_PLL_RAAGA_PLL_PWRDN_PWRDN_PLL_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_PWRDN, mask, mask);
    }
}

