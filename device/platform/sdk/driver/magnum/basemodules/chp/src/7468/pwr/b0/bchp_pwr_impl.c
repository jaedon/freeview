/***************************************************************
*
* This file maps the power resource control to register writes.
* The templates are auto-generated by generate_chp_pwr.pl,
* but must be filled-in manually.
*
***************************************************************/

#include "bchp.h"
#include "bchp_priv.h"
#include "bdbg.h"
#include "bkni.h"

#include "bchp_clk.h"
#include "bchp_avd_rgr_0.h"
#include "bchp_aio_misc.h"
#include "bchp_vcxo_ctl_misc.h"
#include "bchp_hdmi_tx_phy.h"

BDBG_MODULE(BCHP_PWR_IMPL);

void BCHP_PWR_P_HW_AVD0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, val;
    BDBG_MSG(("HW_AVD0: %s", activate?"on":"off"));

    if (activate) {        
        mask = BCHP_CLK_SYS_PLL_1_3_DIS_CH_MASK | BCHP_CLK_SYS_PLL_1_3_EN_CMLBUF_MASK;
        val = 0 | BCHP_CLK_SYS_PLL_1_3_EN_CMLBUF_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_SYS_PLL_1_3, mask, val);

        /* Wait for PLLs to lock */
        BKNI_Sleep(1);

        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_108M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, 0);

        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_216M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, 0);

        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_AVD0_PROG_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, 0);

        mask = BCHP_AVD_RGR_0_SW_RESET_0_disable_avd_clk_rcvr_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_AVD_RGR_0_SW_RESET_0, mask, 0);
    }
    else {
        mask = BCHP_AVD_RGR_0_SW_RESET_0_disable_avd_clk_rcvr_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_AVD_RGR_0_SW_RESET_0, mask, mask);
        
        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_AVD0_PROG_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, mask);

        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_216M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, mask);

        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_108M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, mask);

        mask = BCHP_CLK_SYS_PLL_1_3_DIS_CH_MASK | BCHP_CLK_SYS_PLL_1_3_EN_CMLBUF_MASK;
        val = BCHP_CLK_SYS_PLL_1_3_DIS_CH_MASK | 0;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_SYS_PLL_1_3, mask, val);
    }    
}

void BCHP_PWR_P_HW_RAP_OPEN_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val;
    BDBG_MSG(("HW_RAP_OPEN: %s", activate?"on":"off"));

    if (activate) {
        /* SYS PLL 1 channel 5 */
        val = BREG_Read32(handle->regHandle, BCHP_CLK_SYS_PLL_1_5);
        val &= ~BCHP_CLK_SYS_PLL_1_5_DIS_CH_MASK;
        val |= BCHP_CLK_SYS_PLL_1_5_EN_CMLBUF_MASK;
        BREG_Write32(handle->regHandle, BCHP_CLK_SYS_PLL_1_5, val);
        BKNI_Sleep(1);
        
        /* AIO clocks */
        val = BCHP_CLK_RPT_AIO_CLK_PM_CTRL_DIS_108M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_RPT_AIO_CLK_PM_CTRL, val, 0);
      
        val = BCHP_CLK_RPT_AIO_CLK_PM_CTRL_DIS_216M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_RPT_AIO_CLK_PM_CTRL, val, 0);

        val = BCHP_CLK_RPT_AIO_CLK_PM_CTRL_DIS_RPT_PROG_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_RPT_AIO_CLK_PM_CTRL, val, 0);
    }
    else {       
        /* AIO clocks */
        val = BCHP_CLK_RPT_AIO_CLK_PM_CTRL_DIS_RPT_PROG_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_RPT_AIO_CLK_PM_CTRL, val, val);

        val = BCHP_CLK_RPT_AIO_CLK_PM_CTRL_DIS_216M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_RPT_AIO_CLK_PM_CTRL, val, val);

        val = BCHP_CLK_RPT_AIO_CLK_PM_CTRL_DIS_108M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_RPT_AIO_CLK_PM_CTRL, val, val);

        /* SYS PLL 1 channel 5 */
        val = BREG_Read32(handle->regHandle, BCHP_CLK_SYS_PLL_1_5);
        val |= BCHP_CLK_SYS_PLL_1_5_DIS_CH_MASK;
        val &= ~ BCHP_CLK_SYS_PLL_1_5_EN_CMLBUF_MASK;
        BREG_Write32(handle->regHandle, BCHP_CLK_SYS_PLL_1_5, val);
    }
}

void BCHP_PWR_P_HW_RAP_START_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val;
    BDBG_MSG(("HW_RAP_START: %s", activate?"on":"off"));

    /* AC1 PLL (VCXO_CTL_MISC_AC1_CTRL) and AC1 PLL channel 1 ((VCXO_CTL_MISC_AC1_PM_DIS_CHL_1)) 
       are clock sources for both audio and smartcard */

    if (activate) {
        /* AC1 PLL channel 3 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_2);
        val &= ~BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_2_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_2, val);

        /* AC1 PLL channel 2 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_2);
        val &= ~BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_2_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_2, val);
       
        /* AC0 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL);
        val &= ~(BCHP_VCXO_CTL_MISC_AC0_CTRL_RESET_MASK |
                 BCHP_VCXO_CTL_MISC_AC0_CTRL_POWERDOWN_MASK);
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL, val);

        /* MISC_PWRDOWN */
        val = BREG_Read32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN);
        val &= ~BCHP_AIO_MISC_PWRDOWN_DAC0_MASK;
        val |= BCHP_AIO_MISC_PWRDOWN_PWR_AUTO_MASK;
        val &= ~BCHP_AIO_MISC_PWRDOWN_REF_PD_MASK;
        val &= ~BCHP_AIO_MISC_PWRDOWN_D2C_PD_MASK;
        val &= ~BCHP_AIO_MISC_PWRDOWN_VAC2_PD_MASK;
        val &= ~BCHP_AIO_MISC_PWRDOWN_VAC1_PD_MASK;
        BREG_Write32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN, val);
    }
    else {
        /* MISC_PWRDOWN */
        val = BREG_Read32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN);
        val |= BCHP_AIO_MISC_PWRDOWN_DAC0_MASK;
        val &= ~BCHP_AIO_MISC_PWRDOWN_PWR_AUTO_MASK;
        val |= BCHP_AIO_MISC_PWRDOWN_REF_PD_MASK;
        val |= BCHP_AIO_MISC_PWRDOWN_D2C_PD_MASK;
        val |= BCHP_AIO_MISC_PWRDOWN_VAC2_PD_MASK;
        val |= BCHP_AIO_MISC_PWRDOWN_VAC1_PD_MASK;
        BREG_Write32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN, val);

        /* AC0 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL);
        val |= BCHP_VCXO_CTL_MISC_AC0_CTRL_RESET_MASK |
               BCHP_VCXO_CTL_MISC_AC0_CTRL_POWERDOWN_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL, val);

        /* AC1 PLL channel 2 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_2);
        val |= BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_2_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_2, val);

        /* AC1 PLL channel 3 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_2);
        val |= BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_2_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_2, val);
    }
}

void BCHP_PWR_P_HW_BVN_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_BVN: %s", activate?"on":"off"));

    mask = BCHP_CLK_BVN_TOP_CLK_PM_CTRL_DIS_216M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_BVN_TOP_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

void BCHP_PWR_P_HW_BVN_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_BVN: %s", activate?"on":"off"));

    mask = BCHP_CLK_BVN_TOP_CLK_PM_CTRL_DIS_108M_CLK_MASK;  
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_BVN_TOP_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

void BCHP_PWR_P_HW_VDC_DAC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_VDC_DAC: %s", activate?"on":"off"));

    mask = BCHP_CLK_QDAC_CLK_PM_CTRL_DIS_216M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_QDAC_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

void BCHP_PWR_P_HW_VDC_VEC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_VDC_VEC: %s", activate?"on":"off"));

    mask = BCHP_CLK_VEC_CLK_PM_CTRL_DIS_VEC_DAC_216M_CLK_MASK |
        BCHP_CLK_VEC_CLK_PM_CTRL_DIS_108M_CLK_MASK |
        BCHP_CLK_VEC_CLK_PM_CTRL_DIS_216M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_VEC_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

void BCHP_PWR_P_HW_XPT_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_XPT_108M: %s", activate?"on":"off"));  

    if (activate) {
        mask = BCHP_CLK_SYS_PLL_0_2_DIS_CH_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_SYS_PLL_0_2, mask, activate ? 0 : mask);
        BKNI_Sleep(1);
  
        mask = BCHP_CLK_XPT_CLK_PM_CTRL_DIS_108M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_XPT_CLK_PM_CTRL, mask, activate ? 0 : mask);
    }
    else {
        mask = BCHP_CLK_XPT_CLK_PM_CTRL_DIS_108M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_XPT_CLK_PM_CTRL, mask, activate ? 0 : mask);
        
        mask = BCHP_CLK_SYS_PLL_0_2_DIS_CH_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_SYS_PLL_0_2, mask, activate ? 0 : mask);
    }
}

void BCHP_PWR_P_HW_XPT_XMEMIF_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_XPT_XMEMIF: %s", activate?"on":"off"));   

    if (!activate) {
        /* a short delay (~500us) is needed before a power down of the XMEMIF clock */
        BKNI_Sleep(1);
    }

    /* the 216M clock controls XMEMIF */
    mask = BCHP_CLK_XPT_CLK_PM_CTRL_DIS_216M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_XPT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    /* these are RMX clocks but 7468 doesn't have RMX */
    mask = BCHP_CLK_XPT_CLK_PM_CTRL_DIS_XPT_20P25M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_XPT_CLK_PM_CTRL, mask, activate ? 0 : mask);
    mask = BCHP_CLK_XPT_CLK_PM_CTRL_DIS_XPT_27M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_XPT_CLK_PM_CTRL, mask, activate ? 0 : mask);
    mask = BCHP_CLK_XPT_CLK_PM_CTRL_DIS_XPT_40P5M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_XPT_CLK_PM_CTRL, mask, activate ? 0 : mask);
    mask = BCHP_CLK_XPT_CLK_PM_CTRL_DIS_XPT_54M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_XPT_CLK_PM_CTRL, mask, activate ? 0 : mask);
    mask = BCHP_CLK_XPT_CLK_PM_CTRL_DIS_XPT_81M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_XPT_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

void BCHP_PWR_P_HW_HDMI_TX_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, val;
    BDBG_MSG(("HW_HDMI_TX_TMDS: %s", activate?"on":"off"));
    
    /* SYS PLL */
    mask = BCHP_CLK_SYS_PLL_1_6_DIS_CH_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_SYS_PLL_1_6, mask, activate ? 0 : mask);

    /* 3 clocks needed for TMDS */
    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_216M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_HDMI_MAX_PROG_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);   

    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_VEC_216M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    /* power on/off analog core except CEC */
    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL);
    mask = (BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_PLL_PWRDN_MASK |
            BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_REF_COMP_PWRDN_MASK |
            BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_PWRDN_BG_MASK);
    if (activate) { val &= ~mask; }
    else { val |= mask; }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL, val);

    /* random bit block */
    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_0);
    mask = BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_0_RND_PWRDN_MASK;
    if (activate) { val &= ~mask; }
    else { val |= mask; }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_0, val);

    /* rate managers */
    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_1);
    mask = BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_1_I_PWR_DN_CH1_MASK;
    if (activate) { val &= ~mask; }
    else { val |= mask; }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_1, val);

    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_2);
    mask = BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_2_I_PWRDN_CH2_MASK;
    if (activate) { val &= ~mask; }
    else { val |= mask; }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_2, val);

    /* reset bits must always be cleared */
    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL);
    val &= ~(BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_A_RESET_MASK |
             BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_D_RESET_MASK);
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL, val);
}

void BCHP_PWR_P_HW_HDMI_TX_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_HDMI_TX_108M: %s", activate?"on":"off"));

    /* 108M clock needed for register R/W */
    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_2ND_108M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_108M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

void BCHP_PWR_P_HW_HDMI_TX_CEC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, val;
    BDBG_MSG(("HW_HDMI_TX_CEC_HOTPLUG: %s", activate?"on":"off"));

    /* 2 clocks needed for CEC and hotplug interrupts */
    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_HDMI_PM_27M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_HDMI_27M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    /* CEC bit in analog core and refamp */
    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL);
    mask = (BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_PWRDN_CEC_MASK |
        BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_PWRDN_REFAMP_MASK);
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL, val);
}

void BCHP_PWR_P_HW_M2MC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_M2MC: %s", activate?"on":"off"));

    mask = (BCHP_CLK_M2MC_CLK_PM_CTRL_DIS_216M_CLK_MASK | 
           BCHP_CLK_M2MC_CLK_PM_CTRL_DIS_108M_CLK_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_M2MC_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

void BCHP_PWR_P_HW_SCD_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_SCD: %s", activate?"on":"off"));

    if (activate) {      
        mask = BCHP_CLK_MISC_SMARTCARD_CLOCK_0_SOURCE_SEL_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_MISC, mask, 0);
    }
    else {
        mask = BCHP_CLK_MISC_SMARTCARD_CLOCK_0_SOURCE_SEL_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_MISC, mask, mask);
    }
}

void BCHP_PWR_P_HW_PLL_AC1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val;
    BDBG_MSG(("HW_PLL_AC1: %s", activate?"on":"off"));

    /* VC0/1 powers audio PLLs, smartcard and VEC-656 (VEC-656 is not present on 7468/7208)
       implicit dependency: AC0/1 -> VC0/1 

       we could refactor like this, but it's unneeded for now:

       RAP_START -> HW_ACX_PLL
       {RAP_START, SMARTCARD} -> HW_AC1_PLL
       {HW_RAP_ACX_PLL, HW_RAP_AC1_PLL} -> HW_VC0_PLL */

    if (activate) {
        /* power up VC */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_CTRL);
        val &= ~BCHP_VCXO_CTL_MISC_VC0_CTRL_DRESET_MASK;
        val &= ~BCHP_VCXO_CTL_MISC_VC0_CTRL_ARESET_MASK;
        val &= ~BCHP_VCXO_CTL_MISC_VC0_CTRL_POWERDOWN_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_CTRL, val);
       
        /* power up VC channels */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_1);
        val &= ~BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_1_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_1, val);

        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_2);
        val &= ~BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_2_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_2, val);

        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3);
        val &= ~BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3, val);

        /* start VC output clock */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_CLOCK_ENA_1);
        val |= BCHP_VCXO_CTL_MISC_VC0_PM_CLOCK_ENA_1_CLOCK_ENA_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_CLOCK_ENA_1, val);
        BKNI_Sleep(1);

        /* AC1 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_CTRL);
        val &= ~(BCHP_VCXO_CTL_MISC_AC1_CTRL_RESET_MASK |
                 BCHP_VCXO_CTL_MISC_AC1_CTRL_POWERDOWN_MASK);
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_CTRL, val);

        /* AC1 PLL channel 1 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_1);
        val &= ~BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_1_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_1, val);
    }
    else {       
        /* AC1 PLL channel 1 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_1);
        val |= BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_1_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_PM_DIS_CHL_1, val);

        /* AC1 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_CTRL);
        val |= BCHP_VCXO_CTL_MISC_AC1_CTRL_RESET_MASK |
               BCHP_VCXO_CTL_MISC_AC1_CTRL_POWERDOWN_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_CTRL, val);

        /* stop VC output clock */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_CLOCK_ENA_1);
        val &= ~BCHP_VCXO_CTL_MISC_VC0_PM_CLOCK_ENA_1_CLOCK_ENA_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_CLOCK_ENA_1, val);
        
        /* power down VC channels */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_1);
        val |= BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_1_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_1, val);

        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_2);
        val |= BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_2_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_2, val);

        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3);
        val |= BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3, val);

        /* power down VC */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_CTRL);
        val |= BCHP_VCXO_CTL_MISC_VC0_CTRL_DRESET_MASK;
        val |= BCHP_VCXO_CTL_MISC_VC0_CTRL_ARESET_MASK;
        val |= BCHP_VCXO_CTL_MISC_VC0_CTRL_POWERDOWN_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_CTRL, val);        
    }
}

