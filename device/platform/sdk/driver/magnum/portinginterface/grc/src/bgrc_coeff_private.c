/***************************************************************************
 *     Copyright (c) 2003-2012, Broadcom Corporation
 *     All Rights Reserved
 *     Confidential Property of Broadcom Corporation
 *
 *  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
 *  AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
 *  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
 *
 * $brcm_Workfile: bgrc_coeff_private.c $
 * $brcm_Revision: Hydra_Software_Devel/27 $
 * $brcm_Date: 1/6/12 1:30p $
 *
 * Module Description:
 *
 * Revision History:
 *
 * $brcm_Log: /magnum/portinginterface/grc/7435/bgrc_coeff_private.c $
 * 
 * Hydra_Software_Devel/27   1/6/12 1:30p nissen
 * SW7435-13 : Fixed support for 7435 A0.
 * 
 * Hydra_Software_Devel/26   12/15/11 6:44p nissen
 * SW7435-13 : Added support for 7435 A0.
 * 
 * Hydra_Software_Devel/25   6/9/09 4:13p nissen
 * PR 52504: Changed global and static variables to constants.
 * 
 * Hydra_Software_Devel/24   4/7/09 2:45p nissen
 * PR 52976: Added support for 7635/7630 and future chips using RDB
 * defines.
 * 
 * Hydra_Software_Devel/23   2/4/09 10:52a jrubio
 * PR51629: add more 7336 support
 * 
 * Hydra_Software_Devel/22   12/3/08 7:04p nissen
 * PR 47763: Added support for 7420.
 * 
 * Hydra_Software_Devel/21   7/30/08 8:21p nissen
 * PR 33687: Added support for the 7601.
 * 
 * Hydra_Software_Devel/20   4/4/08 12:02p nissen
 * PR 39460: Added support for the 3556.
 * 
 * Hydra_Software_Devel/19   2/8/08 2:13p nissen
 * PR 38945: Added support for the 3548.
 * 
 * Hydra_Software_Devel/18   2/7/08 12:50p nissen
 * PR 24618: Added sharper anti-flutter filter coefficient table.
 * 
 * Hydra_Software_Devel/17   12/4/07 5:25p nissen
 * PR 36878: Added support for the 7335.
 * 
 * Hydra_Software_Devel/16   9/19/07 11:30a nissen
 * PR 34538: Added support for building for the 7325.
 * 
 * Hydra_Software_Devel/15   9/18/07 1:37p nissen
 * PR 34852: Added support for building for the 3573.
 * 
 * Hydra_Software_Devel/14   5/2/07 11:43a nissen
 * PR 29724: Added support for 7405 A0 including new MacroBlock strip
 * width setting.
 * 
 * Hydra_Software_Devel/13   11/15/06 11:45a nissen
 * PR 25668: Added support for 7403.
 * 
 * Hydra_Software_Devel/12   9/29/06 10:09a nissen
 * PR 24618: Added support for second blurryer anti-flutter filter
 * coefficient table.
 * 
 * Hydra_Software_Devel/11   9/8/06 3:58p nissen
 * PR 23517: Added support for 7440.
 * 
 * Hydra_Software_Devel/10   8/17/06 11:42a nissen
 * PR 21940: Fixed filter table support for 7118.
 * 
 * Hydra_Software_Devel/9   8/17/06 11:30a nissen
 * PR 23179: Added support for building and running on the 3563.
 * 
 * Hydra_Software_Devel/8   4/20/06 9:57a nissen
 * PR 20352: Adjusted sharp filter coefficients for 7400 and 7401.
 * 
 * Hydra_Software_Devel/7   4/13/06 3:37p nissen
 * PR 20352: Added support for all filter coefficients for 7400 and 7401.
 * 
 * Hydra_Software_Devel/6   2/21/06 4:40p nissen
 * PR 19553: Added support for point sample and bilinear filtering for
 * 7400.
 * 
 * Hydra_Software_Devel/5   2/1/06 5:36p nissen
 * PR 19084: Added support for building for the 7400 A0.
 * 
 * Hydra_Software_Devel/4   1/12/06 6:08p nissen
 * PR 18761: Added support for BCHP_VER macro.
 * 
 * Hydra_Software_Devel/3   10/25/05 1:41p nissen
 * PR 17518: Added new 6-tap 2-phase filter coefficient tables for 7401
 * (just sharp for now).
 * 
 * Hydra_Software_Devel/2   2/24/05 1:39p nissen
 * PR 14207: Added bstd.h include.
 * 
 * Hydra_Software_Devel/1   9/23/04 2:29p nissen
 * PR 12729: Filter coefficient tables.
 * 
 ***************************************************************************/

#include "bstd.h"
#include "bstd_defs.h"
#include "berr.h"
#include "bkni.h"

#if (BCHP_CHIP==7435)
#include "bchp_m2mc.h"
#include "bchp_m2mc1.h"
#else
#include "bchp_m2mc.h"
#endif

#include "bgrc.h"
#include "bgrc_private.h"

/***************************************************************************/
#define BGRC_M2MC_ENUM(val)   M2MC_##val

/***************************************************************************/
/* POINT SAMPLE FILTER COEFFICENT TABLE                                    */
/* Single closest pixel (1 tap) is used, resulting in no filtering.        */
/* Generates blocky scales.                                                */
/***************************************************************************/
const uint32_t BGRC_P_FIRCOEFF_POINTSAMPLE[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0000 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0100 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x0000 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0100 ) 
	}
#else
	{ 0x00000000, 0x00000000, 0x10000000, 0x00000000 },
	{ 0x00000000, 0x00000000, 0x10000000, 0x00000000 },
	{ 0x00000000, 0x00000000, 0x10000000, 0x00000000 },
	{ 0x00000000, 0x00000000, 0x10000000, 0x00000000 },
	{ 0x00000000, 0x00000000, 0x10000000, 0x00000000 },
	{ 0x00000000, 0x00000000, 0x10000000, 0x00000000 },
	{ 0x00000000, 0x00000000, 0x10000000, 0x00000000 },
	{ 0x00000000, 0x00000000, 0x10000000, 0x00000000 }
#endif
};

/***************************************************************************/
/* BILINEAR FILTER COEFFICENT TABLE                                        */
/* Closest pixel is filtered with its neighbor (2 taps) using coefficients */
/* derived from the pixel position. Generates slightly blurry up-scales.   */
/***************************************************************************/
const uint32_t BGRC_P_FIRCOEFF_BILINEAR[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0000 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0100 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x0000 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0080 ) 
	}
#else
	{ 0x00000000, 0x00000000, 0x10000000, 0x00000000 }, 
	{ 0x00000000, 0x00000200, 0x0E000000, 0x00000000 }, 
	{ 0x00000000, 0x00000400, 0x0C000000, 0x00000000 }, 
	{ 0x00000000, 0x00000600, 0x0A000000, 0x00000000 }, 
	{ 0x00000000, 0x00000800, 0x08000000, 0x00000000 }, 
	{ 0x00000000, 0x00000A00, 0x06000000, 0x00000000 }, 
	{ 0x00000000, 0x00000C00, 0x04000000, 0x00000000 }, 
	{ 0x00000000, 0x00000E00, 0x02000000, 0x00000000 }
#endif
};

/***************************************************************************/
/* BLURRY FILTER COEFFICENT TABLE                                          */
/* Closest pixel is filtered with two closet neighbors (3-4 tap).          */
/* Similar to bilinear except blurryer.                                    */
/***************************************************************************/
const uint32_t BGRC_P_FIRCOEFF_BLURRY_3to1[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0055 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0056 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x002b ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0055 ) 
	}
#else
	{ 0x00000000, 0x00000554, 0x05580554, 0x00000000 }, 
	{ 0x00000000, 0x00AC0554, 0x055404AC, 0x00000000 }, 
	{ 0x00000000, 0x01540554, 0x05580400, 0x00000000 }, 
	{ 0x00000000, 0x02000554, 0x05580354, 0x00000000 }, 
	{ 0x00000000, 0x02AC0554, 0x055402AC, 0x00000000 }, 
	{ 0x00000000, 0x03540554, 0x05580200, 0x00000000 }, 
	{ 0x00000000, 0x04000554, 0x05580154, 0x00000000 }, 
	{ 0x00000000, 0x04AC0554, 0x055400AC, 0x00000000 }
#endif
};

/***************************************************************************/
/* ANISOTROPIC FILTER COEFFICENT TABLES                                    */
/* Closest pixel is area filtered with its neighbors (up to 8 taps).       */
/* This filter is the same as bilinear when up-scaling.                    */
/* When down-scaling, the amount of taps used depends on the scale factor. */
/***************************************************************************/
const uint32_t BGRC_P_FIRCOEFF_ANISOTROPIC_1to1[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0000 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0100 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x0000 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0080 ) 
	}
#else
	{ 0x00000000, 0x00000000, 0x10000000, 0x00000000 }, 
	{ 0x00000000, 0x00000200, 0x0E000000, 0x00000000 }, 
	{ 0x00000000, 0x00000400, 0x0C000000, 0x00000000 }, 
	{ 0x00000000, 0x00000600, 0x0A000000, 0x00000000 }, 
	{ 0x00000000, 0x00000800, 0x08000000, 0x00000000 }, 
	{ 0x00000000, 0x00000A00, 0x06000000, 0x00000000 }, 
	{ 0x00000000, 0x00000C00, 0x04000000, 0x00000000 }, 
	{ 0x00000000, 0x00000E00, 0x02000000, 0x00000000 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_ANISOTROPIC_2to1[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0000 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0100 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x0000 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0080 ) 
	}
#else
	{ 0x00000000, 0x00000000, 0x08000800, 0x00000000 }, 
	{ 0x00000000, 0x00000100, 0x08000700, 0x00000000 }, 
	{ 0x00000000, 0x00000200, 0x08000600, 0x00000000 }, 
	{ 0x00000000, 0x00000300, 0x08000500, 0x00000000 }, 
	{ 0x00000000, 0x00000400, 0x08000400, 0x00000000 }, 
	{ 0x00000000, 0x00000500, 0x08000300, 0x00000000 }, 
	{ 0x00000000, 0x00000600, 0x08000200, 0x00000000 }, 
	{ 0x00000000, 0x00000700, 0x08000100, 0x00000000 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_ANISOTROPIC_3to1[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0055 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0056 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x002b ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0055 ) 
	}
#else
	{ 0x00000000, 0x00000554, 0x05580554, 0x00000000 }, 
	{ 0x00000000, 0x00AC0554, 0x055404AC, 0x00000000 }, 
	{ 0x00000000, 0x01540554, 0x05580400, 0x00000000 }, 
	{ 0x00000000, 0x02000554, 0x05580354, 0x00000000 }, 
	{ 0x00000000, 0x02AC0554, 0x055402AC, 0x00000000 }, 
	{ 0x00000000, 0x03540554, 0x05580200, 0x00000000 }, 
	{ 0x00000000, 0x04000554, 0x05580154, 0x00000000 }, 
	{ 0x00000000, 0x04AC0554, 0x055400AC, 0x00000000 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_ANISOTROPIC_4to1[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0055 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0056 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x002b ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0055 ) 
	}
#else
	{ 0x00000000, 0x00000400, 0x04000400, 0x04000000 }, 
	{ 0x00000000, 0x00800400, 0x04000400, 0x03800000 }, 
	{ 0x00000000, 0x01000400, 0x04000400, 0x03000000 }, 
	{ 0x00000000, 0x01800400, 0x04000400, 0x02800000 }, 
	{ 0x00000000, 0x02000400, 0x04000400, 0x02000000 }, 
	{ 0x00000000, 0x02800400, 0x04000400, 0x01800000 }, 
	{ 0x00000000, 0x03000400, 0x04000400, 0x01000000 }, 
	{ 0x00000000, 0x03800400, 0x04000400, 0x00800000 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_ANISOTROPIC_5to1[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0033 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0033 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0034 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x001a ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x0033 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0033 ) 
	}
#else
	{ 0x00000000, 0x03340334, 0x03340334, 0x03300000 }, 
	{ 0x00000068, 0x03340334, 0x03340334, 0x02C80000 }, 
	{ 0x000000CC, 0x03340334, 0x03340334, 0x02640000 }, 
	{ 0x00000134, 0x03340334, 0x03340334, 0x01FC0000 }, 
	{ 0x00000198, 0x03340334, 0x03340334, 0x01980000 }, 
	{ 0x00000200, 0x03340334, 0x03340334, 0x01340000 }, 
	{ 0x00000264, 0x03340334, 0x03340334, 0x00CC0000 }, 
	{ 0x000002C8, 0x03340334, 0x03340334, 0x00680000 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_ANISOTROPIC_6to1[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0033 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0033 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0034 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x002a ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x002b ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x002b ) 
	}
#else
	{ 0x00000000, 0x02A802AC, 0x02AC02AC, 0x02AC02A8 }, 
	{ 0x00000054, 0x02AC02AC, 0x02AC02AC, 0x02AC0250 }, 
	{ 0x000000A8, 0x02AC02AC, 0x02AC02AC, 0x02AC01FC }, 
	{ 0x000000FC, 0x02AC02AC, 0x02AC02AC, 0x02AC01A8 }, 
	{ 0x00000154, 0x02AC02AC, 0x02AC02AC, 0x02AC0150 }, 
	{ 0x000001A8, 0x02AC02AC, 0x02AC02AC, 0x02AC00FC }, 
	{ 0x000001FC, 0x02AC02AC, 0x02AC02AC, 0x02AC00A8 }, 
	{ 0x00000250, 0x02AC02AC, 0x02AC02AC, 0x02AC0054 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_ANISOTROPIC_7to1[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0033 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0033 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0034 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x002a ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x002b ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x002b ) 
	}
#else
	{ 0x00000248, 0x0248024C, 0x024C0248, 0x02480248 }, 
	{ 0x00480248, 0x0248024C, 0x024C0248, 0x02480200 }, 
	{ 0x00940248, 0x02480248, 0x024C0248, 0x024801B8 }, 
	{ 0x00DC0248, 0x0248024C, 0x024C0248, 0x0248016C }, 
	{ 0x01240248, 0x0248024C, 0x024C0248, 0x02480124 }, 
	{ 0x016C0248, 0x0248024C, 0x024C0248, 0x024800DC }, 
	{ 0x01B80248, 0x02480248, 0x024C0248, 0x02480094 }, 
	{ 0x02000248, 0x0248024C, 0x024C0248, 0x02480048 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_ANISOTROPIC_8to1[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0033 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0033 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0034 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x002a ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x002b ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x002b ) 
	}
#else
	{ 0x02000200, 0x02000200, 0x02000200, 0x02000200 }, 
	{ 0x02000200, 0x02000200, 0x02000200, 0x02000200 }, 
	{ 0x02000200, 0x02000200, 0x02000200, 0x02000200 }, 
	{ 0x02000200, 0x02000200, 0x02000200, 0x02000200 }, 
	{ 0x02000200, 0x02000200, 0x02000200, 0x02000200 }, 
	{ 0x02000200, 0x02000200, 0x02000200, 0x02000200 }, 
	{ 0x02000200, 0x02000200, 0x02000200, 0x02000200 }, 
	{ 0x02000200, 0x02000200, 0x02000200, 0x02000200 }
#endif
};

/***************************************************************************/
/* SHARP FILTER COEFFICENT TABLES                                          */
/* Closet pixel is area filtered with its neighbors using filter           */
/* coefficents generated with a sin wave formula (all 8 taps). Each scale  */
/* factor has its own table of filter coeffs up to a scale of 8 to 9.      */
/* Up-scales larger than 8 to 9 use a 1 to N coefficent table.             */
/***************************************************************************/
const uint32_t BGRC_P_FIRCOEFF_SHARP_8to9[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0xffff ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0102 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0002 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0xffeb ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0093 ) 
	}
#else
	{ 0x00003FB4, 0x00EC3E54, 0x12143E54, 0x00EC3FB4 }, 
	{ 0x00183FC0, 0x00840040, 0x11583D40, 0x010C3FC0 }, 
	{ 0x00103FE0, 0x3FD402EC, 0x0F983CF4, 0x00F43FD0 }, 
	{ 0x00080014, 0x3EF40628, 0x0CE43D48, 0x00B03FE8 }, 
	{ 0x3FFC0060, 0x3E08099C, 0x099C3E08, 0x00603FFC }, 
	{ 0x3FE800B0, 0x3D480CE4, 0x06283EF4, 0x00140008 }, 
	{ 0x3FD000F4, 0x3CF40F98, 0x02EC3FD4, 0x3FE00010 }, 
	{ 0x3FC0010C, 0x3D401158, 0x00400084, 0x3FC00018 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_SHARP_8to8[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0000 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0100 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0002 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0xffeb ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0093 ) 
	}
#else
	{ 0x00000000, 0x00000000, 0x10000000, 0x00000000 }, 
	{ 0x3FF80024, 0x3F6C01F8, 0x0F943E94, 0x006C3FE8 }, 
	{ 0x3FEC0054, 0x3EC00468, 0x0E503DC0, 0x00AC3FDC }, 
	{ 0x3FE40088, 0x3E1C071C, 0x0C503D74, 0x00C03FD8 }, 
	{ 0x3FDC00B0, 0x3DA009D4, 0x09D43DA0, 0x00B03FDC }, 
	{ 0x3FD800C0, 0x3D740C50, 0x071C3E1C, 0x00883FE4 }, 
	{ 0x3FDC00AC, 0x3DC00E50, 0x04683EC0, 0x00543FEC }, 
	{ 0x3FE8006C, 0x3E940F94, 0x01F83F6C, 0x00243FF8 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_SHARP_8to7[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0xfffc ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0014 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x00e0 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0002 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0xffee ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0090 ) 
	}
#else
	{ 0x0000004C, 0x3F1401A8, 0x0DEC01A8, 0x3F14004C }, 
	{ 0x3FE80064, 0x3EA00378, 0x0DB4002C, 0x3F880030 }, 
	{ 0x3FEC0074, 0x3E3C0580, 0x0CD03F14, 0x3FE80018 }, 
	{ 0x3FF00074, 0x3E040798, 0x0B683E60, 0x00300004 }, 
	{ 0x3FFC0060, 0x3E08099C, 0x099C3E08, 0x00603FFC }, 
	{ 0x00040030, 0x3E600B68, 0x07983E04, 0x00743FF0 }, 
	{ 0x00183FE8, 0x3F140CD0, 0x05803E3C, 0x00743FEC }, 
	{ 0x00303F88, 0x002C0DB4, 0x03783EA0, 0x00643FE8 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_SHARP_8to6[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0xfff9 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0026 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x00c2 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0xffff ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0xfff7 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x008a ) 
	}
#else
	{ 0x00000038, 0x3EB40314, 0x0C000314, 0x3EB40038 }, 
	{ 0x0008002C, 0x3E8C048C, 0x0BC801C0, 0x3EF00038 }, 
	{ 0x00100018, 0x3E880618, 0x0B2C009C, 0x3F380034 }, 
	{ 0x00183FF4, 0x3EB4079C, 0x0A3C3FBC, 0x3F80002C }, 
	{ 0x00203FC0, 0x3F180908, 0x09083F18, 0x3FC00020 }, 
	{ 0x002C3F80, 0x3FBC0A3C, 0x079C3EB4, 0x3FF40018 }, 
	{ 0x00343F38, 0x009C0B2C, 0x06183E88, 0x00180010 }, 
	{ 0x00383EF0, 0x01C00BC8, 0x048C3E8C, 0x002C0008 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_SHARP_8to5[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0xfffb ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0033 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x00a4 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0xfffd ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x0003 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0080 ) 
	}
#else
	{ 0x00003FE4, 0x3F140408, 0x0A040408, 0x3F143FE4 }, 
	{ 0x00183FC8, 0x3F380518, 0x09D402F8, 0x3F0C3FF8 }, 
	{ 0x00183FA4, 0x3F80062C, 0x09780204, 0x3F180004 }, 
	{ 0x00183F7C, 0x3FE80734, 0x08E4012C, 0x3F34000C }, 
	{ 0x00143F58, 0x00740820, 0x08200074, 0x3F580014 }, 
	{ 0x000C3F34, 0x012C08E4, 0x07343FE8, 0x3F7C0018 }, 
	{ 0x00043F18, 0x02040978, 0x062C3F80, 0x3FA40018 }, 
	{ 0x3FF83F0C, 0x02F809D4, 0x05183F38, 0x3FC80018 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_SHARP_8to4[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x003b ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x008a )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0xfffe ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x0010 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0072 ) 
	}
#else
	{ 0x00003FB0, 0x00000454, 0x07F40454, 0x00003FB0 }, 
	{ 0x3FFC3FA0, 0x004C050C, 0x07E403A0, 0x3FC83FC0 }, 
	{ 0x3FF83F90, 0x00AC05BC, 0x07B002F0, 0x3FA43FD0 }, 
	{ 0x3FF03F88, 0x0120065C, 0x075C0244, 0x3F903FDC }, 
	{ 0x3FE83F84, 0x01AC06E8, 0x06E801AC, 0x3F843FE8 }, 
	{ 0x3FDC3F90, 0x0244075C, 0x065C0120, 0x3F883FF0 }, 
	{ 0x3FD03FA4, 0x02F007B0, 0x05BC00AC, 0x3F903FF8 }, 
	{ 0x3FC03FC8, 0x03A007E4, 0x050C004C, 0x3FA03FFC }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_SHARP_8to3[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0006 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x003f ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0076 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x001a ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0066 ) 
	}
#else
	{ 0x00003FE4, 0x00F0041C, 0x0620041C, 0x00F03FE4 }, 
	{ 0x3FE83FE8, 0x0140048C, 0x062003B4, 0x00B03FE0 }, 
	{ 0x3FE83FF8, 0x019804F0, 0x06040340, 0x00743FE0 }, 
	{ 0x3FE40004, 0x01FC054C, 0x05D402D0, 0x00483FE0 }, 
	{ 0x3FE40020, 0x02640598, 0x05980264, 0x00203FE4 }, 
	{ 0x3FE00048, 0x02D005D4, 0x054C01FC, 0x00043FE4 }, 
	{ 0x3FE00074, 0x03400604, 0x04F00198, 0x3FF83FE8 }, 
	{ 0x3FE000B0, 0x03B40620, 0x048C0140, 0x3FE83FE8 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_SHARP_8to2[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x000b ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0040 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x006a )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0004 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x0020 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x005c ) 
	}
#else
	{ 0x00000048, 0x019803B8, 0x04D403B8, 0x01980048 }, 
	{ 0x00040060, 0x01D403F4, 0x04CC0378, 0x015C0034 }, 
	{ 0x0008007C, 0x0218042C, 0x04C00334, 0x01240024 }, 
	{ 0x000C009C, 0x0260045C, 0x04A802EC, 0x00F00018 }, 
	{ 0x001000C4, 0x02A40488, 0x048802A4, 0x00C40010 }, 
	{ 0x001800F0, 0x02EC04A8, 0x045C0260, 0x009C000C }, 
	{ 0x00240124, 0x033404C0, 0x042C0218, 0x007C0008 }, 
	{ 0x0034015C, 0x037804CC, 0x03F401D4, 0x00600004 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_SHARP_8to1[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x000f ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0041 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0060 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0006 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x0024 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0056 ) 
	}
#else
	{ 0x0000009C, 0x01E8036C, 0x041C036C, 0x01E8009C }, 
	{ 0x003800B8, 0x02140388, 0x04080338, 0x01B00080 }, 
	{ 0x003800DC, 0x024803A8, 0x0400030C, 0x0180006C }, 
	{ 0x00400100, 0x027C03C8, 0x03F402DC, 0x01540058 }, 
	{ 0x004C0128, 0x02AC03E0, 0x03E002AC, 0x0128004C }, 
	{ 0x00580154, 0x02DC03F4, 0x03C8027C, 0x01000040 }, 
	{ 0x006C0180, 0x030C0400, 0x03A80248, 0x00DC0038 }, 
	{ 0x008001B0, 0x03380408, 0x03880214, 0x00B80038 }
#endif
};

/***************************************************************************/
/* SHARP & SHARPER (1toN) FILTER COEFFICENT TABLES                         */
/* These tables are used when with sharp or sharper filtering and          */
/* up-scaling greater than 8 to 9.                                         */
/***************************************************************************/
const uint32_t BGRC_P_FIRCOEFF_SHARP_1toN[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0xfffa ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x001f ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x00ce )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0xfff3 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x008d ) 
	}
#else
	{ 0x00000030, 0x3EE00320, 0x0CE001A0, 0x3F200030 }, 
	{ 0x00000030, 0x3EA004D0, 0x0C600070, 0x3F700020 }, 
	{ 0x00000030, 0x3E8006A0, 0x0B603F80, 0x3FB00020 }, 
	{ 0x00100010, 0x3E900860, 0x0A103EE0, 0x3FF00010 }, 
	{ 0x00103FF0, 0x3EE00A10, 0x08603E90, 0x00100010 }, 
	{ 0x00203FB0, 0x3F800B60, 0x06A03E80, 0x00300000 }, 
	{ 0x00203F70, 0x00700C60, 0x04D03EA0, 0x00300000 }, 
	{ 0x00303F20, 0x01A00CE0, 0x03203EE0, 0x00300000 }
#endif
};

const uint32_t BGRC_P_FIRCOEFF_SHARPER_1toN[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0000 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0100 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0003 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0xffeb ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0092 ) 
	}
#else
	{ 0x00000000, 0x00000000, 0x10000000, 0x00000000 }, 
	{ 0x3FD00060, 0x3F300220, 0x0FC03E60, 0x00B03FB0 }, 
	{ 0x3FA000D0, 0x3E5004B0, 0x0EA03D50, 0x01303F70 }, 
	{ 0x3F700130, 0x3D800780, 0x0CC03CE0, 0x01703F50 }, 
	{ 0x3F600170, 0x3CF00A40, 0x0A403CF0, 0x01703F60 }, 
	{ 0x3F500170, 0x3CE00CC0, 0x07803D80, 0x01303F70 }, 
	{ 0x3F700130, 0x3D500EA0, 0x04B03E50, 0x00D03FA0 }, 
	{ 0x3FB000B0, 0x3E600FC0, 0x02203F30, 0x00603FD0 }
#endif
};

/***************************************************************************/
/* ANTI-FLUTTER FILTER COEFFICENT TABLES                                   */
/* Non-scale filter meant to elimiate flickering problems related to       */
/* interlaced displays.                                                    */
/***************************************************************************/
#if 1
/* Most amount of softening */
const uint32_t BGRC_P_FIRCOEFF_ANTIFLUTTER[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0040 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0080 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x0000 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0080 ) 
	}
#else
	{ 0x00000000, 0x00000400, 0x08000400, 0x00000000 }, 
	{ 0x00000000, 0x00000400, 0x08000400, 0x00000000 }, 
	{ 0x00000000, 0x00000400, 0x08000400, 0x00000000 }, 
	{ 0x00000000, 0x00000400, 0x08000400, 0x00000000 }, 
	{ 0x00000000, 0x00000400, 0x08000400, 0x00000000 }, 
	{ 0x00000000, 0x00000400, 0x08000400, 0x00000000 }, 
	{ 0x00000000, 0x00000400, 0x08000400, 0x00000000 }, 
	{ 0x00000000, 0x00000400, 0x08000400, 0x00000000 }
#endif
};
#endif

#if 0
/* Medium amount of softening */
const uint32_t BGRC_P_FIRCOEFF_ANTIFLUTTER[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
	{ 0x00000000, 0x00000800, 0x08000000, 0x00000000 }, 
	{ 0x00000000, 0x00000800, 0x08000000, 0x00000000 }, 
	{ 0x00000000, 0x00000800, 0x08000000, 0x00000000 }, 
	{ 0x00000000, 0x00000800, 0x08000000, 0x00000000 }, 
	{ 0x00000000, 0x00000800, 0x08000000, 0x00000000 }, 
	{ 0x00000000, 0x00000800, 0x08000000, 0x00000000 }, 
	{ 0x00000000, 0x00000800, 0x08000000, 0x00000000 }, 
	{ 0x00000000, 0x00000800, 0x08000000, 0x00000000 }
};
#endif

#if 0
/* Small amount of softening */
const uint32_t BGRC_P_FIRCOEFF_ANTIFLUTTER[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
	{ 0x00000000, 0x00000300, 0x0A000300, 0x00000000 }, 
	{ 0x00000000, 0x00000300, 0x0A000300, 0x00000000 }, 
	{ 0x00000000, 0x00000300, 0x0A000300, 0x00000000 }, 
	{ 0x00000000, 0x00000300, 0x0A000300, 0x00000000 }, 
	{ 0x00000000, 0x00000300, 0x0A000300, 0x00000000 }, 
	{ 0x00000000, 0x00000300, 0x0A000300, 0x00000000 }, 
	{ 0x00000000, 0x00000300, 0x0A000300, 0x00000000 }, 
	{ 0x00000000, 0x00000300, 0x0A000300, 0x00000000 }
};
#endif

#if 0
/* Least amount of softening */
const uint32_t BGRC_P_FIRCOEFF_ANTIFLUTTER[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }, 
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }, 
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }, 
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }, 
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }, 
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }, 
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }, 
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }
};
#endif

/***************************************************************************/
/* ANTI-FLUTTER SCALE FILTER COEFFICENT TABLES                             */
/* Scale filter meant to elimiate flickering problems related to           */
/* interlaced displays.                                                    */
/***************************************************************************/
#if 1
/* This filter can be used to do anti-fluttering for pictures that contain 
   very thin/fine (e.g., 1-pixel thick) horizontal lines. Examples are web 
   browser window images, graphics pictures with thin horizontal lines. 
   The picture will be softened vertically. */
const uint32_t BGRC_P_FIRCOEFF_ANTIFLUTTERSCALE[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0040 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0080 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x0018 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0068 ) 
	}
#else
	{ 0x00000000, 0x003004C0, 0x07B00360, 0x00000000 }, 
	{ 0x00000000, 0x00900560, 0x076002B0, 0x00000000 }, 
	{ 0x00000000, 0x00F00600, 0x07100200, 0x00000000 }, 
	{ 0x00000000, 0x01780688, 0x06880170, 0x00000000 }, 
	{ 0x00000000, 0x02000710, 0x060000F0, 0x00000000 }, 
	{ 0x00000000, 0x02B00760, 0x05600090, 0x00000000 }, 
	{ 0x00000000, 0x036007B0, 0x04C00030, 0x00000000 }, 
	{ 0x00000000, 0x01C80638, 0x063801C8, 0x00000000 }
#endif
};
#endif

#if 0
/* This filter has less softening effect compared to the above one. It can 
   be used to do anti-fluttering for pictures that contain thin horizontal 
   line graphics pictures. */
const uint32_t BGRC_P_FIRCOEFF_ANTIFLUTTERSCALE[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
	{ 0x00000000, 0x3FD004B0, 0x089002F0, 0x00000000 }, 
	{ 0x00000000, 0x00200588, 0x08280230, 0x00000000 }, 
	{ 0x00000000, 0x00700660, 0x07C00170, 0x00000000 }, 
	{ 0x00000000, 0x00F00710, 0x07100070, 0x00000000 }, 
	{ 0x00000000, 0x017007C0, 0x06600070, 0x00000000 }, 
	{ 0x00000000, 0x02300828, 0x05880020, 0x00000000 }, 
	{ 0x00000000, 0x02F00890, 0x04B03FD0, 0x00000000 }, 
	{ 0x00000000, 0x016006A0, 0x06A00160, 0x00000000 }
};
#endif

#if 0
/* This filter has least softening effect compared to the above two. It can 
   be used to do anti-fluttering for pictures that contain TEXT or natural 
   scenes if they need anti-fluttering at all. */
const uint32_t BGRC_P_FIRCOEFF_ANTIFLUTTERSCALE[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
	{ 0x00000000, 0x3E800480, 0x0B3001D0, 0x00000000 }, 
	{ 0x00000000, 0x3E980600, 0x0A9800D0, 0x00000000 }, 
	{ 0x00000000, 0x3EB00780, 0x0A003FD0, 0x00000000 }, 
	{ 0x00000000, 0x3F4008C0, 0x08C03F40, 0x00000000 }, 
	{ 0x00000000, 0x3FD00A00, 0x07803EB0, 0x00000000 }, 
	{ 0x00000000, 0x00D00A98, 0x06003E98, 0x00000000 }, 
	{ 0x00000000, 0x01D00B30, 0x04803E80, 0x00000000 }, 
	{ 0x00000000, 0x002807D8, 0x07D80028, 0x00000000 }
};
#endif

#if 0
/* This filter is similar to the first one specified and can be used to do 
   anti-fluttering for pictures that contain very thin/fine horizontal lines.
   It softens the picture vertically. It gives the uniform gray for an input 
   picture consisting of alternative black/white 1-pixel wide horizontal 
   lines when the aspect ratio is kept. */
const uint32_t BGRC_P_FIRCOEFF_ANTIFLUTTERSCALE[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
	{ 0x00000000, 0x00000400, 0x08000400, 0x00000000 }, 
	{ 0x00000000, 0x004004B8, 0x07B80350, 0x00000000 }, 
	{ 0x00000000, 0x00800570, 0x077002A0, 0x00000000 }, 
	{ 0x00000000, 0x00F80600, 0x07000208, 0x00000000 }, 
	{ 0x00000000, 0x01700690, 0x06900170, 0x00000000 }, 
	{ 0x00000000, 0x02080700, 0x060000F8, 0x00000000 }, 
	{ 0x00000000, 0x02A00770, 0x05700080, 0x00000000 }, 
	{ 0x00000000, 0x015005B8, 0x06B80240, 0x00000000 }
};
#endif

/***************************************************************************/
/* ANTI-FLUTTER BLURRY FILTER COEFFICENT TABLES                            */
/* Non-scale filter meant to elimiate flickering problems related to       */
/* interlaced displays. Blurryer than previous anti-flutter table.         */
/***************************************************************************/
const uint32_t BGRC_P_FIRCOEFF_ANTIFLUTTERBLURRY[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0050 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x0060 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x0020 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0060 ) 
	}
#else
	{ 0x00000000, 0x00000500, 0x06000500, 0x00000000 }, 
	{ 0x00000000, 0x00000500, 0x06000500, 0x00000000 }, 
	{ 0x00000000, 0x00000500, 0x06000500, 0x00000000 }, 
	{ 0x00000000, 0x00000500, 0x06000500, 0x00000000 }, 
	{ 0x00000000, 0x00000500, 0x06000500, 0x00000000 }, 
	{ 0x00000000, 0x00000500, 0x06000500, 0x00000000 }, 
	{ 0x00000000, 0x00000500, 0x06000500, 0x00000000 }, 
	{ 0x00000000, 0x00000500, 0x06000500, 0x00000000 }
#endif
};

/***************************************************************************/
/* ANTI-FLUTTER SHARP FILTER COEFFICENT TABLES                             */
/* Non-scale filter meant to elimiate flickering problems related to       */
/* interlaced displays. Sharper than previous anti-flutter table.          */
/***************************************************************************/
const uint32_t BGRC_P_FIRCOEFF_ANTIFLUTTERSHARP[BGRC_P_FIR_PHASE_COUNT][BGRC_P_FIR_TAP_COUNT / 2] = 
{
#if defined(BCHP_M2MC_HORIZ_FIR_COEFF_PHASE0_2_COEFF_2_SHIFT)
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_01), COEFF_1, 0x0028 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE0_2),  COEFF_2, 0x00B0 )
	},
	{
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_0, 0x0000 ) |
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_01), COEFF_1, 0x0000 ),
		BCHP_FIELD_DATA( BGRC_M2MC_ENUM(HORIZ_FIR_COEFF_PHASE1_2),  COEFF_2, 0x0080 ) 
	}
#else
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }, 
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }, 
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }, 
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }, 
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }, 
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }, 
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }, 
	{ 0x00000000, 0x00000280, 0x0B000280, 0x00000000 }
#endif
};

/* End of File */
