/***************************************************************************
 *     Copyright (c) 2003-2012, Broadcom Corporation
 *     All Rights Reserved
 *     Confidential Property of Broadcom Corporation
 *
 *  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
 *  AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
 *  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
 *
 * $brcm_Workfile: bhdr_repeater.c $
 * $brcm_Revision: Hydra_Software_Devel/6 $
 * $brcm_Date: 7/5/12 1:18p $
 *
 * $brcm_Log: /magnum/portinginterface/hdr/3548/bhdr_repeater.c $
 * 
 * Hydra_Software_Devel/6   7/5/12 1:18p vle
 * SW7425-1988: Merge to mainline
 * 
 * Hydra_Software_Devel/SW7425-1988/4   6/29/12 4:05p vle
 * SW7425-1988: Fix comments
 * 
 * Hydra_Software_Devel/SW7425-1988/3   6/29/12 3:43p vle
 * SW7425-1988: Add device count and KSV to KSV list if attached device is
 * a repeater. This resolve compliance test 3C-II-01 and 3C-II-06.
 * 
 * Hydra_Software_Devel/SW7425-1988/2   6/26/12 7:07p vle
 * SW7425-1988: Reset Rx HDCP register to prevent incorrect report of
 * BStatus and BCaps.
 * 
 * Hydra_Software_Devel/SW7425-1988/1   6/22/12 5:43p vle
 * SW7425-1988: update the MAX_DEV_EXCEED and MAX_CASCADE_EXCEED error
 * from the hdmi_output to the hdmi_input. This is to resolve the
 * incorrect status update in 7425 repeater test 3C-II-08 and 3C-II-09.
 * The tests still fail due to some other errors.
 * 
 * Hydra_Software_Devel/5   6/20/12 5:39p vle
 * SW7425-1988: Add delay after each KVS key load to fix HDCP compliance
 * test 3B-01 failure.
 * 
 * Hydra_Software_Devel/4   5/1/12 5:37p rgreen
 * SW7425-1988:Clear BSTATUS when initializing repeaster mode
 * 
 * Hydra_Software_Devel/3   8/3/11 2:09p rgreen
 * SW7425-833: Update to use BDBG_OBJECT_ASSERT
 * 
 * Hydra_Software_Devel/2   4/18/11 11:57a rgreen
 * SW7422-186:  Merge HDMI HDCP Repeater Support
 * 
 * Hydra_Software_Devel/SW7422-186/2   4/13/11 1:55p rgreen
 * SW7422-186: Remove Request Repeater KSV FIFO callback
 * 
 * Hydra_Software_Devel/SW7422-186/1   4/11/11 2:54p rgreen
 * SW7422-186: Add HDCP Repeater Support
 * 
 * Hydra_Software_Devel/1   2/26/09 8:56p rgreen
 * PR51307: Add compilation option for HDCP Repeater support
 *
 ***************************************************************************/

#if BDBG_DEBUG_BUILD
#if defined LINUX && !defined __KERNEL__
#include "ctype.h"
#endif
#endif

#include "bchp_dvp_hr.h"

#include "bhdr.h"
#include "bhdr_priv.h"



BDBG_MODULE(BHDR_HDCP_REPEATER) ;

/******************************************************************************
Summary:
I2C Rx HDCP Registers 
*******************************************************************************/

/* Rx Bksv value (Read Only) */
#define BHDR_HDCP_RX_BKSV0			0x00
#define BHDR_HDCP_RX_BKSV1			0x01
#define BHDR_HDCP_RX_BKSV2			0x02
#define BHDR_HDCP_RX_BKSV3			0x03
#define BHDR_HDCP_RX_BKSV4			0x04


/* Rx Link verification values (Read Only) */
#define BHDR_HDCP_RX_RI0		 0x08
#define BHDR_HDCP_RX_RI1		 0x09
#define BHDR_HDCP_RX_PJ             0x0A


/* Tx Aksv value (Write Only) */
#define BHDR_HDCP_RX_AKSV0			0x10
#define BHDR_HDCP_RX_AKSV1			0x11
#define BHDR_HDCP_RX_AKSV2			0x12
#define BHDR_HDCP_RX_AKSV3			0x13
#define BHDR_HDCP_RX_AKSV4			0x14


/*  Rx HDCP Enable HDCP 1.1 features (Write Only) */
#define BHDR_HDCP_RX_AINFO             0x15
#define BHDR_HDCP_RX_ENABLE_1_1_FEATURES 0x02


/* Session Random Number (An) value generated by the Tx (Write Only) */
#define BHDR_HDCP_RX_AN0			0x18
#define BHDR_HDCP_RX_AN1			0x19
#define BHDR_HDCP_RX_AN2			0x1a
#define BHDR_HDCP_RX_AN3			0x1b
#define BHDR_HDCP_RX_AN4			0x1c
#define BHDR_HDCP_RX_AN5			0x1d
#define BHDR_HDCP_RX_AN6			0x1e
#define BHDR_HDCP_RX_AN7			0x1f


/* HDCP Repeater Registers */

/* HDCP Repeater SHA-1 Hash value V' */
#define BHDR_HDCP_REPEATER_SHA1_V_H0 0x20
#define BHDR_HDCP_REPEATER_SHA1_V_H1 0x24
#define BHDR_HDCP_REPEATER_SHA1_V_H2 0x28
#define BHDR_HDCP_REPEATER_SHA1_V_H3 0x2c
#define BHDR_HDCP_REPEATER_SHA1_V_H4 0x30
#define BHDR_HDCP_REPEATER_KSV_FIFO 0x43 /* 2 Bytes */

#define BHDR_HDCP_REPEATER_MAX_DEVICE_COUNT 127
#define BHDR_HDCP_REPEATER_MAX_DEPTH 7


/* Rx Capabilities and Status Registers (Read Only) */
#define BHDR_HDCP_RX_BCAPS          0x40 

#define BHDR_HDCP_RX_BSTATUS        0x41 /* 2 Bytes */
#define BDHM_HDCP_RX_BSTATUS_DEPTH        0x0700
#define BHDR_HDCP_RX_BSTATUS_DEVICE_COUNT 0x007F



/******************************************************************************
BERR_Code BHDR_HDCP_P_EnableRepeater
Summary: Enable the HDMI Rx Core as a Repeater
*******************************************************************************/
BERR_Code  BHDR_HDCP_P_EnableRepeater(BHDR_Handle hHDR) 
{
   	BREG_Handle hRegister  ;
	uint32_t Register ;
	uint32_t ulOffset  ;
	uint16_t BStatus =0 ;
	
	BDBG_OBJECT_ASSERT(hHDR, BHDR_P_Handle) ;
	hRegister = hHDR->hRegister ;
	ulOffset = hHDR->ulOffset ;
	
	Register = BREG_Read32(hRegister, BCHP_HDMI_RX_0_HDCP_CONFIG + ulOffset) ;	
	Register |= BCHP_MASK(HDMI_RX_0_HDCP_CONFIG, RDB_REPEATER) ;
	Register |= BCHP_MASK(HDMI_RX_0_HDCP_CONFIG, DISABLE_OTP_REPEATER) ;
	BREG_Write32(hRegister, BCHP_HDMI_RX_0_HDCP_CONFIG + ulOffset, Register) ;

	/* clear HDCP BStatus */
	BHDR_WriteRxI2cRegisterSpace(hHDR,  BAVC_HDMI_HDCP_RX_BSTATUS, (uint8_t *) &BStatus, 2) ;
	

	return BERR_SUCCESS ;
}



/******************************************************************************
Summary: Install Downstream Info 
*******************************************************************************/
void BHDR_HDCP_LoadRepeaterKsvFifo(
	BHDR_Handle hHDR, 
	BHDR_HDCP_RepeaterDownStreamInfo *pDownstreamInfo, 
	uint8_t *pKsvs) 
{
	BERR_Code rc ;
	BREG_Handle hRegister ;
	uint32_t Register ;
	uint32_t ulOffset ;
	uint32_t   BksvRegisterValue ;
	
	uint8_t i, j ;
	uint8_t   
		Ksv[BAVC_HDMI_HDCP_KSV_LENGTH] ;
	uint16_t BStatus ;
	uint8_t BCaps ;
	uint8_t downstreamDevices, downstreamDepth;

	BDBG_ENTER(BHDR_HDCP_LoadRepeaterKsvFifo) ;		
	BDBG_OBJECT_ASSERT(hHDR, BHDR_P_Handle) ;

	BDBG_ASSERT(pDownstreamInfo) ;

	hRegister = hHDR->hRegister ;
	ulOffset = hHDR->ulOffset ;

	/* Update HDCP Rx BStatus */
	rc = BHDR_ReadRxI2cRegisterSpace(hHDR, BAVC_HDMI_HDCP_RX_BSTATUS, 
		(uint8_t *) &BStatus, 2) ;
#if BHDR_CONFIG_DEBUG_HDCP_KEY_LOADING
	BDBG_WRN(("Current BStatus: %x", BStatus)) ;
#endif

	/* add 1 to device count and depth if attached device is a repeater */
	downstreamDevices = pDownstreamInfo->devices + (uint8_t) pDownstreamInfo->isRepeater;
	downstreamDepth = pDownstreamInfo->depth + (uint8_t) pDownstreamInfo->isRepeater;

	BStatus &= ~ BAVC_HDMI_HDCP_RX_BSTATUS_DEPTH ;
	BStatus &= ~ BAVC_HDMI_HDCP_RX_BSTATUS_DEVICE_COUNT ;

	BStatus |= downstreamDepth << 8 ;
	BStatus |= downstreamDevices;

	if ((downstreamDevices > BAVC_HDMI_HDCP_REPEATER_MAX_DEVICE_COUNT)
		|| pDownstreamInfo->maxDevicesExceeded)
	{
		BDBG_ERR(("Downstream Devices of %d exceeds max of %d", 
			downstreamDevices, BAVC_HDMI_HDCP_REPEATER_MAX_DEVICE_COUNT)) ;
		BStatus |= BAVC_HDMI_HDCP_RxStatus_eMaxDevicesExceeded;
	}
		
	if ((downstreamDepth > BAVC_HDMI_HDCP_REPEATER_MAX_DEPTH)
		|| pDownstreamInfo->maxDepthExceeded)
	{
		BDBG_ERR(("Downstream Depth Level of %d exceeds %d", 
			downstreamDepth, BAVC_HDMI_HDCP_REPEATER_MAX_DEPTH)) ;
		BStatus |= BAVC_HDMI_HDCP_RxStatus_eMaxRepeatersExceeded ;
	}

#if BHDR_CONFIG_DEBUG_HDCP_KEY_LOADING
	BDBG_WRN(("Depth: %d Device Count: %d; Updated BStatus: %x", 
		downstreamDepth, downstreamDevices, BStatus)) ;
#endif

	rc = BHDR_WriteRxI2cRegisterSpace(hHDR,  BAVC_HDMI_HDCP_RX_BSTATUS, 
		(uint8_t *) &BStatus, 2) ;

	Register = BREG_Read32(hRegister, BCHP_HDMI_RX_0_HDCP_MON_RX_BSTATUS__BCAPS + ulOffset) ;
	BCaps = (Register & 0x00FF0000) >> 16 ;
	BStatus = Register & 0x0000FFFF ;
	
#if BHDR_CONFIG_DEBUG_HDCP_KEY_LOADING
	BDBG_WRN(("HDCP_MON_RX_BSTATUS__BCAPS %#X", Register)) ;
	BDBG_WRN(("BCaps__BStatus Monitor BCaps: %#02X BStatus: %#04x", 
		BCaps, BStatus)) ;
#endif

	/* append repeater ksv to ksv list */
	if (pDownstreamInfo->isRepeater)
	{
		BKNI_Memcpy(pKsvs + pDownstreamInfo->devices * BAVC_HDMI_HDCP_KSV_LENGTH,
			pDownstreamInfo->repeaterKsv, BAVC_HDMI_HDCP_KSV_LENGTH);
	}

	/* now load the downstream KSVs */
	for (i = 0 ; i < downstreamDevices; i++)
	{
		/* copy the next Ksv */
		for (j = 0 ; j < BAVC_HDMI_HDCP_KSV_LENGTH ; j++)
			Ksv[j] = *(pKsvs+BAVC_HDMI_HDCP_KSV_LENGTH * i  + j)  ;
			

		/* write the 4 LSBs RxBksv to the transmitter... */
		BksvRegisterValue = 
			  Ksv[0] | Ksv[1] <<  8 | Ksv[2] << 16 | Ksv[3] << 24 ;

#if BHDR_CONFIG_DEBUG_HDCP_KEY_LOADING
		BDBG_WRN(("Load KSV FIFO Device # %02d KSV: %02X %02X %02X %02X %02X", 
			i+1, Ksv[4], Ksv[3], Ksv[2], 	Ksv[1], Ksv[0])) ;
#endif		

		BREG_Write32(hRegister, BCHP_HDMI_RX_0_HDCP_KSV_FIFO_0 + ulOffset, BksvRegisterValue) ;

		
		/* write the 1 MSB RxBksv to the transmitter; also write KSV address ... */
		Register = BREG_Read32(hRegister, BCHP_HDMI_RX_0_HDCP_KSV_FIFO_1 + ulOffset) ;
			Register &= ~ (
				  BCHP_MASK(HDMI_RX_0_HDCP_KSV_FIFO_1, KSV)
				| BCHP_MASK(HDMI_RX_0_HDCP_KSV_FIFO_1, KSV_ADDRESS)) ;
				
			Register |= (
				  BCHP_FIELD_DATA(HDMI_RX_0_HDCP_KSV_FIFO_1, KSV, Ksv[4])
				| BCHP_FIELD_DATA(HDMI_RX_0_HDCP_KSV_FIFO_1, KSV_ADDRESS, i)) ;
		BREG_Write32(hRegister, BCHP_HDMI_RX_0_HDCP_KSV_FIFO_1 + ulOffset, Register) ;

		/* pulse to load the current downstream KSV  */
		Register = BREG_Read32(hRegister, BCHP_HDMI_RX_0_HDCP_KSV_FIFO_1 + ulOffset) ;
			Register |= BCHP_MASK(HDMI_RX_0_HDCP_KSV_FIFO_1, KSV_FIFO_LOAD) ;
		BREG_Write32(hRegister, BCHP_HDMI_RX_0_HDCP_KSV_FIFO_1 + ulOffset, Register) ;
			
		Register = BREG_Read32(hRegister, BCHP_HDMI_RX_0_HDCP_KSV_FIFO_1 + ulOffset) ;
			Register &= ~ BCHP_MASK(HDMI_RX_0_HDCP_KSV_FIFO_1, KSV_FIFO_LOAD) ;
		BREG_Write32(hRegister, BCHP_HDMI_RX_0_HDCP_KSV_FIFO_1 + ulOffset, Register) ;

		BKNI_Delay(1000);
	}


#if BHDR_CONFIG_DEBUG_HDCP_KEY_LOADING
	Register = BREG_Read32(hRegister, BCHP_HDMI_RX_0_HDCP_MON_RX_BSTATUS__BCAPS + ulOffset) ;
	BCaps = (Register & 0x00FF0000) >> 16 ;
	BStatus = Register & 0x0000FFFF ;
	

	BDBG_WRN(("HDCP_MON_RX_BSTATUS__BCAPS (Reg= %#08x): BCaps: %#02x BStatus: %#04x", 
		Register, 	BCaps, BStatus)) ;
	BDBG_WRN(("")) ;
	BDBG_WRN(("")) ;
#endif

	hHDR->stHdcpStatus.eAuthState = BHDR_HDCP_AuthState_eKsvFifoReady ;
	
	BDBG_LEAVE(BHDR_HDCP_LoadRepeaterKsvFifo) ;
}



