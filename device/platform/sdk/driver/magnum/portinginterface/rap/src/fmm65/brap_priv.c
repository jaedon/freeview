/***************************************************************************
*     Copyright (c) 2004-2012, Broadcom Corporation
*     All Rights Reserved
*     Confidential Property of Broadcom Corporation
*
*  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
*  AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
*  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
*
* $brcm_Workfile: brap_priv.c $
* $brcm_Revision: Hydra_Software_Devel/388 $
* $brcm_Date: 4/11/12 1:21p $
*
* Module Description:
*	This file contains the common APIs used internally by different 
*	modules of the Raptor Audio PI. 
*
* Revision History:
*
* $brcm_Log: /magnum/portinginterface/rap/base3/brap_priv.c $
* 
* Hydra_Software_Devel/388   4/11/12 1:21p purush
* SW7340-297: [7340]Moved path structure memory allocation from start
* channel to open channel. Porting the changes to Mainline.
* 
* Hydra_Software_Devel/387   2/17/12 7:26p sgadara
* SW7420-2194: [7420] Adding new feature, Mixing of two independent
* decode outputs. Also refactoring SRC programming
* 
* Hydra_Software_Devel/386   2/9/12 10:13p sgadara
* SW7420-2230: [7420] Fix memory leaks
* 
* Hydra_Software_Devel/385   2/8/12 2:03p sgadara
* SW7420-2230: [7420] Change the Feedback buffer from circular to linear
* 
* Hydra_Software_Devel/384   1/20/12 10:20a sgadara
* SW7125-1215: [7125] Fix coverity issue
* 
* Hydra_Software_Devel/383   1/18/12 9:26p sgadara
* SW7125-1184: [7125] Fixing coverity issue - Exceed Array size
* 
* Hydra_Software_Devel/382   1/18/12 8:55p sgadara
* SW7125-270: [7125] Fixing coverity issue - Exceed Path Array size
* 
* Hydra_Software_Devel/381   12/22/11 8:20p sgadara
* SW7420-2118: [7420] Fixing the bug in finding if a path carries
* compressed audio, by changing the logic
* 
* Hydra_Software_Devel/380   9/8/11 11:38a srajapur
* SW7125-1055 : [7125] Coverity Defect ID:32288 DEADCODE brap_priv.c
* Product=97125 SW7125-1054 : [7125]Coverity Defect ID:32295
* OVERRUN_STATIC brap_priv.c Product=97125 SW7125-1082 : [7125]Coverity
* Defect ID:35231 DEADCODE brap_priv.c Product=97125
* 
* Hydra_Software_Devel/379   8/10/11 11:03a srajapur
* SW7420-696:[7420]Fixing the compilation error.
* 
* Hydra_Software_Devel/378   7/25/11 12:16p gourabm
* SW7420-696:[97420]Fix Coverity detected issues - 7420
* 
* Hydra_Software_Devel/377   7/6/11 5:27p srajapur
* SW7405-5405 : [7405] Adding correct comment for "uiFWMixerIpIndex" in
* the hRapCh handle
* 
* Hydra_Software_Devel/376   6/7/11 12:13p gautamk
* SW7405-4713: [7405] programming WRCNT to 0 before disabling the ARC.
* 
* Hydra_Software_Devel/375   5/27/11 6:06p gautamk
* SW7420-1885:[7405] reducing the debug level.
* 
* Hydra_Software_Devel/374   5/25/11 3:15p gautamk
* SW7420-767: [7420] DDRE stage can be added on single decode. Adding
* support for it
* 
* Hydra_Software_Devel/373   5/20/11 4:18p gautamk
* SW7420-847: [7420] Programming  ADAPTIVE_RATE_ENABLE to 0 for enabling
* Force Repeat Drop Control
* 
* Hydra_Software_Devel/372   5/4/11 4:25p gautamk
* SW7420-1826: [7405] Adding fix for audio output group.
* 
* Hydra_Software_Devel/371   4/26/11 7:48p sgadara
* SW7420-1756: [7420] Fixing an issue in support multiple ports for
* Independent delay disabled case
* 
* Hydra_Software_Devel/370   4/20/11 3:43p sgadara
* SW7420-1756: [7420] Implementing code review comments --> Change the
* Pointer validity check function to a macro and name it aptly
* 
* Hydra_Software_Devel/369   4/19/11 9:24p sgadara
* SW7420-1756: [7420] Support multiple ports for Independent delay
* disabled case as well
* 
* Hydra_Software_Devel/368   4/18/11 3:05p sgadara
* SW7420-1756: [7420] Implementing code review comments and correcting
* the indentations
* 
* Hydra_Software_Devel/367   4/6/11 3:21p gautamk
* SW7125-901: [7125] MAI channel Status bit should be picked from
* different structure.
* 
* Hydra_Software_Devel/366   3/28/11 7:14p sgadara
* SW7420-767: [7550] Fixing build issue for 7550
* 
* Hydra_Software_Devel/365   3/18/11 11:07p sgadara
* SW7420-767: [7420] Fixing non-MS build issue
* 
* Hydra_Software_Devel/364   3/18/11 9:42p sgadara
* SW7420-767: [7420] Merge MS11 development branch to mainline
* 
* Hydra_Software_Devel/363   2/21/11 3:48p gautamk
* SW7405-5144: [7405] Correcting the Memset size.
* 
* Hydra_Software_Devel/362   2/11/11 7:40a srajapur
* SW7550-601:[7550]Add BTSC Support in FW PI and CIT -------->
* Programming PEAK A1,A2 and GAIN value to reset values when BTSC is
* enabled on DAC
* 
* Hydra_Software_Devel/361   2/7/11 1:59p gautamk
* SW7550-631: [7550] Sample rate value and mode value in
* Getstreaminformation() is taken from payload sent by FW through
* interrupt.
* 
* Hydra_Software_Devel/360   11/11/10 7:30p gautamk
* SW7405-4713: [7550] Rbuf size for BTSC out should be 4 times the normal
* buffer.
* 
* Hydra_Software_Devel/359   11/8/10 2:05p gautamk
* SW7405-4713:[7405] Fixing error for REal audio
* 
* Hydra_Software_Devel/358   10/29/10 4:08p gautamk
* SW7405-4713:[7405] SPDIFFM is started before O/P so that bUseHwCbit
* flag is available in BRAP_OP_P_Start for initial muting.
* 
* Hydra_Software_Devel/357   10/22/10 10:35p sgadara
* SW3556-1206: [3548,3556] Merge customer branch to main line --> Fixing
* the build issue
* 
* Hydra_Software_Devel/356   10/22/10 10:16p sgadara
* SW3556-1206: [3548,3556] Merge customer branch to main line
* 
* Hydra_Software_Devel/355   10/21/10 7:09p srajapur
* SW7550-601 : [7550] Adding PI Support for BTSC Encoder
* 
* Hydra_Software_Devel/354   10/19/10 3:40p gautamk
* SW7405-4713:[7405] Fixing warnings
* 
* Hydra_Software_Devel/353   10/7/10 7:59p sgadara
* SW3556-1018: [3548,3556] Correcting the index of pIntDstDetails array
* in BRAP_P_MixerSrcRsrcLayout, also removing inactive code.
* 
* Hydra_Software_Devel/352   9/23/10 3:00p gautamk
* SW7325-807: [7325] Fixing watchdog recovery for dual decode
* 
* Hydra_Software_Devel/351   9/16/10 12:20a srajapur
* SW7468-298 :[7468]Merging Real Video Code to main latest
* 
* Hydra_Software_Devel/350   9/3/10 5:31p gautamk
* SW7405-4713: [7405] PPm should be disabled if Ms10 usage case
* 
* Hydra_Software_Devel/349   9/3/10 3:47p gautamk
* SW7405-4713:[7420] Fixing bug in IsPrimary Channel
* 
* Hydra_Software_Devel/348   8/26/10 5:34p gautamk
* SW7405-4713: [7405] Not allocating Adaptive rate ctrl if any of the
* path in the channel is compress
* 
* Hydra_Software_Devel/347   8/25/10 6:42p srajapur
* SW7405-4713: [7405] Fixing compilation error for 7550
* 
* Hydra_Software_Devel/346   8/23/10 9:23p sgadara
* SW3548-3063: [3548,3556] Registering a function leave macro
* 
* Hydra_Software_Devel/345   8/16/10 7:11p gautamk
* SW7405-4052: [7405] bdownmixPort comes into effect only if outputmode
* is not 2_0
* 
* Hydra_Software_Devel/344   8/10/10 1:54p gautamk
* SW7420-767: [7420] Merging MS11 feature support to mainline
* 
* Hydra_Software_Devel/343   8/5/10 3:15p gautamk
* SW7405-4713: [7405] Fixing compilation error for 7550
* 
* Hydra_Software_Devel/342   8/4/10 7:23p gautamk
* SW7405-4713: [7405] Whenever there is a change Output clock rate, SRC
* of running PB and cap should be updated.
* 
* Hydra_Software_Devel/341   8/4/10 6:55p gautamk
* SW7405-4712: [7405] Fixing bug in Programming Output clock.
* 
* Hydra_Software_Devel/340   8/4/10 6:48p gautamk
* SW7405-4712: [7405] Fixing bug in Programming Output clock.
* 
* Hydra_Software_Devel/339   7/23/10 3:50p gautamk
* SW7405-4646: [7405] Restoring mute status of O/P at mixer Level in
* every Start.
* 
* Hydra_Software_Devel/338   7/22/10 6:50p gautamk
* SW7405-3063: [7405] For ringbuffer Capture, only 2 Rbuf should be
* allocated if its stero capture.
* 
* Hydra_Software_Devel/337   7/22/10 5:59p gautamk
* SW7400-2848: [7405] Adding support for on the fly input sample rate
* programming for PB channel.
* 
* Hydra_Software_Devel/336   7/21/10 7:20p gautamk
* SW7405-3063: [7405] For ringbuffer Capture, only 2 Rbuf should be
* allocated if its stero capture.
* 
* Hydra_Software_Devel/335   7/1/10 5:40p gautamk
* SW7335-788: [7405] Fixing bug in Program coefficients
* 
* Hydra_Software_Devel/334   6/28/10 11:46a gautamk
* SW7405-3063: [7405] Fixing compiler warning
* 
* Hydra_Software_Devel/333   6/23/10 1:12p gautamk
* SW7335-774: [7335]: Fixing compilation for 3548 Family
* 
* Hydra_Software_Devel/332   6/22/10 6:12p gautamk
* SW7335-774: [7335] Moving the frequent dynamic Memory allocations of
* structures to BRAP_Open and store it in hRap. Using it from hRap
* whenever required.
* 
* Hydra_Software_Devel/331   6/21/10 4:19p gautamk
* SW7405-3063: [7405] Fixing bug in compressed Rbuf capture.
* 
* Hydra_Software_Devel/330   6/16/10 2:20p gautamk
* SW7405-3063: [7405] Fixing compilation warning with DEBUG=n option
* 
* Hydra_Software_Devel/329   6/7/10 5:18p gautamk
* SW7405-4170: [7405] Sending Physical address for Common buffer to CIT.
* 
* Hydra_Software_Devel/328   6/3/10 7:12p sgadara
* SW3548-2960:[3548,3556] Populating the Association Id in pPath
* correctly
* 
* Hydra_Software_Devel/327   5/31/10 2:48p gautamk
* SW7335-730: [7335] Fixing coverity bugs in mainline
* 
* Hydra_Software_Devel/326   5/17/10 10:54a gautamk
* SW7405-4170: [7405] Merging MS10 changes to mainline
* 
* Hydra_Software_Devel/325   5/13/10 6:16p sgadara
* SW3548-2806-2925: [3548,3556] In BRAP_P_PrepareFciId Parallel path of
* Mixer outlink(Equivalent as Pp of SrcEqSelfLink) is to be used for the
* second SRC in cascade to find out it's parent SRC.
* 
* Hydra_Software_Devel/324   5/12/10 5:06p gautamk
* SW7405-3063:[7405] Fixing broken PCM PB feature.
* 
* Hydra_Software_Devel/323   5/6/10 5:18p gautamk
* SW7405-4253: [7405] For Playback channel, HDMI and SPDIF are using
* seperate FMM path because sharing same SRC among both is causing MIXER
* RATE ERR which is causing audio loss
* 
* Hydra_Software_Devel/322   5/4/10 8:58p sgadara
* SW3548-2852: [3548,3556] Providing support to add same Equalizer to
* multiple output ports. --> Currently the multiple output ports should
* belong to same channel.
* 
* Hydra_Software_Devel/321   4/29/10 5:38p gautamk
* SW7325-547: [7405] Changing the exopsed paramter name
* 
* Hydra_Software_Devel/320   4/29/10 5:32p gautamk
* SW7325-547: [7405] Adding CGMS bit SPDIF Ch bits
* 
* Hydra_Software_Devel/319   4/22/10 5:12p sgadara
* SW7405-4170:[7405,3548,3556] Making chages to internally map AACHE and
* AC3 Encode to Dolby Pulse and DD Transcode in PI for MS10 license
* 
* Hydra_Software_Devel/318   4/15/10 9:45p sgadara
* SW3548-2852: [3548,3556] Providing support to add same Equalizer to
* multiple output ports. --> Currently the multiple output ports should
* belong to same channel.
* 
* Hydra_Software_Devel/317   4/13/10 5:47p sgadara
* SW3548-2881: [3548,3556] Clearing the SRC handle stored in Equalizer
* handle after SRC Stop, which is populated before SRC Start. --> Merge
* to main line
* 
* Hydra_Software_Devel/316   4/9/10 9:59p gautamk
* SW7405-4168: [7405] using MACRO instead of 100.
* 
* Hydra_Software_Devel/315   4/9/10 5:26p gautamk
* SW7405-3063:[7405] Program AssociatioId correctly for capture channel
* 
* Hydra_Software_Devel/314   4/9/10 4:01p gautamk
* SW7405-4168: [7405] Adding support for 0.5x to 2x playback rate.
* 
* Hydra_Software_Devel/313   4/8/10 3:29p gautamk
* SW7125-270:[7125] Fixing coverity issue
* 
* Hydra_Software_Devel/312   4/7/10 6:44p gautamk
* SW7405-4170: [7405] Adding Support for Multi Stream Decoder. Master and
* Secodary channel will be mixed by FwMixer Processing stage.
* 
* Hydra_Software_Devel/311   3/29/10 4:10p gautamk
* SW7550-316: [7550] Scaling coefficients for Compressed Path should
* never be changed
* 
* Hydra_Software_Devel/310   3/25/10 6:22p gautamk
* SW7405-3063: [7405] Correcting the logic to program EbufDatamode for
* DstCh
* 
* Hydra_Software_Devel/309   3/11/10 5:05p speter
* SW3548-2822:[3548] Add Dolby Transcode and Broadcom 3D surround post
* processing algos
* 
* Hydra_Software_Devel/308   3/10/10 5:06p speter
* SW3548-2819:[3548] Adding Dolby Pulse Algorithm
* 
* Hydra_Software_Devel/307   3/9/10 9:32p sgadara
* SW7405-3972: [3548,3556,7405] Adding the support for providing
* decoder/encoder related info.
* 
* Hydra_Software_Devel/306   3/9/10 5:05p gautamk
* SW7405-3063:[7420] Programming ADAPTIVE_RATE_MASTER_ENABLE for 7420
* Family.
* 
* Hydra_Software_Devel/305   2/22/10 8:49p sgadara
* SW3548-2748: [3548,3556] Fixing the issue of a decode channel stop
* start not working during mixing.
* Populating correct Association Id in pPath
* --> Merge to main line
* 
* Hydra_Software_Devel/304   2/19/10 5:21p gautamk
* SW7468-119: [7468] Adding RAP PI support for Real audio LBR
* 
* Hydra_Software_Devel/303   2/10/10 5:28p sgadara
* SW3548-2739-2686: [3548,3556] Fixing build issue for non-DTV platforms
* 
* Hydra_Software_Devel/302   2/8/10 6:59p sgadara
* SW3548-2739-2686: [3548,3556] Modifying the Equalizer implementation
* design to support PEQ, and GEQ+Tone Control.
* --> After Mixer 2 SRCs will be connected back to back if Eq is added
* 
* Hydra_Software_Devel/301   1/27/10 6:02p srajapur
* SW7550-221 : [7550] Fixing the coverity issues.
* 
* Hydra_Software_Devel/300   1/13/10 2:47p gautamk
* SW7405-3202: [7405] implementing code review comments
* 
* Hydra_Software_Devel/299   1/12/10 6:17p sgadara
* SW3556-905: [3548,3556] Adding "Capture of Mixed Audio" feature
* --> Fixing build issue for 7550
* 
* Hydra_Software_Devel/298   1/12/10 2:27p gautamk
* SW7405-3632: [7405] Removing unwanted error check.
* 
* Hydra_Software_Devel/297   1/8/10 9:33p sgadara
* SW3556-905: [3548,3556] Adding "Capture of Mixed Audio" feature
* --> Removing the print
* 
* Hydra_Software_Devel/296   1/8/10 9:24p sgadara
* SW3556-905: [3548,3556] Adding "Capture of Mixed Audio" feature
* --> Populating right AssocId in pPath in GetChannelPaths() and
* searching the started channel in the right AssocId in
* MixerSrcRsrcLayout()
* 
* Hydra_Software_Devel/295   1/7/10 4:25p sgadara
* SW3556-905: [3548,3556] Adding "Capture of Mixed Audio" feature
* 
* Hydra_Software_Devel/294   1/6/10 9:12p sgadara
* SW3556-905: [3548,3556] Adding "Capture of Mixed Audio" feature
* 
* Hydra_Software_Devel/293   12/23/09 9:01p sgadara
* SW3556-832 : [3548,3556] Fixing the case of O/P port+capture when
* Independent delay is disabled.
* --> Merge the fix to main line.
* 
* Hydra_Software_Devel/292   12/17/09 9:16p sgadara
* SW3556-904: [3548,3556] Adding feature of "Fixed Ringbuffer Capture at
* 48khz sample rate"
* 
* Hydra_Software_Devel/291   12/5/09 4:03p gautamk
* SW7405-3063:[7405] validating pointer before accessing it.
* 
* Hydra_Software_Devel/290   12/1/09 12:02p gautamk
* SW7325-625: [7405] Scaling coefficients are preserved in Mixing
* coefficients array.
* 
* Hydra_Software_Devel/289   11/26/09 4:47p gautamk
* SW7550-81: [7405] Adding ifdef statements while enabling passthru
* 
* Hydra_Software_Devel/288   11/24/09 2:31p speter
* SW3548-2629: [3548] Adding SPDIF Rx Passthru without DSP
* 
* Hydra_Software_Devel/287   11/24/09 11:56a speter
* SW3548-2629: [3548] Adding SPDIF Rx Passthru without DSP
* 
* Hydra_Software_Devel/286   11/18/09 3:00p speter
* SW3556-832: [3548] Adding the control to either pause or continue when
* the ring buffer destination is full
* 
* Hydra_Software_Devel/285   11/16/09 5:30p sgadara
* SW3556-832 : [3548,3556] Adding the "dynamic port switching" feature
* support.
* --> Adding the private functions to disable mixer outputs and stop
* output/capture ports.
* 
* Hydra_Software_Devel/284   11/15/09 4:12p sgadara
* SW3556-832 : [3548,3556] Adding the "dynamic port switching" support.
* Optimizing the paths creation for independent delay enabled case.
* --> For dummy ports there will be no separate FMM paths and will also
* be not informed in CIT branch info
* 
* Hydra_Software_Devel/283   11/15/09 12:22p speter
* SW3556-832: [3548] Adding the control to either pause or continue when
* the ring buffer destination is full
* 
* Hydra_Software_Devel/282   11/14/09 2:03p sgadara
* SW3556-832 : [3548,3556] Adding CIT-PI interface for the clock
* programming of loopback capture port(Ringbuffer Destination) by FW.
* 
* Hydra_Software_Devel/281   11/10/09 8:37p sgadara
* SW3556-832 : [3548,3556] Adding CIT-PI interface for the clock
* programming of loopback capture port(Ringbuffer Destination) by FW.
* 
* Hydra_Software_Devel/280   11/10/09 2:37p speter
* SW7405-2959: [3548] Adding DTS-HD support
* 
* Hydra_Software_Devel/279   11/5/09 9:57a speter
* SW3548-2591: [3548] Modifying the get mixer code due to change in
* equalizer architecture
* 
* Hydra_Software_Devel/278   11/3/09 3:44p speter
* SW3548-2591: [3548] Adding code to allocate Equalizer SRCs only if the
* output port in the concerned path has an Equalizer associated with it
* 
* Hydra_Software_Devel/277   10/16/09 4:30p gautamk
* SW7405-3063: [7405] bPrimary should be set only if primary is started.
* 
* Hydra_Software_Devel/276   10/15/09 2:42p gautamk
* SW7405-3063: [7405] Misc changes.
* - Programming SRC for Bypass case.
* 
* Hydra_Software_Devel/275   10/6/09 6:36p srajapur
* SW7550-52 : [7550] Merging branch 7550 code to main line
* 
* Hydra_Software_Devel/274   10/6/09 4:26p gautamk
* SW7405-3063:[7405]Programming Repetition period 4 for DDP
* 
* Hydra_Software_Devel/273   10/5/09 7:19p sgadara
* SW7405-2609: [3548,3556] Enabling Adaptive Rate control to a channel
* only if number of rate managers are enough to be allocated to all of
* its valid paths.
* --> also correcting the indentation.
* 
* Hydra_Software_Devel/272   10/5/09 3:59p gautamk
* SW7405-3063: [7405] FW_STREAm_CTRL1.STREAM_ENA should be disabled in
* case of DDP Passthru.
* 
* Hydra_Software_Devel/271   10/2/09 2:36a srajapur
* SW7550-52: [7550] Merging 7550 branch code to main line
* 
* Hydra_Software_Devel/270   10/1/09 11:17a bhanus
* SW7420-364:[7420]Fixing compilation break for 7420 A1
* 
* Hydra_Software_Devel/269   9/28/09 1:11p gautamk
* SW7405-3070: [7405] exposing RAP_INDEP_DELAY_DISABLED, to disable INDEP
* delay at compile time.
* 
* Hydra_Software_Devel/268   9/28/09 12:27p gautamk
* SW7405-3074 : [7405] restructuring the error checks.
* 
* Hydra_Software_Devel/267   9/22/09 6:24p gautamk
* SW7405-3058: [7405] Adding support for DRA decoder.
* 
* Hydra_Software_Devel/266   9/22/09 5:50p gautamk
* SW7405-3058: [7405] Adding support for DRA decoder.
* 
* Hydra_Software_Devel/265   9/16/09 2:15p gautamk
* SW7405-2606: [7405] Correcting debug mesage.
* 
* Hydra_Software_Devel/264   9/11/09 6:46p sgadara
* SW3548-2188: [3548,3556] Adding support for AMR decode algorithm.
* 
* Hydra_Software_Devel/263   9/8/09 2:32p gautamk
* SW7405-2986: [7405]Enabinge DTS Broadcast Pasthru without DTS
* Licensing. Also Enable Other Passthru which can be allowed without
* license
* 
* Hydra_Software_Devel/262   9/4/09 9:07p sgadara
* SW3548-2454: [3548,3556] Inserting "_P_" to the names of private
* functions.
* 
* Hydra_Software_Devel/261   9/3/09 5:42p gautamk
* SW7325-388: [7405] Storing Volume Level in both Db and 5.23 Format.
* Also both these paramter remains in Sync when calling different Volume
* APIs
* 
* Hydra_Software_Devel/260   9/3/09 3:13p gautamk
* SW7405-2928: [7405]: Adding BMEM_FlushCache() for Dest RIng buffer at
* init as per Jon's request.
* 
* Hydra_Software_Devel/259   8/25/09 1:10p gautamk
* SW7405-2928: [7405] Adding support Multichannel capture.
* 
* Hydra_Software_Devel/258   8/25/09 12:11p speter
* SW3548-2411: [3548] Merging the phase 5.0 release branch to mainline
* 
* Hydra_Software_Devel/RAP_354856_PH_5_0/1   7/27/09 12:23a sgadara
* PR 56147: [3548,3556] Programming the SRC type of ADC In case to Bypass
* for all the paths except capture path.
* 
* Hydra_Software_Devel/257   8/20/09 3:25p gautamk
* PR57729: [7405] Programming RAMP_STEP/STEP_SIZE of Mixer and SRC to 0
* only when all the channels are stopped in all associations.
* 
* Hydra_Software_Devel/256   8/18/09 5:16p gautamk
* PR57729: [7405] Programming RAMP_STEP/STEP_SIZE of Mixer and SRC to 0
* only when all the channels are stopped.
* 
* Hydra_Software_Devel/255   7/30/09 2:20p bhanus
* PR57171: [7420]porting for 7420 B0
* 
* Hydra_Software_Devel/254   7/27/09 2:11p gautamk
* PR57005: [7405] Setting Ramp for decode channel only when no channel is
* started in the association.
* 
* Hydra_Software_Devel/253   7/23/09 3:03p gautamk
* PR57005: [7405] programming RAMP stemp of MS to 0x800, only when MS is
* stopped.
* 
* Hydra_Software_Devel/252   7/8/09 12:03p gautamk
* PR56006: [7405] Fixing coverity issue.
* 
* Hydra_Software_Devel/251   7/7/09 3:43p speter
* PR 55434: [3548,3556] Fixing the watchdog related segmentation fault
* for HDMI / ADC / SPDIF In.
* 
* Hydra_Software_Devel/250   7/7/09 11:44a speter
* PR 56011: [3548,3556] Implementing code review comments (Adding PCM
* capture for independent delay related code)
* 
* Hydra_Software_Devel/249   7/2/09 12:14p gautamk
* PR56006: [7405] Allocating one buffer for HBR
* 
* Hydra_Software_Devel/248   6/30/09 11:57a gautamk
* PR56006: [7405] Using the settings done through Brap_SetInputConfig to
* program capport
* 
* Hydra_Software_Devel/247   6/25/09 4:36p sgadara
* PR 56010: [3548,3556] Implementing code review comments of June 5,
* 2009.
* --> In BRAP_P_GetMixerForRBuf() bringing the mixer finding code  as
* common code for all the channels.
* 
* Hydra_Software_Devel/246   6/23/09 2:33p gautamk
* PR56006: [7405] Fixing coverity bug
* 
* Hydra_Software_Devel/245   6/18/09 2:20p gautamk
* PR56112:[7420] Adding PI support for HDMI 5.1PCm for 7420
* 
* Hydra_Software_Devel/244   6/18/09 12:03p gautamk
* Pr56006: [7405] removing unwanted function
* 
* Hydra_Software_Devel/243   6/18/09 11:50a gautamk
* PR56010: [7405] using BKNI_Sleep(1) instead of some higher value.
* 
* Hydra_Software_Devel/242   6/17/09 5:18p gautamk
* PR56011: [7405] Implementing code review comments
* 
* Hydra_Software_Devel/241   6/15/09 5:12p gautamk
* PR56006:[7405] Disabling adaptive rate ctrl if PPm is disabled
* 
* Hydra_Software_Devel/REFSW_RAP_7405_AACV2/1   6/15/09 5:00p gautamk
* PR56006: [7405] not allocating adaptive rate ctrl when PPm is disabled.
* 
* Hydra_Software_Devel/240   6/12/09 3:39p gautamk
* PR53302: [7405] Merging cleanup code to mainline
* 
* Hydra_Software_Devel/239   6/9/09 12:34p gautamk
* PR55572:[7405] Before accessing any pointer location ccheck if it is
* 0XDA7ADEAD or 0xDEADDA7A in addition to NULL.
* 
* Hydra_Software_Devel/238   6/9/09 11:38a gautamk
* PR47949: [7405]Changing name from PCMOnAVI to PCMWAV
* 
* Hydra_Software_Devel/237   6/5/09 5:19p gautamk
* PR55572: [7405] Adding State BRAP_P_State_eStopInvoked to handle race
* condition between Stopchannel and  Isr functions like SetStcValid_isr
* etc.
* 
* Hydra_Software_Devel/236   6/5/09 4:56p sgadara
* PR 53012: [3548,3556] Fixing the issue of system hang if ringbuffer is
* added first then output port, in the usage case where ringbuffer and
* output port with Independent dealy are added as destinations.
* --> Also correcting the indentation.
* 
* Hydra_Software_Devel/235   6/4/09 5:12p gautamk
* PR47949: [7405] support for PCM on AVI
* 
* Hydra_Software_Devel/234   6/4/09 3:13p gautamk
* PR47949: [7405] PI support of PCM on avi
* 
* Hydra_Software_Devel/233   5/27/09 2:21p gautamk
* PR55470: [7405] Removing hardcoding of SRC RAMP STEP
* 
* Hydra_Software_Devel/232   5/22/09 4:42p gautamk
* PR55135: [7405] Moving SRC programming of PB/CAP from Samplerate_isr to
* RampEnable_isr
* 
* Hydra_Software_Devel/231   5/18/09 5:08p gautamk
* PR52383:[7405] Changes for DTS Broadcast.
* 
* Hydra_Software_Devel/230   5/15/09 2:00p gautamk
* PR54752: [7405] Clearing AUD_FMM_BF_CTRL_ADAPTRATE_REPEATDROP_WRCNT  as
* well at stopchannel.
* 
* Hydra_Software_Devel/229   5/11/09 3:54p gautamk
* PR52383: [7405] Adding algorithm support for DTS decoder.
* 
* Hydra_Software_Devel/228   4/22/09 4:52p sgadara
* PR 54330: [3548,3556] Add support for SRS TruVolume certification.
* --> Fixing the issue of interleaved capture not working.
* 
* Hydra_Software_Devel/227   4/21/09 4:42p sgadara
* PR 54374: [3548,3556] Extending the feature of volume control over
* capture data to capture and playback channels.
* --> Poritng the changes to main line.
* 
* Hydra_Software_Devel/226   4/20/09 5:39p sgadara
* PR 54374: [3548,3556] Fixing the issue of volume control over captured
* data to ring buffers.
* 
* Hydra_Software_Devel/225   4/17/09 7:49p sgadara
* PR 54330: [3548,3556] Add support for SRS TruVolume certification.
* --> Adding the interface, Ringbuffer as the audio source to the
* channel, allocate only rbufs in capture path, no capture port
* required.
* 
* Hydra_Software_Devel/224   4/16/09 3:35p gautamk
* PR52383: [7405] Disabling STREAM_ENA for FW_STREAM_CTRL_1 when hdmi is
* 5.1
* 
* Hydra_Software_Devel/223   4/16/09 2:16p gautamk
* PR52383: [7405] For Compressed path don't program Ping/pong
* coefficients.
* 
* Hydra_Software_Devel/222   4/11/09 6:40p sgadara
* PR 53592: [3548,3556] Fixing the issue of running out of number of Rate
* Managers(Adaptive Rate control). Resource request will be made only
* till the max number of Rate Managers are allocated.
* 
* Hydra_Software_Devel/221   4/7/09 4:57p gautamk
* PR52383: [7405] Programming IOP_CTRl_FCI_CFG for 5.1PCM
* 
* Hydra_Software_Devel/220   4/6/09 12:07p gautamk
* PR53647: [7405] Moving StartWRPtrLocation to StartChannel from
* OpenChannel
* 
* Hydra_Software_Devel/219   4/2/09 4:46p speter
* PR 53491: [3548,3556] Coverity Defect ID:12943 OVERRUN_STATIC - Fixing
* the overun
* 
* Hydra_Software_Devel/218   4/2/09 1:56p gautamk
* PR53647: [7405] adding commments
* 
* Hydra_Software_Devel/217   4/2/09 1:45p gautamk
* PR53647: [7405] exposing  StartWr pointer for Plaback channel Rbufs.
* 
* Hydra_Software_Devel/216   4/2/09 11:23a speter
* PR 52729: [3548,3556] Adding bHbrEnable flag to SPDIF Output as High
* bit rate is required to be supported through SPDIF out as well.
* 
* Hydra_Software_Devel/215   3/23/09 3:55p gautamk
* PR52334: [7405] Modifying register programming for MS/OP/PLL blocks, to
* solve audio loss on spdif.
* 
* Hydra_Software_Devel/214   3/18/09 12:24p gautamk
* PR53328: [7405]
* PR53268: [7405] Fixing coverity
* 
* Hydra_Software_Devel/213   3/17/09 11:59a gautamk
* PR52383: [7405] Enabling Es type for 7405
* 
* Hydra_Software_Devel/212   3/17/09 11:53a gautamk
* PR52383: [7405] correcting programming of SRC for PB.
* 
* Hydra_Software_Devel/211   3/16/09 3:15p speter
* PR 52729: [3548,3556] Adding DDP Passthru support at 192kHz through
* SPDIF Out
* 
* Hydra_Software_Devel/210   3/13/09 7:19p sgadara
* PR 53012: [3548,3556] Adding the feature of capture to ringbuffer when
* Independent dealy is enabled and multiple output ports are connected.
* 
* Hydra_Software_Devel/209   3/12/09 3:32p speter
* PR 52729: [3548,3556] Adding DDP Passthru support at 192kHz through
* SPDIF Out
* 
* Hydra_Software_Devel/208   3/6/09 9:00p gautamk
* PR52845: [7405]
* PR52846: [7405]
* PR52847: [7405]
* PR52848: [7405]Coverity fix
* 
* Hydra_Software_Devel/207   3/5/09 12:17p speter
* PR 52174: [3548,3556] Fixing the code that was causing the problem of
* input switching to become mute - Adding to main line
* 
* Hydra_Software_Devel/206   2/23/09 11:42a gautamk
* PR52069: [7325] Programming O/P clock for PCM playabck/Capture channel
* when, Decode channel is started but didn't started decoding. This can
* happen when scrabled data is feeded to decoder. Checkin in mainline.
* 
* Hydra_Software_Devel/205   2/16/09 4:45p gautamk
* PR52094: [7405] programming StartWR ptr according to size of the buffer
* passed at open time.
* 
* Hydra_Software_Devel/204   2/13/09 5:13p gautamk
* PR48850: [7405] fixing compilation
* 
* Hydra_Software_Devel/203   2/13/09 5:00p gautamk
* PR51897: [7405] using SHaredPP Path type incase of Playback and capture
* channel for 7405
* 
* Hydra_Software_Devel/202   2/9/09 8:28p gautamk
* PR48850: [7405] setting RAMP to 0x800 at stop only for decode channel
* 
* Hydra_Software_Devel/201   2/6/09 2:59p gautamk
* PR48850: [7405] programming ramp for passthru also.
* 
* Hydra_Software_Devel/200   2/6/09 12:01p gautamk
* PR48850: [7405] Programming SRC_RAMP_STEP, DP_VOl_STEP to 0x20 for all
* channels except decode channel. For decode channel it sis programmed
* in Ramp_Enable_isr
* 
* Hydra_Software_Devel/199   2/5/09 6:46p gautamk
* PR48850: [7405] minor fix.
* 
* Hydra_Software_Devel/198   2/4/09 11:24a gautamk
* PR48683: [7325] Disabling shared srcch in case indepedent delay. Fw
* will update th Write Ptr, only for Decode channel
* 
* Hydra_Software_Devel/197   2/2/09 3:18p gautamk
* PR48683: [7405] Correcting the stopping sequence of FMM blocks as per
* RDB description.
* 
* Hydra_Software_Devel/196   1/27/09 4:05p speter
* PR 50495: [3548,3556] Merging the customer branch to main line
* 
* Hydra_Software_Devel/195   1/21/09 4:01p gautamk
* PR50415: [7405] Storing the coefiicients in hRapch handle from
* BRAP_P_ProgramCoefficients
* 
* Hydra_Software_Devel/194   1/2/09 3:18p gautamk
* PR50154:[7405] For Playback/Capture channel, Assuming that outputmode
* will be stereo.
* 
* Hydra_Software_Devel/193   12/22/08 4:38p gautamk
* pr48850: [7405] fIXING COMPILATION WARNING.
* 
* Hydra_Software_Devel/192   12/18/08 10:02a speter
* PR 50495: [3548,3556] Merging Release Phase 4.2 to main line of
* development
* 
* Hydra_Software_Devel/191   12/15/08 4:09p gautamk
* PR50333: [7405] printing  warning messages when AAC-DTS xcode is
* atttempted on non 48Khz stream
* 
* Hydra_Software_Devel/190   12/15/08 2:33p gautamk
* PR48850: [7405]correcting CIT prints
* 
* Hydra_Software_Devel/189   12/12/08 3:13p gautamk
* PR50226: [7405] When Indep delay is on, HBR Rbuf requires larger size.
* PR50227: [7335]
* 
* Hydra_Software_Devel/188   12/12/08 2:41p gautamk
* PR49011: [7405] Finxing the Capture to Rbuf.
* 
* Hydra_Software_Devel/187   12/10/08 11:07p gautamk
* PR50153: [7405] Branch is Cloned if Both have same bDownmixOP
* 
* Hydra_Software_Devel/186   12/10/08 10:59p gautamk
* PR49232:[7405] Adding support for Allocating Rbuf/SrcCh and Paths at
* OpenChannel time.
* 
* Hydra_Software_Devel/185   12/10/08 2:18p gautamk
* PR50008:[7405] Output channel matrix contains LFE field according to
* OutLfe
* 
* Hydra_Software_Devel/184   12/10/08 1:22p gautamk
* PR50136: [7405] Fixing coverity issue
* 
* Hydra_Software_Devel/183   12/10/08 12:08p gautamk
* PR48310: [7405] Fixing coverity issue.
* GetchhanlPath for capture channel is being modified similar Decode
* channel part
* 
* Hydra_Software_Devel/182   12/10/08 11:49a gautamk
* PR48312: [7405] Fixing Coverity Issue.
* PR50134
* 
* Hydra_Software_Devel/RAP_354856_PH_4_1/6   1/27/09 2:07p speter
* PR 50740: [3548,3556] Adding simul mode support for SPDIF/HDMI In using
* generic passthru stage
* 
* Hydra_Software_Devel/RAP_354856_PH_4_1/5   1/19/09 2:44p speter
* PR 50940: [3548,3556] Changing the threshold value to 0xFFFF based on
* firmware team's request. The value of 0xFFFF will stop auto mode in
* adaptrate and hence firmware will be able to control it.
* 
* Hydra_Software_Devel/RAP_354856_PH_4_1/4   12/24/08 3:32a sgadara
* PR 50370: [3548,3556] Updating the "uiAssocId" in "pPath" for capture
* channel(for fullduplex case).
* 
* Hydra_Software_Devel/RAP_354856_PH_4_1/3   12/16/08 2:37p sgadara
* PR 50324: [3548,3556] Properly linking the successive paths in case of
* a capture path. Also increasing the maximum number of paths in a
* channel, supported.
* 
* Hydra_Software_Devel/RAP_354856_PH_4_1/2   12/14/08 11:55p sgadara
* PR 47772: [3548,3556] Adding the code as to allocate SRCs only for the
* first channel that gets started in an association instead for all
* channels in an association.
* 
* Hydra_Software_Devel/RAP_354856_PH_4_1/1   12/4/08 4:45p sgadara
* PR 48708: [3548,3556] Adding the code not to free resources for a Mix
* path case.
* 
* Hydra_Software_Devel/181   12/2/08 9:34p sgadara
* PR 49716: [7325] Updating the mute status so as to take care for both
* cases of calling BRAP_SetDestinationMute() and BRAP_SetOutputMute() by
* application.
* 
* Hydra_Software_Devel/180   12/1/08 4:33p gautamk
* PR48681: [7405] Fixing compile error
* 
* Hydra_Software_Devel/179   12/1/08 3:24p gautamk
* PR48681: [7405] Audio loss on Channel change on Dynex TV fixed.
* --Not disabling  MS/OP CTRL registers for SPDIF / MAI on stop/Close
* Noise at stop deoced fixed.
*  -- Setting the RAmp value ion MS_CTRL at Stop.
* 
* Hydra_Software_Devel/178   12/1/08 11:10a speter
* PR 49453: [3548,3556] Fixing coverity issues
* 
* Hydra_Software_Devel/177   11/25/08 11:07a speter
* PR 49564: [3548,3556] Merging the Phase 4.0 release to main line
* 
* Hydra_Software_Devel/176   11/23/08 12:02a gautamk
* PR49281:[7405] fixing bug in getchannelpath
* 
* Hydra_Software_Devel/175   11/21/08 3:35p gautamk
* PR49281:[7405] Not Programming O/P PLL0 for Playback when Decode is
* already present.
* 
* Fixing Bug in generate cit input.
* 
* Fixing bug in Download Exec function
* 
* Hydra_Software_Devel/173   11/19/08 2:10p gautamk
* PR49248: [7405] Programming mixing coefficents for all paths.
* 
* Hydra_Software_Devel/172   11/19/08 1:33p gautamk
* PR48310: [7405] Fixing coverity issue
* PR48312
* 
* Hydra_Software_Devel/171   11/14/08 5:26p gautamk
* PR48850: [7405] Not programming Adaptive rate Ctrl registers if any of
* the branch is outputting Comp data.
* 
* Hydra_Software_Devel/170   11/14/08 4:12p gautamk
* PR48310: [7405] Fixing coverity issue
* PR48312
* 
* Hydra_Software_Devel/169   11/13/08 2:38p gautamk
* PR48682: [7405] Making StartSelection false for Capture Channel, to get
* rid of delay.
* 
* Also Adding Code for Independelay flag implementaion for  Capture
* channel
* 
* Hydra_Software_Devel/168   11/12/08 4:55p gautamk
* PR48792: [7405] Initializing the Variable bCloned at the start of for
* Loop.
* 
* Hydra_Software_Devel/167   11/11/08 4:58p gautamk
* PR48662: [7405] Fixing Coverity issue
* PR48663: [7405] Fixing Coverity issue
* 
* Hydra_Software_Devel/166   11/11/08 4:48p gautamk
* PR48791:[7405] Removing the instance of uiAssociatioId from hRapCh when
* Association is destroyed.
* Also order of creating the Path is changed in getchannel path.
* 
* Hydra_Software_Devel/165   11/10/08 11:51a gautamk
* PR47323: [7405] Creating different fmm paths in playback channel when
* INdep delay for playback channel is on
* 
* Hydra_Software_Devel/RAP_354856_PH_4_0/5   11/24/08 6:22p sgadara
* PR 49047: [3548,3556] Fixing the DDP decode + PCM mixing issue.
* 
* Hydra_Software_Devel/RAP_354856_PH_4_0/4   11/8/08 12:23a sgadara
* PR 42025: [3548,3556] Add volume control, with cascaded mixers.
* 
* Hydra_Software_Devel/RAP_354856_PH_4_0/3   11/7/08 2:49p sgadara
* PR 43158: [3548,3556] Adding support for minimal delay through decoder.
* 
* Hydra_Software_Devel/RAP_354856_PH_4_0/2   11/6/08 4:19p sgadara
* PR 48564: [3548,3556] Switching to PCM or PES during channel start for
* HDMI/SPDIF.
* 
* Hydra_Software_Devel/RAP_354856_PH_4_0/1   10/31/08 6:07p sgadara
* PR 42025: [3548,3556] Add volume control, with cascaded mixers. --
* >Provide separate mixers for each output port.
* 
* Hydra_Software_Devel/164   10/28/08 11:14p speter
* PR 48086: [3548,3556] Fixing the Playback case when the sampling rate
* of main decoder channel has not yet arrived till the playback channel
* is started.
* 
* Hydra_Software_Devel/163   10/25/08 2:23a speter
* PR 47687: [3548,3556] Fixing the bug in capture channel for Passthru
* case
* 
* Hydra_Software_Devel/162   10/24/08 10:01p speter
* PR 48384: [3548,3556] Merging Phase 3.1 to main line
* 
* Hydra_Software_Devel/161   10/22/08 4:19p gautamk
* PR42605: [7405] Fixing coverity issue.
* 
* Hydra_Software_Devel/160   10/22/08 4:17p gautamk
* PR42605: [7405] Fixing coverity issue.
* 
* Hydra_Software_Devel/RAP_354856_PH_3_1/1   10/23/08 7:16a speter
* PR 47360: [3548,3556]: Changing the design of Spdif Rx. Fixing the
* decision of destination buffer logic. Earlier it was checking SPDIF Rx
* status which did not match with the current algo. This is changed to
* check the algo type.
* 
* Hydra_Software_Devel/159   10/22/08 4:47a speter
* PR 46937: [3548,3556] Adding support for 6 simultaneous destinations
* support and some code cleanup
* 
* Hydra_Software_Devel/158   10/21/08 11:19p speter
* PR42213:[7405] Fixing compilation break
* 
* Hydra_Software_Devel/157   10/21/08 6:22p gautamk
* PR42213:[7405] Allocating only 1 SRC for Playback/Capture. It can
* handle Upsample by 4x and Downsample by 2x.
* 
* Hydra_Software_Devel/156   10/18/08 8:20a speter
* PR 44768: [3548,3556,7405] Moving bIndOpVolCtrl from channel params to
* BRAP_Settings.
* 
* Hydra_Software_Devel/155   10/18/08 2:41a speter
* PR 47961: [3548,3556] Allowing Setinputconfig when the channel is
* running for RFAudio
* 
* Hydra_Software_Devel/154   10/17/08 6:12a speter
* PR 38950: [3548,3556] Making errors to messages and warnings
* 
* Hydra_Software_Devel/153   10/17/08 6:04a speter
* PR 47360: [3548,3556]: Changing the design of Spdif Rx. SPDIF Rx is now
* a device level interrupt and handling of digital input format change
* is moved from RAP PI to higher layer.
* 
* Hydra_Software_Devel/152   10/17/08 2:31a speter
* PR 47360: [3548,3556]: Changing the design of Spdif Rx. SPDIF Rx is now
* a device level interrupt and handling of digital input format change
* is moved from RAP PI to higher layer.
* 
* Hydra_Software_Devel/151   10/16/08 5:33a speter
* PR 47852: [3548,3556] Adding multiple branches support for capture
* channel
* 
* Hydra_Software_Devel/150   10/16/08 1:16a speter
* PR 46655: [3548,3556] Changing the ADC related code for B0
* 
* Hydra_Software_Devel/149   10/15/08 9:42p speter
* PR 45444:[3548,3556] Fixing warnings
* 
* Hydra_Software_Devel/148   10/15/08 7:52p gautamk
* PR47934: [7405] Few seconds of noise on SPDIF/HDMI during PCM to
* Compressed .
* 
* Hydra_Software_Devel/147   10/13/08 5:46p gautamk
* PR42213: [7405] Programming SRC for the PB when O/P sample rate is
* different from input, During decode's sample rate interrupt.
* 
* Hydra_Software_Devel/146   10/13/08 4:05p gautamk
* PR43454: [7405] Minor fix
* 
* Hydra_Software_Devel/145   10/12/08 11:51p gautamk
* PR43454: [7405] fixing compilation and warning.
* 
* Hydra_Software_Devel/144   10/10/08 10:33a speter
* PR 47764: [3548,3556] Merging the release branch 3.0 to main line of
* development
* 
* Hydra_Software_Devel/143   10/7/08 6:01p gautamk
* PR46653: [7405] Programming CBits correctly for Decode channel .
* 
* Hydra_Software_Devel/142   9/30/08 3:55p gautamk
* PR47393: [7405] Setting Mixing coefficent at input side mixer for thos
* mixer also which is part of association having only one channel i.e.
* in association where mixing is not happening.
* 
* Hydra_Software_Devel/141   9/30/08 3:40p gautamk
* PR43454:[7405] When ext i2s capture is of mono stream, then
* sSrcChParams.eLRDataCntl = BRAP_SRCCH_P_LRDataControl_L_2_LR;
* 
* Hydra_Software_Devel/140   9/29/08 10:23p gautamk
* PR47344:[7405] fixing warning.
* 
* Hydra_Software_Devel/139   9/29/08 10:32a gautamk
* PR43454: [7405] Fixing compilation.
* 
* Hydra_Software_Devel/138   9/26/08 7:42p gautamk
* PR47358: [7405] Initializing the variables in each run of for loop.
* 
* Hydra_Software_Devel/RAP_354856_PH_3_0/14   10/9/08 3:05p speter
* PR 47226: [3548,3556] Putting in temporary code to allocate ring buffer
* based on the LFE of output. This might have to be changed based on LFE
* of channel to take care of downmix in FMM
* 
* Hydra_Software_Devel/RAP_354856_PH_3_0/13   10/8/08 6:52p speter
* PR 47226: [3548,3556] Adding code in RAP PI to provide the audio mode
* to all post processing algorithm stages.
* 
* Hydra_Software_Devel/RAP_354856_PH_3_0/12   10/8/08 3:26p speter
* PR 45444: [3548,3556] Adding code for hardware equalizer
* 
* Hydra_Software_Devel/RAP_354856_PH_3_0/11   10/7/08 6:05p speter
* PR 45444: [3548,3556] Fixing GetMixerForOp and GetMixerForRbuf to
* reflect the new equalizer related design changes
* 
* Hydra_Software_Devel/RAP_354856_PH_3_0/10   10/7/08 5:00p sgadara
* PR 47576: [3548,3556] Fixing the channel change issue on SPDIF
* passthrough.
* 
* Hydra_Software_Devel/RAP_354856_PH_3_0/9   10/7/08 1:26p speter
* PR 45444: [3548,3556] Adding code for equalizer
* 
* Hydra_Software_Devel/RAP_354856_PH_3_0/8   10/7/08 11:42a sgadara
* PR 47576: [3548,3556] Programming the application provided volume
* levels for destination at start time.
* 
* Hydra_Software_Devel/RAP_354856_PH_3_0/7   10/7/08 9:32a speter
* PR 45444: [3548,3556] Making changes to support multiple outputs with
* Equalizer
* 
* Hydra_Software_Devel/RAP_354856_PH_3_0/6   10/6/08 7:40p speter
* PR 45444: [3548,3556]: Adding generic code for equalizer
* 
* Hydra_Software_Devel/RAP_354856_PH_3_0/5   10/4/08 2:49p speter
* PR 38950: [3548,3556] Changing BDBG_ERR to BDBG_MSG as the case was not
* an error
* 
* Hydra_Software_Devel/RAP_354856_PH_3_0/4   10/3/08 2:54p speter
* Pr 46611: [3548,3556] Fixing the issue in rbuf capture related to
* watermark
* 
* Hydra_Software_Devel/RAP_354856_PH_3_0/3   9/24/08 6:33p speter
* PR 45444: [3548,3556] Removing unwanted code
* 
* Hydra_Software_Devel/RAP_354856_PH_3_0/2   9/24/08 4:04p speter
* PR 45444: [3548,3556] Adding equalizer code.
* 
* Hydra_Software_Devel/RAP_354856_PH_3_0/1   9/23/08 4:57p speter
* PR 45444: [3548,3556]  Changing the implementation of hardware
* equalizer to reflect the latest changes in the equalizer algorithm
* delivered by Arch team
* 
* Hydra_Software_Devel/137   9/19/08 8:42p sgadara
* PR 44770: [3548,3556] Implementing the Destination based Interrupts for
* 'capture to ringbuffer' feature.
* 
* Hydra_Software_Devel/136   9/19/08 8:32p gautamk
* PR45739: [7405] Fixing warning.
* 
* Hydra_Software_Devel/135   9/19/08 8:28p gautamk
* PR45739: [7405] Fixing compilation for other chip
* 
* Hydra_Software_Devel/134   9/19/08 8:02p gautamk
* PR45739: [7405] removing unwanted code.
* 
* Hydra_Software_Devel/133   9/19/08 6:24p gautamk
* PR45739: [7405] Programming StartWR ptr for indep dealy
* And Changing bLargeRbuf to bIndepDelayEnabled
* 
* Hydra_Software_Devel/132   9/19/08 4:51p sushmit
* PR 43454:[7405]Mai should get added to the path of its muxselector
* 
* Hydra_Software_Devel/131   9/18/08 8:59a speter
* PR 38950: [3548,3556] Adding support for SPDIF In
* 
* Hydra_Software_Devel/130   9/17/08 8:13p sushmit
* PR 43454:[7405] Reducing Cit Input Structure Size. Need to move
* allocation runtime later based on no. of actual branches.
* 
* Hydra_Software_Devel/129   9/17/08 3:24p gautamk
* PR46634: [7405] when independent delay is on, Seperate Path is created
* for Internal capture
* 
* Hydra_Software_Devel/128   9/16/08 4:00p speter
* PR 46942: [3548,3556] Merging back to main line of development to get
* the distinct output feature
* 
* Hydra_Software_Devel/127   9/16/08 2:44p sushmit
* PR 43454:[7405]Adding AC3 Encode Support.
* 
* Hydra_Software_Devel/126   9/15/08 3:48p gautamk
* PR43454: [7405] Do not create seperate path/branch for
* bDownmixedOpPort= true O/P, when outputmode is 2_0
* 
* Hydra_Software_Devel/125   9/12/08 1:24p gautamk
* PR45739: [7405] removing unwanted function call.
* 
* Hydra_Software_Devel/124   9/9/08 6:51p sushmit
* PR 46211: [7405] Adding Data swapping support for PCM Playback
* 
* Hydra_Software_Devel/123   9/9/08 3:11p gautamk
* PR42605: [7405] Fixing coverity issue.
* 
* Hydra_Software_Devel/122   9/8/08 5:26p gautamk
* PR45739: [7405] Adding support for indep delay for o/p
* 
* Hydra_Software_Devel/121   9/5/08 4:32p sushmit
* PR 46588:[7405]Removing Path Alloc/Free during channel open/close time
* for PB & CAP.
* 
* Hydra_Software_Devel/RAP_354856_20080904_BRANCH/2   9/5/08 9:12p sgadara
* PR 44835: [3548,3556] Implementing destination-based volume APIs for
* volume control on capture data.
* 
* Hydra_Software_Devel/RAP_354856_20080904_BRANCH/1   9/5/08 2:44p speter
* PR 38950: [3548,3556] Adding support for SPDIF In
* 
* Hydra_Software_Devel/120   9/4/08 11:41a speter
* PR 45444: [3548,3556] Making the equalizer functionality easily
* manageable by using a macro
* 
* Hydra_Software_Devel/119   9/1/08 3:48p sushmit
* PR 45739:[7405]Independent Delay Support.
* 
* Hydra_Software_Devel/118   8/25/08 2:15p speter
* PR 45444: [3548,3556] Implementing the hardware equalizer. Adding extra
* cascaded SRCs for equalizer upsampling, IIR and downsampling
* 
* Hydra_Software_Devel/117   8/22/08 4:52p gautamk
* PR43454: [7405] removing unwanted BDBG_err
* 
* Hydra_Software_Devel/116   8/22/08 4:06p gautamk
* PR43454: [7405] Clone stage of downmix branch , can be a FW stage.
* 
* Hydra_Software_Devel/115   8/21/08 4:35p gautamk
* PR43454: [7405] HDMI 5.1 can also be in PP branch.
* 
* Hydra_Software_Devel/114   8/20/08 6:26p gautamk
* PR43454: [7405] Adding changes in MixersrcLayout function in #else
* case.
* 
* Hydra_Software_Devel/113   8/20/08 6:11p gautamk
* PR43454: [7405] Changes for Concurrent downmix.
* 
* Hydra_Software_Devel/112   8/20/08 4:38p sushmit
* PR 43454:[7405]Multichannel HDMI Change
* 
* Hydra_Software_Devel/111   8/20/08 12:15p sushmit
* PR 43454:[7405] Fixing Clone DST issue for AudioProcessing
* 
* Hydra_Software_Devel/110   8/14/08 3:33p sushmit
* PR 45621:[7405]Added some more checks
* 
* Hydra_Software_Devel/109   8/14/08 2:59p sushmit
* PR 45629:[7405]Quick Stack Reduction Fix.
* 
* Hydra_Software_Devel/108   8/14/08 12:08p sushmit
* PR 43454:[7405]Updating DSOLA Params.
* 
* Hydra_Software_Devel/107   8/8/08 7:04p speter
* PR 45497: [3548,3556] Fixing the problem of ADC with 3 output ports and
* 1 ring buffer destination
* 
* Hydra_Software_Devel/106   8/1/08 10:48a speter
* PR 44895: [3548] To bring up 'capture to ringbuffer'  feature on 3548
* 
* Hydra_Software_Devel/105   8/1/08 9:13a speter
* PR 44895: [3548,3556] To bring up 'capture to ringbuffer'  feature on
* 3548
* 
* Hydra_Software_Devel/104   7/31/08 5:27p gautamk
* PR45180: [7335] Fixing warning for vxworks
* 
* Hydra_Software_Devel/103   7/30/08 3:13p gautamk
* PR43454: [7405] Some minor fixes
* 
* Hydra_Software_Devel/102   7/29/08 3:11p gautamk
* PR45180: [7335] Fixing compiler error for vxworks
* 
* Hydra_Software_Devel/101   7/28/08 9:48a speter
* PR 45171: [3548,3556] Merging from Phase 2.0 release to main line of
* development (Hydra_Software_Devel)
* 
* Hydra_Software_Devel/100   7/24/08 3:12p gautamk
* PR45087 : [7405]Fixing coverity issue
* PR45088 : [7405]
* PR45089 : [7405]
* 
* Hydra_Software_Devel/99   7/23/08 9:33p gautamk
* PR43454: [7405] Adding PI support for WMA Passthru
* 
* Hydra_Software_Devel/98   7/23/08 4:24p gautamk
* PR44143: [7405] AACHE LOAS is the default audio type when its chosen
* AACHE
* 
* Hydra_Software_Devel/RAP_354856_PH_2_0/2   7/25/08 11:34a speter
* PR 45032: [3548,3556] Adding SRC and Internal Capture port to the
* capture path of ADC to enable downsampling ADC so that DRAM and DSP
* can handle the ADC input data
* 
* Hydra_Software_Devel/RAP_354856_PH_2_0/1   7/24/08 10:21a speter
* PR 45032: [3548,3556] Add DSP support to capture channel (I2S In and
* ADC In)
* 
* Hydra_Software_Devel/97   7/22/08 3:22p speter
* PR 45032: [3548,3556] Adding DSP support to SPDIF/HDMI In
* 
* Hydra_Software_Devel/96   7/22/08 1:30p speter
* PR 45032: [3548,3556] Adding DSP support to SPDIF/HDMI In
* 
* Hydra_Software_Devel/95   7/19/08 12:19a sushmit
* PR43454: [7405] Removing BDBG_ERR
* 
* Hydra_Software_Devel/94   7/18/08 11:17a speter
* PR 44780: [3548,3556] Support for HDMI In
* 
* Hydra_Software_Devel/93   7/17/08 6:18p sgadara
* PR 44895: [3548] To bring up 'capture to ringbuffer'  feature on 3548.
* 
* Hydra_Software_Devel/92   7/17/08 3:28p gautamk
* PR43454: [7405] Fixing the broken Capture/Plaback after Multiple
* association feature.
* 
* Hydra_Software_Devel/91   7/17/08 1:49p gautamk
* PR43454:[7405] Implementing delta code review comment.
* 
* Hydra_Software_Devel/90   7/16/08 5:16p sushmit
* PR 43454: [7405] Fixing PCM Capture
* 
* Hydra_Software_Devel/89   7/16/08 10:07p gautamk
* PR43454: [7405] Implementing delta code review.
* 
* Hydra_Software_Devel/88   7/11/08 3:13p sushmit
* PR 43454: [7405] Fixing Compilation warnings in kernel mode
* 
* Hydra_Software_Devel/87   7/11/08 4:35p gautamk
* PR43454: [7405] adding the Macro for checking validity of
* Branch/Stage/network
* 
* Hydra_Software_Devel/86   7/10/08 6:23p gautamk
* PR41825: [7405] merging the code for multiple associatio from Branch to
* mainline.
* 
* Hydra_Software_Devel/85   7/10/08 1:27p gautamk
* PR43454: [7405] Config parameters for any audio type can be changed
* irrespective of what audio type is currently running.
* 
* Hydra_Software_Devel/84   7/9/08 3:33p sushmit
* PR 44646: [7325] KLOCWORK fix
* 
* Hydra_Software_Devel/83   7/9/08 10:22a speter
* PR 44660:[3548,3556] Merging the Phase 1.5 release branch code to main
* line of development
* 
* Hydra_Software_Devel/82   7/8/08 7:20p gautamk
* PR43454: [7405] written function to determine if the path outputs
* compress data.
* 
* Hydra_Software_Devel/81   7/4/08 4:29p gautamk
* PR43454: [7405] Implementation for Adaptive rate ctrl (2ms lipsync)
* 
* Hydra_Software_Devel/80   7/3/08 11:30p gautamk
* PR42605: [7405] fixing coverity issues for 7405
* 
* Hydra_Software_Devel/79   6/30/08 4:37p gautamk
* PR43454: [7405] removing Enter/Leave statement from Lower level
* function.
* 
* Hydra_Software_Devel/78   6/30/08 4:19p gautamk
* PR43454: [7405] removing unwanted debug message.
* 
* Hydra_Software_Devel/77   6/30/08 3:53p gautamk
* PR43454: [7405] debug message
* 
* Hydra_Software_Devel/76   6/26/08 9:13p gautamk
* PR43454: [7405] Adding sanity check for the network for audio
* processing stages.
* 
* Hydra_Software_Devel/75   6/24/08 7:05a speter
* PR 38950: [3548,3556] Adding support for SPDIF In without DSP
* 
* Hydra_Software_Devel/74   6/20/08 5:57p gautamk
* PR43454: [7405] Adding function determine if the the brancg is cloned
* or not.
* 
* Hydra_Software_Devel/73   6/20/08 12:32a speter
* PR 42110: [3548,3556] Making error to message in AD for SRC
* 
* Hydra_Software_Devel/72   6/19/08 5:54a speter
* PR 42110: [3548,3556] Adding SRC support to ADC
* 
* Hydra_Software_Devel/71   6/17/08 6:22p gautamk
* PR43454: [7405] Fixing compilation warning for VXworks.
* 
* Hydra_Software_Devel/70   6/17/08 5:05p gautamk
* PR43454: [7405] removing BDBG_ERR statement
* 
* Hydra_Software_Devel/69   6/17/08 4:25p gautamk
* PR43454: [7405] Rbuf for HBR is allocated only if BHBREnable is true
* for MAI Port.
* 
* Hydra_Software_Devel/68   6/16/08 12:35a speter
* PR 38950: [3548,3556] Fixing the SPDIF and HDMI In related code
* 
* Hydra_Software_Devel/67   6/15/08 2:42a speter
* PR 42110: [3548,3556] Adding ADC support. Providing Sampling rate from
* application
* 
* Hydra_Software_Devel/66   6/14/08 7:58a speter
* PR 42110: [3548,3556] Adding ADC support
* 
* Hydra_Software_Devel/65   6/12/08 6:21p gautamk
* PR43454: [7405] For HBR on DDP, setting the Start WR pointer
* accordingly
* 
* Hydra_Software_Devel/64   6/11/08 7:49a speter
* PR38950: [3548,3556] Changing generic use of BTSC as RF Audio
* 
* Hydra_Software_Devel/63   6/11/08 7:30a speter
* PR38950: [3548,3556] Changing generic use of BTSC as RF Audio
* 
* Hydra_Software_Devel/62   6/10/08 4:06p sushmit
* PR 38783: [7405] Moving fix to newarch
* 
* Hydra_Software_Devel/61   6/2/08 3:32p sushmit
* PR 41726: [7405] Fixing early triggering of Interrupt for PCM Playback.
* 
* Hydra_Software_Devel/60   6/2/08 1:59p gautamk
* PR41726: [7405] removing unwanted functions and enums
* 
* Hydra_Software_Devel/59   5/29/08 9:47p gautamk
* PR41726: [7405] doing Memset after Malloc
* 
* Hydra_Software_Devel/58   5/29/08 3:29p gautamk
* PR41726: [7405] Adding function to insert/destroy stages internally in
* Task network.
* 
* Hydra_Software_Devel/57   5/28/08 11:39p gautamk
* PR41726: [7405] Modifying files for AAC/AAC-HE LOAS/ADTS
* 
* Hydra_Software_Devel/56   5/20/08 1:55p speter
* PR 42110: [3548,3556] Adding ADC support
* 
* Hydra_Software_Devel/55   5/16/08 1:40p gautamk
* PR42726: [7405] coverity issued fixed
* 
* Hydra_Software_Devel/54   5/14/08 4:29p speter
* PR 38950: [3548,3556] Adding code to support HIFIDAC1 and HIFIDAC2
* 
* Hydra_Software_Devel/53   5/9/08 3:00p speter
* PR 38950: [3548,3556] Fixing the code for 3548 family
* 
* Hydra_Software_Devel/52   5/9/08 2:10p gautamk
* PR42526: [7405] Closing DSPCHN in ungetChannelPath()
* 
* Hydra_Software_Devel/51   5/5/08 11:42a speter
* PR 38950: [3548] Making 3548_FAMILY macro and using it for both 3548
* and 3556 cases.
* 
* Hydra_Software_Devel/50   5/2/08 2:46p gautamk
* PR41726: [7405] Adding PI support for Fw Verification in mainline
* 
* Hydra_Software_Devel/49   4/30/08 7:41p gautamk
* PR42335: [7405] downgrade non-error BDBG_ERR's to either WRN or MSG
* 
* Hydra_Software_Devel/48   4/28/08 4:30p speter
* PR 38950: [3548] Fixing compilation for 3548/3556.
* 
* Hydra_Software_Devel/47   4/23/08 8:03p gautamk
* PR42092: [7405] Fixing the check for return value of BRap_Allocaligned.
* 
* Hydra_Software_Devel/46   4/22/08 2:01p gautamk
* PR41994: [7405] Using BCHP_VER_ Correctly...
* 
* Hydra_Software_Devel/45   4/21/08 6:25p gautamk
* PR41726: [7405] IMplementing review comments start/stop APis
* 
* Hydra_Software_Devel/44   4/17/08 2:24p gautamk
* PR41726: [7405] fixing coverity issue.
* 
* Hydra_Software_Devel/43   4/16/08 12:08p gautamk
* PR41726: [7405] Coverity fixes.
* 
* Hydra_Software_Devel/42   4/14/08 10:34p sushmit
* PR 41726: [7405] Added support for sampling rates 8K, 11.025K & 12K.
* 
* Hydra_Software_Devel/41   4/14/08 1:54p sushmit
* PR 34648: [7405] Fixing Memory Leak on Decode Channel Close
* 
* Hydra_Software_Devel/40   4/11/08 5:12p sushmit
* PR 41365: [7405] Allowing only AC3 Passthru without license.
* 
* Hydra_Software_Devel/39   4/11/08 3:52p sushmit
* PR 34648: [7405] Removing deprecated bSupportDec/Enc/PPAlgos
* 
* Hydra_Software_Devel/38   4/10/08 6:13p sushmit
* PR 34648: [7405] DDP Passthru Bringup.
* 
* Hydra_Software_Devel/37   4/8/08 2:23p gautamk
* PR34648: [7405] Merging wdog code to mainline
* 
* Hydra_Software_Devel/RAP_NEWFWARCH_WDOG/3   4/8/08 2:02p gautamk
* PR34648: [7405] Merging wdog code to mainline
* 
* Hydra_Software_Devel/RAP_NEWFWARCH_WDOG/2   4/1/08 2:28p gautamk
* PR34648: [7405] Merging change to wdog branch
* 
* Hydra_Software_Devel/26   3/31/08 12:13p nitinb
* PR 34648: [7405] Implemented review comments: Removed unused handle
* hArc from memory read/write functions. Removed function
* BRAP_P_DummyMemRead32().
* 
* Hydra_Software_Devel/25   3/27/08 10:55p sushmit
* PR 34648: [7405] Adding XptContextMap to RapCh for saving over
* flush/watchdog
* 
* Hydra_Software_Devel/24   3/24/08 2:48p sushmit
* PR 34648: [7405] Kernel Mode Unaligned Memory Access Fix, removing
* BDBG_ERRs, fix for multiple dest.
* 
* Hydra_Software_Devel/23   3/19/08 5:05p gautamk
* PR34648: [7405] replacing BDBG_ERR with BDBG_MSG
* 
* Hydra_Software_Devel/22   3/18/08 7:00p gautamk
* PR34648: [7405] Fixing Bugs for GenCItOutput and createProcessing stage
* 
* Hydra_Software_Devel/21   3/17/08 10:40p sushmit
* PR 34648: [7405] Adding default event enable mask to start task params
* & fixing HDMI passthru when both SPDIF & HDMI are configured for
* passthru
* 
* Hydra_Software_Devel/20   3/14/08 11:55a gautamk
* PR34648: [7405] Merging the branched code to mainline
* 
* Hydra_Software_Devel/19   3/13/08 2:45p sushmit
* PR 34648: [7405] Checking in AACHE Support Changes
* 
* Hydra_Software_Devel/18   3/13/08 11:28a sushmit
* PR 34648: [7405] Fixing Broken PCM Playback
* 
* Hydra_Software_Devel/17   3/6/08 12:19p sushmit
* PR 34648: [7405] Removing Bringup Hacks of Gate Open Programming &
* HifiDac Programming as FW is doing these now.
* 
* Hydra_Software_Devel/16   3/5/08 9:21p sushmit
* PR 34648: [7405] Moving latest fixes to base3
* 
* Hydra_Software_Devel/15   3/3/08 3:51p sushmit
* PR 39255: [7405] Moving output port timebase related changes to base3
* 
* Hydra_Software_Devel/14   3/3/08 2:52p gdata
* PR34648: [7405] Fixing coverity defects.
* 
* Hydra_Software_Devel/13   3/3/08 2:50p gautamk
* PR34648: [7405] Fixing coverity defects.
* 
* Hydra_Software_Devel/12   2/28/08 10:02a gdata
* PR34648: [7405] Changes of review comment
* 
* Hydra_Software_Devel/11   2/27/08 4:40p sushmit
* PR 40006: [7405] Adding Fix for Dec Channel, need to add more
* 
* Hydra_Software_Devel/10   2/26/08 6:39p gautamk
* PR34648: [7405] Fixing bugs and programming RDBDsp Offset to CIT.
* 
* Hydra_Software_Devel/9   2/22/08 4:54p gdata
* PR34648: [7405] fixing coverity defects
* 
* Hydra_Software_Devel/8   2/22/08 4:19p gautamk
* PR34648: [7405] fixing coverity defects + implementing review comments
* 
* Hydra_Software_Devel/7   2/15/08 5:26p gdata
* PR34648: [7405] Adding the changes to support the interrupt install
* before channel start
* 
* Hydra_Software_Devel/6   2/7/08 5:38p nitinb
* PR34648: [7405] Fixed compilation warnings.
* 
* Hydra_Software_Devel/5   1/31/08 5:24p gautamk
* PR34648: [7405] Removing BRAP_DSPCHN_DecodeMode_eSimulMode Enum
* 
* Hydra_Software_Devel/4   1/29/08 7:04p gautamk
* PR34648: [7405] programming CDB/ITB END_PTR
* 
* Hydra_Software_Devel/3   1/28/08 7:47p gautamk
* PR34648: [7405] Adding config param programming for Ac3 as per new
* design in which hRap stores config struct in the Format FW expects
* 
* Hydra_Software_Devel/2   1/24/08 12:04a sushmit
* PR34648: [7405] Merging in updated code from Base2
* 
* Hydra_Software_Devel/378   1/21/08 11:03a speter
* PR 28188: [3563] Fixing the capture to file (ring buffer destination)
* for SPDIF input
* 
* Hydra_Software_Devel/377   1/18/08 2:34p sushmit
* PR 38695: [7405] Updating PI so that both SPDIF & HDMI can be supported
* on passthru channel with Mai taking data straight from mixer.
* 
* Hydra_Software_Devel/376   1/17/08 6:34p gdata
* PR38790: [7440] Adding support for LPCM_A_DVD
* 
* 
* Hydra_Software_Devel/375   1/14/08 11:53a sushmit
* PR 36003: [7405] Fixing AAC Passthru & compilation warnings.
* 
* Hydra_Software_Devel/374   1/9/08 8:17p bhanus
* PR38296: [7440] Changes done during DTS-HD SUB Audio bring up.
* 
* Hydra_Software_Devel/373   1/7/08 2:20p gdata
* PR38296: [7440] Adding config structure support for DTSHD SUB audio
* 
* Hydra_Software_Devel/372   1/2/08 1:54p gdata
* PR 32582 : [7440] Adding the chnage in open time buffer
* Not allocate the buffer if audio processing is DtsNeo and SM is also
* enabled from application.
* 
* Hydra_Software_Devel/371   12/27/07 12:26p bhanus
* PR 32582 : [7440] Added the DTS Neo Bring up changes.
* 
* Hydra_Software_Devel/370   12/24/07 3:47p gdata
* PR37996: [7440] Using cache write to speed up the memory write at FW
* download
* 
* Hydra_Software_Devel/369   12/20/07 3:15p sushmit
* PR 36084: [7405] Proper storage for scaling coeffs created
* 
* Hydra_Software_Devel/368   12/20/07 2:11p gdata
* PR 38328:[7440] Fixing compilation break.
* 
* Hydra_Software_Devel/367   12/20/07 11:38a bhanus
* PR 38328:[7440] Adding support for DDBM Config 2a and 2b
* 
* Hydra_Software_Devel/366   12/20/07 11:30a gdata
* PR38296: [7440] Adding support for DTSHD SUB audio
* 
* Hydra_Software_Devel/365   12/19/07 9:52p sushmit
* PR 36084: [7405] Fixing Mixing case for independent output volume
* control
* 
* Hydra_Software_Devel/364   12/19/07 7:48p bhanus
* PR 38328:[7440] Fixing compilation break.
* 
* Hydra_Software_Devel/363   12/19/07 12:10p bhanus
* PR 38328:[7440] Adding support for DDBM Config 2a and 2b
* 
* Hydra_Software_Devel/362   12/17/07 1:30p sushmit
* PR 36084: [7405] Making bIndOpVolCtrl start time parameter common for
* all platforms.
* 
* Hydra_Software_Devel/361   12/17/07 12:27p sushmit
* PR 38063: [7405] Adding bLoopAroundEn flag for PCM Playback
* 
* Hydra_Software_Devel/360   12/16/07 7:16p sushmit
* PR 36084: [7405] Adding support for adding separate mixer per output
* port.
* 
* Hydra_Software_Devel/359   12/14/07 10:37a bhanus
* PR37880: [7440] Fixing the issues introduced due to merge on main line.
* 
* Hydra_Software_Devel/358   12/4/07 8:26p gdata
* PR37880: [7440] Merging the Massproduction branch to main branch.
* 
* Hydra_Software_Devel/357   11/27/07 10:37a speter
* PR 37577: [3563] Merging branch Phase2.9 to main line
*
* Hydra_Software_Devel/356   11/21/07 2:55p sushmit
* PR 36823: [7405] Minor Changes
* 
* Hydra_Software_Devel/355   11/19/07 5:00p sushmit
* PR 36822: [7405] Fixing issues with passthru channel for combined SPDIF
* & HDMI compressed output
* 
* Hydra_Software_Devel/354   11/19/07 3:16p sushmit
* PR 36822: [7405] Making MAI take data straight from Mixer.
* 
* Hydra_Software_Devel/353   11/13/07 1:24p speter
* PR 36669: [3563] Fixing the Custom Voice Interframe buffer size. This
* was causing noise with PL2 - SRS combination
* 
* Hydra_Software_Devel/352   11/13/07 12:17p speter
* PR 34996: [3563] Fixing the custom equalizer both Fcorner simultaneous
* programming problem
* 
* Hydra_Software_Devel/RAP_7405_PR36115/1   11/15/07 1:07p sushmit* PR 36115: [7405] Fixing MAI programming so that HDMI CBITs get sent* out.* * Hydra_Software_Devel/351   11/6/07 3:12p sushmit
* PR 36115: [7405] Fixing PCM-HDMI Cbit programming.
* 
* Hydra_Software_Devel/350   11/2/07 11:41a sushmit
* PR 36003: [7405] Fixing a return call
* 
* Hydra_Software_Devel/349   10/26/07 12:36p kagrawal
* PR 36461: [7440] Also increasing the FW buffer sizes for DTS-HD algo to
* supports 2048 Frame Size certification
* 
* Hydra_Software_Devel/RAP_7440_Phase2C_MassProduction/2   10/26/07 12:33p kagrawal
* PR 36461: [7440] Also increasing the FW buffer sizes for DTS-HD algo to
* supports 2048 Frame Size certification
* 
* Hydra_Software_Devel/348   10/26/07 11:39a kagrawal
* PR 36461: [7440] Increasing the DTS algo FW buffer sizes for
* certification that supports 2048 Frame Size
* 
* Hydra_Software_Devel/RAP_3563_PH_2_9/5   11/19/07 2:49p speter
* PR 37278: [3563] Implementing multiple post processing branches so that
* the effects of one PP does not affect the other output ports. Capture
* Channel related fix
* 
* Hydra_Software_Devel/RAP_3563_PH_2_9/4   11/17/07 1:03p speter
* PR 37278: [3563] Implementing multiple post processing branches so that
* the effects of one PP does not affect the other output ports
* 
* Hydra_Software_Devel/RAP_3563_PH_2_9/3   11/5/07 6:25p speter
* PR 34996: [3563] Fixing the custom equalizer both Fcorner simultaneous
* programming problem
* 
* Hydra_Software_Devel/RAP_3563_PH_2_9/2   11/5/07 5:33p speter
* PR 36083: [3563] Moving the Custom Mixer requirement code in a branch
* 
* Hydra_Software_Devel/RAP_3563_PH_2_9/1   10/31/07 1:16p speter
* PR 36083: [3563] Fixing the resource exhausted problem due to the new
* mixer cascade requirement in SPDIF In
* 
* Hydra_Software_Devel/347   10/25/07 3:03p sushmit
* PR 36003: [7405] Updated WMAPRO Support
* 
* Hydra_Software_Devel/346   10/25/07 1:40a gautamk
* PR36409: [3563] Fixing Coverity issue for 3563 RAP Code base
* 
* Hydra_Software_Devel/345   10/24/07 4:17p speter
* PR 28188: [3563] Fixing the cloning with Output port as first
* destination and Ring Buffer as second destination
* 
* Hydra_Software_Devel/344   10/24/07 2:37p speter
* PR 36397: [3563] Fixing issue in SPDIF IN passthru
* 
* Hydra_Software_Devel/343   10/24/07 11:18a sushmit
* PR 36003: [7405] Checking in WMAPRO support, need RDB update from FW
* team.
* 
* Hydra_Software_Devel/342   10/23/07 5:00p sushmit
* PR 36083: [3563] Independent Delay & Custom Mixer Requirement working
* together.
* 
* Hydra_Software_Devel/341   10/23/07 12:59p speter
* PR 36083: [3563] Fixing memory leak for 3563.
* 
* Hydra_Software_Devel/340   10/22/07 2:37p sushmit
* PR 36003: [7405] Fixing compilation errors due to recent 7440/3563
* checkins.
* 
* Hydra_Software_Devel/339   10/22/07 2:01p speter
* PR 34102: [3563] Downloading AAC HE executables for AAC. This also
* implies that the default downmix required for AAC can now be
* discarded.
* 
* Hydra_Software_Devel/338   10/19/07 3:56p speter
* PR 36083: [3563] Fixing the destinations order so that the custom mixer
* layout works properly.
* 
* Hydra_Software_Devel/337   10/19/07 12:03a speter
* PR 36083: [3563] Fixing the cloning problems in the Mixer cascade
* 
* Hydra_Software_Devel/336   10/18/07 8:01p speter
* PR 36083: [3563] Fixing the level problem in the mixer cascade
* 
* Hydra_Software_Devel/335   10/18/07 5:23p speter
* PR 36083: [3563] Fixing the API SetGain and Amplification to use the
* Mixer level in BRAP_P_GetMixerForOpPort. This also requied isolating
* BRAP_P_GetMixerForOpPort for 3563.
* 
* Hydra_Software_Devel/334   10/18/07 4:28p speter
* PR 36083: [3563] Fixing the 3 Mixer custom Requirement
* 
* Hydra_Software_Devel/333   10/18/07 2:14p speter
* PR 36083: [3563] Checking in the new Volume APIs related changes.
* 
* Hydra_Software_Devel/332   10/15/07 4:02p speter
* PR 36100: [3563] Merge the 2.8 Release branch to main line
* 
* Hydra_Software_Devel/331   10/12/07 12:33p gdata
* PR36008: [7440] Merging the debug support for FW decode params to main
* branch
* 
* Hydra_Software_Devel/330   10/12/07 12:22p sushmit
* PR 36003: [7405] Adding support for memory leak debug
* 
* Hydra_Software_Devel/RAP_3563_PH_2_8/2   10/15/07 2:28p speter
* PR 28188: [3563] Fixing the capture path zero (The capture path with ID
* zero is meant only for the capture part of SPDIF / HDMI / BTSC and
* I2S)
* 
* Hydra_Software_Devel/RAP_3563_PH_2_8/1   10/12/07 2:39p speter
* PR 34996: [3563] Fixing the swap issue in custom equalizer
* 
* Hydra_Software_Devel/329   10/11/07 4:53p speter
* PR 28188: [3563] Modifications to support capturing to file in SPDIF Rx
* mode
* 
* Hydra_Software_Devel/328   10/11/07 4:09p sushmit
* PR 36003: [7405] Fixing Memory Leaks & Extra Initializers
* 
* Hydra_Software_Devel/327   10/11/07 1:49p sushmit
* PR 36003: [7405] PCM Capture Bringup for 7405
* 
* Hydra_Software_Devel/326   10/11/07 1:31p sushmit
* PR 36003: [7405] Bringing up Internal Capture for 7405
* 
* Hydra_Software_Devel/325   10/9/07 6:02p gdata
* PR 35751 : [7440] Exposing the control of enable/disable soft limit
* cofficients to application.
* 
* Hydra_Software_Devel/324   10/9/07 9:28a gdata
* PR35793: [7440] Fixing the compilation break
* 
* Hydra_Software_Devel/323   10/8/07 5:19p gdata
* PR35793: [7440] Fixing the coverity issue
* 
* Hydra_Software_Devel/322   10/8/07 2:29p kagrawal
* PR 35788: [7440,7405,3563] Fixing BKNI memory leak in
* BRAP_UngetChannelPaths()
* 
* Hydra_Software_Devel/321   10/5/07 7:41p gdata
* PR35413 : [7440] Merging handling for DTS-CD compressed on main branch
* 
* Hydra_Software_Devel/320   10/4/07 2:43p gautamk
* PR35688: [7405] Implementing FW authentication support (NDS support)
* for 7405 code base.
* 
* Hydra_Software_Devel/319   10/4/07 2:12p sushmit
* PR 35464: [7405] BRAP_DSP_P_Close memory leak fixed & some other
* changes for memory leak debugging
* 
* Hydra_Software_Devel/318   10/1/07 7:13p gdata
* PR32768: [7440] Added BRAP_GetSecMetadataInfo() debug function.
* 
* Hydra_Software_Devel/317   9/30/07 1:58p sushmit
* PR35140: [7405] Develop 7325 Raptor PI for Bringup
* 
* Hydra_Software_Devel/316   9/28/07 4:02p speter
* PR 29166: [3563] Fixing the BERR_TRACE which was throwing error
* messages on the console
* 
* Hydra_Software_Devel/315   9/28/07 1:45p gdata
* PR35409 : [7440][HiDef-DVD PR6157 & PR5983 ]: Fixing compilation break
* for 3563 & 7405
* 
* Hydra_Software_Devel/314   9/28/07 11:22a gdata
* PR35409 : [7440][HiDef-DVD PR6157 & PR5983 ]:
* Fixing two seperate issues.
* - Fixing the problem of pointer dereferencing. Pointer of decode
* compressed path of primary channel is getting freed at secondary
* channel. So later when primary channel is again trying to access that
* pointer application crashes.
* 
* -Correcting the programming of downmix coeff also which is not related
* to above crash.
* 
* Hydra_Software_Devel/313   9/28/07 9:41a speter
* PR 35335: [3563] Fixing the playback and decode mixing for more than
* one output port (cloning case).
* 
* Hydra_Software_Devel/312   9/26/07 10:20a kagrawal
* PR 35357: [7440] [HiDef-Dvd PR6135] Fixing BKNI memory leak in Open SM
* and XCD paths
* 
* Hydra_Software_Devel/311   9/25/07 9:34a gdata
* PR35327: [7440] [HifiDef-PR6045] Correcting the down mixing coefficient
* values which were read from the wrong array.
* 
* Hydra_Software_Devel/310   9/24/07 4:29p gdata
* PR 32827: [7440] Increased DTS-LBR 3-Stage FW buffer memory sizes:
* - Interframe buffer from 20k to 30k
* - scratch buffer from 0k to 7k
* 
* Hydra_Software_Devel/309   9/24/07 11:44a speter
* PR 35304: [3563] Merge the Phase 2.7 release code to main line
* 
* Hydra_Software_Devel/RAP_3563_PH_2_7/1   9/24/07 10:24a speter
* PR 35074: [3563] Adding additional user parameters for PEQ increases
* the size of the buffer to be programmed.
* 
* Hydra_Software_Devel/308   9/19/07 3:35p speter
* PR 35074: [3563] Providing RAP PI support for PEQ post processing
* algorithm
* 
* Hydra_Software_Devel/307   9/18/07 5:03p speter
* PR 34996: [3563] Adding support for Custom Mode Equalizer
* 
* Hydra_Software_Devel/306   9/18/07 3:09p sushmit
* PR 34860: [7405][3563] Fixing issue when pAudioParams->eInputSR is set
* to BAVC_AudioSamplingRate_eUnknown for STB/DTV App.
* 
* Hydra_Software_Devel/305   9/17/07 3:50p speter
* PR 34559: [3563] Fixing multiple destination problem in PCM playback
* 
* Hydra_Software_Devel/304   9/14/07 12:06p gdata
* PR 32768: [7440] Code modifications for Secondary Metadata
* 
* Hydra_Software_Devel/303   9/13/07 7:03p kagrawal
* PR 34823: [7440] Fixing BKNI memory leak
* 
* Hydra_Software_Devel/302   9/11/07 12:09p speter
* PR 34376: [3563] Custom Voice sizes updated.
* 
* Hydra_Software_Devel/301   9/7/07 4:06p speter
* PR 34673: [3563] Merging the Phase 2.6 branch to mainline
* 
* Hydra_Software_Devel/300   9/7/07 11:54a gdata
* PR34672 : [7440] Fixing the problem with PCM channel playback with
* encoder. Fixed by having two mixing levels in DecPCM path.
* 
* Hydra_Software_Devel/1   1/22/08 4:47p sushmit
* PR34648: [7405] Merging in updated code from Base2
* 
* Hydra_Software_Devel/Rap_7405_NewFwIf/8   1/16/08 5:03p gdata
* PR34648: [7405]  Adding changes for getchannelpath and distribute
* destination
* 
* Hydra_Software_Devel/Rap_7405_NewFwIf/7   1/16/08 11:57a sushmit
* PR34648: [7405] Downloading CIT to DRAM
* 
* Hydra_Software_Devel/Rap_7405_NewFwIf/6   1/10/08 6:46p gautamk
* PR34648: [7405] Files for Mapping Processing network to CIT input
* 
* Hydra_Software_Devel/Rap_7405_NewFwIf/5   1/10/08 3:18p sushmit
* PR 34648: [7405] Removing hDsp from hDspChn
* 
* Hydra_Software_Devel/Rap_7405_NewFwIf/4   1/3/08 2:19p bhanus
* PR34648: [7405] Adding changes for Channel Audio Processing network for
* CIT module.
* 
* Hydra_Software_Devel/Rap_7405_NewFwIf/3   12/14/07 2:05p gautamk
* PR34648: [7405] Adding updated files for download FW modules
* 
* Hydra_Software_Devel/Rap_7405_NewFwIf/2   10/31/07 1:43p nitinb
* PR 34648: [7405] Implemented review comments of new API interface as
* mentioned in PR progress-log (dated 10/31/2007)
* 
* Hydra_Software_Devel/Rap_7405_NewFwIf/1   10/3/07 4:49p gautamk
* PR34648: [7405] checkin updated files for new PI/FW arch
* 
* Hydra_Software_Devel/299   9/5/07 3:18p gdata
* PR 32827: [7440] Merging DTS-LBR 3-Stage support to
* Hydra_Software_Devel branch
* 
* Hydra_Software_Devel/RAP_7440_DTSLBR_3Stages/1   9/4/07 4:49p gdata
* PR 32827: [7440] Adding support for 3 stage DTS-LBR
* 
* Hydra_Software_Devel/RAP_3563_PH_2_6/1   9/6/07 1:20p speter
* PR 34460: [3563] Changing code to use 'Custom' for specific Post
* procesing algorithms
* 
* Hydra_Software_Devel/298   8/31/07 2:22p sushmit
* PR 34135: [7405] Fixing AAC-HE memory.
* 
* Hydra_Software_Devel/297   8/30/07 1:47a bhanus
* PR 34438 : [7440] Removing the hack for even number of consumers at one
* level. Done proper fix.
* 
* Hydra_Software_Devel/296   8/29/07 7:57a bhanus
* PR 34412 : [7440] Making StartWRPoint for Cap buffers to be fixed at
* 4096 bytes from base address as that is the minimum requirement. We
* can not keep in terms of percentage as it would change StartWRPoint
* with size of buffer.
* 
* Hydra_Software_Devel/295   8/29/07 1:58a bhanus
* PR 34412 : [7440] Setting the StartWR point to 8% (Two Frame size) of
* RBUF size.
* 
* Hydra_Software_Devel/294   8/29/07 1:51a bhanus
* PR 34412 : [7440]Added fix to copy the base and End Address for DB path
* RBUFs same as that of Capture Ring Buffers.
* 
* Hydra_Software_Devel/293   8/28/07 11:29a kagrawal
* PR 34359 : [7440] Fixed seg-fault due to the check-in for stack
* reduction changes
* 
* Hydra_Software_Devel/292   8/28/07 7:15a bhanus
* PR 34359 : [7440] Fixing Multichannel to Stereo transition issue.
* 
* Hydra_Software_Devel/291   8/27/07 3:13p speter
* PR 34376: [3563] RAP PI support for Custom Voice
* 
* Hydra_Software_Devel/290   8/27/07 12:17p sushmit
* PR 34135: [7405] Updating AACHE support & merging in stack reduction
* fixes.
* 
* Hydra_Software_Devel/289   8/27/07 10:54a speter
* PR 33362: [3563] Including enum BRAP_P_UsgPath_eDlyBalance to be part
* of 3563 though it is used only for 7440. Otherwise there are so many
* places where #ifdef Sequential path is required.
* 
* Hydra_Software_Devel/288   8/26/07 4:45a bhanus
* PR 33362 : [7440] Added code for mixingLevelOnly in DB path.
* 
* Hydra_Software_Devel/287   8/24/07 7:01p bhanus
* PR 34340 : [7440] Added code to do downmix in DB path.
* 
* Hydra_Software_Devel/286   8/24/07 6:26a bhanus
* PR 34325 : [7440] Changing the programming of SrcCh in DB path for
* unsigned content.
* 
* Hydra_Software_Devel/285   8/23/07 7:37p bhanus
* PR 34280 : [7440] Fixed the mixer input allocation for downmixing on
* PCM PB channels.
* 
* Hydra_Software_Devel/284   8/23/07 8:28a bhanus
* PR 34262 : [7440] Fixed the Audio drop on Multichannel by:
* - Changing uiStartWRPoint for DB path rbuf to be 3992 bytes from base
* address.
* - Changing Capture RBUF size to 48k
* 
* Hydra_Software_Devel/283   8/21/07 2:29p kagrawal
* PR 33094: [7440] Adding support to feed HBR compressed to I2s_multi1 -
* fixed a bug in appropriate path creation
* 
* Hydra_Software_Devel/282   8/21/07 2:08p speter
* PR 34202: [3563] Provide Custom Bass post processing algorithm support
* 
* Hydra_Software_Devel/281   8/20/07 6:37p kagrawal
* PR 34154: [7440] Putting WMA-PRO only if not 7440
* 
* Hydra_Software_Devel/280   8/20/07 3:29p kagrawal
* PR 34154: [3563] Fixed compilation breaks due to last check in
* 
* Hydra_Software_Devel/279   8/20/07 2:52p kagrawal
* PR 34154: [7440] Fixed compilation breaks due to auto merge
* 
* Hydra_Software_Devel/278   8/20/07 2:27p kagrawal
* PR 34154: [7440] Merged from 7440_Phase2B_Fixes branch
* 
* Hydra_Software_Devel/REFSW_RAP_7405_PR34312/1   8/24/07 5:19p sushmit
* PR 34312: [7405] Reducing Stack Size
* 
* Hydra_Software_Devel/277   8/17/07 3:32p sushmit
* PR 34135: [7405] Adding WMA Support
* 
* Hydra_Software_Devel/276   8/17/07 2:06p sushmit
* PR 34135: [7405] Adding WMA Support
* 
* Hydra_Software_Devel/275   8/10/07 4:38p speter
* PR 33403: [3563] AAC_HE LOAS/ADTS support merged to main line.
*
* Hydra_Software_Devel/274   8/10/07 4:29p speter
* PR 33935: [3563] Fixing compilation break in 3563 and C++ style
* comments warnings.
* 
* Hydra_Software_Devel/273   8/10/07 2:59p bhanus
* PR 33935 : [7440] Fixing allocation of 3 mixer inputs for PCM PB
* channel in DB path.
* 
* Hydra_Software_Devel/272   8/9/07 3:06p sushmit
* PR 30552: [3563] Added Channel Link Create/Destroy APIs. Modified
* BRAP_ProcessDigitalInputFormatChange to take care of Simul mode for
* compressed input.
* 
* Hydra_Software_Devel/271   8/7/07 9:35p bhanus
* PR 33804: [7440] Fixed Stack Overflow Issue
* 
* Hydra_Software_Devel/270   8/6/07 10:50p bhanus
* PR 33804: [7440] Fixed DecodeCompressed path copy and free for PCM
* Playback channel.
* 
* Hydra_Software_Devel/269   8/3/07 9:00p gautamk
* PR33771 : [7440] : Removing Assert(0) , which was causing segmentaion
* fault
* 
* Hydra_Software_Devel/268   8/3/07 2:25p sushmit
* PR 27646: [7405] Updating PT sizes for AAC etc. for Phase 1.0 testing.
* Also enabling both AC3 & AC3+ support for 7405 when RAP_DDP_SUPPORT is
* enabled.
* 
* Hydra_Software_Devel/267   8/2/07 5:37p speter
* PR 33403: [3563] Reverting the changes for AAC HE as the support is
* added in branch and not on main line
* 
* Hydra_Software_Devel/266   8/2/07 3:14p sushmit
* PR 27646: [7405] Increased MPEG passthru size & updated ST_GA register
* related code
* 
* Hydra_Software_Devel/265   8/2/07 11:55a speter
* PR 33403: [3563] AAC SBR multichannel support with 3 executables
* support added in RAP PI
*
* Hydra_Software_Devel/RAP_3563_AAC_HE_ADTS_LOAS_SUPPORT/1   8/2/07 5:03p speter
* PR 33403: [3563] AAC SBR multichannel support with 3 executables
* support added in RAP PI
* 
* Hydra_Software_Devel/264   7/30/07 5:53p speter
* PR 33608: [3563] Algo Sizes for Custom Surround post processing algorithm
* 
* Hydra_Software_Devel/263   7/30/07 4:25p kagrawal
* PR 33094: [7440] Added Watchdog Recovery support for DB path
* 
* Hydra_Software_Devel/262   7/30/07 11:35a kagrawal
* PR 32582: [7440] Checking in proper FW buffer sizes for DTS-Neo
* 
* Hydra_Software_Devel/261   7/27/07 10:17p kagrawal
* PR 32986: [7440] Removing a redundant error check that was obstructing
* 7.1 to 5.1 downmix mixer linking
* 
* Hydra_Software_Devel/260   7/27/07 3:21p speter
* PR 32986: [3563] Fixing the problem in PrepareFCI ID for the external
* capture ports of 3563 and 7405.
* 
* Hydra_Software_Devel/259   7/27/07 12:18p kagrawal
* PR 32986: [7440] Fixing mixer allocation for mixingOnlyLevel for
* sequential path
* 
* Hydra_Software_Devel/258   7/26/07 4:45p speter
* PR 33477: [3563] Merge the Phase 2.3 branch to main
* 
* Hydra_Software_Devel/257   7/26/07 11:54a kagrawal
* PR 32986: [7440] Fixing mixer allocation for even number of cloned
* output ports at 2 or more levels
* 
* Hydra_Software_Devel/256   7/26/07 10:04a kagrawal
* PR 32504: [7440] Increasing DTS-HD Table size from 179992 bytes to
* 180060 bytes
* 
* Hydra_Software_Devel/255   7/25/07 3:22p kagrawal
* PR 32504: [7440] HD-DVD LPCM User Config Changes to accomodate [32][8]
* coeffs instead of [8][8]
* 
* Hydra_Software_Devel/254   7/25/07 12:43p kagrawal
* PR 33094: [7440] Compressed HBR - Increasing decode channel ring-buffer
* size from 48k to 96k
* 
* Hydra_Software_Devel/253   7/25/07 12:14p kagrawal
* PR 33094: [7440] HBR compressed support - increased interframe memory
* for
* - DDP7.1 from 0 to 0x18100
* - MLP from 0 to 62000
* 
* Hydra_Software_Devel/252   7/18/07 6:38p gautamk
* PR33094 : [7440] Adding Support for Passthru mode For Algo DDP7.1, MLp
* and DTSHD (HBR Mode),
* 
* Hydra_Software_Devel/251   7/18/07 3:22p kagrawal
* PR 33089: [7440] Passing dual mono mode to DVD LPCM using user config
* param
* 
* Hydra_Software_Devel/250   7/17/07 2:59p kagrawal
* PR 32986 : [7440 B0] Code modified for Sequential path bring up.
* - Added HBR path support
* 
* Hydra_Software_Devel/249   7/17/07 10:55a kagrawal
* PR 32504: [7440] Increasing DTS-HD interframe size from 70678 bytes to
* 136500 bytes
* 
* Hydra_Software_Devel/248   7/16/07 6:44p bhanus
* PR 32986 : [7440 B0] Code modified for Sequential path bring up.
* - Removed Dead Code
* - Making code common for Decode and PCM PB channel for GetChannelPath
* function.
* 
* Hydra_Software_Devel/247   7/15/07 2:05p bhanus
* PR 32986 : [7440 B0] Code modified for running two 5.1 capture in
* parallel.
* 
* Hydra_Software_Devel/246   7/13/07 2:48p bhanus
* PR 32986: [7440 B0] Code modified for copy path in Sequantial path
* implementation.
* 
* Hydra_Software_Devel/245   7/13/07 1:47p bhanus
* PR 32986: [7440 B0] Code modifed for Sequential path bring up.
* 
* Hydra_Software_Devel/244   7/12/07 10:12a bhanus
* PR 32768 : [7440 B] Modified code for Secondary Metadata bring up.
* 
* Hydra_Software_Devel/243   7/10/07 4:24p sushmit
* PR 31453: Fixing seg fault for SPDIF passthru case & also removing SRC-
* MIXER linkage code for linking src & mixers at different levels.
* 
* Hydra_Software_Devel/242   7/10/07 12:12p bmishra
* PR 32828 : [3563] Fixed the compilation issue for 3563 in the fucntion
* BRAP_P_IsDstAlreadyPresent
* 
* Hydra_Software_Devel/241   7/9/07 6:33p bmishra
* PR 23951: Fixed the issue of PCM Playback causing segmentation fault
* when ring buffer is choosen as destination
* 
* Hydra_Software_Devel/240   7/9/07 4:21p bhanus
* PR 32828 : [7440 B] Code modified for Bitstream HBR bring up.
* - Added condition to throw error if App tries to add any compressed
* output port along with HBR compressed.
* 
* Hydra_Software_Devel/239   7/9/07 4:14p gautamk
* PR32827 : Adding PI support for DTS LBR Multi Channel
* 
* Hydra_Software_Devel/238   7/9/07 3:20p gautamk
* PR32789: [7440] Add Phase2B Feature - PCM Playback in Interrupt Mode
* 
* Hydra_Software_Devel/RAP_3563_PH_2_3/4   7/12/07 1:40p sushmit
* PR 28719: Removing BERR_TRACE call temporarily for 3563 in ConvertSR
* 
* Hydra_Software_Devel/RAP_3563_PH_2_3/3   7/12/07 12:19p sushmit
* PR 28719:
* As same SRCCH can't drive multiple SRCs, making one SRC drive multiple
* mixers for non-independent delay case.
* Programming the SR_DELAY registers only if the output port has
* independent delay enabled
* Taking in change in ISIF buffer alloc
* Making BDBG_ERR to BDBG_MSG in BRAP_P_ConvertSR for 3563 only,
* 
* Hydra_Software_Devel/RAP_3563_PH_2_3/2   7/11/07 5:31p sushmit
* PR 28719: Fixed SOURCECH_CFGi register programming & getting rbuf from
* pool for shared rbufs.
* 
* Hydra_Software_Devel/RAP_3563_PH_2_3/1   7/10/07 5:24p nitinb
* PR 30069: Fixing seg fault for SPDIF passthru case & also removing SRC-
* MIXER linkage code for linking src & mixers at different levels
* 
* Hydra_Software_Devel/237   7/6/07 4:30p sushmit
* PR 32735: Updation of CBIT programming by HOST/DSP
* 
* Hydra_Software_Devel/236   7/5/07 4:13p sushmit
* PR 32735: Support on the fly change of SPDIF channel status bits from
* host through DSP.
* 
* Hydra_Software_Devel/235   7/5/07 10:20a kagrawal
* PR 32504: Adding watchdog support for SM, HBR, DTS-Neo
* 
* Hydra_Software_Devel/234   7/4/07 3:04p bmishra
* PR 23951: Enabled capture path for ring buffer as destination
* 
* Hydra_Software_Devel/233   7/3/07 9:15p bhanus
* PR 32691 :  Fix for audio lost during comp->enc/pcm transition [HiDef-
* Dvd PR 4600]
* - Resetting the Internal Dst during CloseDecPath.
* 
* Hydra_Software_Devel/232   7/3/07 7:03p bmishra
* PR 23951: Merging Autotrap related changes
* 
* Hydra_Software_Devel/231   7/3/07 12:28p bhanus
* PR 32730 : Fxing Hidef-DVD PR4723
* - Fixed linking error introduced by last check-in.
* - Fixing SRC allocation.
* 
* Hydra_Software_Devel/230   7/2/07 2:34p kagrawal
* PR 32691: Merging from 7440 Phase1 branch
* - Fix for audio lost during comp->enc/pcm transition [HiDef-Dvd PR
* 4600]
* - Moving CapPort stop after SrcCh stop
* - Enabled wait for group disable logic for SrcCh
* 
* Hydra_Software_Devel/7440_Phase1.0_Fixes/2   7/2/07 2:29p kagrawal
* PR 32691: Fix for audio lost during comp->enc/pcm transition [HiDef-Dvd
* PR 4600]
* - Moving CapPort stop after SrcCh stop
* - Enabled wait for group disable logic for SrcCh
* 
* Hydra_Software_Devel/229   7/2/07 11:49a sushmit
* PR 28719: Checkin Independent Delay Update
* 
* Hydra_Software_Devel/228   7/1/07 10:26a sushmit
* PR 28719: Checkin Independent Delay Update
* 
* Hydra_Software_Devel/227   6/29/07 12:41a kagrawal
* PR 32504: [7440] Adding code to handle HBR/SM output ports in any
* sequence
* 
* Hydra_Software_Devel/226   6/28/07 9:29p kagrawal
* PR 32504: [7440] For HBR path, SrcCh should be interleaved
* 
* Hydra_Software_Devel/225   6/28/07 4:37p kagrawal
* PR 32582: [7440] Enabling capture path for DTS-Neo in non-sequential
* mode
* 
* Hydra_Software_Devel/224   6/28/07 4:15p sushmit
* PR 30171: Mixers allocated at same level
* 
* Hydra_Software_Devel/223   6/28/07 2:47p gautamk
* PR32504: Increasing the no of exec for DTS from 2 to 5.
* 
* Hydra_Software_Devel/222   6/27/07 10:07p kagrawal
* PR 32504: Added bound check for ParallelPath to prevent hOp corruption.
* Increased BRAP_RM_P_MAX_PARALLEL_PATHS to 5 for 7440.
* 
* Hydra_Software_Devel/221   6/27/07 8:36p gautamk
* PR32504: Providing  SPDIF0/1 C-bit  params to DSP1 for XCD.
* 
* Hydra_Software_Devel/220   6/27/07 12:28p gautamk
* PR32504: PR30069: Adding support for having SPDIF0 +SPDIF1 enabled
* together for Simul  mode.
* 
* Hydra_Software_Devel/219   6/26/07 11:40a bhanus
* PR 32504 :[7440 BO] Code modified for 7.1 Downmix support.
* 
* Hydra_Software_Devel/218   6/26/07 11:16a gautamk
* PR30069: Adding support for having SPDIF0 +SPDIF1 enabled together for
* Simul and XCD mode.
* 
* Hydra_Software_Devel/217   6/22/07 2:49p bhanus
* PR 30069 : [7440 B] Fixed SRC allocation and SRC SRAM allocation issue
* (HiDef DVD PR 4508)
* 
* Hydra_Software_Devel/216   6/22/07 11:59a sushmit
* PR 27646: 7405 Bringup
* 
* Hydra_Software_Devel/215   6/20/07 12:22p sushmit
* PR 28188: Fixing RBUF Close
* 
* Hydra_Software_Devel/214   6/19/07 10:44a kagrawal
* PR30069: Added BRAP_MIXER_P_ConvertVolInDbTo5_23Format function.
* 
* Hydra_Software_Devel/213   6/18/07 3:05p sushmit
* PR 28188: Modified BRAP_P_CloseCapPath so that RBUFs & DSTCHs don't get
* closed if not allocated in OpenCapPath
* 
* Hydra_Software_Devel/212   6/18/07 1:50p sushmit
* PR 28188: Adding RBUF support to BRAP_RemoveDestination
* 
* Hydra_Software_Devel/211   6/15/07 8:04p gautamk
* PR30069: [7440] Added DTS-Extension Support.
* 
* Hydra_Software_Devel/210   6/15/07 5:06p kagrawal
* PR 30069: Fixing compilation breaks in 3563
* 
* Hydra_Software_Devel/209   6/15/07 2:26p kagrawal
* PR 30069: [7440] Merging Phase2.0 branch to Hydra_Software_Devel
* 
* Hydra_Software_Devel/RAP_7440_Phase2.0_Branch/9   6/14/07 1:41p kagrawal
* PR 30069: [7440] Changed FW buffer sizes for SM
* 
* Hydra_Software_Devel/RAP_7440_Phase2.0_Branch/8   6/14/07 1:30p bhanus
* PR 30069 : [7440 B0] Added code to support:
* - HBR path
* - HBR configuration of I2sMulti_1 and Mai
* - Passing HBR flag to DSP1
* 
* Hydra_Software_Devel/RAP_7440_Phase2.0_Branch/7   6/13/07 7:30p gautamk
* PR30069: Adding Private functon BRAP_P_GetInterchannelVolume , which
* populates volume for each channel, which in turn is written to DDBM
* Config params.
* 
* Hydra_Software_Devel/RAP_7440_Phase2.0_Branch/6   6/12/07 5:50p kagrawal
* PR 30069: [7440] Added support for independent channel delay for DSP1
* audio processing
* 
* Hydra_Software_Devel/RAP_7440_Phase2.0_Branch/5   6/11/07 7:05p gautamk
* PR30069: New Config Parameter structure for Speaker Management
* 
* Hydra_Software_Devel/RAP_7440_Phase2.0_Branch/4   6/11/07 3:31p gautamk
* PR30069: New Config Parameter structure for Speaker Management
* 
* Hydra_Software_Devel/RAP_7440_Phase2.0_Branch/3   6/11/07 10:53a kagrawal
* PR 30069: [7440] DTS-Neo needs stereo input - Added support for non-
* sequential path only
* 
* Hydra_Software_Devel/RAP_7440_Phase2.0_Branch/2   6/9/07 5:29p kagrawal
* PR 30069: [7440] Added support for DTS-Neo PostProcessing
* 
* Hydra_Software_Devel/RAP_7440_Phase2.0_Branch/1   6/7/07 2:20p kagrawal
* PR 30069: Added support for branches and stages for DSP1 audio post
* processing
* 
* Hydra_Software_Devel/208   6/14/07 7:26p gautamk
* PR30069: Changes for new algorithm Mpeg MC
* 
* Hydra_Software_Devel/207   6/14/07 5:15p gautamk
* PR30069: [7440] Error check for DDP 7.1 Simul mode
* 
* Hydra_Software_Devel/206   6/14/07 4:49p gautamk
* PR30069: Adding Algorithm DDP 7.1
* 
* Hydra_Software_Devel/205   6/14/07 3:55p bhanus
* PR 30069 : [7440 B0] Added support for playing unsigned content for PCM
* PB channel.
* 
* Hydra_Software_Devel/204   6/13/07 2:52p nitinb
* PR 30789: Support MPEG2 LSF audio decoding
* 
* Hydra_Software_Devel/203   6/13/07 1:49p sushmit
* PR 27646: Temporary fix of 7405 compilation break
* 
* Hydra_Software_Devel/202   6/13/07 1:33p sushmit
* PR 27646: 7405 PI Update
* 
* Hydra_Software_Devel/201   6/13/07 9:39a kagrawal
* PR 32070: Added support for sampling rates 8kHz, 12kHz and 11.025kHz
* 
* Hydra_Software_Devel/200   6/12/07 8:24p sushmit
* PR 27646: Fixing 7405 FMM
* 
* Hydra_Software_Devel/199   6/12/07 4:54p sushmit
* PR 27646: 7405 PI Update
* 
* Hydra_Software_Devel/198   6/11/07 9:05p nitinb
* PR 29166: Moved volume states from output handle to RAP handle. This
* removes restriction of calling add destination API before calling
* volume APIs.
* 
* Hydra_Software_Devel/197   6/11/07 4:56p gautamk
* PR31912: Removing warning message
* "AUD_FMM_BF_CTRL_SOURCECH_GROUP_ENABLE_STATUS=0x1 is not disabled"
* 
* Hydra_Software_Devel/196   6/9/07 5:33p bhanus
* PR 30069 : [7440 B0] Fixed issues for SPDIF1 (Hidef -DVD PR 4254)
* 
* Hydra_Software_Devel/195   6/8/07 3:19p bhanus
* PR 30069 : [7440 B0] Added code for HDMI HBR Compressed Support.
* 
* Hydra_Software_Devel/194   6/7/07 3:47p speter
* PR 31930: [3563] The coefficients for the Equalizer and Tone control
* needs to be swapped to get the desired behavior
* 
* Hydra_Software_Devel/194   6/7/07 3:44p speter
* PR 31930: [3563] The coefficients for the Equalizer and Tone control
* needs to be swapped to get the desired behavior
* 
* Hydra_Software_Devel/193   6/7/07 7:25p bhanus
* PR 30069 : [7440B0] Added code for Secondary Metadata Processing.
* 
* Hydra_Software_Devel/192   6/7/07 5:32p bhanus
* PR 30069 : [7440 B0] Fixed issue of updating associated usage path (
* HiDef-DVD PR 4196)
* 
* Hydra_Software_Devel/191   6/6/07 4:36p nitinb
* PR 31865: Enable support for AAC-HE in 3563 RAP PI
* 
* Hydra_Software_Devel/190   6/5/07 10:57a speter
* PR 31827: [3563] Merging from Phase 2.0 release branch to main
* 
* Hydra_Software_Devel/189   6/4/07 4:03p bhanus
* PR 30069 :[7440 B0] Fixed issue of Interleaving in DstCh for sequential
* path for PCM PB channel.
* 
* Hydra_Software_Devel/188   6/4/07 2:07p bhanus
* PR 30069 :[7440 B0] Added Support for SPDIF1 and I2SMulti0 as Mux
* Select for HDMI
* 
* Hydra_Software_Devel/187   6/1/07 2:58p sushmit
* PR 30069: XCD Watchdog Recovery Fixed.
* 
* Hydra_Software_Devel/186   6/1/07 11:28a kagrawal
* PR 30069: Adding support for BAVC_StreamType_eMpeg1System
* 
* Hydra_Software_Devel/185   5/31/07 3:48p sushmit
* PR 30069: XCD DEC & PB Start-Stop-Start
* 
* Hydra_Software_Devel/184   5/29/07 3:57p kagrawal
* PR 30069: Fixing issue reported by Coverity
* 
* Hydra_Software_Devel/183   5/28/07 1:34p bhanus
* PR 30069 : Fixed Coverity Issues.
* 
* Hydra_Software_Devel/RAP_3563_PH_2_0/4   6/4/07 3:55p speter
* PR 31798: [3563] Segmentation fault fix in Playback. hDspChn was being
* accessed in Playback case where it is null. Avoiding hDspchn access in
* case of playback channel.
* 
* Hydra_Software_Devel/RAP_3563_PH_2_0/3   5/29/07 10:58a speter
* PR 31246: Noise on first time reboot has been fixed. Warnings also
* supressed.
* 
* Hydra_Software_Devel/RAP_3563_PH_2_0/2   5/29/07 2:23p sushmit
* PR 28719: Fixing wrong code checked in.
* 
* Hydra_Software_Devel/RAP_3563_PH_2_0/1   5/29/07 1:45p sushmit
* PR28719: Adding code for independent delay & fixing MULPP broken
* 

* Hydra_Software_Devel/182   5/25/07 6:22p kagrawal
* PR 30069: Added first-cut PB watchdog support
* 
* Hydra_Software_Devel/181   5/24/07 6:20p kagrawal
* PR 30069: [7440 B0] Added support for stereo output on multi-I2s1
* 
* Hydra_Software_Devel/180   5/24/07 2:39p sushmit
* PR 27646: 7405 Compilation & linking
* 
* Hydra_Software_Devel/179   5/23/07 5:52p nitinb
* PR 31498: Merge RAP PI development from phase 1.7 branch to main branch
* 
* Hydra_Software_Devel/RAP_3563_PH_1_7/1   5/15/07 3:01p nitinb
* PR 28180: Add protection code for audio latch up in low level code
* 
* Hydra_Software_Devel/178   5/15/07 3:28p bhanus
* PR 30069 : Fixed an issue in preparing mixer request for downmixing
* introduced due to not resetting bInputMixLvl flag.
* 
* Hydra_Software_Devel/177   5/15/07 2:29p bhanus
* PR 30069: Fixed a Issue of invalid initialization in DecPCM Path for
* switching between PCM to Transcode over SPDIF.
* 
* Hydra_Software_Devel/176   5/14/07 5:24p kagrawal
* PR 30069: [7440] Added following support:
* - BRAP_P_GetBaseSR(), BRAP_P_GetPLLForSR(), BRAP_P_IsInternalCapPort()
* - Added AM changes for allocating Fs Timing Source
* - Allocating internal capPort in OpenCapPath()
* - Removed internal capPort copy and remove hack from
* BRAP_P_StartFmmModuleHandles
* - Populating sInPathProp->uiPathIdx for SM and XCD
* 
* Hydra_Software_Devel/175   5/12/07 2:24p sushmit
* PR 27646: Fixing Memory Leak
* 
* Hydra_Software_Devel/174   5/11/07 8:59p sushmit
* PR 27646: Getting 7405 PI compiled
* 
* Hydra_Software_Devel/173   5/11/07 12:29p kagrawal
* PR 30069: Added code for SPDIF1
* 
* Hydra_Software_Devel/172   5/10/07 2:44p gautamk
* PR30069: Changes for Any to Any resource linking
* 
* Hydra_Software_Devel/171   5/9/07 12:09p bhanus
* PR 30069 : [7440 B0] Code modified for :
* - Unified SR Support
* - Copy Path to enable Mixing on Sequential Path
* 
* Hydra_Software_Devel/170   5/8/07 4:18p bhanus
* PR 30069: Fixed a issue where Audio Mode of decode channel was getting
* reset in CloseDecPath.
* 
* Hydra_Software_Devel/169   5/8/07 12:27p bhanus
* PR 30069 : Fixed the issue of not closing mixer on channel stop.
* 
* Hydra_Software_Devel/168   5/7/07 4:36p nitinb
* PR 28862: [3563] Added support for post processing algorithm BBE
* 
* Hydra_Software_Devel/167   5/6/07 6:42p bhanus
* PR 30069 : [7440 B0] Added code for :
* - Unified Sampling Rate
* - Copy path for Sequential Path
* - Enabling PCM playback on Sequential Path
* 
* Hydra_Software_Devel/166   5/6/07 3:27p kagrawal
* PR 30069: Added support for reusing an already opened/started path
* 
* Hydra_Software_Devel/165   5/4/07 2:48p bhanus
* PR 30069 : Fixed a bug introduced for non-sequential path
* implementation.
* 
* Hydra_Software_Devel/164   5/4/07 12:25p sushmit
* PR 30069: Fixing DEC Path watchdog after recent changes
* 
* Hydra_Software_Devel/163   5/4/07 11:57a sushmit
* PR 30069: Watchdog recovery support for ENC/XCD
* 
* Hydra_Software_Devel/162   5/3/07 4:58p speter
* PR 28716: [3563] SpdifRx, Input Spdif from Comp1->Comp2 switching
* support added. Major code revamp done in SpdifRx Module.
* 
* Hydra_Software_Devel/161   5/3/07 4:43p speter
* PR 30400: [3563] Merge happened from branch RAP_3563_PH_1_6 to
* Hydra_Software_Devel. After that it was found that 7440 common code
* throws warnings for unused variables in 3563. Fixing the same.
* 
* Hydra_Software_Devel/160   5/3/07 4:12p speter
* PR 30400: [3563] Merged the changes done as part of Phase 1.6 Release
* to the main line. Merge happened from branch RAP_3563_PH_1_6 to
* Hydra_Software_Devel
* 
* Hydra_Software_Devel/159   5/2/07 12:16p kagrawal
* PR 30069: Adding initial support for Watchdog Recovery
* 
* Hydra_Software_Devel/158   4/28/07 6:21p sushmit
* PR 28561: Fixing Start-Stop-Start of XCD
* 
* Hydra_Software_Devel/157   4/27/07 6:20p bhanus
* PR 30069 : Fixed the Rbuf size and startWr point for PCM PB channel.
* 
* Hydra_Software_Devel/156   4/27/07 5:27p gautamk
* PR30069: Fixing SrcCh and DstCh stop sequence limitation . And adding
* function I2sHwConfigMulti/I2sHwConfigConfig for B0
* 
* Hydra_Software_Devel/155   4/26/07 7:35p bhanus
* PR 30069 : Code Modified for sequential path bring up
* 
* Hydra_Software_Devel/154   4/24/07 7:26p gautamk
* PR30069: Changes for 7.1 Output mode support
* 
* Hydra_Software_Devel/153   4/24/07 7:21p nitinb
* PR 29169: [3563] Allocated seperate mixers for cloned output ports to
* achieve seperate volume controls for cloned outputs
* 
* Hydra_Software_Devel/152   4/24/07 2:29p gautamk
* PR30069: Changes for 7.1 Output mode support
* 
* Hydra_Software_Devel/151   4/23/07 4:33p sushmit
* PR 28561: Fixed Ext CAP issue for 3563
* 
* Hydra_Software_Devel/150   4/20/07 1:57p bhanus
* PR 28561 : Fixed the issue in MixerSrclayout introduced by last
* changes.
* 
* Hydra_Software_Devel/149   4/19/07 11:43a kagrawal
* PR 28561: Added uiPthOpenCnt and uiPthStartCnt in BRAP_P_ObjectHandles
* a.k.a. pPath
* 
* Hydra_Software_Devel/148   4/18/07 6:53p kagrawal
* PR 28561: Increased DTS-LBR interframe size from 10240 to 20480
* 
* Hydra_Software_Devel/147   4/18/07 5:14p bhanus
* PR 28561 : Modified MixerSRCLayout for making it generic to be used by
* all paths.
* - Added code for sequential path implementation.
* 
* Hydra_Software_Devel/146   4/18/07 4:34p sushmit
* PR 28561: HDMI Destination should not start a Cap Path
* 
* Hydra_Software_Devel/145   4/18/07 4:30p sushmit
* PR 28714: Using field in DspChn instead of separate APIs
* 
* Hydra_Software_Devel/144   4/18/07 10:33a kagrawal
* PR 28561: Proper RM for CapPort and relevant changes in AM that removes
* hardcoding with internal capport usage
* 
* Hydra_Software_Devel/143   4/17/07 5:17p nitinb
* PR 29914: RAP PI internal state variables not getting reset on channel
* stop
* 
* Hydra_Software_Devel/142   4/16/07 4:45p kagrawal
* PR 28561: [7440] Updated firmware buffer sizes for DTS-LBR
* - Code clean up
* 
* Hydra_Software_Devel/141   4/16/07 2:11p sushmit
* PR 28561: Fixing 3563 Compilation error due to last checkin.
* 
* Hydra_Software_Devel/140   4/16/07 9:46a kagrawal
* PR 28561: Reduced channel handle size by changing sPath[] to *pPath[]
* 
* Hydra_Software_Devel/139   4/13/07 2:34p sushmit
* PR 28561: Fixing AddDestination for HDMI for transcoded output
* 
* Hydra_Software_Devel/138   4/11/07 2:38p bhanus
* PR 28561 : Fixed Sampling rate issue for PCM playback Channel
* 
* Hydra_Software_Devel/137   4/11/07 1:43p kagrawal
* PR 28561: Fixed a seg fault due to uninitialize structure in
* ProgramDownMixCoefficients()
* 
* Hydra_Software_Devel/136   4/10/07 4:44p nitinb
* PR 29381: Fixed seg fault for 3563
* 
* Hydra_Software_Devel/135   4/10/07 12:19p speter
* PR 27912: Fixed Open time allocation problem for DecIn Ring Buffer
* 
* Hydra_Software_Devel/134   4/10/07 11:58a nitinb
* PR 29381: Malloc/Free large size structures instead of allocating on
* stack to prevent stack overflow
* 
* Hydra_Software_Devel/133   4/10/07 10:35a sushmit
* PR29166: Removing warning
* 
* Hydra_Software_Devel/132   4/9/07 8:16p sushmit
* PR 29166:
* Volume Change: Left & Right volume level stored in hOp instead of
* hMixer. SetVolume added during Op_start.
* Mute Status Change: Mute status stored properly in hOp. SetMute added
* during Op_Start.
* Set/Get BTSC Mode: Includes open & run time BTSC mode & config changes.
* Added BtscParams in Inputconfig & CapportParams.
* Tone Control changes: Modified so that these can be changed even before
* start.
* 
* Hydra_Software_Devel/131   4/9/07 2:12p speter
* PR 28710: Provide 200 steps for equalizer / tone control parameters
* 
* Hydra_Software_Devel/130   4/9/07 9:48a kagrawal
* PR 28561: AC3_LossLess needs burst repetition period just like AC3 and
* AC3Plus
* 
* Hydra_Software_Devel/129   4/6/07 1:52p sushmit
* PR 28188: Adding Sampling Rate field to BRAP_RbufDetails.
* 
* Hydra_Software_Devel/128   4/5/07 4:35p speter
* PR 28931: [3563] Adding DTS Passthru support in SPDIF/HDMI In. Added
* note for 7440/3563 capture path handling in distribute destinations
* 
* Hydra_Software_Devel/127   4/5/07 2:53p sushmit
* PR 28188: Fixing output sampling rate of internal capture for 3563 to
* 48KHz
* 
* Hydra_Software_Devel/126   4/4/07 1:30a nitinb
* PR 28865: Added support for post processing algorithm XEN
* 
* Hydra_Software_Devel/125   4/3/07 1:45p sushmit
* PR 28714: Multiple PP branch support
* 
* Hydra_Software_Devel/124   4/2/07 5:21p kagrawal
* PR 29403: [7440] Fixing error from concurrent stereo output ports along
* with multi-channel speaker managed output ports.
* - Increasing uiLevel even for internal destination in
* BRAP_P_MixerSrcRsrcLayout()
* 
* Hydra_Software_Devel/123   4/1/07 6:52a bhanus
* PR 28934 :[7440 B0] Added code for CAP Port Grouping.
* 
* Hydra_Software_Devel/122   3/30/07 6:13p kagrawal
* PR 28561: [7440] Enabled BRAP_SetAudioProcessingConfig() and
* BRAP_GetAudioProcessingConfig() APIs
* 
* Hydra_Software_Devel/121   3/29/07 7:10p speter
* PR 28713: Making the change specific to 3563. Earlier it was common to
* both 3563 and 7440
* 
* Hydra_Software_Devel/120   3/29/07 5:16p kagrawal
* PR 28561: Fixed compilation breaks for 3563 due to the last check-in
* 
* Hydra_Software_Devel/119   3/29/07 5:05p kagrawal
* PR 28561: [7440] Adding support for DDBM user config params
* 
* Hydra_Software_Devel/118   3/29/07 4:40p nitinb
* PR 28983: Fixed programming of output ports in DSPCHN start parameters
* for all parallel paths
* 
* Hydra_Software_Devel/117   3/29/07 4:07p speter
* PR 28713: Adding DSP Start functionality for capture channel. Fixing
* capture channel related bugs
* 
* Hydra_Software_Devel/116   3/29/07 10:51a kagrawal
* PR 28920: [7440 A0, 3563] Fix for audio drag/drop issue.
* - Proper FCI linking for mixer loop back
* 
* Hydra_Software_Devel/115   3/28/07 5:11p nitinb
* PR 28177: Audio, Application need an API to set Spdif Channel Status
* raw data to Spdif Tx
* 
* Hydra_Software_Devel/114   3/28/07 3:36p kagrawal
* PR 28561: [7440] Fixed seg-fault in SM due to the last check-in
* 
* Hydra_Software_Devel/113   3/27/07 4:00p kagrawal
* PR 28561: [7440] Adding support for DTS-LBR
* 
* Hydra_Software_Devel/112   3/27/07 11:59a speter
* PR 28718: Spdif Rx code organisation related changes
* 
* Hydra_Software_Devel/111   3/24/07 1:14a bhanus
* PR 28934 : Fixed SRC linking for multiple destinations on different
* Sample Rate.
* 
* Hydra_Software_Devel/110   3/22/07 3:24p kagrawal
* PR 28561: Removing checks against MLP and DDLossLess
* 
* Hydra_Software_Devel/109   3/21/07 10:33p bhanus
* PR 28934 : [7440 B0] Modified the FCI ID calculation logic for loopback
* from DP.
* - Removed extra Debug messages.
* 
* Hydra_Software_Devel/108   3/21/07 5:07p kagrawal
* PR 28561: Fixed SM start-stop sequence for a PB channel. Destroy timer
* from close cap_path is called only when a ring buffer has been added
* as a destination.
* 
* Hydra_Software_Devel/107   3/21/07 11:56a kagrawal
* PR 28917: [7440, 3563]
* - Fixed mixer request preparation code to properly allocate mixers for
* concurrent output ports (Test case: 5.1 I2s0, 2.0 DAC, I2s4 and SPDIF)
* - Corrected error handling in BRAP_P_StartOpPathFmmModules() because of
* which an error was not propagated properly
* 
* Hydra_Software_Devel/106   3/16/07 5:08p gautamk
* PR27912 : Implementaion of Open time memory allocation for Ring Buffers
* 
* Hydra_Software_Devel/105   3/16/07 1:39p sushmit
* PR 26864: Fixing wrong configparams for PLII
* 
* Hydra_Software_Devel/104   3/15/07 8:52a sushmit
* PR 26864: Termporary fix for BTSC Start Issue.
* 
* Hydra_Software_Devel/103   3/15/07 2:21a bhanus
* PR 28040 : [7440 B0] Merging the changes done during bring up from 7440
* B0 Bring up branch to main branch
* 
* Hydra_Software_Devel/102   3/13/07 1:05p speter
* PR 27999: Removing unused variable to avoid compilation warning
* 
* Hydra_Software_Devel/101   3/13/07 12:34p sushmit
* PR 26864: Fixing seg fault for CAP Channel.
* 
* Hydra_Software_Devel/100   3/12/07 6:15p sushmit
* PR 28561: Fixing external CAP for 3563, Capture Only Mode.
* 
* Hydra_Software_Devel/99   3/12/07 4:10p nitinb
* PR 26864: Corrected interstage buffer sizes for post processing
* algorithms
* 
* Hydra_Software_Devel/98   3/12/07 2:33p sushmit
* PR 28561: Fixing Internal CAP for both 7440 & 3563.
* 
* Hydra_Software_Devel/97   3/10/07 5:03p speter
* PR 27999: Fix for spdif compressed input and buffer for ac3 config
* increased to match the code
* 
* Hydra_Software_Devel/96   3/10/07 4:20p sushmit
* PR 28561: Fixing Internal CAP for both 7440 & 3563.
* 
* Hydra_Software_Devel/95   3/10/07 1:11a nitinb
* PR 26864: Corrected PL-II interframe buffer size
* 
* Hydra_Software_Devel/94   3/7/07 11:14a kagrawal
* PR 27912: Checking in SetGain/GetGain code [on behalf of Bhanu]
* 
* Hydra_Software_Devel/93   3/6/07 4:38p speter
* PR 27999: Fix for GetMixerForOpPort
* 
* Hydra_Software_Devel/92   3/6/07 1:04p kagrawal
* PR 27912: Checking memPtr in BRAP_P_Free() before freeing the mem
* 
* Hydra_Software_Devel/91   3/5/07 3:38p kagrawal
* PR 27912: Output PLL programming fix:
* 1. Setting BRAP_FW_TO_PROGRAM_OUTPUT_PORT_PLL to 0 for 7440 and 1 for
* all others
* 2. [7440] PI should program the output PLL for ports carrying PCM data
* 3. [7440] FW should program the output PLL for ports carrying
* compressed data
* 
* Hydra_Software_Devel/90   3/5/07 10:24a speter
* PR 27999: Fix for Equalizer/Tone Controller
* 
* Hydra_Software_Devel/89   3/2/07 5:01p speter
* PR 27999: Equalizer Tone Control Fix
* 
* Hydra_Software_Devel/88   3/2/07 11:28a kagrawal
* PR 27912: PI support for Speaker Management. Added following pvt
* functions
* - BRAP_P_OpenSMPath
* - BRAP_P_CloseSMPath
* - BRAP_P_StartSMPath
* - BRAP_P_StopSMPath
* - BRAP_P_GetSRFromOpDetails
* 
* Hydra_Software_Devel/87   3/1/07 10:07a kagrawal
* PR 27912: New MIT changes for 7440
* 
* Hydra_Software_Devel/86   2/27/07 9:33p kagrawal
* PR 27912: Fixed compilation error for 3563
* 
* Hydra_Software_Devel/85   2/27/07 9:02p kagrawal
* PR 27912: Modifications to take Audio Processing config params
* 
* Hydra_Software_Devel/84   2/27/07 6:27p nitinb
* PR 26864: Support post processing algorithms like SRS, AVL and PL-II in
* 3563 RAP PI
* 
* Hydra_Software_Devel/83   2/26/07 4:09p speter
* PR 27999: Enabled AAC and DTS passthru in PI
* 
* Hydra_Software_Devel/82   2/23/07 4:01p kagrawal
* PR 27912: Fixed Downmixing decision for level 0
* 
* Hydra_Software_Devel/81   2/23/07 1:37p sushmit
* PR 25607: Fixing Internal Capture & XCD for 7440.
* 
* Hydra_Software_Devel/80   2/22/07 2:40p bhanus
* PR 27912 : Fixed Mixing Coeff issue for compressed path.
* 
* Hydra_Software_Devel/79   2/22/07 12:23p bhanus
* PR 28040 : Modified code for 7440 B0 porting
* 
* Hydra_Software_Devel/78   2/21/07 2:36p speter
* PR 27999: Fixing the code in CloseFmmModules to make the sPath entries
* as null.
* 
* Hydra_Software_Devel/77   2/16/07 1:10p bhanus
* PR 27912 : Modified for  Static Downmixing Support.
* 
* Hydra_Software_Devel/76   2/15/07 11:47a speter
* PR 21566: Volume and Mute Control Fix. GetMixerForOp function had a bug
* that was returning hMixer as NULL
* 
* Hydra_Software_Devel/75   2/9/07 6:27p bhanus
* PR 25607 : Fixed Compilation warnings
* 
* Hydra_Software_Devel/74   2/9/07 6:21p bhanus
* PR 25607 : Fixed Compilation warnings
* 
* Hydra_Software_Devel/73   2/9/07 2:00p bhanus
* PR 25607 : Modified code for DTS/DTS-HD bringup
* 
* Hydra_Software_Devel/72   2/8/07 11:09a bhanus
* PR 25607 : Added code for programming user provided mixing
* coefficients.
* 
* Hydra_Software_Devel/71   2/7/07 12:30p speter
* PR 25346: [3563] SPDIF/HDMI In Feature - Manual interrupt related fix
* and HDMI In Select related fix.
* 
* Hydra_Software_Devel/70   2/6/07 4:30p nitinb
* PR 25607: Fixed cloning 3 output ports for 3563
* 
* Hydra_Software_Devel/69   2/6/07 3:12p nitinb
* PR 25607: Added missing code to stop/close destination channel and
* capture ports for stopping capture channel
* 
* Hydra_Software_Devel/68   2/6/07 1:15p kagrawal
* PR 25607: Misc fixes for supporting dual decode
* 
* Hydra_Software_Devel/67   2/5/07 1:09p bhanus
* PR 25607: Added support for cloning of output ports
* - Added code for BRAP_P_CloseCapPath() and BRAP_P_StopCapPath()
* 
* Hydra_Software_Devel/66   2/2/07 12:31p kagrawal
* PR 25607: Added support for DDP convert and simul mode
* 
* Hydra_Software_Devel/65   1/31/07 6:44p kagrawal
* PR 27285: [7440] Enabled support for ES stream type
* 
* Hydra_Software_Devel/64   1/30/07 6:26p kagrawal
* PR 25607: Firmware buffer size changes for DDP2.0. For backward
* compatibility, these sizes are max of earlier version of DDP and
* DDP2.0.
* 
* Hydra_Software_Devel/63   1/30/07 1:08p speter
* PR 27309: [3563] DDP and AC3 separation. Fixing compilation issues in
* case of RAP_DDP_SUPPORT=y
* 
* Hydra_Software_Devel/62   1/29/07 3:31p bhanus
* PR 25607: Added Support for Multi-executable DTS/DTS-HD
* 
* Hydra_Software_Devel/61   1/24/07 5:43p speter
* PR 27309: [3563] DDP and AC3 separation
* 
* Hydra_Software_Devel/60   1/22/07 7:26p sushmit
* PR 26864: Ext I2S, SPDIF & BTSC bringup
* 
* Hydra_Software_Devel/59   1/19/07 6:08p bhanus
* PR 25607 : Modified to add MPEG Support for 7440.
* 
* Hydra_Software_Devel/58   1/18/07 11:10a bhanus
* PR 25607 : Modified code in BRAP_P_IsAudModeGreater() to return false
* if two Audio Modes are equal.
* 
* Hydra_Software_Devel/57   1/12/07 8:29p sushmit
* PR 26864:
* New MIT structure modfications
* PP memory calculation modifications
* Passthru context RBUF allocation fix
* Also contains Dec Config Params
* 
* Hydra_Software_Devel/56   1/12/07 3:47p kagrawal
* PR 25607: Added an extra check in BRAP_P_IsDstAlreadyPresent()
* 
* Hydra_Software_Devel/55   1/12/07 10:34a kagrawal
* PR 25607: Added BRAP_P_IsDstAlreadyPresent() to check if an output port
* is already added to an association
* 
* Hydra_Software_Devel/54   1/10/07 2:33p speter
* PR 26864: [7440] PP compilation related changes.
* 
* Hydra_Software_Devel/53   1/9/07 6:24p bselva
* PR 26864: Checking in the changes for new dec config buffer param
* interface
* 
* Hydra_Software_Devel/52   1/5/07 10:48a kagrawal
* PR 25607: Distributing the destinations to each of the sPaths - added
* BRAP_P_DistributeDest()
* 
* Hydra_Software_Devel/51   1/4/07 2:04p bhanus
* PR 25607: Modified for Multichannel mixing
* 
* Hydra_Software_Devel/50   1/4/07 11:25a bhanus
* PR 25607: Added Support for Multi Channel Mixing.
* - Re- designed BRAP_P_MixerSrcRsrcLayout()
* 
* Hydra_Software_Devel/49   1/3/07 4:49p bhanus
* PR 25346: [7440/3563] - Removing bCompressed as it is no more required
* 
* Hydra_Software_Devel/48   12/29/06 1:09a nitinb
* PR 26766 : 1. Updated function BRAP_P_IsAlgoTypeSupported() for 3563
* 2. Updated function BRAP_P_OpenDecPath for capture channel
* 
* Hydra_Software_Devel/47   12/28/06 1:41p speter
* PR 25346: [3563] SPDIF/HDMI In Feature - DSP source related changes
* 
* Hydra_Software_Devel/46   12/27/06 2:19p bhanus
* PR 25607 : Modified code for Full Duplex Capture.
* 
* Hydra_Software_Devel/45   12/26/06 4:36p kagrawal
* PR 26804: Fix for adding-removing HDMI (or any outport) a number of
* times : Deallocating SRC SRAM before calling BRAP_SRC_P_Stop()
* 
* Hydra_Software_Devel/44   12/22/06 10:25a kagrawal
* PR 25607: Resetting hMaiOp in BRAP_P_ResetOpResrcGrant
* 
* Hydra_Software_Devel/43   12/21/06 11:26a kagrawal
* PR 25607: Added code to stop HDMI output port in
* BRAP_P_StopFmmModuleHandles()
* 
* Hydra_Software_Devel/42   12/21/06 10:31a kagrawal
* PR 25607: - Fixed segment faults due to pDstDetails
* - Added support for adding and removing destinations in any sequence
* - Added support for using any valid destination after a series of calls
* to add-remove destinations
* 
* Hydra_Software_Devel/41   12/19/06 5:50p bselva
* PR 25346: Checking in the changes for 3563 new features
* 
* Hydra_Software_Devel/40   12/15/06 2:30p kagrawal
* PR 25607: Added proper support for HDMI output port
* 
* Hydra_Software_Devel/39   12/13/06 5:06p speter
* PR 25346: [3563] SPDIF/HDMI In Feature
* 
* Hydra_Software_Devel/38   12/13/06 4:37p speter
* PR 25346: [3563] SPDIF/HDMI In Feature
* 
* Hydra_Software_Devel/37   12/11/06 2:17p kagrawal
* PR 25607: Added sDstDetails to the associated channel handle. Removed
* it from hRapCh.
* 
* Hydra_Software_Devel/36   12/7/06 1:28p sushmit
* PR 25346: Merging 3563 to Hydra
* 
* Hydra_Software_Devel/35   12/7/06 10:57a sushmit
* PR 25607: Updated Enc AddDestination
* 
* Hydra_Software_Devel/34   12/6/06 10:50a sushmit
* PR 25607: Fixed issues in postprocessing none.
* 
* Hydra_Software_Devel/33   12/4/06 1:53p kagrawal
* PR 25607: Bug fixes for stereo PCM over HDMI output port
* 
* Hydra_Software_Devel/32   11/29/06 11:13a bhanus
* PR 25607 : Modified for SRC bringup
* 
* Hydra_Software_Devel/31   11/27/06 2:00p sushmit
* PR 25607: Added code for CAP, XCD & ChSubTypeNone
* 
* Hydra_Software_Devel/30   11/27/06 1:37p sushmit
* PR 25607: Added code for CAP, XCD & ChSubTypeNone
* 
* Hydra_Software_Devel/29   11/27/06 12:13p sushmit
* PR 25607: Added code for CAP, XCD & ChSubTypeNone
* 
* Hydra_Software_Devel/28   11/22/06 7:20p kagrawal
* PR 25607: Added eInputAudMode and bInputLfePresent in the start param
* for decode channel
* 
* Hydra_Software_Devel/27   11/22/06 2:21p kagrawal
* PR 26079: Removed compilation warnings due to C++ type comments
* 
* Hydra_Software_Devel/26   11/17/06 5:17p bhanus
* PR 25607 : Code modified for Mixing bringup
* 
* Hydra_Software_Devel/25   11/16/06 12:23p sushmit
* PR 25607: Encode/Transcode Additions.
* 
* Hydra_Software_Devel/24   11/15/06 12:00p bhanus
* PR 24717: Modified channel params structure
* - Removed sPbChParams
* -Added sBufferParams.
* 
* Hydra_Software_Devel/23   11/13/06 6:31p kagrawal
* PR 25607: Incremented uiNoChannels for LFE
* 
* Hydra_Software_Devel/22   11/10/06 1:30p kagrawal
* PR 25607: Fixed compilation break due to last check-in
* 
* Hydra_Software_Devel/21   11/10/06 1:27p kagrawal
* PR 25607: - Added support for multi channel output on I2s_multi.
* - Enabled passthru in decode channel
* - Code clean up
* 
* Hydra_Software_Devel/20   11/9/06 7:27p bhanus
* PR 24717 : Added code to initialize the sDstCh and sCapPort in hRapCh
* to invalid values.
* 
* Hydra_Software_Devel/19   11/9/06 12:15p bhanus
* PR 24717 : Added Support for PCM Playback.
* 
* Hydra_Software_Devel/18   11/3/06 3:14p speter
* PR 24717: Added support for DTS algorithm
* 
* Hydra_Software_Devel/17   11/2/06 6:22p kagrawal
* PR 24717: Added some checks
* 
* Hydra_Software_Devel/16   11/2/06 5:17p speter
* PR 24717: Added support for LPCM algos.
* 
* Hydra_Software_Devel/15   10/31/06 3:05p kagrawal
* PR 24717: Code clean-up and added some checks
* 
* Hydra_Software_Devel/14   10/16/06 3:02p sushmit
* PR 24717: Updating Transcode related PI
* 
* Hydra_Software_Devel/13   10/10/06 6:51p kagrawal
* PR 24717:  Post bring up code clean-up
* 
* Hydra_Software_Devel/12   10/9/06 6:01p kagrawal
* PR 24717: Removed a bring-up hack - added support for all output ports
* for a decode channel
* 
* Hydra_Software_Devel/11   10/6/06 5:45p kagrawal
* PR 24717: 1. Merged 7440 devel branch to Hydra_Software_Devel
* 2. Also, added support for passthru
* 
* Hydra_Software_Devel/10   10/3/06 2:55p kagrawal
* PR 20654: Removed a redundant debug message
* 
* Hydra_Software_Devel/9   9/26/06 6:42p kagrawal
* PR 20654: Corrected FCI Id genertion when source is a mixer
* 
* Hydra_Software_Devel/8   9/19/06 6:11p kagrawal
* PR 20654: Added channel change support
* Added following private functions:
* - BRAP_P_StopFmmModuleHandles()
* - BRAP_P_CloseFmmModuleHandles()
* - BRAP_P_UnlinkFmmModuleHandles()
* - BRAP_P_StopDecPath()
* - BRAP_P_CloseDecPath()
* - BRAP_P_UngetChannelPaths()
* - BRAP_P_ResetOpResrcGrant()
* 
* Hydra_Software_Devel/7   9/18/06 3:49p kagrawal
* PR 20654: Fixed compilation warnings
* 
* Hydra_Software_Devel/6   9/11/06 3:02p kagrawal
* PR 20654: Removed redundant debug msg
* 
* Hydra_Software_Devel/5   9/7/06 4:57p kagrawal
* PR 20654: Modifications for bring up
* 
* Hydra_Software_Devel/4   8/31/06 4:05p kagrawal
* PR 20654: Added testcode for bringup
* 
* Hydra_Software_Devel/3   8/24/06 3:11p kagrawal
* PR 20654: Fixes for AC3 plus decode with latest RDB
* 
* Hydra_Software_Devel/2   8/18/06 11:35a kagrawal
* PR 20654: Fixed issues found during emulation
* 
* Hydra_Software_Devel/1   8/17/06 12:07p speter
* PR 20654: Added from BLR_RAP_7440A0_Bring_Up_Branch
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/21   8/17/06 11:37a kagrawal
* PR 20654: Fixed errors found during emulation
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/20   8/10/06 3:54p kagrawal
* PR 20654: Resolved linking error
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/19   8/7/06 1:50p kagrawal
* PR 20654: Fixed compilation error
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/18   8/7/06 1:37p kagrawal
* PR 20654: Added support for decode passthru and simul mode
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/17   8/4/06 7:11p bhanus
* PR 20654: Added BRAP_GetGain() and BRAP_GetPan()
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/16   8/3/06 6:47p kagrawal
* PR 20654: Fixed compilation error
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/15   8/2/06 9:15p kagrawal
* PR 20654: Fixed compilation error
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/14   8/1/06 3:01p kagrawal
* PR 20654: Added misc codes:
* - Linking Output Port with Mixers
* - Redesigned AddDestination
* - Corrected RM resource grant and request structure for output port
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/13   8/1/06 11:35a bhanus
* PR 20654: Added Interface to convert absolute value of SR to Enum
* BRAP_P_ConvertSrToEnum()
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/12   7/31/06 6:34p kagrawal
* PR 20654: Added code for linking SRC and Mixers
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/11   7/28/06 10:51p kagrawal
* PR 20654: Added and modifiled StartFmmModules()
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/10   7/28/06 3:03p bhanus
* PR 20654: Added and modified code for BRAP_P_OpenFmmModuleHandles()
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/9   7/28/06 10:46a kagrawal
* PR 20654: Added code for BRAP_P_OpenFmmModuleHandles() and
* BRAP_P_LinkFmmModuleHandles()
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/8   7/28/06 10:38a bhanus
* PR 20654 : Added code for BRAP_SetGain() and BRAP_SetPan()
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/7   7/26/06 10:05p kagrawal
* PR 20654: Added and modified many private helper routines
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/6   7/21/06 11:34a bhanus
* PR 20654 : Added API BRAP_P_GetMixerForOpPort.
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/5   7/19/06 4:33a kagrawal
* PR 20654: Added BRAP_DEC_P_ChannelOpen() and
* BRAP_P_InitRapChannelHandle()
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/4   7/17/06 1:21p bmishra
* PR 20654 : Refined the code for Mixer and SRC resource layout algo
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/3   7/13/06 7:47p bmishra
* PR 20654 : Added basic code for Mixer and SRC resource request for
* levels other than level 0
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/2   7/13/06 12:59p bmishra
* PR 20654 : Added code for Mixer and SRC resource request for level 0
* 
* Hydra_Software_Devel/BLR_RAP_7440A0_Bring_Up_Branch/1   6/19/06 11:21a kagrawal
* PR 20654: Initial version
* 
***************************************************************************/
#include "brap.h"
#include "brap_priv.h"

BDBG_MODULE(rap_priv);

/* For debugging Link Info */
#define BRAP_P_DBG_LINK_INFO 0
#define BRAP_P_STOP_TIMEOUT_COUNTER 30

/* This flag decides if we want FW to program the output PLL or not */
 

#define TRIWINDOW_WIDTH_SEL_VALUE 8
#define ADAPTIVE_RATE_THRESHOLD_VALUE 0xFFFF



/***************************************************************************
Summary:
    Private function that updates the already allocated output and spdiffm 
    ids in the resource grant structure.
****************************************************************************/
static BERR_Code
BRAP_P_UpdateOpResrcGrant(
    BRAP_ChannelHandle      hRapCh,         /* [in] Raptor channel handle */
    BRAP_P_ObjectHandles    *pPath,         /* [in] Path which carries output 
                                               details */
    BRAP_RM_P_ResrcGrant    *pRsrcGrnt      /* [out] Resource grant to update */
    );

/***************************************************************************
Summary:
    Private function that resets/removes output port and spdiffm ids from the
    resource grant structure.
****************************************************************************/
static BERR_Code
BRAP_P_ResetOpResrcGrant(
    BRAP_Handle             hRap,           /* [in] Raptor device handle */
    BRAP_P_ObjectHandles    *pPath,         /* [in] Path which carries output 
                                               details */
    BRAP_RM_P_ResrcGrant    *pRsrcGrnt      /* [out] Resource grant to update */
    );


/***************************************************************************
Summary:
    A Destination Group is the number of destinations associated with one 
    output mode. For example if for one RAP Channel there are three stereo 
    outputs, then each of these output ports constitute one destination group. 
****************************************************************************/    
typedef struct BRAP_P_DstGrpDetails
{
    bool                bInputMixingLvlOnly;
    BRAP_OutputMode     eAudioMode;     /* Audio Mode for this output group */
    bool                bLfeOn;         /* Whether LFE exists for this output 
                                           group */
    BAVC_AudioSamplingRate   eSamplingRate;  /* Sampling rate */
    BRAP_DstDetails     *pDstDetails;   /* Pointer to dst details. This 
                                           is valid only if a particular
                                           Mixing Level feeds to a destination 
                                           directly. It is NULL if a mixing 
                                           level doesn't feed to some 
                                           destination directly */
    BRAP_P_InternalDst  *pIntDstDetails;/* Pointer to internal destination as
                                           Internal capture port */
}BRAP_P_DstGrpDetails;

static const 
BRAP_P_DstGrpDetails sDstGrpInvalid = {
    false,                              /* bInputMixingLvlOnly */
    BRAP_OutputMode_eLast,              /* eAudioMode */
    false,                              /* bLfeOn */
    BAVC_AudioSamplingRate_eUnknown,    /* eSamplingRate */
    NULL,                               /* pDstDetails */
    NULL                                /* pIntDstDetails */
};

#define BRAP_P_MAX_OUTPUT_CONFIGS   8
#if (BRAP_3548_FAMILY == 1)
/* This is a workaround to support ADC with 6 destinations 
The extra internal capture port for sampling rate conversion reasons
adds up to the usual destinations in MixerSrcRescLayout giving 7.
This needs to be fixed later and when that is done we need to make
#define BRAP_P_MAX_CLONES           as 6
*/
#define BRAP_P_MAX_CLONES           7
#else
#define BRAP_P_MAX_CLONES           4
#endif

static const 
BRAP_P_MixingLevelProp  sMixingLevelPropInvalid = {
    BAVC_AudioSamplingRate_eUnknown,    /* InputSR */
    BAVC_AudioSamplingRate_eUnknown,    /* OutputSR */
    BRAP_OutputMode_eLast,              /* Input Aud Mode */
    false,                              /* bInputLfeOn */
    BRAP_OutputMode_eLast,              /* Output Aud Mode */
    false,                              /* bOutputLfeOn */
    {NULL,                              /* pDstDetails[0] */
    NULL},                              /* pDstDetails[1] */
    {NULL,                              /* pIntDstDetails[0] */
    NULL}                               /* pIntDstDetails[1] */
 };


static const BRAP_P_OpAudModProp sOutputAudModeProp[BRAP_OutputMode_eLast] = 
{/*|ChNo|ChBits| L    | R   | Ls   | Rs   | C    | Lfe  | Lb   | Rb  | */   
    {1,  0x80, {true, false, false, false, false, false, false, false}},/*1_0*/
    {0,  0x00, {false, false, false, false, false, false, false, false}},/*XXX*/
    {0,  0x28, {false, false, true, false, true, false, false, false}},/*1_1 TODO */
    {2,  0xC0, {true, true, false, false, false, false, false, false}},/*2_0*/
    {3,  0xC8, {true, true, false, false, true, false, false, false}},/*3_0*/
    {3,  0xE0, {true, true, true, false, false, false, false, false}},/* 2_1 */
    {4,  0xE8, {true, true, true, false, true, false, false, false}},/* 3_1 */
    {4,  0xF0, {true, true, true, true, false, false, false, false}},/* 2_2 */
    {5,  0xF8, {true, true, true, true, true, false, false, false}},/* 3_2 */   
    {6,  0xFA, {true, true, true, true, true, false, true, false}},/* 3_3 */
    {7,  0xFB, {true, true, true, true, true, false, true, true}}/* 3_4 */
    /* TODO: Add more modes */
};


static const BRAP_P_InternalDst sInternalDst = {
    {
        BRAP_CapInputPort_eMax,
        BRAP_CapInputPort_eMax,
        BRAP_CapInputPort_eMax,
        BRAP_CapInputPort_eMax
    },
    BAVC_AudioSamplingRate_eUnknown,
    BRAP_OutputMode_eLast,
    false
};


/* BRAP_P_AlignAddress : Aligns the address to the specified bit position
 */
uint32_t BRAP_P_AlignAddress(
		uint32_t	ui32Address,	/* [in] size in bytes of block to allocate */
		uint32_t	uiAlignBits		/* [in] alignment for the block */
		)
{
	return (ui32Address+((1<<uiAlignBits)-1)) & ~((1<<uiAlignBits)-1) ;
}


/***************************************************************************
Summary: Gets the watchdog recovery flag 

Description:
	This function returns current status of watchdog recovery flag. This
	is required to know whether a function is getting called in watchdog
	context or from application.

Returns:
	Watchdog flag

See Also:
**************************************************************************/
bool BRAP_P_GetWatchdogRecoveryFlag(BRAP_Handle hRap)
{
	return hRap->bWatchdogRecoveryOn;
}

/* BRAP_P_AllocAligned : A wrapper around the BMEM module to 
 * include static memory allocation 
 */
#ifndef BRAP_MEM_DBG
void *BRAP_P_AllocAligned(
		BRAP_Handle  hRap,        /* [in] The RAP device handle */
		size_t       ulSize,      /* [in] size in bytes of block to allocate */
		unsigned int uiAlignBits, /* [in] alignment for the block */
		unsigned int uiBoundary   /* [in] boundary restricting allocated value */
		)
{
	uint32_t ui32_AllocMem ;
	uint32_t ui32_adjSize ;
	void *ptr;

#if (EMULATION==0)
	BSTD_UNUSED(ui32_AllocMem);
	BSTD_UNUSED(ui32_adjSize);

	ptr = BMEM_AllocAligned(
			hRap->hHeap, 
			ulSize, 
			uiAlignBits, 
			uiBoundary) ;
	BDBG_MSG(("Allocated Memory : %08lx, size %08lx", ptr, ulSize));
    

	hRap->uiTotalMemUsed+=ulSize;

	return (ptr == 0)? (void *)BRAP_P_INVALID_DRAM_ADDRESS : ptr ;

#else
	BSTD_UNUSED(uiBoundary);
	BSTD_UNUSED(ptr);

	ui32_adjSize = ulSize + (1<<uiAlignBits)-1 ;

	/* The simple static memory allocator works as follows :
	 * The running pointer always points to the starting address
	 * of the remaining and free portion of the static memory block.
	 */
	ui32_AllocMem = hRap->sMemAllocInfo.currentStaticMemoryPointer ;

	BDBG_MSG(("Current Mem Pointer = 0x%08x, Base = 0x%08x, Size = 0x%08x",
	hRap->sMemAllocInfo.currentStaticMemoryPointer,
	hRap->sMemAllocInfo.currentStaticMemoryBase,
	hRap->sMemAllocInfo.staticMemorySize));

	/* Point the running pointer to the end+1 of the current buffer *
	 * but first check if the static memory block is not exhausted */
	if( (hRap->sMemAllocInfo.currentStaticMemoryPointer+ulSize) > 
		(hRap->sMemAllocInfo.currentStaticMemoryBase +
		hRap->sMemAllocInfo.staticMemorySize) )
	{
		BDBG_ERR(("BRAP_P_AllocAligned : No more Static Memory available"));
		return (void *) BRAP_P_INVALID_DRAM_ADDRESS ;
	}

	/* Align the address to the specified Bit position */
	ui32_AllocMem = BRAP_P_AlignAddress(ui32_AllocMem, uiAlignBits) ;

	hRap->sMemAllocInfo.currentStaticMemoryPointer += ui32_adjSize;

	/* Set the memory that is allocate to zero, this is asure allocated memory is a known value */
	{
		uint32_t offset;
		
		for(offset = 0; offset <= ui32_adjSize; offset += 4)
		{
			/* may over the allocated buffer by upto 3 bytes, but this should be okay 
			   since the override will occur to unallocated memory, due to the simple
			   memory allocator that currently exist */
			BRAP_P_DRAMWRITE( (ui32_AllocMem + offset), 0x00);
		}
	}


	/* TODO : Add Boundary checks */

	hRap->uiTotalMemUsed+=ulSize;
	BDBG_MSG(("Allocated Memory : %08lx, size %08lx, prealigned = %08lx", ui32_AllocMem, ulSize,hRap->sMemAllocInfo.currentStaticMemoryPointer ));


	return (void *)ui32_AllocMem ;	
#endif
}
#endif

/* BRAP_P_Free : A wrapper around the BMEM module to free device memory.
 */
BERR_Code BRAP_P_Free(
		BRAP_Handle  hRap,        	/* [in] The RAP device handle */
		void *pMemPtr)			/* [in] Pointer to device memory to be freed */
{
	BERR_Code err = BERR_SUCCESS;
	BDBG_ASSERT(hRap);

    if((pMemPtr !=NULL) && (pMemPtr!=(void *)BRAP_P_INVALID_DRAM_ADDRESS))
    {
        BDBG_MSG(("BRAP_P_Free: Freeing pMemPtr = 0x%x",pMemPtr));
    	err = BMEM_Free(hRap->hHeap, pMemPtr);        
    }
	return err;
}

/* BRAP_P_ConvertAddressToOffset: Wrapper on BMEM function BMEM_ConvertAddressToOffset.
 * Since for 7411 chips, RAP PI doesn't get virtual pointer to device memory and access
 * device memory using physical address only, this function returns device offset equal
 * to virtual pointer to device memory for these chips. For all other chips it calls 
 * BMEM function BMEM_ConvertAddressToOffset for this conversion.
 */
BERR_Code BRAP_P_ConvertAddressToOffset(
	BMEM_Handle  Heap,    /* Heap that contains the memory block. */
	void        *pvAddress, /* Address of the memory block */
	uint32_t    *pulOffset)   /* [out] Returned device offset. */
{
	BERR_Code err = BERR_SUCCESS;
	
#if (EMULATION==0)
	err = BMEM_ConvertAddressToOffset(Heap, pvAddress, pulOffset);
#else
	BSTD_UNUSED(Heap);
	*pulOffset = (uint32_t) pvAddress;
#endif
	return err;
}

/* BRAP_P_ConvertOffsetToAddress: Wrapper on BMEM function BMEM_ConvertOffsetToAddress.
 */
BERR_Code BRAP_ConvertOffsetToAddress
(
	BMEM_Handle   hHeap,    /* Heap that contains the memory block */
	uint32_t      ulOffset,  /* Device offset within the heap. */
	void        **ppvAddress)  /* [out] Returned address. */
{
	BERR_Code err = BERR_SUCCESS;
	
	err = BMEM_ConvertOffsetToAddress(hHeap, ulOffset, ppvAddress);

	return err;
}

BERR_Code BRAP_P_CopyDataToDram(BMEM_Handle hHeap,
                                    uint32_t *data,
									uint32_t memAdr,
									uint32_t size)
{
    void *dest=NULL;
    BERR_Code    ret=BERR_SUCCESS;
    if (data==NULL) {
            ret = BMEM_Heap_ConvertAddressToCached(hHeap,(void *) memAdr,(void **) &dest);
            if (ret!=BERR_SUCCESS)
             {
                BDBG_ERR(("BMEM_Heap_ConvertAddressToCached returned Error %d",ret));
                return BERR_TRACE(ret);
            }            
            BKNI_Memset(dest, 0, size);
            ret = BMEM_Heap_FlushCache(hHeap,(void *)dest,size);      
            if (ret!=BERR_SUCCESS)
             {
                BDBG_ERR(("BMEM_Heap_FlushCache returned Error %d",ret));
                return BERR_TRACE(ret);
            }            
            
    }
    else {
            ret = BMEM_Heap_ConvertAddressToCached(hHeap,(void *) memAdr,(void **) &dest);
            if (ret!=BERR_SUCCESS)
             {
                BDBG_ERR(("BMEM_Heap_ConvertAddressToCached returned Error %d",ret));
                return BERR_TRACE(ret);
            }                        
            BKNI_Memcpy(dest, data , size);
            ret = BMEM_Heap_FlushCache(hHeap,(void *)dest,size);
            if (ret!=BERR_SUCCESS)
             {
                BDBG_ERR(("BMEM_Heap_FlushCache returned Error %d",ret));
                return BERR_TRACE(ret);
            }                
    }
    return ret;
}

#ifndef EMULATION
void BRAP_MemWrite32(
					uint32_t	offset, /* Memory offset to write */
					uint32_t	data   /* Data to write */
					)
{
	*((volatile uint32_t *)offset) = data;
}

void BRAP_MemWrite32_isr(
					uint32_t	offset, /* Memory offset to write */
					uint32_t	data   /* Data to write */
					)
{
	*((volatile uint32_t *)offset) = data;
}

void BRAP_MemWrite8(
					uint32_t	offset, /* Memory offset to write */
					uint8_t	data   /* Data to write */
					)
{
	*((volatile uint8_t *)offset) = data;
}

uint32_t BRAP_MemRead32(
						uint32_t	offset /* Memory offset to write */
					   )
{
	uint32_t ui32ValRead;

	ui32ValRead = *((volatile uint32_t *)offset);
	return ui32ValRead;
}

uint32_t BRAP_MemRead32_isr(
						uint32_t	offset /* Memory offset to write */
					   )
{
	uint32_t ui32ValRead;

	ui32ValRead = *((volatile uint32_t *)offset);
	return ui32ValRead;
}

uint8_t BRAP_MemRead8(
						uint32_t	offset /* Memory offset to write */
					   )
{
	uint8_t ui8ValRead;

	ui8ValRead = *((volatile uint8_t *)offset);

	return ui8ValRead;

}

void BRAP_DSP_Write32(BREG_Handle hReg,
					uint32_t		offset,
					uint32_t		data,
					bool			bIsrCxt)
{
	if (bIsrCxt)
        {
		BRAP_Write32_isr(hReg, offset, data);
        }
	else
    {
		BRAP_Write32(hReg, offset, data);
}
}

uint32_t BRAP_DSP_Read32(BREG_Handle hReg,
					uint32_t		offset,
					bool			bIsrCxt)
{
	uint32_t regVal;

	if(bIsrCxt)
		regVal = BRAP_Read32_isr(hReg, offset);
	else
		regVal = BRAP_Read32(hReg, offset);

	return regVal;
}

#endif /* EMULATION */

/**************************************************************************
Summary:
    Private function that outputs true if (eAudioMode2, bLfeOn2) is greater
    than (eAudioMode1, bLfeOn1) else it outputs false in pMatched.
**************************************************************************/
BERR_Code
BRAP_P_IsAudModeGreater(
	BRAP_OutputMode 	eAudioMode1, 
	bool 			    bLfeOn1,
	BRAP_OutputMode 	eAudioMode2, 
	bool 			    bLfeOn2,
	bool                *pMatched)
{
    BRAP_P_OpAudModProp sOpModeProp1, sOpModeProp2;
    BERR_Code           ret = BERR_SUCCESS;

    BDBG_ASSERT(pMatched);

    *pMatched = false;

    BDBG_MSG(("BRAP_P_IsAudModeGreater: (opMode, lfe)1 = (%d,%d)",
        eAudioMode1, bLfeOn1));
    BDBG_MSG(("BRAP_P_IsAudModeGreater: (opMode, lfe)2 = (%d,%d)",
        eAudioMode2, bLfeOn2));

    /* Initialization to bypass compiler warnings */
    sOpModeProp1.ui8ChanBits = 0;
    sOpModeProp2.ui8ChanBits = 0;
    
    ret = BRAP_P_GetAudOpModeProp(eAudioMode1, bLfeOn1, &sOpModeProp1);
    if(BERR_SUCCESS != ret)
    {
        BDBG_ERR(("BRAP_P_IsAudModeGreater: GetAudOpModeProp returned %d",ret));
        return BERR_TRACE(ret);
    }

    ret = BRAP_P_GetAudOpModeProp(eAudioMode2, bLfeOn2, &sOpModeProp2);
    if(BERR_SUCCESS != ret)
    {
        BDBG_ERR(("BRAP_P_IsAudModeGreater: GetAudOpModeProp returned %d",ret));
        return BERR_TRACE(ret);
    }
    if(sOpModeProp2.ui8ChanBits == sOpModeProp1.ui8ChanBits)
    {
        *pMatched = false;
    }
    else
    {
        /* Logic: if (bitMap1 OR bitMap2) XOR bitMap1 is 0 then bitMap1 is a 
           superset of bitMap2 */
        if((sOpModeProp2.ui8ChanBits | sOpModeProp1.ui8ChanBits) 
            ^ sOpModeProp2.ui8ChanBits)
        {
            *pMatched = false;
        }
        else
        {
            *pMatched = true;
        }
    }

    return ret;
}

/* This function returns number of SRCs required in cascade.
    Valid values: 1 & 2.
    Invalid or error : 0 */    
unsigned int 
BRAP_P_NumSrcReqdInCascade(
    BAVC_AudioSamplingRate eInputSR, 
    BAVC_AudioSamplingRate eOutputSR
    )
{
    BERR_Code ret = BERR_SUCCESS;
    unsigned int uiInSr = 0, uiOutSr = 0, uiNumSRCs = 0;

    BDBG_MSG(("BRAP_P_NumSrcReqdInCascade: eInputSR = %d, eOutputSR = %d",
            eInputSR, eOutputSR));

    ret = BRAP_P_ConvertSR(eInputSR, &uiInSr);
    if(BERR_SUCCESS != ret)
    {
        ret = BERR_TRACE(ret);
        return 0;
    }
    
    ret = BRAP_P_ConvertSR(eOutputSR, &uiOutSr);
    if(BERR_SUCCESS != ret)
    {
        ret = BERR_TRACE(ret);
        return 0;    
    }    

    if(uiInSr >= uiOutSr)
    {
        if(2>(uiInSr / uiOutSr))
        {
            uiNumSRCs = 1;
        }
        else if((2== (uiInSr / uiOutSr))&& (0==(uiInSr % uiOutSr)))
        {
            uiNumSRCs = 1;
        }
        else if(((2== (uiInSr / uiOutSr))&& (0!=(uiInSr % uiOutSr)))||
                ((2<(uiInSr / uiOutSr)) && (4 > (uiInSr / uiOutSr))))
        {
            uiNumSRCs = 2;
        }
        else if((4 == (uiInSr / uiOutSr))&& (0==(uiInSr % uiOutSr)))
        {
            uiNumSRCs = 1;
        }
        else if(((4 == (uiInSr / uiOutSr))&& (0!=(uiInSr % uiOutSr)))||
                (4 < (uiInSr / uiOutSr)))
        {
            uiNumSRCs = 2;
        }

    }
    else
    {
        if(2>(uiOutSr / uiInSr))
        {
            uiNumSRCs = 1;
        }
        else if((2== (uiOutSr / uiInSr)) && (0==(uiOutSr % uiInSr)))
        {
            uiNumSRCs = 1;
        }
        else if(((2== (uiOutSr / uiInSr)) && (0!=(uiOutSr % uiInSr)))||
                ((2<(uiOutSr / uiInSr)) && (4 > (uiOutSr / uiInSr))))
        {
            uiNumSRCs = 2;
        }
        else if((4 == (uiOutSr / uiInSr))&& (0==(uiOutSr % uiInSr)))
        {
            uiNumSRCs = 1;
        }
        else if(((4 == (uiOutSr / uiInSr))&& (0!=(uiOutSr % uiInSr)))||
                (4 < (uiOutSr / uiInSr)))
        {
            uiNumSRCs = 2;
        }
   }

    /* Assert if number of SRCs required in cascade is more than 2 */
    if(uiNumSRCs > 2)
    {
        BDBG_ERR(("uiInSR = %d uiOutSR = %d, uiNumSRCs = %d",
            uiInSr, uiOutSr, uiNumSRCs));
        ret = BERR_TRACE(BERR_NOT_SUPPORTED);
        return 0;
    }
    
    return uiNumSRCs;
}
                                       
/* Return TRUE, if douwnmixing is required, return FALSE if downmixing is 
   required, ASSERT, if Upmixing is required since it is not supported */
BERR_Code BRAP_P_DecideDwnMixing(BRAP_OutputMode eInputAudMode,
                            bool bInLfeOn,
                            BRAP_OutputMode eOutputAudMode,
                            bool bOutLfeOn,
                            bool *pbDownMix)
{
    BERR_Code   ret = BERR_SUCCESS;
    bool        bModeMatched = false;

    BDBG_MSG(("OutputAudMode %d  InputAudMode %d InputLFE %d outputLFE %d",
                eOutputAudMode,eInputAudMode,bInLfeOn,bOutLfeOn));

    
    *pbDownMix = false;

    ret = BRAP_P_IsAudModeGreater(eInputAudMode,bInLfeOn, eOutputAudMode, bOutLfeOn,
                                       &bModeMatched);
    if(BERR_SUCCESS != ret)    
    {
        return BERR_TRACE(ret);
    }
    
    if(true == bModeMatched)
    {
        if((eInputAudMode == eOutputAudMode)&&(bInLfeOn == bOutLfeOn))
        {
            *pbDownMix = false;
        }
        else
        {
            BDBG_ERR(("OutputAudMode %d is greate than InputAudMode %d",
                                                eOutputAudMode,eInputAudMode));
            BDBG_ASSERT(0);
        }
    }
    else
    {
        if((eInputAudMode == eOutputAudMode)&&(bInLfeOn == bOutLfeOn))
        {
            *pbDownMix = false;
        }
        else
        {
            *pbDownMix = true;
        }
    }        
    BDBG_MSG(("pbDownMix %d",*pbDownMix));
    return ret;
}

BERR_Code BRAP_P_GetSharedAssociation(
    BRAP_ChannelHandle      hRapCh,
    bool                    *pbShareAssoc
    )
{
    BERR_Code       ret = BERR_SUCCESS;
    BRAP_Handle     hRap = hRapCh->hRap;
    unsigned int    i=0,uiAssocId=0,j=0;
    bool            flag=false;
    BDBG_ENTER(BRAP_P_GetSharedAssociation);

    for(j = 0; j<BRAP_MAX_ASSOCIATED_GROUPS; ++j)
    {
        if(hRapCh->uiAssociationId[j] == BRAP_INVALID_VALUE)
        {
            continue;
        }
        
        flag=false;
        uiAssocId = hRapCh->uiAssociationId[j];
        for (i=0;i<BRAP_MAX_PRI_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
        {
            if((hRap->sAssociatedCh[uiAssocId].hPriDecCh[i] != NULL)&&
               (hRap->sAssociatedCh[uiAssocId].hPriDecCh[i] != hRapCh)) 
            {
                pbShareAssoc[uiAssocId] = true;
                flag=true;
                break;
            }
        }
        if(flag == false)
        {
            for (i=0;i<BRAP_MAX_SEC_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
            {
                if((hRap->sAssociatedCh[uiAssocId].hSecDecCh[i]!= NULL)&&
                   (hRap->sAssociatedCh[uiAssocId].hSecDecCh[i] != hRapCh)) 
                {
                    pbShareAssoc[uiAssocId] = true;
                    flag=true;
                    break;
                }
            }
        }
        if(flag == false)
        {
            for (i=0;i<BRAP_MAX_PB_CHAN_IN_ASSOCIATED_GRP;i++)
            {
                if ((hRap->sAssociatedCh[uiAssocId].hPBCh[i] != NULL)&&
                    (hRap->sAssociatedCh[uiAssocId].hPBCh[i] != hRapCh))
                {
                    pbShareAssoc[uiAssocId] = true;
                    flag=true;
                    break;
                }
            }
        }
        if(flag == false)
        {
            for (i=0;i<BRAP_MAX_CAP_CHAN_IN_ASSOCIATED_GRP;i++)
            {
                if ((hRap->sAssociatedCh[uiAssocId].hCapCh[i] != NULL)&&
                    (hRap->sAssociatedCh[uiAssocId].hCapCh[i] != hRapCh))
                {
                    pbShareAssoc[uiAssocId] = true;
                    flag=true;
                    break;
                }
            }
        }
        
    }
    
    BDBG_LEAVE(BRAP_P_GetSharedAssociation);
    return ret;
}

BERR_Code BRAP_P_GetStartedChannel(
    BRAP_ChannelHandle      hRapCh,
    bool                    *pbPrimaryPresent,
    BRAP_ChannelHandle      *phStrtdAssocCh
)
{
    BERR_Code       ret = BERR_SUCCESS;
    BRAP_Handle     hRap = hRapCh->hRap;
    unsigned int    i=0,uiAssocId=0,j=0;

    BDBG_ENTER(BRAP_P_GetStartedChannel);
    for(j=0; j<BRAP_MAX_ASSOCIATED_GROUPS; ++j)
    {
    /* Check if any of the channels in the channel group which contains the 
       current channel, has been started */
        if(hRapCh->uiAssociationId[j] == BRAP_INVALID_VALUE)
        {
            continue;
        }
        uiAssocId = hRapCh->uiAssociationId[j];
    for (i=0;i<BRAP_MAX_PRI_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
    {
            if(hRap->sAssociatedCh[uiAssocId].hPriDecCh[i] != NULL) 
        {
                if(hRap->sAssociatedCh[uiAssocId].hPriDecCh[i]->eState == BRAP_P_State_eStarted)
            {
                pbPrimaryPresent[uiAssocId] = true;            
                /* Primary has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hPriDecCh[i];
                    BDBG_MSG(("BRAP_P_GetStartedChannel: Channel started for Association=%d is primary=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if(NULL == phStrtdAssocCh[uiAssocId])
    {
        for (i=0;i<BRAP_MAX_SEC_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
        {
                if((hRap->sAssociatedCh[uiAssocId].hSecDecCh[i]!= NULL) &&
                   (hRap->sAssociatedCh[uiAssocId].hSecDecCh[i]->eState == BRAP_P_State_eStarted))
            {
                /* Secondary has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hSecDecCh[i];
                    BDBG_MSG(("BRAP_P_GetStartedChannel: Channel started for Association=%d is Secodary=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if( NULL == phStrtdAssocCh[uiAssocId])
    {
        for (i=0;i<BRAP_MAX_PB_CHAN_IN_ASSOCIATED_GRP;i++)
        {
                if ((hRap->sAssociatedCh[uiAssocId].hPBCh[i] != NULL) &&
                    (hRap->sAssociatedCh[uiAssocId].hPBCh[i]->eState == BRAP_P_State_eStarted))
            {
                /* Sound effect channel has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hPBCh[i];
                    BDBG_MSG(("BRAP_P_GetStartedChannel: Channel started for Association=%d is PB=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if( NULL == phStrtdAssocCh[uiAssocId])
    {
        for (i=0;i<BRAP_MAX_CAP_CHAN_IN_ASSOCIATED_GRP;i++)
        {
                if ((hRap->sAssociatedCh[uiAssocId].hCapCh[i] != NULL) &&
                    (hRap->sAssociatedCh[uiAssocId].hCapCh[i]->eState == BRAP_P_State_eStarted))
            {
                /* Capture channel has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hCapCh[i];
                    BDBG_MSG(("BRAP_P_GetStartedChannel: Channel started for Association=%d is Capture=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if(NULL == phStrtdAssocCh[uiAssocId])
        {
            BDBG_MSG(("BRAP_P_GetStartedChannel: No Channel is started for Association=%d ",uiAssocId));
        }
    }

    BDBG_LEAVE(BRAP_P_GetStartedChannel);
    return ret;
}

BERR_Code BRAP_P_GetOtherStartedChannel(
    BRAP_ChannelHandle      hRapCh,
    bool                    *pbPrimaryPresent,
    BRAP_ChannelHandle      *phStrtdAssocCh
)
{
    BERR_Code       ret = BERR_SUCCESS;
    BRAP_Handle     hRap = hRapCh->hRap;
    unsigned int    i=0,uiAssocId=0,j=0;

    BDBG_ENTER(BRAP_P_GetOtherStartedChannel);
    for(j=0; j<BRAP_MAX_ASSOCIATED_GROUPS; ++j)
    {
        uiAssocId = j;
    for (i=0;i<BRAP_MAX_PRI_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
    {
            if((hRap->sAssociatedCh[uiAssocId].hPriDecCh[i] != NULL) 
                &&(hRap->sAssociatedCh[uiAssocId].hPriDecCh[i] != hRapCh))
        {
                pbPrimaryPresent[uiAssocId] = true;
                if(hRap->sAssociatedCh[uiAssocId].hPriDecCh[i]->eState == BRAP_P_State_eStarted)
            {
                /* Primary has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hPriDecCh[i];
                    BDBG_MSG(("BRAP_P_GetOtherStartedChannel: Channel started for Association=%d is primary=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if(NULL == phStrtdAssocCh[uiAssocId])
    {
        for (i=0;i<BRAP_MAX_SEC_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
        {
                if((hRap->sAssociatedCh[uiAssocId].hSecDecCh[i]!= NULL) &&
                   (hRap->sAssociatedCh[uiAssocId].hSecDecCh[i]->eState == BRAP_P_State_eStarted)
                    &&(hRap->sAssociatedCh[uiAssocId].hSecDecCh[i] != hRapCh))
            {
                /* Secondary has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hSecDecCh[i];
                    BDBG_MSG(("BRAP_P_GetOtherStartedChannel: Channel started for Association=%d is Secodary=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if( NULL == phStrtdAssocCh[uiAssocId])
    {
        for (i=0;i<BRAP_MAX_PB_CHAN_IN_ASSOCIATED_GRP;i++)
        {
                if ((hRap->sAssociatedCh[uiAssocId].hPBCh[i] != NULL) &&
                    (hRap->sAssociatedCh[uiAssocId].hPBCh[i]->eState == BRAP_P_State_eStarted)
                    &&(hRap->sAssociatedCh[uiAssocId].hPBCh[i] != hRapCh))
                    
            {
                /* Sound effect channel has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hPBCh[i];
                    BDBG_MSG(("BRAP_P_GetOtherStartedChannel: Channel started for Association=%d is PB=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if( NULL == phStrtdAssocCh[uiAssocId])
    {
        for (i=0;i<BRAP_MAX_CAP_CHAN_IN_ASSOCIATED_GRP;i++)
        {
                if ((hRap->sAssociatedCh[uiAssocId].hCapCh[i] != NULL) &&
                    (hRap->sAssociatedCh[uiAssocId].hCapCh[i]->eState == BRAP_P_State_eStarted)
                    &&(hRap->sAssociatedCh[uiAssocId].hCapCh[i] != hRapCh))                    
            {
                /* Capture channel has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hCapCh[i];
                    BDBG_MSG(("BRAP_P_GetOtherStartedChannel: Channel started for Association=%d is Capture=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if(NULL == phStrtdAssocCh[uiAssocId])
        {
            BDBG_MSG(("BRAP_P_GetOtherStartedChannel: No Channel is started for Association=%d ",uiAssocId));
        }
    }

    BDBG_LEAVE(BRAP_P_GetOtherStartedChannel);
    return ret;
}

static BERR_Code 
BRAP_P_FormAndSortDestGrp(
    BRAP_ChannelHandle      hRapCh,
    unsigned int            uiPth,
    BRAP_P_DstGrpDetails    *pDstGrp,
    bool                    bSetTopDecCh,
    BRAP_P_InternalDst      *pIntDst,
    unsigned int            *puiMaxDstGrp,
    bool                    bPrimaryPresent,
    unsigned int            uiAssocId
)
{
    BERR_Code               ret = BERR_SUCCESS;
    unsigned int            dst = 0, m = 0, n = 0, chp = 0;
    BRAP_P_OpAudModProp     sCurOpAudModeProp;
    BRAP_OutputPort         eOp = BRAP_OutputPort_eMax;
	unsigned int            uiNumDstGrp = 0;
    unsigned int            uiNumIntDstGrp = 0;
    unsigned int            uiNumTotalDst = 0;
    unsigned int            uiMaxDstGrp = 0;
    bool                    bInputMixingOnlyLvlReqd = true;
    BRAP_P_DstGrpDetails    sTempDstGrp;
    bool                    bModeMatched = false;
    unsigned int            uiSRn =0, uiSRm = 0;
    unsigned int                     i=0;
#if BRAP_P_CUSTOM_MIXER_REQUIREMENT    
    BRAP_OutputPort         eOutputOrder[5] = {BRAP_OutputPort_eI2s4, BRAP_OutputPort_eDac0, BRAP_OutputPort_eDac1, BRAP_OutputPort_eDac2, BRAP_OutputPort_eSpdif};
    BRAP_DstDetails         *pTempDstDetails = NULL;
#endif    
    bool                    bPrimary[BRAP_MAX_ASSOCIATED_GROUPS]={false,false,false,false};
    BRAP_ChannelHandle      hStrtdAssocCh[BRAP_MAX_ASSOCIATED_GROUPS] ={NULL,NULL,NULL,NULL};  
    BDBG_ENTER(BRAP_P_FormAndSortDestGrp);



#if BRAP_P_CUSTOM_MIXER_REQUIREMENT
    /* We sort the destinatinos such that the output port with more mixers is first and with the least at the last.
    This is to ensure smooth flow in Mixer allocation for CustomRequirment */  
    for (i=0; i<5; i++)
    {
        for (dst=0; dst<BRAP_P_MAX_DST_PER_RAPCH; dst++)
        {
            if((NULL == hRapCh->pPath[uiPth]) || (NULL == hRapCh->pPath[uiPth]->pDstDetails[dst]))
            {
                continue;
            }

            if (eOutputOrder[i] == hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR])
            {
                pTempDstDetails = hRapCh->pPath[uiPth]->pDstDetails[dst];
                hRapCh->pPath[uiPth]->pDstDetails[dst] = hRapCh->pPath[uiPth]->pDstDetails[i];
                hRapCh->pPath[uiPth]->pDstDetails[i] = pTempDstDetails;
            }
        }
    
    }

#endif

    /* Form the Destination Group Array */
    for(dst=0, uiNumDstGrp=0; dst < BRAP_P_MAX_DST_PER_RAPCH; dst++)
    {
        if((NULL == hRapCh->pPath[uiPth]) || 
                               (NULL == hRapCh->pPath[uiPth]->pDstDetails[dst]))
        {
            continue;
        }

        BDBG_MSG(("BRAP_P_FormAndSortDestGrp: dst = %d,"
                  " hRapCh->pPath[%d]->pDstDetails[dst]->eAudioDst = %d", dst,
                  uiPth, hRapCh->pPath[uiPth]->pDstDetails[dst]->eAudioDst));

        switch(hRapCh->pPath[uiPth]->pDstDetails[dst]->eAudioDst)
        {
            case BRAP_AudioDst_eOutputPort:

#if BRAP_P_MAI_NEEDS_MUX_SELECTOR
            /* Mai can't be fed directly in 7440 A0 / 3563 A0 */
            if(BRAP_OutputPort_eMai == hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.
                                sOpDetails.eOutput[BRAP_OutputChannelPair_eLR])
            {
                continue;
            }
#else            
            if((((BRAP_OutputPort_eMai == hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR])
                 &&(((BRAP_P_UsgPath_eDecodePcm == hRapCh->pPath[uiPth]->eUsgPath)
                   ||(BRAP_P_UsgPath_ePPBranch== hRapCh->pPath[uiPth]->eUsgPath)
                   ||(BRAP_P_UsgPath_eSharedPP== hRapCh->pPath[uiPth]->eUsgPath)))
                   &&(BRAP_OutputPort_eMai != hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiMultiSettings.eMaiMuxSelector))
               ||((BRAP_OutputPort_eSpdif== hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR])
                 &&(((BRAP_P_UsgPath_eDecodeCompress== hRapCh->pPath[uiPth]->eUsgPath)
                     ||(BRAP_P_UsgPath_ePPBranch== hRapCh->pPath[uiPth]->eUsgPath)
                     ||(BRAP_P_UsgPath_eSharedPP== hRapCh->pPath[uiPth]->eUsgPath))
                     &&(true== hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].bCompressed))))
                 &&(BRAP_OutputMode_e3_2 == hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.sOpDetails.eAudioMode))
            {
                continue;
            }
#endif 
            pDstGrp[uiNumDstGrp].eAudioMode = 
                hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.sOpDetails.eAudioMode;
            pDstGrp[uiNumDstGrp].bLfeOn = 
                hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.sOpDetails.bLfeOn;
            pDstGrp[uiNumDstGrp].pDstDetails = hRapCh->pPath[uiPth]->pDstDetails[dst];
            
            ret = BRAP_P_GetAudOpModeProp(pDstGrp[uiNumDstGrp].eAudioMode, 
                                          pDstGrp[uiNumDstGrp].bLfeOn,
                                          &sCurOpAudModeProp);
            if(BERR_SUCCESS != ret)
            {
                BDBG_ERR(("BRAP_P_GetAudOpModeProp returned %d", ret));
                return BERR_TRACE(ret);
            }

            for (chp = 0; chp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; chp++)
	        {
                if((sCurOpAudModeProp.bChnExists[chp*2] == true) ||
                   (sCurOpAudModeProp.bChnExists[(chp*2)+1] == true))
                {
                    /* Make sure that there is a valid port for this channel 
                       pair */
                    eOp = hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.sOpDetails.eOutput[chp]; 
                    if(eOp >= BRAP_OutputPort_eMax)
                    {
                        BDBG_ERR(("pDstDetails[%d].sOpDetails.eOutput[%d] = %d",
                            dst,chp,eOp));
                        return BERR_TRACE(BERR_NOT_INITIALIZED);
                    }                   

                    /* Get its sampling rate */
                    if(false == bSetTopDecCh)
                    {
                        if(hRapCh->eChannelType == BRAP_ChannelType_eDecode)
                        {
                        pDstGrp[uiNumDstGrp].eSamplingRate = hRapCh->hRap->sOutputSettings[eOp].eOutputSR;
                        }
                        else
                        {
                            ret = BRAP_P_GetStartedChannel(hRapCh,bPrimary,hStrtdAssocCh);
                            if(ret != BERR_SUCCESS)
                            {
                                BDBG_ERR(("BRAP_P_GetStartedChannel returnrd error"));
                                return BERR_TRACE(ret);
                            }                            
                            if((hStrtdAssocCh[uiAssocId] != NULL)
                                &&(true == bPrimary[uiAssocId])
                                &&(hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->bGateOpened == true))
                            {
                                pDstGrp[uiNumDstGrp].eSamplingRate = hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->eSamplingRate;
                            }
                            else
                            {
                                pDstGrp[uiNumDstGrp].eSamplingRate = hRapCh->hRap->sOutputSettings[eOp].eOutputSR;
                            }
                        }
                    }
                    else
                    {
                        pDstGrp[uiNumDstGrp].eSamplingRate = BAVC_AudioSamplingRate_eUnknown;
                    }
                }
            }    
			uiNumDstGrp++;
            break;
            case BRAP_AudioDst_eRingBuffer:
    /*		pDstGrp[dst].eAudioMode = BRAP_OutputMode_e2_0;
    		pDstGrp[dst].bLfeOn = false;
    		pDstGrp[dst].eSamplingRate = BAVC_AudioSamplingRate_e48k;
    		pDstGrp[dst].pDstDetails = &(hRapCh->pPath[uiPth]->pDstDetails[dst]);
    		uiNumDstGrp++;*/
    		continue;
    		break;
            default:
            /* TODO: Return not supported */
            break;
        }/* switch */
    }/* for dst */
    /* Internal destination (i.e. capture path) is present. 
       So add this information to the Destination Group Array also */
    for(i =0 ; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        if(hRapCh->pPath[uiPth]->pDstDetails[i] != NULL)
        {
            if(hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                break;
        }
    }
    if((i < BRAP_P_MAX_DST_PER_RAPCH) ||
         /* Capture path for Post-Mixing */
       (((BRAP_P_UsgPath_eDecodePcm == hRapCh->pPath[uiPth]->eUsgPath) ||
         (BRAP_P_UsgPath_ePPBranch == hRapCh->pPath[uiPth]->eUsgPath))&&
        (BRAP_P_IsAssociationNWValid(&(hRapCh->hRap->sAssociatedCh[uiAssocId].sDstDetails[0])))))
    {
        for(dst = 0; dst < BRAP_RM_P_MAX_INTERNAL_DST; dst++)
        {
            /* Here, we cannot take a decision based on the eCapPort as eCapPort has
               not been allocated and pIntDst[dst]eCapPort[] still points to invalid
               value. This is because we are still in the resource request preparation
               stage. But, we can definitely check for eInputAudMode to check if an
               internal destination is required or not. */
            if(pIntDst[dst].eInputAudMode != BRAP_OutputMode_eLast)
            {
                BDBG_MSG(("Found the Internal Destination uiNumDstGrp + dst = %d",
                    uiNumDstGrp + dst));
                pDstGrp[uiNumDstGrp + dst].eAudioMode = pIntDst[dst].eInputAudMode;
                pDstGrp[uiNumDstGrp + dst].pIntDstDetails = &(pIntDst[dst]);
                pDstGrp[uiNumDstGrp + dst].bLfeOn = pIntDst[dst].bLfeOn;
                
#if (BRAP_DYNAMIC_PORT_SWITCHING == 1)
                /*ToDo: This code is causing O/P port+capture to fail when Independent delay is disabled. Check it. */
                if(false == bSetTopDecCh)
                {
                    pDstGrp[uiNumDstGrp + dst].eSamplingRate = pIntDst[dst].eInputSR;            
                }
                else
                {
                    pDstGrp[uiNumDstGrp + dst].eSamplingRate =  BAVC_AudioSamplingRate_eUnknown;
                }
#else
                pDstGrp[uiNumDstGrp + dst].eSamplingRate = pIntDst[dst].eInputSR;
#endif            
                uiNumIntDstGrp++;
            }
        }
    }

    uiNumTotalDst = uiNumDstGrp + uiNumIntDstGrp;
	BDBG_MSG(("uiNumTotalDst = %d, uiNumDstGrp =%d, uiNumIntDstGrp = %d",
               uiNumTotalDst,uiNumDstGrp,uiNumIntDstGrp));

	/* We do not need the input mixing level in any path other than Decode PCM*/
    if((BRAP_P_UsgPath_eDecodePcm == hRapCh->pPath[uiPth]->eUsgPath)	
        &&(hRapCh->eChannelType == BRAP_ChannelType_eDecode))/* Assuming that PCM Capture and PCM playback will always be stereo*/
    {

        /* Check if the audio mode is same as the input audio mode. If so,
           extra stage for input mixing only is not required. */
        for(dst = 0; dst < uiNumTotalDst; dst++)
        {        
            /* If Primary is present in the association, consider its input mode */
            if ((true == bPrimaryPresent)&&
                (BRAP_P_State_eStarted == hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->eState))
            {
                if((pDstGrp[dst].eAudioMode == 
                hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->eInputAudMode) && 
                   (pDstGrp[dst].bLfeOn == 
                   hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->bInputLfeOn)

                    )
                {
                    bInputMixingOnlyLvlReqd = false;
                    break;
                }
                else
                {
                    bInputMixingOnlyLvlReqd = true;
                }
            }
            /* Else take current channels input mode */
            else
            {
                if((pDstGrp[dst].eAudioMode == hRapCh->eInputAudMode)/* && 
                   (pDstGrp[dst].bLfeOn == hRapCh->bInputLfeOn)*/
                   )
                {
                    bInputMixingOnlyLvlReqd = false;
                    break;
                }
                else
                {
                    if((BRAP_P_IsAssociationNWValid(&(hRapCh->hRap->sAssociatedCh[uiAssocId].sDstDetails[0])))
                       || ((hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eOutputPort)
                        &&(hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.sOpDetails.eAudioMode == BRAP_OutputMode_e2_0)
                        &&(hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))
                        ||((hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                        &&(hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.sRBufDetails.eAudioMode == BRAP_OutputMode_e2_0)
                        &&(hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0)))
                    {
                        bInputMixingOnlyLvlReqd = false;
                        break;
                    }
                    else
                    {
                        bInputMixingOnlyLvlReqd = true;
    			    }
    			}
            }
        }
    }
    else
    {
        bInputMixingOnlyLvlReqd = false;
    }
	BDBG_MSG(("bInputMixingOnlyLvlReqd = %d", bInputMixingOnlyLvlReqd));

    /* If none of the destinations have audio mode same as the input audio mode, 
       then we need to add the first entry in pDstGrp corresponding to the input 
       audio mode. It is done because in this case, there is requirement of a 
       level where mixing of primary decode, secondary decode and sound effect 
       channels has to happen then it should be downmixed to result the output 
       audio modes required. Add this stage at the end of the array first. In 
       the next step bring this stage to the first entry */
    if(true == bInputMixingOnlyLvlReqd)
    {
        /* As we are going to introduce a dummy dst group, check if 
           this can be accomodated */
        if(uiNumTotalDst >= (BRAP_P_MAX_DST_PER_RAPCH + BRAP_RM_P_MAX_INTERNAL_DST))
        {
            BDBG_ERR(("No space available for adding a dummy destination grp"));
            return BERR_TRACE(BERR_NOT_SUPPORTED);
        }
            
        /* Prepare pDstGrp to hold dummy mixing level with no immediate dest */ 
        uiMaxDstGrp = uiNumTotalDst + 1;
        pDstGrp[uiNumTotalDst].bInputMixingLvlOnly = true;
        pDstGrp[uiNumTotalDst].pDstDetails = NULL;
        pDstGrp[uiNumTotalDst].pIntDstDetails = NULL;
            
        /* Sampling rate of the primary channel in the channel group should be 
           the sampling rate of this stage */
        /* TODO: It should be unified SR */

        if(hRapCh->eChannelSubType == BRAP_ChannelSubType_ePrimary)
        {
            BRAP_P_ConvertSrToEnum(hRapCh->uiInputSamplingRate,&(pDstGrp[uiNumTotalDst].eSamplingRate));            
        }
        else if(true == bSetTopDecCh) 
        {
            /* Decode channel for Set Top Platform. 
               Mark the Sampling rate as invalid */
            pDstGrp[uiNumTotalDst].eSamplingRate = BAVC_AudioSamplingRate_eUnknown;
        }
        else if(NULL == 
                hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0])
        {
            /* Primary channel doesn't exist for this group. This must be a 
               playback channel for Set Top Application. Mark the input sampling 
               rate as the sampling rate of this stage */
            BRAP_P_ConvertSrToEnum(hRapCh->uiInputSamplingRate,&(pDstGrp[uiNumTotalDst].eSamplingRate));                        
        }
        else if(hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->eState 
                == BRAP_P_State_eStarted)
        {
            /* Take the sampling rate of the primary channel in the group, 
               if started */
            pDstGrp[uiNumTotalDst].eSamplingRate 
                = hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->eSamplingRate;
        }
        else
        {
            BRAP_P_ConvertSrToEnum(hRapCh->uiInputSamplingRate,&(pDstGrp[uiNumTotalDst].eSamplingRate));                                
        }

        if (true == bPrimaryPresent)
        {
             pDstGrp[uiNumTotalDst].eAudioMode = 
                hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->eInputAudMode;
             pDstGrp[uiNumTotalDst].bLfeOn = 
                hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->bInputLfeOn;
        }
        else
        {
            pDstGrp[uiNumTotalDst].eAudioMode = hRapCh->eInputAudMode;

            /*pDstGrp[uiNumTotalDst].bLfeOn = hRapCh->bInputLfeOn;*/
            if(hRapCh->pPath[uiPth]->pDstDetails[0] != NULL)
            {
                if(hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eOutputPort)
                    pDstGrp[uiNumTotalDst].bLfeOn = hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.sOpDetails.bLfeOn;
                else
                    pDstGrp[uiNumTotalDst].bLfeOn = false;
            }
            else
            {
                    pDstGrp[uiNumTotalDst].bLfeOn = false;
            }  
        }

        /* Exchange the 1st and this level so that this stage will appear as 
           the first entry in the pDstGrp array */
        sTempDstGrp = pDstGrp[uiNumTotalDst];
        pDstGrp[uiNumTotalDst] = pDstGrp[0];
        pDstGrp[0] = sTempDstGrp;
    }
    else
    {
        uiMaxDstGrp = uiNumTotalDst;
    }

    /*TODO:while sorting itself we should store the number of direct consumers
           of this dstgrp. This will be used while allocating mixer output. */

    /* Sort destination groups in a particular order 
        a) decreasing order of data mode (7.1, 5.1, 2.0)
        b) increasing order of sampling rate with in the same data mode */
    for(m = 0; m < uiMaxDstGrp - 1; m++)
    {
        for(n = m +1 ; n < uiMaxDstGrp; n++)
        {
            BDBG_MSG(("m=%d n=%d, uiMaxDstGrp=%d (%d, %d) (%d, %d)", 
               m , n , uiMaxDstGrp,
               pDstGrp[m].eAudioMode, 
               pDstGrp[m].bLfeOn, 
               pDstGrp[n].eAudioMode, 
               pDstGrp[n].bLfeOn));
            if (true == pDstGrp[m].bInputMixingLvlOnly)
                continue;
            
            ret = BRAP_P_IsAudModeGreater(pDstGrp[m].eAudioMode, 
                                       pDstGrp[m].bLfeOn, 
                                       pDstGrp[n].eAudioMode, 
                                       pDstGrp[n].bLfeOn,
                                       &bModeMatched);
            if(BERR_SUCCESS != ret)    
            {
                return BERR_TRACE(ret);
            }
            
            if(true == bModeMatched)
            {
                sTempDstGrp = pDstGrp[m];
                pDstGrp[m] = pDstGrp[n];
                pDstGrp[n] = sTempDstGrp;
            }
            else if((pDstGrp[m].eAudioMode == pDstGrp[n].eAudioMode) && 
                    (pDstGrp[m].bLfeOn == pDstGrp[n].bLfeOn))
            {
                if((BRAP_ChannelType_eDecode == hRapCh->eChannelType )&&
                (BRAP_ChannelSubType_eNone ==hRapCh->eChannelSubType))
                {
                    /* do nothing */
            	}
                else
                {
                BRAP_P_ConvertSR(pDstGrp[m].eSamplingRate,&uiSRm);
                BRAP_P_ConvertSR(pDstGrp[n].eSamplingRate,&uiSRn);
                if(uiSRm < uiSRn)
                {
                    sTempDstGrp = pDstGrp[m];
                    pDstGrp[m] = pDstGrp[n];
                    pDstGrp[n] = sTempDstGrp;
                }
                else
                {
                    /* do nothing */
                }
            }
            }
            else
            {
                /* do nothing, dst are already sorted */
            }
        }/* for n */
    }/* for m */

    *puiMaxDstGrp = uiMaxDstGrp;

    BDBG_LEAVE(BRAP_P_FormAndSortDestGrp);
    return ret;
}

BERR_Code BRAP_P_PrepareSrcRequest(
    BRAP_ChannelHandle      hRapCh,
    BRAP_P_OpAudModProp     sOpAudModeProp,
    BRAP_P_MixingLevelProp  sMixingLevels,
    BRAP_RM_P_SrcMixerReq   *pSrcMixerReq,
    unsigned int            uiPp,
    unsigned int            uiLvl,
    BRAP_ChannelHandle      hStrtdAssocCh,
    unsigned int            uiAsctdUsgPath,
    unsigned int            uiPth
)
{
    BERR_Code               ret = BERR_SUCCESS;
    unsigned int            chp = 0;
    unsigned int            uiNumSRCs = 0;
    unsigned int            i = 0;
    BRAP_RM_P_SrcGrant      sPrivSrcGrant;
    BRAP_P_ObjectHandles    *pTempPath=NULL;


    BDBG_ENTER(BRAP_P_PrepareSrcRequest);

    /* If we need fresh SRC - if its Level 0 or there is no channel 
       started in the Association */
    if((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eMixPath)
        ||(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eSharedPP))
    {
        pTempPath = hRapCh->pPath[hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx];
        if(pTempPath == NULL)
        {   
            BDBG_ERR(("In path of Mix path got corrupted"));
            BDBG_ASSERT(0);
        }
        else
        {
            for (chp = 0; chp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; chp++)
            {
                if((sOpAudModeProp.bChnExists[chp*2] == true) ||
                   (sOpAudModeProp.bChnExists[(chp*2)+1] == true))
                {
                    /* SRCs will have only one parallel path */
                    for(i = 0; i < BRAP_RM_P_MAX_SRC_IN_CASCADE; i++)
                    {
                        sPrivSrcGrant = pTempPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].
                                            sSrcGrant[i][chp][uiPp];

                        if((BRAP_RM_P_INVALID_INDEX != sPrivSrcGrant.uiSrcId)&&
                           (BRAP_RM_P_INVALID_INDEX != sPrivSrcGrant.uiSrcBlkId))
                        {
                            /* New allocation is required, since for each channel 
                               one SRC will be required */
                            pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcBlkId 
                                    = sPrivSrcGrant.uiSrcBlkId;
                            pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcId 
                                    = sPrivSrcGrant.uiSrcId;
                            pSrcMixerReq->sSrcReq[i][chp][uiPp].bAllocate = true;
                            BDBG_MSG(("SrcBlkId=%d SrcId=%d",pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcBlkId,
                                pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcId));
                        }
                    }
                }
                else
                {
                    pSrcMixerReq->sSrcReq[0][chp][uiPp].bAllocate = false;
                }    
            }
        }
    }
    else
    {
    if((NULL == hStrtdAssocCh)||(0 == uiLvl))
    {
        for (chp = 0; chp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; chp++)
        {  
            if((sOpAudModeProp.bChnExists[chp*2] == true) ||
               (sOpAudModeProp.bChnExists[(chp*2)+1] == true))
            {
                /* For the input audio mode, this audio channel pair 
            	   exists, so SRC and Mixer needs to be allocated */

                /* SRC Request */
                /* Check if 2 SRCs in cascade are required. 
                    2 SRCs in cascade are required when the SRC ratio 
                    is greater than 4 */

                if(((BRAP_ChannelType_eDecode == hRapCh->eChannelType)&&
                   (BRAP_ChannelSubType_eNone == hRapCh->eChannelSubType))
                   ||(BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)/*Assuming that for PCM playback/Capture we will do only Lint Mode SRC*/
                   ||(BRAP_ChannelType_ePcmCapture== hRapCh->eChannelType))
            	{
            		uiNumSRCs = 1;
            	}
            	else
            	{
                    uiNumSRCs = BRAP_P_NumSrcReqdInCascade(
                                        sMixingLevels.eInputSR, 
                                        sMixingLevels.eOutputSR);
                }
                BDBG_MSG(("uiNumSRCs > %d", uiNumSRCs));
                
                if((uiNumSRCs > BRAP_RM_P_MAX_SRC_IN_CASCADE) || (uiNumSRCs == 0)) 
                {
                    BDBG_ERR(("BRAP_P_NumSrcReqdInCascade returned invalid"
                              " value uiNumSRCs > %d", uiNumSRCs));
                    return BERR_TRACE(BERR_NOT_SUPPORTED);
                }

                    /* SRCs will have only one parallel path */
                for(i = 0; i < uiNumSRCs; i++)
                {
            	    pSrcMixerReq->sSrcReq[i][chp][uiPp].bAllocate = true;
                     
                    /* New allocation is required, since for each channel 
                       one SRC will be required */
                    pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcBlkId 
                            = BRAP_RM_P_INVALID_INDEX;
                    pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcId 
                            = BRAP_RM_P_INVALID_INDEX;
                }
            }
            else
            {
                pSrcMixerReq->sSrcReq[0][chp][uiPp].bAllocate = false;
            }
            } /* for chp */
    }
    /* There is a started channel, Reallocate previously allocated SRCs */
    else
    {
        for (chp = 0; chp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; chp++)
        {
            if((sOpAudModeProp.bChnExists[chp*2] == true) ||
               (sOpAudModeProp.bChnExists[(chp*2)+1] == true))
            {
                /* SRCs will have only one parallel path */
                for(i = 0; i < BRAP_RM_P_MAX_SRC_IN_CASCADE; i++)
                {
                    sPrivSrcGrant = hStrtdAssocCh->pPath[uiAsctdUsgPath]->sRsrcGrnt.
                                sSrcMixerGrnt[uiLvl].sSrcGrant[i][chp][uiPp];

                    if((BRAP_RM_P_INVALID_INDEX != sPrivSrcGrant.uiSrcId)&&
                       (BRAP_RM_P_INVALID_INDEX != sPrivSrcGrant.uiSrcBlkId))
                    {
                        /* New allocation is required, since for each channel 
                           one SRC will be required */
                        pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcBlkId 
                                = sPrivSrcGrant.uiSrcBlkId;
                        pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcId 
                                = sPrivSrcGrant.uiSrcId;

                        pSrcMixerReq->sSrcReq[i][chp][uiPp].bAllocate = true;

                    }
                }
            }
            else
            {
                pSrcMixerReq->sSrcReq[0][chp][uiPp].bAllocate = false;
            }    
        }
    }
    }

    
    BDBG_LEAVE(BRAP_P_PrepareSrcRequest);
    return ret;
}


BERR_Code BRAP_P_PrepareMixerRequest(
    BRAP_ChannelHandle      hRapCh,
    BRAP_ChannelHandle      hStrtdAssocCh,
    BRAP_RM_P_SrcMixerReq   *pSrcMixerReq,
    bool                    bPrimaryPresent,
    unsigned int            uiAsctdUsgPath,
    bool                    bInputMixingLvlOnly,
    unsigned int            uiNumMixerOutputs,
    unsigned int            uilvl,
    bool                    bDwmixEn,
    BRAP_P_MixingLevelProp  sMixingLvl,
    unsigned int            uiPth,
    unsigned int            uiAssocId
)
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_P_OpAudModProp     sMixLvlOpAudModeProp;
    BRAP_P_OpAudModProp     sCurOpAudModeProp;
    BRAP_ChannelHandle      hMasterCh = NULL;
    unsigned int            chp =0, uiPp = 0;
    unsigned int            i=0, j=0;
    BRAP_RM_P_MixerGrant    sPrivMixerGrant;
    BRAP_OutputChannelPair  eInChp = BRAP_OutputChannelPair_eMax;
    
    BDBG_ENTER(BRAP_P_PrepareMixerRequest);
    
/* 
   Algo for mixer allocation

   - Find the master channel & it's 1st level data mode 
        - If Primary decode is present, it is the master.
        - If Primary is not present in association, then the channel opened first is master.
        
   - If you are the master, allocate one mixer per chan pair (check if any other associated
     channel has already been allocated. If yes, then reallocate those mixers with new
     inputs.)
   - If you are not the master
        a) If master's 1st level of mixing has been allocated
           - for each of your chan pair allocate all the mixers 
             already allocated for the master with differen inputs
        b) If master's 1st level is not allocated
           - for each of your chan pair allocate all the mixers
             required assuming master is already allocated. Later on
             when resources for master will be allocated, these 
             mixers will be reallocated there.   

    Note: If you are the master, only one mixer input is allocated per channel pair.
          If you are not the master then n mixer input is allocated per channel pair
            where n is = number of channel pairs present in your audmode.
          (In other words, each channel pair feeds to each of the mixers allocated for the master)  
    
*/


    BDBG_MSG((" BRAP_P_PrepareMixerRequest Params :: "
        "\n\thRapCh = 0x%x" 
        "\n\thStrtdAssocCh = 0x%x"  
        "\n\tpSrcMixerReq = 0x%x"
        "\n\tbPrimaryPresent = 0x%x" 
        "\n\tuiAsctdUsgPath = 0x%x" 
        "\n\tbInputMixingLvlOnly = 0x%x" 
        "\n\tuiNumMixerOutputs = 0x%x"
        "\n\tuilvl = 0x%x"
        "\n\tbDwmixEn = 0x%x"
        "\n\tuiPth=0x%x",
        hRapCh, hStrtdAssocCh, pSrcMixerReq,
        bPrimaryPresent, uiAsctdUsgPath, bInputMixingLvlOnly,
        uiNumMixerOutputs, uilvl, bDwmixEn, uiPth));

    BSTD_UNUSED(uiPth);

    /* Initialization to bypass compiler warning */
    sCurOpAudModeProp.uiNoChannels = 0;

    if (NULL == hStrtdAssocCh)
    {
        /* This is the first channel to be started. Allocate 
           mixer according to the Master channel */
        /* Find the master channel */
        if (true == bPrimaryPresent)
        {
            hMasterCh = hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0];
        }
        else
        {
            hMasterCh = hRapCh;
        }

        ret = BRAP_P_GetAudOpModeProp(sMixingLvl.eOutputAudMode, 
                                sMixingLvl.bOutputLfeOn,&sMixLvlOpAudModeProp);
        if(BERR_SUCCESS != ret)
        {
            BDBG_ERR(("BRAP_P_GetAudOpModeProp returned %d", ret));
            return BERR_TRACE(ret);
        }

        for(chp =0; chp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; chp++)
        {
            if((true == sMixLvlOpAudModeProp.bChnExists[chp*2])||
               (true == sMixLvlOpAudModeProp.bChnExists[(chp*2) + 1]))
            {
                if(true == hRapCh->hRap->sSettings.bIndOpVolCtrl)
                {
                for(i=uiPp; i < BRAP_RM_P_MAX_PARALLEL_PATHS; i++)
                {
                    if(pSrcMixerReq->sMixerReq[chp][i].bAllocate == true)
                    uiPp++;
                    else
                        break;
                }
                }
                pSrcMixerReq->sMixerReq[chp][uiPp].bAllocate = true;
                
                pSrcMixerReq->sMixerReq[chp][uiPp].sReallocateMixer.uiDpId 
                                                = BRAP_RM_P_INVALID_INDEX;
                
                pSrcMixerReq->sMixerReq[chp][uiPp].sReallocateMixer.uiMixerId 
                                                = BRAP_RM_P_INVALID_INDEX;
                
                if(false == bDwmixEn)
                {
                    if(0 == uilvl)
                    {
                    /* If Current channel is master */
                    if ((hMasterCh == hRapCh))
                    {
                       pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewInput = 1;
                       /* Mixer input chpair is the same as the Master's chpair */
                       pSrcMixerReq->sMixerReq[chp][uiPp].bInputChPair[chp] = true;
                    }
                    else /* Current channel is not the master */
                    {
                        ret = BRAP_P_GetAudOpModeProp(sMixingLvl.eInputAudMode,
                                                       sMixingLvl.bInputLfeOn,
                                                       &sCurOpAudModeProp);
                        if(BERR_SUCCESS != ret)
                        {
                            BDBG_ERR(("BRAP_P_GetAudOpModeProp returned %d", ret));
                            return BERR_TRACE(ret);
                        }

                        pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewInput = 
                                            (sCurOpAudModeProp.uiNoChannels + 1)/2;
                        for(eInChp=0; eInChp<BRAP_OutputChannelPair_eMax; eInChp++)
                        {
                            if((true == sCurOpAudModeProp.bChnExists[eInChp*2])||
                            (true == sCurOpAudModeProp.bChnExists[(eInChp*2) + 1]))
                            {
                                pSrcMixerReq->sMixerReq[chp][uiPp].
                                                        bInputChPair[eInChp]= true;
                            }
                        }/* for eInChp */
                    }
                }
                    else
                    {
                        BDBG_MSG(("Came for Level %d",uilvl));
                        pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewInput = 1;
                        /* Mixer input chpair is the same as the Master's chpair */
                        pSrcMixerReq->sMixerReq[chp][uiPp].bInputChPair[chp] = true;
                    }
                        
                }
                else /* Down Mix at this level */
                {
                    ret = BRAP_P_GetAudOpModeProp(sMixingLvl.eInputAudMode,
                                                   sMixingLvl.bInputLfeOn,
                                                   &sCurOpAudModeProp);
                    if(BERR_SUCCESS != ret)
                    {
                        BDBG_ERR(("BRAP_P_GetAudOpModeProp returned %d", ret));
                        return BERR_TRACE(ret);
                    }

                    pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewInput = 
                                        (sCurOpAudModeProp.uiNoChannels + 1)/2;
                    for(eInChp=0; eInChp<BRAP_OutputChannelPair_eMax; eInChp++)
                    {
                        if((true == sCurOpAudModeProp.bChnExists[eInChp*2])||
                        (true == sCurOpAudModeProp.bChnExists[(eInChp*2) + 1]))
                        {
                            pSrcMixerReq->sMixerReq[chp][uiPp].
                                                    bInputChPair[eInChp]= true;
                        }
                    }/* for eInChp */
                }
            }/* if bDwnMix */
        
            /* For Mixer Output */
            if(bInputMixingLvlOnly == true)
            {
                pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewOutput = 1;
                /* Mixer output 1 can only be used for Loopback to other Mixer */
                pSrcMixerReq->sMixerReq[chp][uiPp].uiMixerOutputId[0] = 1;
                for(i=0; i<BRAP_RM_P_MAX_MIXER_OUTPUTS; i++)
                {
                    pSrcMixerReq->sMixerReq[chp][uiPp].sReallocateMixer.uiMixerOutputId[i] 
                        = BRAP_RM_P_INVALID_INDEX;
                }
            }
            else
            {
                /* TODO: Allocate number of outputs depending on direct consumers 
                         at that Level */
                pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewOutput = uiNumMixerOutputs; 
                
                for(i=0; i<BRAP_RM_P_MAX_MIXER_OUTPUTS; i++)
                {
                    pSrcMixerReq->sMixerReq[chp][uiPp].sReallocateMixer.uiMixerOutputId[i] 
                        = BRAP_RM_P_INVALID_INDEX;
                }
            }/* if bInputMixingLvlOnly */
            
            BDBG_MSG(("Mixer Request : chp = %d, uiPp = %d, \n "
                      "pSrcMixerReq->sMixerReq[chp][uiPp].bAllocate = %d \n"
                      "pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewInput = %d \n"
                      "pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewOutput =%d \n",
                        chp,uiPp,pSrcMixerReq->sMixerReq[chp][uiPp].bAllocate,
                        pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewInput,
                        pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewOutput));
        }
    }
    else if (NULL != hStrtdAssocCh) 
    {
        
        /* If a channel in association is already started, Reallocate already 
           allocated mixers */
        ret = BRAP_P_GetAudOpModeProp(sMixingLvl.eOutputAudMode, 
                                sMixingLvl.bOutputLfeOn,&sMixLvlOpAudModeProp);
        if(BERR_SUCCESS != ret)
        {
            BDBG_ERR(("BRAP_P_GetAudOpModeProp returned %d", ret));
            return BERR_TRACE(ret);
        }
        
        if(0 == uilvl)
        {
            for(chp =0; chp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; chp++)
            {
                if((true == sMixLvlOpAudModeProp.bChnExists[chp*2])||
                   (true == sMixLvlOpAudModeProp.bChnExists[(chp*2) + 1]))
                {
                    if(true == hRapCh->hRap->sSettings.bIndOpVolCtrl)
                    {
                    for(i=uiPp; i < BRAP_RM_P_MAX_PARALLEL_PATHS; i++)
                    {
                        if(pSrcMixerReq->sMixerReq[chp][i].bAllocate == true)
                        uiPp++;
                        else
                            break;
                    }
                    }          
                    for(i=0;i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;i++)
                    {
                        BDBG_ASSERT(hStrtdAssocCh->pPath[uiAsctdUsgPath] != NULL);
                        
                        sPrivMixerGrant = hStrtdAssocCh->pPath[uiAsctdUsgPath]->
                                    sRsrcGrnt.sSrcMixerGrnt[0].sMixerGrant[i][uiPp];
                        if((BRAP_RM_P_INVALID_INDEX != sPrivMixerGrant.uiDpId)&&
                           (BRAP_RM_P_INVALID_INDEX != sPrivMixerGrant.uiMixerId))
                        {
                            pSrcMixerReq->sMixerReq[i][uiPp].bAllocate = true;
                    
                            pSrcMixerReq->sMixerReq[i][uiPp].sReallocateMixer.uiDpId = sPrivMixerGrant.uiDpId;
                            pSrcMixerReq->sMixerReq[i][uiPp].sReallocateMixer.uiMixerId = sPrivMixerGrant.uiMixerId;

                            for(j=0;j<BRAP_RM_P_MAX_MIXER_OUTPUTS;j++)
                            {
                                pSrcMixerReq->sMixerReq[i][uiPp].sReallocateMixer.uiMixerOutputId[j]
                                                = sPrivMixerGrant.uiMixerOutputId[j];
                            }
                            
                            if(BRAP_ChannelSubType_ePrimary == hRapCh->eChannelSubType)
                            {
                                pSrcMixerReq->sMixerReq[i][uiPp].uiNumNewInput = 1;
                                pSrcMixerReq->sMixerReq[i][uiPp].bInputChPair[i]= true;
                            }
                            else
                            {
                                ret = BRAP_P_GetAudOpModeProp(sMixingLvl.eInputAudMode,
                                                   sMixingLvl.bInputLfeOn,
                                                   &sCurOpAudModeProp);
                                if(BERR_SUCCESS != ret)
                                {
                                    BDBG_ERR(("BRAP_P_GetAudOpModeProp returned %d", ret));
                                    return BERR_TRACE(ret);
                                }
                                pSrcMixerReq->sMixerReq[i][uiPp].uiNumNewInput = 
                                                    (sCurOpAudModeProp.uiNoChannels + 1)/2;
                                for(eInChp=0; eInChp<BRAP_OutputChannelPair_eMax; eInChp++)
                                {
                                    if((true == sCurOpAudModeProp.bChnExists[eInChp*2])||                                
                                    (true == sCurOpAudModeProp.bChnExists[(eInChp*2) + 1]))
                                    {                                    
                                        pSrcMixerReq->sMixerReq[i][uiPp].bInputChPair[eInChp]= true;
                                    }                            
                                }/* for eInChp */
                            }
                            /* For Mixer Output */
                            pSrcMixerReq->sMixerReq[i][uiPp].uiNumNewOutput = BRAP_RM_P_INVALID_INDEX;
                        }
                    }
                }
            }
        }
        else
        {
            /* Copy the already allocated mixers and reallocate them */
            for(i=0;i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;i++)
            {
                BDBG_ASSERT(NULL != hStrtdAssocCh->pPath[uiAsctdUsgPath]);
                sPrivMixerGrant = hStrtdAssocCh->pPath[uiAsctdUsgPath]->sRsrcGrnt.
                                    sSrcMixerGrnt[uilvl].sMixerGrant[i][uiPp];
                if((BRAP_RM_P_INVALID_INDEX != sPrivMixerGrant.uiDpId)&&
                   (BRAP_RM_P_INVALID_INDEX != sPrivMixerGrant.uiMixerId))
                {
                    pSrcMixerReq->sMixerReq[i][uiPp].bAllocate = true;
            
                    pSrcMixerReq->sMixerReq[i][uiPp].sReallocateMixer.uiDpId = sPrivMixerGrant.uiDpId;
                    pSrcMixerReq->sMixerReq[i][uiPp].sReallocateMixer.uiMixerId = sPrivMixerGrant.uiMixerId;

                    for(j=0;j<BRAP_RM_P_MAX_MIXER_OUTPUTS;j++)
                    {
                        pSrcMixerReq->sMixerReq[i][uiPp].sReallocateMixer.uiMixerOutputId[j]
                                        = sPrivMixerGrant.uiMixerOutputId[j];
                    }
                    
                    for (j=0;j<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;j++)
                    {
                        BDBG_MSG(("Mixer Reallocate Input Id[%d] = %d",j,sPrivMixerGrant.uiMixerInputId[j]));
                        pSrcMixerReq->sMixerReq[i][uiPp].sReallocateMixer.uiMixerInputId[j]
                                        = sPrivMixerGrant.uiMixerInputId[j];
                    }
                    /* For Mixer Output */
                    pSrcMixerReq->sMixerReq[i][uiPp].uiNumNewOutput = BRAP_RM_P_INVALID_INDEX;
                    pSrcMixerReq->sMixerReq[i][uiPp].uiNumNewInput = BRAP_RM_P_INVALID_INDEX;
                }
            }
        }
    }
    else
    {
        /* This condition should never come */
        BDBG_ASSERT(0);
    }
   
    BDBG_LEAVE(BRAP_P_PrepareMixerRequest);
    return ret;
}

#if (BRAP_INDEP_OP_DELAY_SUPPORTED ==1)
BERR_Code BRAP_P_ResrcReqRbufSrcch(
    BRAP_ChannelHandle      hRapCh,         /* [in] The RAP Channel handle */
    BRAP_RM_P_ResrcReq      *pResrcReq,     /* [out] Resource Request filled 
                                               with Mixer and SRC layout */
    unsigned int            uiPth,          /* [in] Path index */
    BRAP_P_OpAudModProp *pOpModeProp,   /* [in] OpMode property structure
                                       passed by reference */    
    bool  bCompress                                       
)
{
    BERR_Code               ret = BERR_SUCCESS;
    unsigned int            dst = 0;
    BRAP_OutputChannelPair  eChP = BRAP_OutputChannelPair_eMax;

    BDBG_ENTER(BRAP_P_ResrcReqRbufSrcch);
    BSTD_UNUSED(uiPth);

    /* Assign RBUF & SRCCH requests based on sorted DSTs */
    for(dst = 0, eChP = 0; dst < BRAP_P_MAX_DST_PER_RAPCH; dst++)
    {
        if(NULL == hRapCh->pDstDetails[dst])
            continue;
        if(BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[dst]->eAudioDst)
        {
            if(eChP >= BRAP_RM_P_MAX_OP_CHANNEL_PAIRS)
            {
                BDBG_ERR(("Exceeding Max no of channel pair."));
                return BERR_TRACE(BERR_INVALID_PARAMETER);
            }
            /* Rbuf */
            pResrcReq->sRbufReq[eChP].bAllocate = true;
            pResrcReq->sRbufReq[eChP].eBufDataMode =  BRAP_BufDataMode_eStereoNoninterleaved;
            /* SrcCh */
            pResrcReq->sSrcChReq[eChP].bAllocate = true;
            /* AdaptRateCtrl */
                if((bCompress == false)
                    &&(pOpModeProp->bChnExists[0] == true) 
                    && (pOpModeProp->bChnExists[1] == true)) /* i.e LR Channel Pair*/
                {
                    if((pOpModeProp->bChnExists[2] == true) /*Ls*/
                        ||(pOpModeProp->bChnExists[3] == true)/*Rs*/
                        ||(pOpModeProp->bChnExists[4] == true)/*Center*/
                        ||(pOpModeProp->bChnExists[6] == true) /*Lr*/
                        ||(pOpModeProp->bChnExists[7] == true))/*Rr*/
                        {
                            BDBG_MSG(("AdaptRateCtrl is not allocated for Multichannel"));
                        }
                        else
                        {
                		    /* AdaptRateCtrl */
                            BDBG_MSG(("Populating resource request for AdaptRateCtrl"));                            
                            pResrcReq->sAdaptRateCtrlReq[eChP].bAllocate = true;                            
                        }          
                }
            eChP++;
        }
    }
    
    BDBG_LEAVE(BRAP_P_ResrcReqRbufSrcch);
    return ret;
}
#endif

BERR_Code BRAP_P_MixerSrcRsrcLayout(
    BRAP_ChannelHandle      hRapCh,         /* [in] The RAP Channel handle */
    BRAP_RM_P_ResrcReq      *pResrcReq,     /* [out] Resource Request filled 
                                               with Mixer and SRC layout */
    unsigned int            uiPth,          /* [in] Path index */
    BRAP_P_MixingLevelProp  *pMixingLevels, /* [out] Pointer to an array of
                                               structure to hold mixing level
                                               properties */
    BRAP_P_InternalDst      *pIntDst,       /* [in] Internal destination struct
                                               pointer */
    BRAP_OutputMode         eAudMode,       /* [in] Audio Mode for Input to Mixer*/
    bool                    bLfe,           /* [in] LFE status for Input to mixer*/
    BAVC_AudioSamplingRate  eSR,             /* [in] Sampling rate for level 0 
                                               SRC allocation */
    bool   bCompress                                               
)
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_P_DstGrpDetails    sDstGrp[BRAP_P_MAX_DST_PER_RAPCH + 
                                                    BRAP_RM_P_MAX_INTERNAL_DST + 1];
    /* Extra one to keep invalid entry for stack usage reduction */
    unsigned int            dst = 0, /*chp = 0,*/ uiLevel = 0, uiPp = 0;
    unsigned int            i=0, j=0, k=0, uiIntDst = 0 /*, path=0*/;
    BRAP_ChannelHandle      hStrtdAssocCh[BRAP_MAX_ASSOCIATED_GROUPS];
    bool                    bPrimaryPresent[BRAP_MAX_ASSOCIATED_GROUPS];
    unsigned int            uiAsctdUsgPath[BRAP_MAX_ASSOCIATED_GROUPS];
    bool                    bSetTopDecCh = false;
    bool                    bLfeOn = false;
    BRAP_P_OpAudModProp     sCurOpAudModeProp;
    unsigned int            uiMaxDstGrp = 0;
    BRAP_RM_P_SrcMixerReq   *pSrcMixerReq = NULL;
    unsigned int            uiNumConsumers = 0;
#if BRAP_P_EQUALIZER
    bool                    bSrcBlkAssigned = false;
    unsigned int            uisrc_blk = 0,uisrc_id = 0, l = 0;
    unsigned int            uiNumSrcEqAllocated[BRAP_RM_P_MAX_SRC_BLCK];    
    unsigned int            uiSrcRequestindex = 0;
    unsigned int            uiNumSrcEqsRequired = 0;
    unsigned int            uiCurrentAssocIdOfChan=0;
#endif
    bool                    bDwmixEn = false;
    unsigned int            sClonedDst[BRAP_P_MAX_OUTPUT_CONFIGS][BRAP_P_MAX_CLONES];
    unsigned int            uiNumMixerOutputs =0, uiAssocId=0;
    unsigned int            uiNumMixerRqd =0;
    bool                    bInputMixLvl = false;
    unsigned int            uiPpMix = 0;
    bool                    bBreakLoop = false, bLookStartedChan = true;

    
    BDBG_ENTER(BRAP_P_MixerSrcRsrcLayout);

    if(hRapCh->pPath[uiPth] == NULL)
    {
        BDBG_ERR(("Path handle should not be null "));
        BDBG_ASSERT(0);
        return BERR_TRACE(BERR_INVALID_PARAMETER);
    }
    BKNI_Memset((void *)&sCurOpAudModeProp,0,sizeof(BRAP_P_OpAudModProp));
    /* Init sDstGrp[] to hold invalid values */
    for(dst = 0; dst < BRAP_P_MAX_DST_PER_RAPCH + BRAP_RM_P_MAX_INTERNAL_DST + 1; dst++)
    {
        sDstGrp[dst] = sDstGrpInvalid;
    }

#if BRAP_P_EQUALIZER
    for(uisrc_blk=0; uisrc_blk<BRAP_RM_P_MAX_SRC_BLCK; uisrc_blk++)
    {
        uiNumSrcEqAllocated[uisrc_blk] = 0;
    }
#endif    

    for (i=0; i < BRAP_P_MAX_OUTPUT_CONFIGS; i++)
    {
        for(j=0;j<BRAP_P_MAX_CLONES;j++)
        {
            sClonedDst[i][j]=BRAP_INVALID_VALUE;
        }
    }
    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
    {
        hStrtdAssocCh[uiAssocId]=NULL;
        bPrimaryPresent[uiAssocId]=false;
        uiAsctdUsgPath[uiAssocId] = BRAP_INVALID_VALUE;
    }

#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
    if((BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh)) &&
       ((hRapCh->pPath[uiPth]->eUsgPath != BRAP_P_UsgPath_eDecodePcmPostMixing) &&
        (hRapCh->pPath[uiPth]->eUsgPath != BRAP_P_UsgPath_ePPBranchPostMixing)))
    {
        /* In MS11 case Decode channels output to DRAM and a PB channel to RBUF. 
           So DecodePCM and PPBranch paths don't share any resources and have to 
           be formed for each channel. Only PostMixing path is shared. */
        bLookStartedChan = false;
    }
#endif    
    if(bLookStartedChan == true)
    {
        ret = BRAP_P_GetStartedChannel(hRapCh,bPrimaryPresent,hStrtdAssocCh);
        if(ret != BERR_SUCCESS)
        {
            BDBG_ERR(("BRAP_P_GetStartedChannel returned error"));
            return BERR_TRACE(ret);
        }
    }
   
    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
    {
        if(hRapCh->uiAssociationId[uiAssocId] != BRAP_INVALID_VALUE)
        {
            BDBG_MSG(("BRAP_P_MixerSrcRsrcLayout: hRapCh = 0x%x hStartedAssoCh[uiAssocId=%d] = 0x%x",
                hRapCh,hRapCh->uiAssociationId[uiAssocId],hStrtdAssocCh[hRapCh->uiAssociationId[uiAssocId]]));
        }
    }
    
    /* Need to search for a started channel in the association that the given path(uiPth) belongs to. */
    uiAssocId = hRapCh->pPath[uiPth]->uiAssocId;
    if(BRAP_P_IsPointerValid((void *)hStrtdAssocCh[uiAssocId]))
    {   
        /* Check if the same path has been started in the associated started 
           channel */
        bBreakLoop  =false;
        for(i=0; i<BRAP_P_MAX_PATHS_IN_A_CHAN; i++)
        {
            if(!(BRAP_P_IsPointerValid((void *)hStrtdAssocCh[uiAssocId]->pPath[i])))
            {
                continue;
            }

            for(j =0 ; j < BRAP_P_MAX_DST_PER_RAPCH; j++)
            {
                if(hStrtdAssocCh[uiAssocId]->pPath[i]->pDstDetails[j] == NULL)
                    continue;
                for(k =0 ; k < BRAP_P_MAX_DST_PER_RAPCH; k++)                    
                {
                    if(hRapCh->pPath[uiPth]->pDstDetails[k] == NULL)
                    {
                        if((BRAP_INVALID_VALUE != hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx) &&
                           (BRAP_P_UsgPath_eCapture == hRapCh->pPath[hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx]->eUsgPath))
                        {
                            /* hRapCh has DecodePcmPostMixing path. Don't get out of the loop. 
                               pDstDetails will be null for DecodePcm/PPBranch path in all the channels of this Assoc */
                        }
                        else
                            continue;                        
                    }
                    if(hStrtdAssocCh[uiAssocId]->pPath[i]->pDstDetails[j] == hRapCh->pPath[uiPth]->pDstDetails[k])
                    {
                        uiAsctdUsgPath[uiAssocId] = i;
                        bBreakLoop  = true;
                        break;
                    }                        
                }
                if(true == bBreakLoop)
                    break;
            }
            if(true == bBreakLoop)
                break;

        }

        if(i >= BRAP_P_MAX_PATHS_IN_A_CHAN)
        {
            BDBG_ERR(("BRAP_P_MixerSrcRsrcLayout : Could not find Similar"
                              " path in started associated channel "));
            return BERR_TRACE(BERR_NOT_INITIALIZED);
        }
    }

    /* Check if this channel is a Decode Channel for Set Top Box Platform */
    if((hRapCh->eChannelSubType == BRAP_ChannelSubType_eNone) && 
       (hRapCh->eChannelType == BRAP_ChannelType_eDecode))
    {
        bSetTopDecCh = true;
    }

    /* Check LFE Status */
    if(hRapCh->eChannelType == BRAP_ChannelType_eDecode)
    {
        bLfeOn = hRapCh->bInputLfeOn;
    }
    else
    {
        hRapCh->bInputLfeOn = bLfeOn = false;
    }

    /* TODO: Add support for compressed path e.g. passthru, transcode */
    /* Prepare the destination group */
    ret = BRAP_P_FormAndSortDestGrp(hRapCh,uiPth,sDstGrp,bSetTopDecCh,pIntDst,
                              &uiMaxDstGrp,bPrimaryPresent[uiAssocId],uiAssocId);
    if(ret != BERR_SUCCESS)
    {
        BDBG_ERR(("BRAP_P_FormAndSortDestGrp returnrd error"));
        return BERR_TRACE(ret);
    }

    /* Update the Sorted Dsts in Clone Array */
    for(dst = 0,i=0,j=0; dst < uiMaxDstGrp; dst++)
    {
        if(0 == dst)
        {
            BDBG_MSG(("\t sDstGrp[dst=%d].eAudioMode=%d"
                      "\n\t sDstGrp[dst].eSamplingRate=%d",
                        dst,sDstGrp[dst].eAudioMode,
                        sDstGrp[dst].eSamplingRate));
            
            sClonedDst[i][j] = dst;
        }
        else
        {
            BDBG_MSG(("\t sDstGrp[dst=%d].eAudioMode=%d"
                      "\n\t sDstGrp[dst].eSamplingRate=%d"
                      "\n\t sDstGrp[dst-1].eAudioMode=%d"
                      "\n\t sDstGrp[dst-1].eSamplingRate=%d",
                        dst,sDstGrp[dst].eAudioMode,
                        sDstGrp[dst].eSamplingRate,
                        sDstGrp[dst-1].eAudioMode,
                        sDstGrp[dst-1].eSamplingRate));
            
            if((sDstGrp[dst-1].eAudioMode == sDstGrp[dst].eAudioMode) && 
               (sDstGrp[dst-1].eSamplingRate == sDstGrp[dst].eSamplingRate))
            {
                /* This is the clone of the previous Dst */
                if(true == hRapCh->hRap->sSettings.bIndOpVolCtrl)
                {
                  i++;j = 0;
                }
                else
                {
                  j++;
                }

                if( j >= BRAP_P_MAX_CLONES)
                {
                    BDBG_ERR(("Maximum %d clonned ports possible.",BRAP_P_MAX_CLONES));
                    BDBG_ASSERT(0);
                    return BERR_TRACE(BERR_NOT_SUPPORTED);
                }
                sClonedDst[i][j]=dst;
                
            }
            else
            {
                /* This is not a clone of previous Dst */
                i++;
                j=0;
                if( i >= BRAP_P_MAX_OUTPUT_CONFIGS)
                {
                    BDBG_ERR(("Maximum Eight Different output ports' config possible."));
                    return (BERR_NOT_SUPPORTED);
                }
                sClonedDst[i][j]=dst;
                
            }
        }
    }

    for (i=0; i < BRAP_P_MAX_OUTPUT_CONFIGS; i++)
    {
        for(j=0;j<BRAP_P_MAX_CLONES;j++)
        {
            if(BRAP_INVALID_VALUE == sClonedDst[i][j])
                sClonedDst[i][j] = BRAP_P_MAX_DST_PER_RAPCH + BRAP_RM_P_MAX_INTERNAL_DST;
        }
    }

    for(i=0,uiLevel = 0,uiPp = 0 ;(i< BRAP_P_MAX_OUTPUT_CONFIGS);i++)
    {
        bInputMixLvl = false;
        
        if((NULL == sDstGrp[sClonedDst[i][0]].pDstDetails)&&
           (NULL == sDstGrp[sClonedDst[i][0]].pIntDstDetails)&&
           (false == sDstGrp[sClonedDst[i][0]].bInputMixingLvlOnly))
        {
            continue;
        }
        uiNumConsumers = 0;
        for(j=0;j<BRAP_P_MAX_CLONES;j++)
        {
            if ((NULL != sDstGrp[sClonedDst[i][j]].pDstDetails)||
                (NULL != sDstGrp[sClonedDst[i][j]].pIntDstDetails)||
                (true == sDstGrp[sClonedDst[i][j]].bInputMixingLvlOnly))
            {
                uiNumConsumers++;
        		BDBG_MSG(("1 j=%d uiNumConsumers=%d",j,uiNumConsumers ));
            }
            if(true == sDstGrp[sClonedDst[i][j]].bInputMixingLvlOnly)
            {
                bInputMixLvl =true;
            }
        }
        if(0 == uiLevel)
        {
            if((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDownmixedPath)
                ||(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDownmixedMixPath)
                ||((hRapCh->pPath[uiPth]->pDstDetails[0] != NULL)
                       && (hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eOutputPort)
                       && (hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.sOpDetails.eAudioMode == BRAP_OutputMode_e2_0)
                       && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))
                ||((hRapCh->pPath[uiPth]->pDstDetails[0] != NULL)
                       && (hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                       && (hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.sRBufDetails.eAudioMode == BRAP_OutputMode_e2_0)
                       && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))                       
                ||(bCompress == true))
            {
                pMixingLevels[uiLevel].eInputAudMode = BRAP_OutputMode_e2_0;
                pMixingLevels[uiLevel].bInputLfeOn = false;
                pMixingLevels[uiLevel].eInputSR = eSR;
            }
            else
            {
                pMixingLevels[uiLevel].eInputAudMode = eAudMode;
                pMixingLevels[uiLevel].bInputLfeOn = bLfe;
                pMixingLevels[uiLevel].eInputSR = eSR;
            }
        }
        else
        {
            pMixingLevels[uiLevel].eInputAudMode = pMixingLevels[uiLevel-1].eOutputAudMode;
            pMixingLevels[uiLevel].eInputSR = pMixingLevels[uiLevel-1].eOutputSR;
            pMixingLevels[uiLevel].bInputLfeOn = pMixingLevels[uiLevel-1].bOutputLfeOn;
        }
        pMixingLevels[uiLevel].eOutputAudMode = sDstGrp[sClonedDst[i][0]].eAudioMode; 
        pMixingLevels[uiLevel].bOutputLfeOn = sDstGrp[sClonedDst[i][0]].bLfeOn;
        pMixingLevels[uiLevel].eOutputSR = sDstGrp[sClonedDst[i][0]].eSamplingRate;

        pSrcMixerReq = &(pResrcReq->sSrcMixerReq[uiLevel]);

        /* For SRC allocation, for level 0, we need the channel's audio mode */
            ret = BRAP_P_GetAudOpModeProp(pMixingLevels[uiLevel].eInputAudMode,
                                      pMixingLevels[uiLevel].bInputLfeOn,
                                      &sCurOpAudModeProp);
        if(BERR_SUCCESS != ret)
        {
            BDBG_ERR(("BRAP_P_GetAudOpModeProp returned %d", ret));
            return BERR_TRACE(ret);
        }

        /* This is required to allow mixing of primary, secondary and sound 
           effects. Also, after first level of mixing there is no 
           distinction between primary and secondary sub channels */
        if((0 == uiLevel)||
           (pMixingLevels[uiLevel].eOutputSR != pMixingLevels[uiLevel-1].eOutputSR))
        {
            ret = BRAP_P_PrepareSrcRequest(hRapCh,sCurOpAudModeProp,
                                    pMixingLevels[uiLevel],pSrcMixerReq,uiPp,
                                    uiLevel,hStrtdAssocCh[uiAssocId],uiAsctdUsgPath[uiAssocId],uiPth);
            if(BERR_SUCCESS != ret)
            {
                BDBG_ERR(("BRAP_P_PrepareSrcRequest returned %d", ret));
                return BERR_TRACE(ret);
            }
        }
        BDBG_MSG(("BRAP_P_DecideDwnMixing: InMode %d, OutMode %d, uiLevel %d",
                                pMixingLevels[uiLevel].eInputAudMode,
                                pMixingLevels[uiLevel].eOutputAudMode,
                                uiLevel));

        if((BRAP_ChannelType_eDecode == hRapCh->eChannelType)||
	     (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType))
        {
            if(((BRAP_P_UsgPath_eDecodePcm == hRapCh->pPath[uiPth]->eUsgPath)&&
                (0!=uiLevel)&&
                (false == bInputMixLvl)&&
                (pMixingLevels[uiLevel].eInputAudMode != 
                                            pMixingLevels[uiLevel].eOutputAudMode))
               )
            {
                ret = BRAP_P_DecideDwnMixing(pMixingLevels[uiLevel].eInputAudMode,
                                             pMixingLevels[uiLevel].bInputLfeOn,
                                             pMixingLevels[uiLevel].eOutputAudMode,
                                             pMixingLevels[uiLevel].bOutputLfeOn,
                                             &bDwmixEn);
                BDBG_MSG(("BRAP_P_DecideDwnMixing: bDwnMixEn %d ",bDwmixEn));

                if(BERR_SUCCESS != ret)
                {
                    BDBG_ERR(("BRAP_P_DecideDwnMixing returned %d", ret));
                    return BERR_TRACE(ret);
                }
            }
        }
        
        if(1 < uiNumConsumers)
        {
            uiNumMixerRqd = (uiNumConsumers -1);
        }
        else
        {
            uiNumMixerRqd = 1;
        }
        
        for(j=0,k=0,uiIntDst=0; j<uiNumConsumers; j++)
        {
#if BRAP_P_CUSTOM_MIXER_REQUIREMENT
            uiLevel=0;
            pSrcMixerReq = &(pResrcReq->sSrcMixerReq[uiLevel]);
#endif
            pMixingLevels[uiLevel].pIntDstDetails[uiIntDst] = sDstGrp[sClonedDst[i][j]].pIntDstDetails;

            if(1 < uiMaxDstGrp)
            {
                uiNumMixerOutputs = 2;
            }
            else
            {
                uiNumMixerOutputs = 1;
            }

            BDBG_MSG(("uiPath=%d",uiPth));

#if BRAP_P_CUSTOM_MIXER_REQUIREMENT
                BDBG_MSG(("Custom Mixer Requirement is enalbed"));
                uiNumMixerOutputs = 2;
#endif            
            ret = BRAP_P_PrepareMixerRequest(hRapCh,hStrtdAssocCh[uiAssocId],pSrcMixerReq,
                                             bPrimaryPresent[uiAssocId],uiAsctdUsgPath[uiAssocId],
                                             sDstGrp[sClonedDst[i][j]].bInputMixingLvlOnly,
                                             uiNumMixerOutputs,uiLevel,bDwmixEn,
                                             pMixingLevels[uiLevel],uiPth,uiAssocId);
            if(BERR_SUCCESS != ret)
            {
                BDBG_ERR(("BRAP_P_PrepareMixerRequest returned %d for uiAssocId=%d", ret,uiAssocId));
                return BERR_TRACE(ret);
            }

#if BRAP_P_CUSTOM_MIXER_REQUIREMENT
            {   
                int x =0, nNumExtraMixers=0;
                
                if (NULL != sDstGrp[sClonedDst[i][j]].pDstDetails)
                {
                    /* If there is atleast one valid destination pDstDetails will not be NULL here */
                    if (sDstGrp[sClonedDst[i][j]].pDstDetails->uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR] == BRAP_OutputPort_eI2s4)
                        nNumExtraMixers = 2;
                    else if (sDstGrp[sClonedDst[i][j]].pDstDetails->uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR] == BRAP_OutputPort_eDac0)
                        nNumExtraMixers = 1;
                    else
                        nNumExtraMixers = 0;
                    
                    for(x=0;x<nNumExtraMixers;x++)
                    {
                        uiLevel++;
                        
                        pMixingLevels[uiLevel].eInputAudMode = pMixingLevels[uiLevel-1].eOutputAudMode;
                        pMixingLevels[uiLevel].eInputSR = pMixingLevels[uiLevel-1].eOutputSR;
                        pMixingLevels[uiLevel].bInputLfeOn = pMixingLevels[uiLevel-1].bOutputLfeOn;
                        pMixingLevels[uiLevel].eOutputAudMode = sDstGrp[sClonedDst[i][0]].eAudioMode; 
                        pMixingLevels[uiLevel].bOutputLfeOn = sDstGrp[sClonedDst[i][0]].bLfeOn;
                        pMixingLevels[uiLevel].eOutputSR = sDstGrp[sClonedDst[i][0]].eSamplingRate;

                        pSrcMixerReq = &(pResrcReq->sSrcMixerReq[uiLevel]);
                        ret = BRAP_P_PrepareMixerRequest(hRapCh,hStrtdAssocCh[uiAssocId],pSrcMixerReq,
                                                     bPrimaryPresent[uiAssocId],uiAsctdUsgPath[uiAssocId],
                                                     sDstGrp[sClonedDst[i][j]].bInputMixingLvlOnly,
                                                     uiNumMixerOutputs,uiLevel,bDwmixEn,
                                                     pMixingLevels[uiLevel],uiPth,uiAssocId);
                        if(BERR_SUCCESS != ret)
                        {
                            BDBG_ERR(("BRAP_P_PrepareMixerRequest returned %d", ret));
                            return BERR_TRACE(ret);
                        }
                    }
                }
            }
#endif            
            
            if (true == sDstGrp[sClonedDst[i][j]].bInputMixingLvlOnly)
            {
                if(NULL != sDstGrp[sClonedDst[i][j]].pDstDetails)
                {
                    if (true == hRapCh->hRap->sSettings.bIndOpVolCtrl)
                    {
                        pMixingLevels[uiLevel].pDstDetails[uiPpMix] = sDstGrp[sClonedDst[i][j]].pDstDetails;
                    }
                    else
                    {
                        pMixingLevels[uiLevel].pDstDetails[k] = sDstGrp[sClonedDst[i][j]].pDstDetails;
                    }
                }

                if(NULL != sDstGrp[sClonedDst[i][j]].pIntDstDetails)
                {
                    pMixingLevels[uiLevel].pIntDstDetails[uiIntDst] = sDstGrp[sClonedDst[i][j]].pIntDstDetails;
                }

                if ((true == hRapCh->hRap->sSettings.bIndOpVolCtrl) &&
                    (NULL != sDstGrp[sClonedDst[i][j]].pDstDetails))
                {
                    uiPpMix++;
                }
                else if((NULL != sDstGrp[sClonedDst[i][j]].pDstDetails) ||
                        (NULL != sDstGrp[sClonedDst[i][j]].pIntDstDetails))
                {
                    uiLevel++;
                    
                    pMixingLevels[uiLevel].eInputAudMode = pMixingLevels[uiLevel-1].eOutputAudMode;
                    pMixingLevels[uiLevel].eInputSR = pMixingLevels[uiLevel-1].eOutputSR;
                    pMixingLevels[uiLevel].bInputLfeOn = pMixingLevels[uiLevel-1].bOutputLfeOn;
                }
   
                pMixingLevels[uiLevel].eOutputAudMode = sDstGrp[sClonedDst[i][0]].eAudioMode; 
                pMixingLevels[uiLevel].bOutputLfeOn = sDstGrp[sClonedDst[i][0]].bLfeOn;
                pMixingLevels[uiLevel].eOutputSR = sDstGrp[sClonedDst[i][0]].eSamplingRate;

                pSrcMixerReq = &(pResrcReq->sSrcMixerReq[uiLevel]);
            }
            else
            {
                if(((NULL != sDstGrp[sClonedDst[i][j+1]].pDstDetails) || (NULL != sDstGrp[sClonedDst[i][j+1]].pIntDstDetails))&& 
                   (2 >= (uiNumConsumers - j))&&
                   (NULL == sDstGrp[sClonedDst[i+1][0]].pDstDetails)&&(NULL == sDstGrp[sClonedDst[i+1][0]].pIntDstDetails))
                {
                    if(NULL != sDstGrp[sClonedDst[i][j]].pDstDetails)
                    { 
#if BRAP_P_CUSTOM_MIXER_REQUIREMENT
                        pMixingLevels[uiLevel].pDstDetails[uiPpMix] = sDstGrp[sClonedDst[i][j]].pDstDetails;
#else
                        pMixingLevels[uiLevel].pDstDetails[k] = sDstGrp[sClonedDst[i][j]].pDstDetails;
#endif
                        k++;
                    }
                    else if(NULL != sDstGrp[sClonedDst[i][j]].pIntDstDetails)
                    {
                        pMixingLevels[uiLevel].pIntDstDetails[uiIntDst] = sDstGrp[sClonedDst[i][j]].pIntDstDetails;
                        uiIntDst++;
                    }                    
                }
                else
                {
                    if(NULL != sDstGrp[sClonedDst[i][j]].pDstDetails)
                    {
                        if (true == hRapCh->hRap->sSettings.bIndOpVolCtrl)
                        {
                            pMixingLevels[uiLevel].pDstDetails[uiPpMix] = sDstGrp[sClonedDst[i][j]].pDstDetails;
                        }
                        else
                        {
                            pMixingLevels[uiLevel].pDstDetails[k] = sDstGrp[sClonedDst[i][j]].pDstDetails;
                        }
                    }
                    
                    if ((true == hRapCh->hRap->sSettings.bIndOpVolCtrl) &&
                        (NULL != sDstGrp[sClonedDst[i][j]].pDstDetails))
                    {
                        uiPpMix++;
                    }
                    else if((NULL != sDstGrp[sClonedDst[i][j]].pDstDetails) ||
                            (NULL != sDstGrp[sClonedDst[i][j]].pIntDstDetails))
                    {
                        uiLevel++;
                        
                        pMixingLevels[uiLevel].eInputAudMode = pMixingLevels[uiLevel-1].eOutputAudMode;
                        pMixingLevels[uiLevel].eInputSR = pMixingLevels[uiLevel-1].eOutputSR;
                        pMixingLevels[uiLevel].bInputLfeOn = pMixingLevels[uiLevel-1].bOutputLfeOn;
                    }
   
                    pMixingLevels[uiLevel].eOutputAudMode = sDstGrp[sClonedDst[i][0]].eAudioMode; 
                    pMixingLevels[uiLevel].bOutputLfeOn = sDstGrp[sClonedDst[i][0]].bLfeOn;
                    pMixingLevels[uiLevel].eOutputSR = sDstGrp[sClonedDst[i][0]].eSamplingRate;

                    pSrcMixerReq = &(pResrcReq->sSrcMixerReq[uiLevel]);
                }
            }
        }
    }
#if BRAP_P_EQUALIZER
    /* Request and allocate the SRC for Equalizer here
        We need uiNumConsumers SRC Equalizers one for each destination */

    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
    {
        hStrtdAssocCh[uiAssocId]=NULL;
        bPrimaryPresent[uiAssocId]=false;
    }
    
    ret = BRAP_P_GetStartedChannel(hRapCh,bPrimaryPresent,hStrtdAssocCh);
    if(ret != BERR_SUCCESS)
    {
        BDBG_ERR(("BRAP_P_GetStartedChannel returnrd error"));
        return BERR_TRACE(ret);
    }

    uiCurrentAssocIdOfChan = hRapCh->pPath[uiPth]->uiAssocId;

    for(i=0;i< BRAP_P_MAX_OUTPUT_CONFIGS;i++)
    {
        if((NULL == sDstGrp[sClonedDst[i][0]].pDstDetails)&&
           (NULL == sDstGrp[sClonedDst[i][0]].pIntDstDetails)&&
           (false == sDstGrp[sClonedDst[i][0]].bInputMixingLvlOnly))
        {
            continue;
        }

        for(j=0;j<BRAP_P_MAX_CLONES;j++)
        {
            if (NULL != sDstGrp[sClonedDst[i][j]].pDstDetails)
            {
                /* For valid output port paths see if equalizer has been added */
                BRAP_P_DstDetails *pvtDstDetails;
                unsigned int uiAssocitationID = 0;
                
                pvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
                if( NULL==pvtDstDetails)
                {
                    ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
                    goto end;
                }
                BKNI_Memset(pvtDstDetails,0,sizeof( BRAP_P_DstDetails ));                        
                
                ret  = BRAP_P_GetPvtDstDetails (
                                hRapCh,
                                sDstGrp[sClonedDst[i][j]].pDstDetails,
                                pvtDstDetails,
                                &uiAssocitationID
                            );
                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_P_GetPvtDstDetails returnrd error"));
                    return BERR_TRACE(ret);
                }

                if(pvtDstDetails->hEqualizer != NULL)
                {
                    if(hStrtdAssocCh[uiCurrentAssocIdOfChan] == NULL)
                    {                    
                        pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].bAllocate = true;
                        pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].sReallocateSrcEq.uiSrcBlkId = BRAP_RM_P_INVALID_INDEX;
                        pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].sReallocateSrcEq.uiSrcId = BRAP_RM_P_INVALID_INDEX;
                        uiNumSrcEqsRequired++;

                        pResrcReq->sSrcEqReq[1][0][uiSrcRequestindex].bAllocate = true;
                        pResrcReq->sSrcEqReq[1][0][uiSrcRequestindex].sReallocateSrcEq.uiSrcBlkId = BRAP_RM_P_INVALID_INDEX;
                        pResrcReq->sSrcEqReq[1][0][uiSrcRequestindex].sReallocateSrcEq.uiSrcId = BRAP_RM_P_INVALID_INDEX;
                        uiNumSrcEqsRequired++;                            

                        /* Same Equalizer can be added to multiple output ports that belong 
                           to same raptor channel. If an SRC for this EQ is already allocated,
                               allocate the subsequent SRCs for this EQ from the same block */
                        for(l=0; l<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; l++)
                        {
                            for(uiPp=0; uiPp<BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
                            {
                                for(k=0; k<BRAP_P_MAX_PATHS_IN_A_CHAN; k++)
                                {                            
                                    if((NULL != pvtDstDetails->hEqualizer->hSrcEq[0][l][uiPp][k]) &&
                                       (NULL != pvtDstDetails->hEqualizer->hSrcEq[1][l][uiPp][k]))
                                    {
                                        BDBG_MSG(("BRAP_P_MixerSrcRsrcLayout: Requesting SRC from the same Block %d"
                                            "as that of earlier allocated Equalizer SRC.", 
                                            pvtDstDetails->hEqualizer->hSrcEq[0][l][uiPp][k]->uiBlkId));
                                        
                                        pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].uiBlkId = 
                                                        pvtDstDetails->hEqualizer->hSrcEq[0][l][uiPp][k]->uiBlkId;
                                        pResrcReq->sSrcEqReq[1][0][uiSrcRequestindex].uiBlkId = 
                                                        pvtDstDetails->hEqualizer->hSrcEq[1][l][uiPp][k]->uiBlkId;
                                        bSrcBlkAssigned = true;
                                        break;                                    
                                    }
                                }
                                if(true == bSrcBlkAssigned)
                                    break;
                            }
                            if(true == bSrcBlkAssigned)
                                break;                            
                        }

                        if(false == bSrcBlkAssigned)
                        {
                            /* Count the total number of Equalizer SRCs allocated so far */
                            for(uisrc_blk=0;uisrc_blk<BRAP_RM_P_MAX_SRC_BLCK;uisrc_blk++)
                            {
                                for(uisrc_id=0;uisrc_id<BRAP_RM_P_MAX_SRC_PER_SRC_BLCK;uisrc_id++)
                                {
                                    if((0 < hRapCh->hRap->hRm->sSrcUsage[uisrc_blk][uisrc_id].uiUsageCount) &&
                                       (true == hRapCh->hRap->hRm->sSrcUsage[uisrc_blk][uisrc_id].bSrcEq))
                                    {
                                        uiNumSrcEqAllocated[uisrc_blk]++;                            
                                    }                        
                                }
                            }

                            /* There are 160 Coeff adresses available in SRC0 for IIR filter
                               so 2 SrcEqs((40+40)*2) can be allocated. In SRC1 we have entire
                               360 Coeff adresses for IIR filters so 4 SrcEqs can be allocated,
                               leaving 40 more addresses free */                     
                            if(2 > uiNumSrcEqAllocated[0])
                            {
                                pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].uiBlkId = 0;                        
                                pResrcReq->sSrcEqReq[1][0][uiSrcRequestindex].uiBlkId = 0;
                            }
                            else if(4 > uiNumSrcEqAllocated[1])
                            {
                                pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].uiBlkId = 1;                        
                                pResrcReq->sSrcEqReq[1][0][uiSrcRequestindex].uiBlkId = 1;
                            }
                            else
                            {
                                BDBG_ERR(("BRAP_RM_P_AllocateSrcEq: Could not Allocate SRC." 
                                    " No Free SRC/Coefficient Address available"));
                                return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);                    
                            } 
                            BDBG_MSG(("BRAP_P_MixerSrcRsrcLayout: Requesting SRC from Block %d",
                                pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].uiBlkId));
                        }
                        uiSrcRequestindex++;
                    }
                    else
                    {
                        for(k=0; k < BRAP_P_MAX_PATHS_IN_A_CHAN; k++)
                        {
                            if(hStrtdAssocCh[uiCurrentAssocIdOfChan]->pPath[k] == NULL)
                                continue;
                            for(l=0; l < BRAP_P_MAX_DST_PER_RAPCH; l++)
                            {
                                if((hStrtdAssocCh[uiCurrentAssocIdOfChan]->pPath[k]->pDstDetails[l]->eAudioDst == 
                                    pvtDstDetails->sExtDstDetails.eAudioDst) &&
                                   (hStrtdAssocCh[uiCurrentAssocIdOfChan]->pPath[k]->pDstDetails[l]->uDstDetails.sOpDetails.eOutput[0] == 
                                    pvtDstDetails->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]))
                                {
                                    for(uiPp=0;uiPp<BRAP_RM_P_MAX_PARALLEL_PATHS;uiPp++)
                                    {           
                                        if((hStrtdAssocCh[uiCurrentAssocIdOfChan]->pPath[k]->sRsrcGrnt.
                                            sSrcEqGrant[0][0][uiPp].uiSrcBlkId != BRAP_RM_P_INVALID_INDEX) &&
                                           (hStrtdAssocCh[uiCurrentAssocIdOfChan]->pPath[k]->sRsrcGrnt.
                                            sSrcEqGrant[0][0][uiPp].uiSrcId != BRAP_RM_P_INVALID_INDEX))
                                        {
                                            pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].bAllocate = true;                
                                            pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].sReallocateSrcEq.uiSrcBlkId = 
                                                hStrtdAssocCh[uiCurrentAssocIdOfChan]->pPath[k]->sRsrcGrnt.sSrcEqGrant[0][0][uiPp].uiSrcBlkId;
                                            pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].sReallocateSrcEq.uiSrcId = 
                                                hStrtdAssocCh[uiCurrentAssocIdOfChan]->pPath[k]->sRsrcGrnt.sSrcEqGrant[0][0][uiPp].uiSrcId;
                                            uiSrcRequestindex++;
                                            uiNumSrcEqsRequired++;                                            
                                            bBreakLoop = true;
                                            break;
                                        }
                                    }
                                }
                                if(bBreakLoop == true)
                               break;                                
                            }
                            if(bBreakLoop == true)
                           break;
                        }
                    }    
                }
                else
                {
                    pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].bAllocate = false;
                    uiSrcRequestindex++;                        
                }
            }
            
            if (NULL != sDstGrp[sClonedDst[i][j]].pIntDstDetails)
            {
                /* No equalizer for internal capture ports in this method */
                pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].bAllocate = false;
                uiSrcRequestindex++;
            }
        }
    }

    BDBG_MSG (("Equalizer Related Resource: uiNumSrcEqsRequired = %d",uiNumSrcEqsRequired));

#endif
#if BRAP_P_EQUALIZER
end:
#endif
    BDBG_LEAVE(BRAP_P_MixerSrcRsrcLayout);
    return ret;
}


BERR_Code BRAP_P_ValidateDecPathParams(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	const BRAP_ChannelParams	*pAudioParams   /* [in] Audio params passed 
	                                               during channel start time */
    )
{
    BERR_Code ret = BERR_SUCCESS;
    bool bWdgRecovery = false;
    BRAP_Handle hRap = NULL;
    
    /* Check if this is a watchdog recovery. */
      BDBG_ASSERT(hRapCh);
    bWdgRecovery = BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap);
    hRap = hRapCh->hRap;
  

    /* Check for valid supported conditions if not watchdog recovery */
    if(false == bWdgRecovery) 
    {
        if(BRAP_ChannelType_eDecode == hRapCh->eChannelType)
        {
            /* Check DecodeMode */
            switch(pAudioParams->sDspChParams.eDecodeMode)
            {
                /* Modes supported:  */
                case BRAP_DSPCHN_DecodeMode_eDecode:
                case BRAP_DSPCHN_DecodeMode_ePassThru:
                    break;
                /* Not supported */
                default:
                    BDBG_ERR(("BRAP_P_OpenAndStartDecPath: Decode mode %d not" 
                        " supported", pAudioParams->sDspChParams.eDecodeMode));
                    return BERR_TRACE(BERR_INVALID_PARAMETER);
            }

            if(BRAP_AudioSource_eExtCapPort != pAudioParams->eAudioSource)
            {
                /* Check audio algorithm type */
/*                ret = BRAP_P_IsAlgoTypeSupported(hRap, pAudioParams->sDspChParams.eType);
                if(BERR_SUCCESS != ret)
                {
                    return BERR_TRACE(ret);                        
                }*/
#if 0                
                if(!((BRAP_DSPCHN_AudioType_eAc3 == pAudioParams->sDspChParams.eType)&&
                    (BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode)))
                {
                    if(false == BRAP_FWDWNLD_P_IsAudCodecSupported(pAudioParams->sDspChParams.eType))
                    {
                        BDBG_ERR(("Algo Type (%d) Not Supported", pAudioParams->sDspChParams.eType));
                        return BERR_TRACE(ret);                        
                    }
                }
#endif

/*				else if(BRAP_DSPCHN_AudioType_eDdp7_1== pAudioParams->sDspChParams.eType)
				{
					if ((pAudioParams->sDspChParams.eDecodeMode == BRAP_DSPCHN_DecodeMode_ePassThru)
                    || (pAudioParams->sDspChParams.eDecodeMode == BRAP_DSPCHN_DecodeMode_eSimulMode))
                    {
                        BDBG_ERR(("Compressed data format not supported for algorithm DDP 7.1. Use Ac3Plus instead."));
                        return BERR_TRACE(BRAP_ERR_COMP_SPDIF_NOT_ALLOWED);
                    }  
				}
  */              

                /* 1. bDtsCdCompressed and bHbrCompressed should not be enabled for 
                      together. 
                   2. bDtsCdCompressed can be enabled only for DTS-HD or DTS algo simul mode */
                if((true == pAudioParams->sDspChParams.bDtsCdCompressed) && 
                   (true == pAudioParams->sDspChParams.bHbrCompressed)) 
                {
                    BDBG_ERR(("Both bDtsCdCompressed and bHbrCompressed can't be true together"));
                    return BERR_TRACE(BERR_INVALID_PARAMETER);
                }

                if((true == pAudioParams->sDspChParams.bDtsCdCompressed) && 
                   ((BRAP_DSPCHN_AudioType_eDts != pAudioParams->sDspChParams.eType) && 
                     (BRAP_DSPCHN_AudioType_eDtshd != pAudioParams->sDspChParams.eType))) 
                {
                    BDBG_ERR(("bDtsCdCompressed = true not supported for AlgoType = %d and DecodeMode = %d",
                        pAudioParams->sDspChParams.eType, pAudioParams->sDspChParams.eDecodeMode));
                    return BERR_TRACE(BERR_INVALID_PARAMETER);
                }
                    
            	/* Check if the algo type was selected at BRAP_Open time. Otherwise  
            	   we may not have sufficient memory for this algorithm */

                /* Check stream type */
                ret = BRAP_P_IsStreamTypeSupported(
                        pAudioParams->sDspChParams.eStreamType);
                if(BERR_SUCCESS != ret)
                {
                    return BERR_TRACE(ret);                        
                }
            }

            /* TODO: Check if bPtsSpecificDecode supported for 7440 */
            /* bPtsSpecificDecode should not be set to true */
            if(true == pAudioParams->sDspChParams.bPtsSpecificDecode) 
            {
                BDBG_ERR(("PTS specific decode is supported only for 7411 D0"));
                return BERR_TRACE(BERR_NOT_SUPPORTED);
            }
            
            /* TODO: Add more checks for decode channel here */
        }
    
        /* TODO: check conditions for other channel types here */

    }/* bWdgRecovery == false */

    /* Sanity tests outside the watchdog recovery */

    return ret;
}

/***********************************************
Summary: This function tells if the output of the path is compress or linear.
Please note that before this calling this function, the destinations in the path needs to be populated
***********************************************/
BERR_Code
BRAP_P_IsPathOutputCompress(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	unsigned int                                uiPth,
	bool                                         *pbCompress
	)
{
    BRAP_P_DstDetails   *pPvtDstDetails = NULL;
    unsigned int i =0;
    BERR_Code ret = BERR_SUCCESS;

    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(pbCompress);        
    BDBG_ENTER(BRAP_P_IsPathOutputCompress);

    if(hRapCh->pPath[uiPth] == NULL)
    {
        BDBG_ERR(("Path should not be NULL"));
        ret = BERR_TRACE(BERR_INVALID_PARAMETER);
        goto exit;              
    }
	pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
    if ( NULL==pPvtDstDetails )
	{
        BDBG_ERR(("Sysmtem memory not availbale"));
        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        goto exit;            
	}
    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));        

    if ((BRAP_P_UsgPath_eDecodeCompress==hRapCh->pPath[uiPth]->eUsgPath) ||
        (BRAP_P_UsgPath_eDecodeCompressPostMixing==hRapCh->pPath[uiPth]->eUsgPath))
    {
       *pbCompress = true;
       goto exit;
    }
    else
    {
        for(i = 0 ; i< BRAP_P_MAX_DST_PER_RAPCH ; i++)
        {
            if(NULL != hRapCh->pPath[uiPth]->pDstDetails[i])
            {
                if((BRAP_AudioDst_eOutputPort == hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst)
                    &&(true == hRapCh->hRap->sOutputSettings[hRapCh->pPath[uiPth]->pDstDetails[i]->\
                                uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR]].bCompressed))
                {
                    *pbCompress = true;
                    break;
                }                
            
                else if((BRAP_AudioDst_eRingBuffer == hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst)
                        &&(true == hRapCh->pPath[uiPth]->pDstDetails[i]->uDstDetails.sRBufDetails.bCompress))
                {
                    *pbCompress = true;
                    break;
                }                
            }
        }
        if(i == BRAP_P_MAX_DST_PER_RAPCH)
        {
            /* Did not find compressed audio in the path. Assume PCM */
            /* Ofcourse incase of Loopback To DSP, pre-loopback paths have pDstDetails[i] NULL for all 'i',
               but currently only PCM loopback to DSP is supported */
            *pbCompress = false;        
        }
    }
    
exit:
    BDBG_LEAVE(BRAP_P_IsPathOutputCompress);
    return ret;
}

/**************************************************************************
Summary:
    Private function that starts a decode path.
**************************************************************************/
BERR_Code 
  BRAP_P_StartDecPath(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */
    const unsigned int          uiPth       	/* [in] Path idx corresponding 
                                                   to pPath[] array element */
    )
{
    BERR_Code                   ret = BERR_SUCCESS;
    BRAP_DSPCHN_P_AudioParams   *pDspChParams = NULL;
    unsigned int                i = 0;
    bool                        bCompress = false;
    bool                        bWdgRecovery = false;
#if ( (BRAP_3548_FAMILY == 1) )
    bool                        bLinked = false;
    bool                        bSlave = false;
#endif
    bool                        bRequireDSP = false;
    bool                        bFMMPathAllocated = true;

    BDBG_ENTER(BRAP_P_StartDecPath);

    if(NULL == hRapCh->pPath[uiPth])
    {
        ret = BERR_TRACE(BERR_NOT_INITIALIZED);
        goto exit;
    }

    if((BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath) &&
       (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType))
    {
        BDBG_MSG(("StartDecPath: Returning success for PCMPB compress path\n"));
        goto exit;        
    }
    
    /* For MS10, MS11 the decode channels output to sepearate task(FW Mixer) 
       through DRAM buffers and not FMM */
    ret = BRAP_P_IsFMMPathAllocated(hRapCh, uiPth, &bFMMPathAllocated);
    if(BERR_SUCCESS!=ret)
    {
        BDBG_ERR(("BRAP_P_IsFMMPathAllocated returned Error!"));
        ret = BERR_TRACE(ret);
        goto exit;
    }
    BDBG_MSG(("bFMMPathAllocated=%d",bFMMPathAllocated));      
    
	bWdgRecovery = BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap);
    /* Check if the path has already been started. If yes, just increment the 
       count and return success. */
    if((bWdgRecovery == false) 
        && (0 != hRapCh->pPath[uiPth]->uiPthStartCnt))
    {
        /* Increment the open count */
        hRapCh->pPath[uiPth]->uiPthStartCnt++;

        BDBG_MSG(("BRAP_P_StartDecPath: Dec Path %d was already started. " 
                "New start count = %d", uiPth, hRapCh->pPath[uiPth]->uiPthStartCnt));

        /* DSPCHN start need not be called again but add the new input to FW Mixer task */
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
        if((BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh)) && 
           ((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcmPostMixing) ||
            (hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodeCompressPostMixing)))
        {
            uint32_t                ui32Offset, j = 0;
            BRAP_P_IOBufferDetails  *psIOBufInfo; /* Contains Buffer details of Decode or PB Output/Input to FW Mixer */

            psIOBufInfo = (BRAP_P_IOBufferDetails *)BKNI_Malloc(sizeof(BRAP_P_IOBufferDetails));
            if(psIOBufInfo == NULL)
            {
                ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
                goto free_IO_resrc;
            }
            
            if(hRapCh->eChannelType == BRAP_ChannelType_eDecode)
            {
                if(hRapCh->hMultiStreamDecoder != NULL)
                {
                    psIOBufInfo->eBufferType = BRAP_P_IOBufferType_eDRAM;
                    for(i=0; i<BRAP_P_MAX_FW_STG_INPUTS; i++)
                    {
                        if(hRapCh->hMultiStreamDecoder->bDRAMBuffersUsed[i] == false)
                            break;
                    }
                    if(i == BRAP_P_MAX_FW_STG_INPUTS)
                    {
                        BDBG_ERR(("No free DRAM buffer found for InterTask buffer usage"));
                        ret = BRAP_ERR_BAD_DEVICE_STATE;
                        goto free_IO_resrc;
                    }
                    
                    psIOBufInfo->uBufferDetails.sIOBuffer.uiNumBuffers = hRapCh->hMultiStreamDecoder->uiNumValidIOBuffer[i];

                    for(j=0 ; j<psIOBufInfo->uBufferDetails.sIOBuffer.uiNumBuffers; j++)
                    {	
                        BRAP_P_ConvertAddressToOffset(	hRapCh->hHeap,
    						(void *)(hRapCh->hMultiStreamDecoder->ui32InterTaskIoBufferAddress[i][j]), &ui32Offset);
                        psIOBufInfo->uBufferDetails.sIOBuffer.sIOCircularBuf[j].ui32BaseAddr = ui32Offset;
                        psIOBufInfo->uBufferDetails.sIOBuffer.sIOCircularBuf[j].ui32ReadAddr = ui32Offset;
                        psIOBufInfo->uBufferDetails.sIOBuffer.sIOCircularBuf[j].ui32WriteAddr = ui32Offset;

                        BRAP_P_ConvertAddressToOffset(	hRapCh->hHeap,
    						(void *)(hRapCh->hMultiStreamDecoder->ui32InterTaskIoBufferAddress[i][j] \
    						+ BRAP_AF_P_INTERTASK_IOBUFFER_SIZE), &ui32Offset);
                        psIOBufInfo->uBufferDetails.sIOBuffer.sIOCircularBuf[j].ui32EndAddr = ui32Offset;
                        psIOBufInfo->uBufferDetails.sIOBuffer.sIOCircularBuf[j].ui32WrapAddr = ui32Offset;
                    }
                    BRAP_P_ConvertAddressToOffset(  hRapCh->hHeap,
                        (void *)(hRapCh->hMultiStreamDecoder->ui32InterTaskIoGenericBufferAddress[i]), &ui32Offset);
                    psIOBufInfo->uBufferDetails.sIOBuffer.sIOGenericCircularBuf.ui32BaseAddr = ui32Offset;
                    psIOBufInfo->uBufferDetails.sIOBuffer.sIOGenericCircularBuf.ui32ReadAddr = ui32Offset;
                    psIOBufInfo->uBufferDetails.sIOBuffer.sIOGenericCircularBuf.ui32WriteAddr = ui32Offset;
                    
                    BRAP_P_ConvertAddressToOffset(  hRapCh->hHeap,
                        (void *)(hRapCh->hMultiStreamDecoder->ui32InterTaskIoGenericBufferAddress[i] \
                        +BRAP_AF_P_INTERTASK_IOGENBUFFER_SIZE), &ui32Offset); 
                    psIOBufInfo->uBufferDetails.sIOBuffer.sIOGenericCircularBuf.ui32EndAddr = ui32Offset;
                    psIOBufInfo->uBufferDetails.sIOBuffer.sIOGenericCircularBuf.ui32WrapAddr = ui32Offset;                                            
                }
                else
                {
                    BDBG_ERR(("Multi Stream Decoder handle invalid"));
                    ret = BERR_NOT_SUPPORTED;
                    goto free_IO_resrc;
                }
            }
            else if(hRapCh->eChannelType == BRAP_ChannelType_ePcmPlayback)    
            {
                /* Get Ring Buffer indices from CapturePath(uiPth-1) */
                BDBG_ASSERT(NULL != hRapCh->pPath[uiPth-1]);
                if(BRAP_P_UsgPath_eCapture == hRapCh->pPath[uiPth-1]->eUsgPath)
                {
                    psIOBufInfo->eBufferType = BRAP_P_IOBufferType_eFMM;                
                    psIOBufInfo->uBufferDetails.sIOBufId.uiNumBuffers = 2;
                    psIOBufInfo->uBufferDetails.sIOBufId.ui32RbufId[0] = 
                        hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[0];
                    psIOBufInfo->uBufferDetails.sIOBufId.ui32RbufId[1] = 
                        hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[1];
                }
                else
                {
                    BDBG_ERR(("Previous path is not Capture path."));
                    ret = BERR_NOT_SUPPORTED;
                    goto free_IO_resrc;
                }                
            }
            else
            {
                BDBG_ERR(("Capture channel not supported currently"));
                ret = BERR_NOT_SUPPORTED;
                goto free_IO_resrc;          
            }

            ret  = BRAP_DSPCHN_P_AddRemoveInputToTask(hRapCh, hRapCh->pPath[uiPth]->hDspCh, true, psIOBufInfo);
            if(ret != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_DSPCHN_P_AddRemoveInputToTask returned error"));
                goto free_IO_resrc;
            }
			free_IO_resrc:
            if(psIOBufInfo)
                BKNI_Free(psIOBufInfo);
        }
#endif        

        /* Return success */
        BDBG_LEAVE (BRAP_P_StartDecPath);
        ret = BERR_SUCCESS;
        goto exit;        
    }   

	/* Malloc large local structures */
	pDspChParams = hRapCh->hRap->sOpenTimeMallocs.pDspChParams;
	if( NULL==pDspChParams )
	{
        ret = BERR_TRACE( BERR_OUT_OF_SYSTEM_MEMORY );
        goto exit;        
	}
    BKNI_Memset(pDspChParams, 0, sizeof(BRAP_DSPCHN_P_AudioParams));

#if ( (BRAP_3548_FAMILY == 1) )
	if(( BRAP_ChannelType_eDecode==hRapCh->eChannelType )
		&&( BRAP_DSPCHN_DecodeMode_eDecode==pAudioParams->sDspChParams.eDecodeMode ))
	{
        for(i=0;i<BRAP_RM_P_MAX_LINKAGE_SUPPORTED;i++)
        {
            if((true == hRapCh->hRap->sChLinkInfo[i].bUsedLinkage)&&
                (hRapCh == hRapCh->hRap->sChLinkInfo[i].hRapMasterCh))
            {
                bLinked = true;
                break;
            }
        }
    }
	if(( BRAP_ChannelType_eDecode==hRapCh->eChannelType )
		&&( BRAP_DSPCHN_DecodeMode_ePassThru==pAudioParams->sDspChParams.eDecodeMode ))
	{
        for(i=0;i<BRAP_RM_P_MAX_LINKAGE_SUPPORTED;i++)
        {
            if((true == hRapCh->hRap->sChLinkInfo[i].bUsedLinkage)&&
                (hRapCh == hRapCh->hRap->sChLinkInfo[i].hRapSlaveCh))
            {
                bSlave = true;
                break;
            }
        }
    }
#endif
    

    if((BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath) 
        ||( BRAP_DSPCHN_DecodeMode_ePassThru==pAudioParams->sDspChParams.eDecodeMode ))
        bCompress = true;
    else 
        bCompress = false;

    if(true == bFMMPathAllocated)
    {
        ret = BRAP_P_IsPathOutputCompress(hRapCh,uiPth,&bCompress);
        if(ret != BERR_SUCCESS)
        {
            BDBG_ERR(("BRAP_P_StartDecPath: BRAP_P_IsPathOutputCompress() returned err(%d)",ret));	
            ret = BERR_TRACE(ret); 
            goto exit;                
        }

        /* Start all internal module handles */
        ret = BRAP_P_StartFmmModuleHandles(hRapCh, pAudioParams, uiPth, bCompress);
        if(BERR_SUCCESS != ret)
        {
        	BDBG_ERR(("BRAP_P_StartDecPath: BRAP_P_StartFmmModuleHandles failed %d",
                ret));
            ret = BERR_TRACE(ret); 
            goto exit;        
        }
        if (false == bCompress)
        {
            /* Program the mixing Coefficients for the channel */
            ret = BRAP_P_ProgramCoefficients(hRapCh, &(pAudioParams->sMixingCoeff));
            if(BERR_SUCCESS != ret)
            {
            	BDBG_ERR(("BRAP_P_StartDecPath: BRAP_P_ProgramCoefficients failed %d",
                    ret));
                ret = BERR_TRACE(ret); 
                goto exit;            
            }
            /* Program the Down-mixing Coefficients for the channel */
            if((BRAP_ChannelType_eDecode == hRapCh->eChannelType)||
    			(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType))
            {
                ret = BRAP_P_ProgramDownMixCoefficients(hRapCh,uiPth);
                if(BERR_SUCCESS != ret)
                {
                	BDBG_ERR(("BRAP_P_StartDecPath: BRAP_P_ProgramDownMixCoefficients failed %d",
                        ret));
                	ret = BERR_TRACE(ret); 
                    goto exit;
                }
            }
            if(false == bWdgRecovery)
            hRapCh->sMixingCoeff = pAudioParams->sMixingCoeff;
        }
    }

    /* Decide whether to have DSP or not */
#if (BRAP_3548_FAMILY == 1)  
    if ( (BRAP_ChannelType_ePcmCapture == hRapCh->eChannelType) ||
         (BRAP_ChannelType_eDecode == hRapCh->eChannelType)
       )
    {
        bRequireDSP = true;
    }
    if ( (BRAP_ChannelType_eDecode == hRapCh->eChannelType) &&
         (BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode) &&
         (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) &&
         ( (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort)||
           (BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)
         )
       )
    {
        bRequireDSP = false;

        /* Also in this mode we should put the SPDIF RX to PCM mode */
        BRAP_SPDIFRX_P_SwitchToCompressed (hRapCh->hRap);
    }
#else
    if (BRAP_ChannelType_eDecode == hRapCh->eChannelType)
    {
        bRequireDSP = true;
    }
#endif     
    if (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
    {
        /* Assocition network */
        if((BRAP_P_IsPointerValid((void *)hRapCh->pPath[uiPth]->hDspCh)) &&
           (hRapCh->pPath[uiPth]->hDspCh->bChSpecificDspCh == false))
        {
            bRequireDSP = true;
        }
    }
    
    if (true == bRequireDSP)
    {
        /* Populate sDspChnParams structure */    
    	pDspChParams->sExtAudioParams = pAudioParams->sDspChParams;

        if((BRAP_DSPCHN_DecodeMode_eDecode == pAudioParams->sDspChParams.eDecodeMode) ||
           (BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode))
        {
            pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.bIsSingleI2SHbrMode = false;

          	/* Initialize the ring buffer index array in sDspChnParams */
        	for(i=0; i < BRAP_RM_P_MAX_OP_CHANNELS; i++)
        	{
        		pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.rBufIndex[i] 
	                    = (int8_t)BRAP_RM_P_INVALID_INDEX;
                
        		pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.inputRBufIndex[i] 
	                    = (int8_t)BRAP_RM_P_INVALID_INDEX;
        	}

            for(i=0; i < BRAP_RM_P_MAX_OP_CHANNELS; i++)
            {
        		pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.rBufIndex[i] = 
                   hRapCh->pPath[uiPth]->sRsrcGrnt.uiRbufId[i];
            }

            /* TODO: sMixerParams: mixer ids and input info for metadata preparation */    
        }
        else
            BDBG_ASSERT(0);

        /* Other misc DSP channel params */                        
      	pDspChParams->eTimebase = pAudioParams->eTimebase;
      	pDspChParams->uiTransChId = hRapCh->uiXptChannelNo;
		pDspChParams->sXptContextMap = pAudioParams->sXptContextMap;
    	pDspChParams->bPlayback =  pAudioParams->bPlayback;
        pDspChParams->bMultiChanOnI2S = false;
        pDspChParams->sExtAudioParams.eLowDelayEnableMode = pAudioParams->eLowDelayEnableMode;


        /* Add the SPDIF channel status buffer params to the sDspChParams */
        if(true == hRapCh->hRap->bOpSettingsValid[BRAP_OutputPort_eSpdif])
        {
            /* TODO: Check with firmware team if they need to know the 
               output port or ring buffer that will be carrying SPDIF data */
            pDspChParams->sSpdifChStatusParams[0] = 
                hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].sSpdifChanStatusParams;
    		pDspChParams->bUpdateChStatusParams =
			!( hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].bUseSpdifPackedChanStatusBits );
        }

        /* Add the MAI channel status buffer params to the sDspChParams */
        if(true == hRapCh->hRap->bOpSettingsValid[BRAP_OutputPort_eMai])
        {
            /* TODO: Check with firmware team if they need to know the 
               output port or ring buffer that will be carrying SPDIF data */
            pDspChParams->sSpdifChStatusParams[1] = 
                hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams;
    		pDspChParams->bUpdateChStatusParams =
			!( hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].bUseSpdifPackedChanStatusBits );
        }
        
        if((BRAP_DSPCHN_DecodeMode_eDecode == pAudioParams->sDspChParams.eDecodeMode) ||
           (BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode))
        {  
            if ((BRAP_P_UsgPath_ePPBranch == hRapCh->pPath[uiPth]->eUsgPath)||
                (BRAP_P_UsgPath_eMixPath== hRapCh->pPath[uiPth]->eUsgPath)||
                (BRAP_P_UsgPath_eSharedPP== hRapCh->pPath[uiPth]->eUsgPath)||                    
                (BRAP_P_UsgPath_eDownmixedMixPath== hRapCh->pPath[uiPth]->eUsgPath)||                    
                (BRAP_P_UsgPath_eDownmixedPath== hRapCh->pPath[uiPth]->eUsgPath) ||
                (BRAP_P_UsgPath_ePPBranchPostMixing== hRapCh->pPath[uiPth]->eUsgPath))
            {
                ret = BRAP_DSPCHN_P_DummyStart(hRapCh->pPath[uiPth]->hDspCh, pDspChParams);
            }
            else
            {
                BDBG_MSG(("BRAP_P_StartDecPath: Calling DSPCHN_P_Start"));
                /* Note: A DSP channel is required to be started only if it is a 
                   decode mode or passthru mode or passthru context of simul mode */
                   
                if (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource)
                {
#if (BRAP_7550_FAMILY != 1)
                    pDspChParams->sDecOrPtParams.eDecSourceType = BRAP_DSPCHN_P_SourceType_eFMMBuf;
                    /* Get Ring Buffer indices from CapturePath(uiPth-1) */
                    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth-1]);
                    pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.inputRBufIndex[0] = 
                        hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[0];
                    pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.inputRBufIndex[1] = 
                        hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[1];


                    if ( (BRAP_CapInputPort_eRfAudio == hRapCh->eCapInputPort)||
                         (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort)||
                         (BRAP_CapInputPort_eExtI2s0 == hRapCh->eCapInputPort)
                       )
                    {
                        pDspChParams->sExtAudioParams.eDecodeMode = BRAP_DSPCHN_DecodeMode_eDecode;
                        pDspChParams->sExtAudioParams.eType = BRAP_DSPCHN_AudioType_ePcm;
                        pDspChParams->sExtAudioParams.eOutputSampleRate = BAVC_AudioSamplingRate_e48k;
                        pDspChParams->sExtAudioParams.eStreamType = BAVC_StreamType_ePes;

                        if(BRAP_CapInputPort_eExtI2s0 == hRapCh->eCapInputPort)
                        {
                            pDspChParams->sExtAudioParams.eInputSampleRate = 
                                hRapCh->hRap->sInputSettings[hRapCh->eCapInputPort].eSampleRate;
                        }
                    }
#endif                        
                }
                else if(BRAP_AudioSource_eRingBuffer== hRapCh->eAudioSource)
                {
                    /* Get Ring Buffer indices from CapturePath(uiPth-1) */
                    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth-1]);
                    pDspChParams->sDecOrPtParams.eDecSourceType = BRAP_DSPCHN_P_SourceType_eFMMBuf;
                    pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.inputRBufIndex[0] = 
                        hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[0];
                    pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.inputRBufIndex[1] = 
                        hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[1];                    
                }

                if(false == hRapCh->pPath[uiPth]->hDspCh->bChSpecificDspCh)
                {
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT                        
                    if(BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh))
                    {
                        /* First configuration/start of FW Mixer, 0th input port will be used */
                        /* FW doesn't assume that 0th one is the mixer input port.
                        FW checks all the input port and finds out which one is valid*/
                        hRapCh->uiFWMixerIpIndex = 0;
                    }
#endif                    
                    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth-1]);
                    /* Get Ring Buffer indices from CapturePath(uiPth-1) */
                    if(BRAP_P_UsgPath_eCapture == hRapCh->pPath[uiPth-1]->eUsgPath)
                    {
                        pDspChParams->sDecOrPtParams.eDecSourceType = BRAP_DSPCHN_P_SourceType_eFMMBuf;
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.inputRBufIndex[0] = 
                            hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[0];
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.inputRBufIndex[1] = 
                            hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[1];
                    }
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT                        
                    else if((BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh)) &&
                            ((BRAP_P_UsgPath_eDecodePcm == hRapCh->pPath[uiPth-1]->eUsgPath) ||
                             (BRAP_P_UsgPath_ePPBranch == hRapCh->pPath[uiPth-1]->eUsgPath)) &&
                            (BRAP_P_IsPointerValid((void *)hRapCh->pPath[uiPth-1]->hDspCh)))
                    {
                        uint32_t    ui32Offset = 0, j = 0;

                        i = hRapCh->uiFWMixerIpIndex;       
                        pDspChParams->sDecOrPtParams.eDecSourceType = BRAP_DSPCHN_P_SourceType_eDRAMBuf;
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoBuffer.eBufferType = BRAP_AF_P_BufferType_eDRAM;
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoBuffer.ui32NumBuffers = hRapCh->hMultiStreamDecoder->uiNumValidIOBuffer[i];
                        if(hRapCh->hMultiStreamDecoder->bDRAMBuffersUsed[i] == true)
                        {
                            BDBG_ERR(("This is first start of Decode Post-Mixing path, 0th DRAM Buffer can't be in use"));
                        	ret = BRAP_ERR_BAD_DEVICE_STATE; 
                            goto exit;
                        }
                        for(j=0 ; j<pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.sDecIoBuffer.ui32NumBuffers ; j++)
                        {	
                            BRAP_P_ConvertAddressToOffset(	hRapCh->hHeap, (void *)(hRapCh->hMultiStreamDecoder->\
                                ui32InterTaskIoBufferAddress[i][j]), &ui32Offset);
    						pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                              sDecIoBuffer.sCircBuffer[j].ui32BaseAddr = ui32Offset;
                            pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                                sDecIoBuffer.sCircBuffer[j].ui32ReadAddr = ui32Offset;
                            pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                                sDecIoBuffer.sCircBuffer[j].ui32WriteAddr = ui32Offset;

                            BRAP_P_ConvertAddressToOffset(	hRapCh->hHeap, (void *)(hRapCh->hMultiStreamDecoder->\
                                ui32InterTaskIoBufferAddress[i][j] + BRAP_AF_P_INTERTASK_IOBUFFER_SIZE), &ui32Offset);
    						pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                              sDecIoBuffer.sCircBuffer[j].ui32EndAddr = ui32Offset;
    						pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                              sDecIoBuffer.sCircBuffer[j].ui32WrapAddr = ui32Offset;
                            
                        }
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoGenericBuffer.eBufferType = BRAP_AF_P_BufferType_eDRAM;
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoGenericBuffer.ui32NumBuffers = 1;

                        BRAP_P_ConvertAddressToOffset(  hRapCh->hHeap, (void *)(hRapCh->hMultiStreamDecoder->\
                            ui32InterTaskIoGenericBufferAddress[i]), &ui32Offset);
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoGenericBuffer.sCircBuffer.ui32BaseAddr = ui32Offset;
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoGenericBuffer.sCircBuffer.ui32ReadAddr = ui32Offset;
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoGenericBuffer.sCircBuffer.ui32WriteAddr = ui32Offset;

                        BRAP_P_ConvertAddressToOffset(  hRapCh->hHeap, (void *)(hRapCh->hMultiStreamDecoder->\
                            ui32InterTaskIoGenericBufferAddress[i] +BRAP_AF_P_INTERTASK_IOGENBUFFER_SIZE), &ui32Offset);
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoGenericBuffer.sCircBuffer.ui32EndAddr = ui32Offset;
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoGenericBuffer.sCircBuffer.ui32WrapAddr = ui32Offset;
                    }
#endif
                    pDspChParams->bPlayback = false;
                    pDspChParams->sExtAudioParams.eDecodeMode = BRAP_DSPCHN_DecodeMode_eDecode;
                    pDspChParams->sExtAudioParams.eType = BRAP_DSPCHN_AudioType_ePcm;
                    pDspChParams->sExtAudioParams.eStreamType = BAVC_StreamType_ePes;
                    pDspChParams->sExtAudioParams.bPPMCorrection = false;
                }

                ret = BRAP_DSPCHN_P_CreateDstConfig(hRapCh->pPath[uiPth]->hDspCh, pDspChParams);
                if(BERR_SUCCESS != ret)
                {
                    BDBG_ERR(("BRAP_P_StartDecPath: BRAP_DSPCHN_P_CreateDstConfig failed %d", ret));
                    ret = BERR_TRACE(ret); 
                    goto exit;                    
                }

#if (BRAP_3548_FAMILY == 1)
                if ( (BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource)  &&
                        ((BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort) ||
                         (BRAP_CapInputPort_eHdmi  == pAudioParams->eCapInputPort)
                        ) 
                   )
                {
                    /* The input data flow from SPDIF Rx has to be set properly */
                    BKNI_EnterCriticalSection();
                    if (BRAP_DSPCHN_AudioType_ePcm == pDspChParams->sExtAudioParams.eType)
                    {
                        BRAP_SPDIFRX_P_SwitchToPCM (hRapCh->hRap);
                    }
                    else
                    {
                        BRAP_SPDIFRX_P_SwitchToPES (hRapCh->hRap, 0);
                    }
                    BKNI_LeaveCriticalSection();
                }
#endif
                ret = BRAP_DSPCHN_P_Start(hRapCh->pPath[uiPth]->hDspCh, pDspChParams);
                if(BERR_SUCCESS != ret)
                {
                    BDBG_ERR(("BRAP_P_StartDecPath: BRAP_DSPCHN_P_Start failed %d", ret));
                    ret = BERR_TRACE(ret); 
                    goto exit;
                }
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT                        
                if((BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh)) &&
                   (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType) &&
                   (hRapCh->pPath[uiPth]->hDspCh->bChSpecificDspCh == false))
                {
                    hRapCh->hMultiStreamDecoder->bDRAMBuffersUsed[hRapCh->uiFWMixerIpIndex] = true;
                }
#endif
            }
        }
        else
            BDBG_MSG(("Did **NOT** Call DSPCHN_P_Start"));
    }   

    if (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
    {
#if (BRAP_P_WATERMARK_WORKAROUND == 1)
        if(bWdgRecovery == false)
        {
            ret = BTMR_StartTimer(hRapCh->hTimer, 1000);
            if(ret != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_P_StartDecPath: BTMR_StartTimer() returned err(%d)",ret));
                return BERR_TRACE(ret);
                goto exit;
            }
            BDBG_MSG(("BRAP_P_StartDecPath: Start timer done!"));
        }
#endif            
    }

    if((BERR_SUCCESS == ret) && (bWdgRecovery == false))
    {
        /* Increment the start count */
        hRapCh->pPath[uiPth]->uiPthStartCnt++;

        BDBG_MSG(("BRAP_P_StartDecPath: hRapCh->pPath[uiPth=%d]->uiPthStartCnt = %d",
            uiPth, hRapCh->pPath[uiPth]->uiPthStartCnt));
        
        /* Exit successfully */
        goto exit;    
    }

exit: 
    BDBG_MSG(("StartDecPath Done!"));
    BDBG_LEAVE(BRAP_P_StartDecPath);
    return ret;
}

/**************************************************************************
Summary:
    Private function that stops a decode path.
**************************************************************************/
BERR_Code 
BRAP_P_StopDecPath(
	BRAP_ChannelHandle 			hRapCh,     /* [in] RAP Channel handle */
    const unsigned int          uiPth       /* [in] Path idx corresponding 
                                               to pPath[] array element */
    )
{
    BERR_Code                   ret = BERR_SUCCESS;

#if  (BRAP_7405_FAMILY ==1)
    unsigned int    uiPp= 0,uiChPair  = 0;
    bool bPrimary[BRAP_MAX_ASSOCIATED_GROUPS] = {false,false,false,false};
    BRAP_ChannelHandle hStartedChannel[BRAP_MAX_ASSOCIATED_GROUPS] = {NULL,NULL,NULL,NULL};
    unsigned int i = 0;
    bool bOtherChannelStarted = false;
    unsigned int ui32RegVal=0;
#if  (BRAP_7550_FAMILY !=1)    
    unsigned int uiBlkId=0,uiBlkOffset=0;    
#endif
#endif
    bool                        bFMMPathAllocated = true;
    
    BDBG_ENTER(BRAP_P_StopDecPath);

    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth]);

    if((BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath) &&
       (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType))
    {
        BDBG_MSG(("StopDecPath: Returning success for PCMPB compress path\n"));
        BDBG_LEAVE(BRAP_P_StopDecPath);
        return BERR_SUCCESS;        
    }
    
    /* For MS10, MS11 the decode channels output to sepearate task(FW Mixer) through DRAM and not FMM */
    ret = BRAP_P_IsFMMPathAllocated(hRapCh, uiPth, &bFMMPathAllocated);
    if(BERR_SUCCESS!=ret)
    {
        BDBG_ERR(("BRAP_P_IsFMMPathAllocated returned Error!"));
        ret = BERR_TRACE(ret);
        goto exit;
    }
    BDBG_MSG(("bFMMPathAllocated=%d",bFMMPathAllocated));    
    
    /* Error state check */
    if (0 == hRapCh->pPath[uiPth]->uiPthStartCnt)
    { 
        /* This should never happen. If it does, it means the system
           has gone into an invalid state!!!!*/
        BDBG_ERR (("BRAP_P_StopDecPath: Dec Path start count is already 0"));
        return BERR_TRACE (BERR_NOT_SUPPORTED);
    }

    /* Decrement the start count */
    hRapCh->pPath[uiPth]->uiPthStartCnt--;

    BDBG_MSG(("BRAP_P_StopDecPath: For uiPth=%d New uiPthStartCnt = %d", 
        uiPth, hRapCh->pPath[uiPth]->uiPthStartCnt));

    /* If the new start count is not 0, do not close the resources instead 
       return success */
    if(0 != hRapCh->pPath[uiPth]->uiPthStartCnt)
    {
        BDBG_MSG(("BRAP_P_StopDecPath: uiPthStartCnt = %d so not closing resources!"));

        /* DSPCHN Stop need not be called but remove the corresponding input from FW Mixer task */
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
        if((BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh)) && 
           ((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcmPostMixing) ||
            (hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodeCompressPostMixing)))
        {            
            ret  = BRAP_DSPCHN_P_AddRemoveInputToTask(hRapCh, hRapCh->pPath[uiPth]->hDspCh, false, NULL);
            if(ret != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_DSPCHN_P_AddRemoveInputToTask returned error"));
                goto exit;
            }
        }
#endif        
        BDBG_LEAVE(BRAP_P_StopDecPath);
        return BERR_SUCCESS;
    }
    else
    {
        hRapCh->pPath[uiPth]->uiPthStartCnt++;
    }
    
#if BRAP_P_WATERMARK_WORKAROUND==1
	if (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
	{
		ret = BTMR_StopTimer(hRapCh->hTimer);
		if ( ret != BERR_SUCCESS )
		{
			BDBG_ERR(("BRAP_P_StopDecPath: BTMR_StopTimer() returned err(%d)",ret));	
			ret = BERR_TRACE(ret);
			return ( ret );
		}
	}
#endif  	
#if (BRAP_7405_FAMILY == 1)
    /* Program the Ramp Amount */
    if(hRapCh->eChannelType == BRAP_ChannelType_eDecode)
    {
        ret = BRAP_P_GetOtherStartedChannel(hRapCh,bPrimary,hStartedChannel);
        if(BERR_SUCCESS != ret)
        {
            return BERR_TRACE(ret);
        }                
        for(i=0; i < BRAP_MAX_ASSOCIATED_GROUPS; i++)
        {
            if(NULL != hStartedChannel[i])
            {
                bOtherChannelStarted = true;
                break;
            }            
        }
        if(false == bOtherChannelStarted)
        {
            for(uiChPair = 0; uiChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; uiChPair++)
            {
                for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
                {
                    if(NULL == hRapCh->pPath[uiPth]->sOp[uiChPair][uiPp].hSpdifFm)
                        continue;
    
                    BRAP_Write32 (hRapCh->hRegister,
                                  BCHP_AUD_FMM_MS_CTRL_FW_RAMP_AMOUNT_0 + hRapCh->pPath[uiPth]->sOp[uiChPair][uiPp].hSpdifFm->ui32Offset, 
                                  0x800); 
                }
            }
        }
    }
#endif

    /* Stop the DSP channel, if any in this path */
    if(NULL != hRapCh->pPath[uiPth]->hDspCh)
    {  
        BDBG_MSG(("Calling DSPCHN_P_Stop"));
        ret = BRAP_DSPCHN_P_Stop(hRapCh->pPath[uiPth]->hDspCh);
        if(BERR_SUCCESS != ret)
        {
        	BDBG_ERR(("BRAP_P_StopDecPath: BRAP_DSPCHN_P_Stop failed %d",ret));
        	return BERR_TRACE(ret); 
        }
    }
    else
        BDBG_MSG(("Did **NOT** Call DSPCHN_P_Stop"));

    if(true == bFMMPathAllocated)
    {
        /* Stop all internal module handles */
        ret = BRAP_P_StopFmmModuleHandles(hRapCh, uiPth);
        if(BERR_SUCCESS != ret)
        {
        	BDBG_ERR(("BRAP_P_StopDecPath: StopFmmModuleHandles failed %d",ret));
        	return BERR_TRACE(ret); 
        }

#if (BRAP_7405_FAMILY == 1)
    /* Program the Ramp Amount */
        bOtherChannelStarted =false;

        ret = BRAP_P_GetOtherStartedChannel(hRapCh,bPrimary,hStartedChannel);
        if(BERR_SUCCESS != ret)
        {
            return BERR_TRACE(ret);
        }                
        for(i=0; i < BRAP_MAX_ASSOCIATED_GROUPS; i++)
        {
            if(NULL != hStartedChannel[i])
            {
                    bOtherChannelStarted = true;
                    break;
            }            
        }
        
        if(false == bOtherChannelStarted)
        {
            ui32RegVal = BRAP_Read32 (hRapCh->hRegister,BCHP_AUD_FMM_DP_CTRL0_VOLUME_RAMP_STEP);

            ui32RegVal &= ~(BCHP_MASK (    
                            AUD_FMM_DP_CTRL0_VOLUME_RAMP_STEP, 
                            VOLUME_RAMP_STEP));
            
            ui32RegVal |= (BCHP_FIELD_DATA (    
                                AUD_FMM_DP_CTRL0_VOLUME_RAMP_STEP, 
                                VOLUME_RAMP_STEP, 
                                0x00));

            BRAP_Write32 (hRapCh->hRegister, BCHP_AUD_FMM_DP_CTRL0_VOLUME_RAMP_STEP, ui32RegVal);

#if (BRAP_7550_FAMILY != 1)
            for (uiBlkId = 0; uiBlkId < BRAP_RM_P_MAX_SRC_BLCK; uiBlkId++)
            {
                uiBlkOffset = 0;
#if ( BRAP_RM_P_MAX_SRC_BLCK > 1 )    
                uiBlkOffset = (BCHP_AUD_FMM_SRC_CTRL1_STRM_ENA - BCHP_AUD_FMM_SRC_CTRL0_STRM_ENA) * uiBlkId;
#endif
                ui32RegVal = BRAP_Read32 (hRapCh->hRegister,BCHP_AUD_FMM_SRC_CTRL0_RAMP_STEP + uiBlkOffset);

                ui32RegVal &= ~(BCHP_MASK (    
                                AUD_FMM_SRC_CTRL0_RAMP_STEP, 
                                STEP_SIZE));
                
                ui32RegVal |= (BCHP_FIELD_DATA (    
                                    AUD_FMM_SRC_CTRL0_RAMP_STEP, 
                                    STEP_SIZE, 
                                    0x00));
                BRAP_Write32(hRapCh->hRegister, BCHP_AUD_FMM_SRC_CTRL0_RAMP_STEP + uiBlkOffset, ui32RegVal);  
            }            
#endif    
        }
#endif
    }


    /* Decrement the start count */
    hRapCh->pPath[uiPth]->uiPthStartCnt--;
exit:    
    BDBG_LEAVE(BRAP_P_StopDecPath);
    return ret;
}

/**************************************************************************
Summary:
    Private function that starts a Capture path.
**************************************************************************/
BERR_Code 
BRAP_P_StartCapPath(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */
    const unsigned int          uiPth       	/* [in] Path idx corresponding 
                                                   to pPath[] array element */
    )
{
    BERR_Code                   ret = BERR_SUCCESS;
    bool bCompress = false;
#if (BRAP_P_WATERMARK_WORKAROUND == 1)
    unsigned int i = 0;
#endif
    bool                        bWdgRecovery = false;
   
    BDBG_ENTER(BRAP_P_StartCapPath);

	bWdgRecovery = BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap);

    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth]);

    /* Check if the path has already been started. If yes, just increment the 
       count and return success. */
    if((bWdgRecovery == false) 
        && (0 != hRapCh->pPath[uiPth]->uiPthStartCnt))
    {
        /* Increment the open count */
        hRapCh->pPath[uiPth]->uiPthStartCnt++;

        BDBG_MSG(("BRAP_P_StartCapPath: Cap Path %d was already started. " 
                "New start count = %d", uiPth, hRapCh->pPath[uiPth]->uiPthStartCnt));

        /* Return success */
        BDBG_LEAVE (BRAP_P_StartCapPath);
        return BERR_SUCCESS;
    }

    /* Start all internal module handles */
    ret = BRAP_P_StartFmmModuleHandles(hRapCh, pAudioParams, uiPth, bCompress);
    if(BERR_SUCCESS != ret)
    {
    	BDBG_ERR(("BRAP_P_StartCapPath: BRAP_P_StartFmmModuleHandles failed %d",
            ret));
    	return BERR_TRACE(ret); 
    }
    /* TODO: Do we need to do SetSamplingRate As in previous Chips ?*/

    /* TODO: Check if it is correct */
#if (BRAP_P_WATERMARK_WORKAROUND == 1)
    for(i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
    if( 
        ( (pAudioParams->eCapMode == BRAP_CaptureMode_eCaptureOnly) ||
          ( 
            (hRapCh->pPath[uiPth]->pDstDetails[i] != NULL) && 
            (hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst == BRAP_AudioDst_eRingBuffer)
          )
        ) &&
        (bWdgRecovery == false) &&
        (0 != uiPth)
      )
    {
#ifdef AUTOTRAP
        ret = BTMR_StartTimer(hRapCh->hTimer1, 1000);
#else
        ret = BTMR_StartTimer(hRapCh->hTimer, 1000);
#endif /* AUTOTRAP */
    	if(ret != BERR_SUCCESS)
    	{
    		BDBG_ERR(("BRAP_CAP_Start: BTMR_StartTimer() returned err(%d)",ret));
    		ret = BERR_TRACE(ret);
    	}
    	BDBG_MSG(("BRAP_CAP_Start: Start timer done!"));
            break;
        }
    }
#endif

    if((BERR_SUCCESS == ret) && (bWdgRecovery == false))
    {
        /* Increment the start count */
        hRapCh->pPath[uiPth]->uiPthStartCnt++;

        BDBG_MSG(("BRAP_P_StartCapPath: hRapCh->pPath[uiPth=%d]->uiPthStartCnt = %d",
            uiPth, hRapCh->pPath[uiPth]->uiPthStartCnt));
        
        /* Exit successfully */
        goto exit;    
    }

exit:
    BDBG_LEAVE(BRAP_P_StartCapPath);
    return ret;
}
/**************************************************************************
Summary:
    Private function that stops a capture path.
**************************************************************************/
BERR_Code 
BRAP_P_StopCapPath(
	BRAP_ChannelHandle 			hRapCh,     /* [in] RAP Channel handle */
    const unsigned int          uiPth       /* [in] Path idx corresponding 
                                               to pPath[] array element */
    )
{
    BERR_Code                   ret = BERR_SUCCESS;
#if (BRAP_P_WATERMARK_WORKAROUND==1)
    unsigned int i = 0;
#endif
    BDBG_ENTER(BRAP_P_StopCapPath);

    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth]);

    /* Error state check */
    if (0 == hRapCh->pPath[uiPth]->uiPthStartCnt)
    { 
        /* This should never happen. If it does, it means the system
           has gone into an invalid state!!!!*/
        BDBG_ERR (("BRAP_P_StopCapPath: Cap Path start count is already 0"));
        return BERR_TRACE (BERR_NOT_SUPPORTED);
    }

    /* Decrement the start count */
    hRapCh->pPath[uiPth]->uiPthStartCnt--;

    BDBG_MSG(("BRAP_P_StopCapPath: For uiPth=%d New uiPthStartCnt = %d", 
        uiPth, hRapCh->pPath[uiPth]->uiPthStartCnt));

    /* If the new start count is not 0, do not close the resources instead 
       return success */
    if(0 != hRapCh->pPath[uiPth]->uiPthStartCnt)
    {
        BDBG_MSG(("BRAP_P_StopCapPath: uiPthStartCnt = %d so not closing resources!"));
        BDBG_LEAVE(BRAP_P_StopCapPath);
        return BERR_SUCCESS;
    }
    else
    {
        hRapCh->pPath[uiPth]->uiPthStartCnt++;
    }

    
#if (BRAP_P_WATERMARK_WORKAROUND==1)
    for(i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        if((hRapCh->pPath[uiPth]->pDstDetails[i] != NULL) && 
            (hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst 
             == BRAP_AudioDst_eRingBuffer))
        {
#ifdef AUTOTRAP
            ret = BTMR_StopTimer(hRapCh->hTimer1);
#else
	        ret = BTMR_StopTimer(hRapCh->hTimer);
#endif /* AUTOTRAP */
	        if ( ret != BERR_SUCCESS )
	        {
		        BDBG_ERR(("BRAP_P_StopCapPath: BTMR_StopTimer() returned err(%d)",
                          ret));	
		        ret = BERR_TRACE(ret);
		        return ( ret );
	        }
        }
    }
#endif  	

    /* Stop all internal module handles */
    ret = BRAP_P_StopFmmModuleHandles(hRapCh, uiPth);
    if(BERR_SUCCESS != ret)
    {
    	BDBG_ERR(("BRAP_P_StopCapPath: StopFmmModuleHandles failed %d",ret));
    	return BERR_TRACE(ret); 
    }

    /* Decrement the start count */
    hRapCh->pPath[uiPth]->uiPthStartCnt--;	
    BDBG_LEAVE(BRAP_P_StopCapPath);
    return ret;
}
/**************************************************************************
Summary:
    Private function that opens a decode path.
**************************************************************************/
BERR_Code 
BRAP_P_OpenDecPath(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */
    const unsigned int          uiPth,      	/* [in] Path idx corresponding 
                                                   to pPath[] array element */
    unsigned int                uiNumCapPath    /* [in] If path is feeding to 
                                                   a capture path */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    bool                    bWdgRecovery = false;
    bool                    bCompress = false,bAdaptiveRateEnable=false;
    BRAP_ChannelType        eChType = BRAP_ChannelType_eMax;
    BRAP_Handle             hRap = NULL;
    BRAP_RM_P_ResrcReq      *psRsrcReq = NULL;
    BRAP_RM_P_ResrcGrant    *psRsrcGrnt = NULL;
    bool                    bLfeOn = false;
    BRAP_OutputMode         eInAudMode = BRAP_OutputMode_eLast;
    BRAP_P_OpAudModProp     sOpAudModeProp;
    BRAP_OutputChannelPair  eChP = BRAP_OutputChannelPair_eMax;
    unsigned int            dst = 0;
    unsigned int            i=0, j=0,uiAssocId=0, k= 0;
#if (BRAP_7550_FAMILY != 1)
    unsigned int            uiPthId = 0, uiChp = 0, uiPrllPth = 0;
    BRAP_CapInputPort       eCapPort;
    BRAP_BufDataMode        eBufDataMode;
#endif    
    BRAP_ChannelHandle      hMasterCh = NULL;
    BRAP_OutputPort         eOp = BRAP_OutputPort_eMax;
    BRAP_P_ObjectHandles    *pTempPth=NULL;
    bool                    bFound = false, bIntCapPortFound = false;
    unsigned int            uiNumRateMngrsAlloctd = 0;    
    unsigned int            uiNumPathsNeedRateCtrl = 0;
    bool                    bPrimary[BRAP_MAX_ASSOCIATED_GROUPS];    
    BRAP_ChannelHandle      hStartedAssocCh[BRAP_MAX_ASSOCIATED_GROUPS];
    BAVC_AudioSamplingRate  eInputSamplingRate;     
    BRAP_P_DstDetails       *pPvtDstDetails = NULL;
    bool                    bFMMPathAllocated = true;
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT    
    uint32_t                uiNumBuffers=0,uiFreeIndex=BRAP_INVALID_VALUE;
    BRAP_RBUF_P_Settings    sRBufSettings;
#endif    
    BDBG_ENTER(BRAP_P_OpenDecPath); 
    BDBG_MSG(("BRAP_P_OpenDecPath CALLED!!!"));
    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth]);

    hRap = hRapCh->hRap;
    BDBG_ASSERT(hRap);

    if((BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath) &&
       (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType))
    {
        BDBG_MSG(("OpenDecPath: Returning success for PCMPB compress path\n"));
        goto exit;        
    }    

	/* Malloc large structures */
	pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
	if ( NULL==pPvtDstDetails )
	{
	    ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        goto free_rsrc;                                
	}
    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));
                            
    /* Check if this is a watchdog recovery. */
	bWdgRecovery = BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap);

    if(false == bWdgRecovery)
    {
        /* Check if the path has already been opened. If yes, just increment the 
           count and return success. */
        if(0 != hRapCh->pPath[uiPth]->uiPthOpenCnt)
        {
            /* Increment the open count */
            hRapCh->pPath[uiPth]->uiPthOpenCnt++;

            BDBG_MSG(("BRAP_P_OpenDecPath: Dec Path %d was already open. " 
                    "New open count = %d", uiPth, hRapCh->pPath[uiPth]->uiPthOpenCnt));

            /* Return success */
            BDBG_LEAVE (BRAP_P_OpenDecPath);
            return BERR_SUCCESS;
        }

    	/* Malloc large structures */
    	psRsrcReq = hRap->sOpenTimeMallocs.psResrcReq;
    	if ( NULL==psRsrcReq )
    	{
    			ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
				goto free_rsrc;
    	}
        BKNI_Memset(psRsrcReq, 0, sizeof(BRAP_RM_P_ResrcReq));          
    	psRsrcGrnt = hRap->sOpenTimeMallocs.psResrcGrant;
    	if ( NULL==psRsrcGrnt )
    	{
    			ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
				goto free_rsrc;
    	}
        BKNI_Memset(psRsrcGrnt, 0, sizeof(BRAP_RM_P_ResrcGrant));        	
        /* Invalid init the resource request */
        BRAP_RM_P_InitResourceReq(psRsrcReq);
    }

    /* Validate parameters */    
    ret = BRAP_P_ValidateDecPathParams(hRapCh, pAudioParams);
    if(BERR_SUCCESS != ret)
    {
        ret = BERR_TRACE(ret);                        
    	goto exit;
    }
    
    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
    {
        hStartedAssocCh[uiAssocId]=NULL;
        bPrimary[uiAssocId]=false;
    }
                
    if(BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath)
    {
        bCompress = true;
    }
    else
    {
        bCompress = false;
    } 

    /* For MS10, MS11 the decode channels output to sepearate task(FW Mixer) through DRAM and not FMM */
    ret = BRAP_P_IsFMMPathAllocated(hRapCh, uiPth, &bFMMPathAllocated);
    if(BERR_SUCCESS!=ret)
    {
        BDBG_ERR(("BRAP_P_IsFMMPathAllocated returned Error!"));
        ret = BERR_TRACE(ret);
        goto exit;
    }
    BDBG_MSG(("bFMMPathAllocated=%d",bFMMPathAllocated));
    
    ret = BRAP_P_IsPathOutputCompress(hRapCh,uiPth,&bCompress);
    if(ret != BERR_SUCCESS)
    {
        BDBG_ERR(("BRAP_P_StartDecPath: BRAP_P_IsPathOutputCompress() returned err(%d)",ret));	
        ret = BERR_TRACE(ret); 
        goto exit;                
    }
    
    BRAP_P_EnableAdaptiveRate(hRapCh,&bAdaptiveRateEnable,pAudioParams->sDspChParams.bPPMCorrection);
    
    eChType = hRapCh->eChannelType;

    if(false == bWdgRecovery) 
    {
        if((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eMixPath)
            ||(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eSharedPP))
        {
            pTempPth = hRapCh->pPath[hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx];
        }
        if(BRAP_ChannelType_eDecode == eChType)
        {        
            /* XPT Channel number for the current channel. This is used by the 
               DSP Firmware to determine the CDB and ITB used for the current 
               DSP Context */
            hRapCh->uiXptChannelNo = pAudioParams->sXptContextMap.ContextIdx;
            hRapCh->sXptContextMap = pAudioParams->sXptContextMap;

            if((hRapCh->eChannelSubType == BRAP_ChannelSubType_ePrimary) ||
               (hRapCh->eChannelSubType == BRAP_ChannelSubType_eNone) ||
               (hRapCh->eChannelSubType == BRAP_ChannelSubType_eSecondary))
            {
                hRapCh->bInputLfeOn = pAudioParams->bInputLfePresent;
                hRapCh->eInputAudMode = pAudioParams->eInputAudMode;
            }
        }

        if(true == bFMMPathAllocated)
        {
            /* Form the Resource Request */
            psRsrcReq->eChType = hRapCh->eChannelType;
            psRsrcReq->eChSubType = hRapCh->eChannelSubType;
            psRsrcReq->ePath = hRapCh->pPath[uiPth]->eUsgPath;

            /* To prepare the resource request, we need to know what all channels 
               are required for this path. Get this info. */
            /* TODO: This code can be generalized later. */
            if(BRAP_ChannelType_eDecode == eChType)
            {
                eInAudMode = hRapCh->eInputAudMode;
                /*bLfeOn = hRapCh->bInputLfeOn;*/
                if(hRapCh->pPath[uiPth]->pDstDetails[0] != NULL)
                {
                    if(hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eOutputPort)
                        bLfeOn = hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.sOpDetails.bLfeOn;
                    else
                        bLfeOn = false;
                }
                else
                {
                    bLfeOn = false;
                }
            }
            else if(BRAP_ChannelType_ePcmPlayback == eChType)
            {
                /* TODO: This code has to be revisited. Using eCurOpMode to 
                   get rid of the seg fault due to pInputAudMode in MixerSrcRsrcLayout */
                /* Another assumption here is - a PB channel is always stereo */   
                hRapCh->eInputAudMode = BRAP_OutputMode_e2_0;
                if((BRAP_P_UsgPath_eDecodePcmPostMixing == hRapCh->pPath[uiPth]->eUsgPath) ||
                   (BRAP_P_UsgPath_ePPBranchPostMixing == hRapCh->pPath[uiPth]->eUsgPath))
                {
                    eInAudMode = BRAP_OutputMode_e2_0;            
                }
                else
                {
                    if(BRAP_BufDataMode_eStereoNoninterleaved == pAudioParams->eBufDataMode)
                        eInAudMode = BRAP_OutputMode_e2_0;
                    else
                        eInAudMode = BRAP_OutputMode_e1_0;
                }

                hRapCh->bInputLfeOn = false;
            }
#if (BRAP_7550_FAMILY != 1)        
            else if(BRAP_ChannelType_ePcmCapture == eChType)
            {
                bLfeOn = false;
                hRapCh->bInputLfeOn = false;
                /* As of now, decode path is required only for external capture */
                /* Find out what buffer data mode is configured for capture channel.
                 * TODO: This code needs to be revisited to remove hardcoding
                 * pPath[0], sCapPort[0][0] etc */
                BDBG_ASSERT(NULL != hRapCh->pPath[0]); 
                eCapPort = hRapCh->pPath[0]->sCapPort[0][0].hCapPort->eCapPort;
                eBufDataMode = hRap->sInputSettings[eCapPort].eBufDataMode;
                if(BRAP_BufDataMode_eStereoNoninterleaved == eBufDataMode)
                    eInAudMode = BRAP_OutputMode_e2_0;
                else
                    eInAudMode = BRAP_OutputMode_e2_0;/*Set the INputmode 2_0, and ebufdataMode will later will be used to configure BUFFER_PAIR_ENABLE*/
                    hRapCh->eInputAudMode = eInAudMode;
            }
#endif
            /* Update the info in pPath->sInPathProp */
            /* TODO: Remove hardcoding to 0 if in future number of in link for path
               become more than one */

    /*        if(false == bCompress)*/
            if(1) /* 7043 Passthru + RBUF Cap Test */
            {
                if((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eMixPath)
                    ||(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eSharedPP))
                {
                    ret = BRAP_P_GetAudOpModeProp(eInAudMode, bLfeOn, &sOpAudModeProp);
                    if(BERR_SUCCESS != ret)
                    {
                        BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_GetAudOpModeProp"
                            " returned %d",ret));
                        ret = BERR_TRACE(ret);
                        goto free_rsrc;
                    }
                    for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                	{
            			/* For the input audio mode, this audio channel exists, 
            			   so RBuf is required to be allocated */
                        /* Note: For a DEC channel, If there is just 1 channel valid in a channel pair,
                           even then DSP requires ring buffer for both the channels. 
                           DSP will write 0's in other channel. So. take care of that
                           allocation here. */                   
                		if((sOpAudModeProp.bChnExists[eChP*2] == true)||
                           (sOpAudModeProp.bChnExists[(eChP*2)+1] == true))
                		{
                			psRsrcReq->sRbufReq[eChP].bAllocate = false;
                            psRsrcReq->sRbufReq[eChP].eBufDataMode = BRAP_BufDataMode_eStereoNoninterleaved;
                            psRsrcReq->sSrcChReq[eChP].bAllocate = false;
                		}
                    }
                }
                else if((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDownmixedPath)
                           ||(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDownmixedMixPath)
                               ||((BRAP_P_IsPointerValid((void *)hRapCh->pPath[uiPth]->pDstDetails[0])) &&
                                  (((hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eOutputPort)
                                &&(hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.
                            sOpDetails.eAudioMode == BRAP_OutputMode_e2_0)
                                &&(hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))
                            ||((hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                                &&(hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.sRBufDetails.eAudioMode == BRAP_OutputMode_e2_0)
                                    &&(hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))))
                           ||(true == bCompress))
                {
                    BDBG_MSG(("Populating Resource request for BRAP_P_UsgPath_eDownmixedPath"));
                    /*If its a downmixed Path allocate only one pair of Rbuf */
                    psRsrcReq->sRbufReq[0].bAllocate = true;
                    psRsrcReq->sRbufReq[0].eBufDataMode =   BRAP_BufDataMode_eStereoNoninterleaved;                
                    psRsrcReq->sSrcChReq[0].bAllocate = true;
                }         
                else
                {
                    /* Prepare resource request for rbuf and srcch */
                    ret = BRAP_P_GetAudOpModeProp(eInAudMode, bLfeOn, &sOpAudModeProp);
                    if(BERR_SUCCESS != ret)
                    {
                        BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_GetAudOpModeProp"
                            " returned %d",ret));
                        ret = BERR_TRACE(ret);
                        goto free_rsrc;
                    }

                    /* Resource request for Rbufs and SrcChs */
                    for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                    {
            			/* For the input audio mode, this audio channel exists, 
            			   so RBuf is required to be allocated */
                        /* Note: For a DEC channel, If there is just 1 channel valid in a channel pair,
                           even then DSP requires ring buffer for both the channels. 
                           DSP will write 0's in other channel. So. take care of that
                           allocation here. */                   
                		if((sOpAudModeProp.bChnExists[eChP*2] == true) &&
                           (sOpAudModeProp.bChnExists[(eChP*2)+1] == true))
                		{
#if (BRAP_7405_FAMILY == 1)            		
                            if(!((BRAP_ChannelType_ePcmPlayback== eChType)
                                &&(hRapCh->bOpenTimeWrToRbuf == true)
                                &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif                            
                            {            		
                		    /* Rbuf */
                			psRsrcReq->sRbufReq[eChP].bAllocate = true;
                            /* SrcCh */
                            psRsrcReq->sSrcChReq[eChP].bAllocate = true;
              		        }
                            psRsrcReq->sRbufReq[eChP].eBufDataMode =   BRAP_BufDataMode_eStereoNoninterleaved;
          		        }
                        else if(
                           ((sOpAudModeProp.bChnExists[eChP*2] == true) &&
                           (sOpAudModeProp.bChnExists[(eChP*2)+1] == false)) ||
                           ((sOpAudModeProp.bChnExists[eChP*2] == false) &&
                           (sOpAudModeProp.bChnExists[(eChP*2)+1] == true))
                           ) 
                        {
#if (BRAP_7405_FAMILY == 1)            		
                            if(!((BRAP_ChannelType_ePcmPlayback== eChType)
                                &&(hRapCh->bOpenTimeWrToRbuf == true)
                                &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif   
                            {
                    		    /* Rbuf */
                                psRsrcReq->sRbufReq[eChP].bAllocate = true;
                    		    /* SrcCh */
                                psRsrcReq->sSrcChReq[eChP].bAllocate = true;                             
                            }
                            if(BRAP_ChannelType_eDecode == eChType)
                            {
                                psRsrcReq->sRbufReq[eChP].eBufDataMode = 
                                    BRAP_BufDataMode_eStereoNoninterleaved;
                            }
                            else if((BRAP_ChannelType_ePcmPlayback == eChType)||
                                (BRAP_ChannelType_ePcmCapture == eChType))
                            {
                                psRsrcReq->sRbufReq[eChP].eBufDataMode = 
                                    pAudioParams->eBufDataMode;
                            }
                            else 
                            {
                                BDBG_ASSERT(0); /* TODO : remove this once PB etc is implemented */
                                /* TODO: Enable this later for PB 
                                psRsrcReq->sRbufReq[eChP].eBufDataMode = hRapCh->eBufDataMode;
                                
                                */
                            }                    
                        }
                    } /* for eChP */

                    if(true == bAdaptiveRateEnable)
                    {
                        /* Prepare resource request for AdaptRateCtrl */
                        /* AdaptRateCtrl is only allocated for stereo channel */
                        if((sOpAudModeProp.bChnExists[0] == true) 
                            && (sOpAudModeProp.bChnExists[1] == true)) /* i.e LR Channel Pair*/
                        {
                            bool    bPPMCorrectionSuprtd = true;
                            
                            for(i=0; i<BRAP_P_MAX_DST_PER_RAPCH; i++)
                            {
                                /* To consider RBuf Dstn as well when compressed capture is supported */
                                if((hRapCh->pDstDetails[i] != NULL) &&
                                   (hRapCh->pDstDetails[i]->eAudioDst == BRAP_AudioDst_eOutputPort))
                                {
                                    eOp = hRapCh->pDstDetails[i]->uDstDetails.sOpDetails.eOutput[0];

                                    if((eOp == BRAP_OutputPort_eMai)   ||
                                       (eOp == BRAP_OutputPort_eSpdif) ||
                                       (eOp == BRAP_OutputPort_eSpdif1))
                                    {
                                        if((hRap->bOpSettingsValid[eOp] == true) &&
                                           (hRap->sOutputSettings[eOp].bCompressed == true))
                                        {
                                            bPPMCorrectionSuprtd = false;
                                            BDBG_MSG(("Adaptive Rate Control cannot be enabled if any of "
                                                "Raptor channel destinations carry compressed data"));
                                            break;
                                        }
                                    }
                                }
                            }

                            if(bPPMCorrectionSuprtd == true)
                            {
                            if((sOpAudModeProp.bChnExists[2] == true) /*Ls*/
                                ||(sOpAudModeProp.bChnExists[3] == true)/*Rs*/
                                ||(sOpAudModeProp.bChnExists[4] == true)/*Center*/
                                ||(sOpAudModeProp.bChnExists[6] == true) /*Lr*/
                                ||(sOpAudModeProp.bChnExists[7] == true))/*Rr*/
                            {
                                    bPPMCorrectionSuprtd = false;
                                BDBG_MSG(("AdaptRateCtrl is not allocated for Multichannel"));
                            }
                            else
                            {
                                /* Count the total number of Rate Managers allocated till now.*/    
                                for(i=0; i<BRAP_RM_P_MAX_DEC_CHANNELS; i++)
                                {
                                    for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                                    {
                                        if( (hRap->hRapDecCh[i] != NULL) &&
                                            (hRap->hRapDecCh[i]->pPath[j] != NULL) &&
                                                (BRAP_RM_P_INVALID_INDEX != 
                                                    hRap->hRapDecCh[i]->pPath[j]->sRsrcGrnt.uiAdaptRateCtrlId[0])
                                               )
                                        {
                                            uiNumRateMngrsAlloctd += 1;
                                        }
                                    }
                                }

                                /* Count the number of paths in the channel that are yet to be allocated Rate Managers.*/    
                                for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                                {
                                    if((hRapCh->pPath[j] != NULL) &&
                                        ((hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)
                                         ||(hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_ePPBranch)) &&
                                        (BRAP_RM_P_INVALID_INDEX == hRapCh->pPath[j]->sRsrcGrnt.uiAdaptRateCtrlId[0]) 
                                      )
                                    {
                                        uiNumPathsNeedRateCtrl += 1;
                                    }
                                }
                                
                                    if( !(uiNumPathsNeedRateCtrl <= (BRAP_RM_P_MAX_ADAPTRATE_CTRL - uiNumRateMngrsAlloctd)))
                                    {
                                        bPPMCorrectionSuprtd = false;
                                        BDBG_MSG(("Not enough Rate Managers available, Adapative Rate control is disabled for this channel %x", hRapCh));
                                    }
                                }
                            } /* end of if(bPPMCorrectionSuprtd == true) */
                            if(bPPMCorrectionSuprtd == true)
                                {
                        		    /* AdaptRateCtrl Request*/
                                    psRsrcReq->sAdaptRateCtrlReq[0].bAllocate = true;
                                BDBG_MSG(("Populating resource request for AdaptRateCtrl"));
                            }
                        } 
                    } /*end of if(true == pAudioParams->sDspChParams.bPPMCorrection)*/
                } /*end of else at if((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eMixPath)...*/

    		    BDBG_MSG(("uiNumCapPath > %d", uiNumCapPath));

                if(0 != uiNumCapPath)
                {
                    for(i=0;i<uiNumCapPath;i++)
                    {
                        for(j=0; j < BRAP_P_MAX_DST_PER_RAPCH;j++)
                        {
                            if(NULL == hRapCh->pDstDetails[j])
                            {
                                continue;
                            }
                            
                            if(BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[j]->eAudioDst)
                            {
#if (BRAP_7550_FAMILY != 1)                        
                                for(k =0 ; k < BRAP_P_MAX_DST_PER_RAPCH; k++)
                                {
                                    if(hRapCh->pPath[uiPth]->pDstDetails[k] != NULL)
                                    {
                                        if((hRapCh->pPath[uiPth]->pDstDetails[k]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                                            &&(hRapCh->pPath[uiPth]->pDstDetails[k] == hRapCh->pDstDetails[j]))
                                            break;
                                    }
                                }

                                if(k < BRAP_P_MAX_DST_PER_RAPCH)
                                {
        		                    BDBG_MSG(("hRapCh->pDstDetails[j].uDstDetails.sRBufDetails.eAudioMode > %d", 
                                      hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.eAudioMode));
                                    
                            		BDBG_MSG(("hRapCh->pDstDetails[j].uDstDetails.sRBufDetails.bLfeOn > %d", 
                                      hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.bLfeOn));
                                
                                    hRapCh->sIntDst[i].eInputAudMode = hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.eAudioMode;
                                    hRapCh->sIntDst[i].bLfeOn = false;
                                    /* 7440 A0 transcoder require input SR of data to DSP at 48kHz. */
        /*                            hRapCh->sIntDst[i].eInputSR = BAVC_AudioSamplingRate_e48k;*/
                                    /* This was wrong, we should set it to input sampling rate */
                                    /* RBUF has a sampling rate associated now */
                                    /*hRapCh->sIntDst[i].eInputSR = hRapCh->eInputSamplingRate;*/
                                    hRapCh->sIntDst[i].eInputSR = hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.eSampleRate;

                                    /* Get the other started channel(if any) from the association. bPrimary is not being used*/
                                    ret = BRAP_P_GetOtherStartedChannel(hRapCh, bPrimary, hStartedAssocCh);
                                    if(BERR_SUCCESS != ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto exit;        
                                    }
                                    
                                    ret = BRAP_P_GetAssocId(hRapCh, hRapCh->pPath[uiPth]->pDstDetails[k], &uiAssocId );    
                                    if(BERR_SUCCESS != ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto exit;
                                    }             

                                    if((hStartedAssocCh[uiAssocId] == NULL)
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
        /* Currently MS11 usage mode at max has 2 decode and 1 PB channels, 
           and no resources are shared among them as decode channels output to DRAM and PB to RBUF */
                                       ||(BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh))
#endif           
                                      )
                                    {
                                        /* Allocate Internal Cap ports and store them as internal Destinations */
                                        /* Prepare resource request for cap port */
                                        ret = BRAP_P_GetAudOpModeProp(
                                                        hRapCh->sIntDst[i].eInputAudMode, 
                                                        hRapCh->sIntDst[i].bLfeOn,
                                                        &sOpAudModeProp);
                                        if(BERR_SUCCESS != ret)
                                        {
                                            BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_GetAudOpModeProp returned %d",ret));
                                            ret = BERR_TRACE(ret);
                                            goto free_rsrc;
                                        }

                                        /* Resource request for Capport */
                                        for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                                        {
                                            if((sOpAudModeProp.bChnExists[eChP*2] == true) ||
                                               (sOpAudModeProp.bChnExists[(eChP*2)+1] == true))
                                            {
                                    		    /* Resource request for internal capport */
                                    			psRsrcReq->sCapReq[eChP][i].bAllocate = true;
                                                psRsrcReq->sCapReq[eChP][i].eCapPort = BRAP_CapInputPort_eMax;
                                                psRsrcReq->sFsTmgSrcReq.bAllocate = true;
                                                psRsrcReq->sFsTmgSrcReq.uiFsTmgSrcId = BRAP_RM_P_INVALID_INDEX;
                                  		    }
                          	            }
                              	    }
                                    else
                                    {
                                        for(uiPthId=0; uiPthId < BRAP_P_MAX_PATHS_IN_A_CHAN; uiPthId++)
                                        {
                                            if(NULL == hStartedAssocCh[uiAssocId]->pPath[uiPthId])
                                            {
                                                continue;
                                            }
                                            for(uiChp=0; uiChp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; uiChp++)
                                            {
                                                for(uiPrllPth=0; uiPrllPth < BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; uiPrllPth++)
                                                {   
                                                    if((NULL != hStartedAssocCh[uiAssocId]->pPath[uiPthId]->sCapPort[uiChp][uiPrllPth].hCapPort) &&
                                                       (BRAP_CapInputPort_eIntCapPort3 >= 
                                                         hStartedAssocCh[uiAssocId]->pPath[uiPthId]->sCapPort[uiChp][uiPrllPth].hCapPort->eCapPort))
                                                    {
                                            		    /* Mixing case: Internal Capture port is already allocated for this association */
                                            			psRsrcReq->sCapReq[uiChp][uiPrllPth].bAllocate = true;
                                                        psRsrcReq->sCapReq[uiChp][uiPrllPth].eCapPort = 
                                                            hStartedAssocCh[uiAssocId]->pPath[uiPthId]->sCapPort[uiChp][uiPrllPth].hCapPort->eCapPort;
                                                        /* uiFsTmgSrcId is not used anywhere */
                                                        bFound = true;
                                                        break;
                                                    }
                                                }
                                                if(bFound == true)
                                                    break;
                                            }
                                            if(bFound == true)
                                                break;
                                        }
                                    }
                              	}
#else
                                BDBG_ERR(("Error: Ringbuffer destination found in hRapCh->pDstDetails[#d] = %x is not supported",
                                                    j,hRapCh->pDstDetails[j]));
                                ret = BERR_TRACE(BERR_NOT_SUPPORTED);
                                goto exit;
#endif
                          	}
        		            else if(BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[j]->eAudioDst)
            			 	{
                                BRAP_ProcessingType    eAudioProcessing = BRAP_ProcessingType_eNone;
                                bool                    bPrimaryPresent[BRAP_MAX_ASSOCIATED_GROUPS];
                                BRAP_ChannelHandle      hStrtdAssocCh[BRAP_MAX_ASSOCIATED_GROUPS];
                                for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; ++uiAssocId)
                                {
                                    bPrimaryPresent[uiAssocId] = false;
                                    hStrtdAssocCh[uiAssocId] = NULL;
                                }
                                
                                	/* Initialize before use */
                                BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));                                
                                ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                            hRapCh->pDstDetails[j],
                                            pPvtDstDetails,
                                            &uiAssocId);
                                if(BERR_SUCCESS!=ret)
                                {
                                    ret = BERR_TRACE(ret);
                                    goto free_rsrc;
                                }
                                eAudioProcessing = pPvtDstDetails->eAudioProcessing;
            		            BDBG_MSG(("hRapCh->pDstDetails[j].uDstDetails.sOpDetails.eAudioProcessing > %d", eAudioProcessing));

#if (BRAP_7550_FAMILY != 1)                            
                                /* Capture path for Association Network */
                                if((BRAP_P_UsgPath_eDecodePcm == hRapCh->pPath[uiPth]->eUsgPath) &&
                                   (BRAP_P_IsAssociationNWValid(pPvtDstDetails)))
                                {
        		                    BDBG_MSG(("hRapCh->pDstDetails[j].uDstDetails.sOpDetails.eAudioMode > %d", 
                                      hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eAudioMode));
                                    
                            		BDBG_MSG(("hRapCh->pDstDetails[j].uDstDetails.sOpDetails.bLfeOn > %d", 
                                      hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.bLfeOn));
                                
                                    hRapCh->sIntDst[i].eInputAudMode = hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eAudioMode;
                                    hRapCh->sIntDst[i].bLfeOn = false;
                                    hRapCh->sIntDst[i].eInputSR = BAVC_AudioSamplingRate_e48k; /* By default set to 48khz */
                                    
                                    /* Get the other started channel(if any) from the association. bPrimary is not being used*/
                                    ret = BRAP_P_GetOtherStartedChannel(hRapCh, bPrimary, hStartedAssocCh);
                                    if(BERR_SUCCESS != ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto exit;        
                                    }
                                    
                                    ret = BRAP_P_GetAssocId(hRapCh, hRapCh->pDstDetails[j], &uiAssocId );    
                                    if(BERR_SUCCESS != ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto exit;
                                    }             
                                
                                    if((hStartedAssocCh[uiAssocId] == NULL)
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
/* Currently MS11 usage mode at max has 2 decode and 1 PB channels, 
   and no resources are shared among them as decode channels output to DRAM and PB to RBUF */
                                        ||(BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh))
#endif           
                                      )
                                    {
                                        /* Allocate Internal Cap ports and store them as internal Destinations */
                                        /* Prepare resource request for cap port */
                                        ret = BRAP_P_GetAudOpModeProp(
                                                        hRapCh->sIntDst[i].eInputAudMode, 
                                                        hRapCh->sIntDst[i].bLfeOn,
                                                        &sOpAudModeProp);
                                        if(BERR_SUCCESS != ret)
                                        {
                                            BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_GetAudOpModeProp returned %d",ret));
                                            ret = BERR_TRACE(ret);
                                            goto free_rsrc;
                                        }

                                        /* Resource request for Capport */
                                        for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                                        {
                                            if((sOpAudModeProp.bChnExists[eChP*2] == true) ||
                                               (sOpAudModeProp.bChnExists[(eChP*2)+1] == true))
                                            {
                                    		    /* Resource request for internal capport */
                                    			psRsrcReq->sCapReq[eChP][i].bAllocate = true;
                                                psRsrcReq->sCapReq[eChP][i].eCapPort = BRAP_CapInputPort_eMax;
                                                psRsrcReq->sFsTmgSrcReq.bAllocate = true;
                                                psRsrcReq->sFsTmgSrcReq.uiFsTmgSrcId = BRAP_RM_P_INVALID_INDEX;
                                  		    }
                          	            }
                              	    }
                                    else
                                    {
                                        for(uiPthId=0; uiPthId < BRAP_P_MAX_PATHS_IN_A_CHAN; uiPthId++)
                                        {
                                            if(NULL == hStartedAssocCh[uiAssocId]->pPath[uiPthId])
                                            {
                                                continue;
                                            }
                                            for(uiChp=0; uiChp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; uiChp++)
                                            {
                                                for(uiPrllPth=0; uiPrllPth < BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; uiPrllPth++)
                                                {   
                                                    if((NULL != hStartedAssocCh[uiAssocId]->pPath[uiPthId]->sCapPort[uiChp][uiPrllPth].hCapPort) &&
                                                       (BRAP_CapInputPort_eIntCapPort3 >= 
                                                         hStartedAssocCh[uiAssocId]->pPath[uiPthId]->sCapPort[uiChp][uiPrllPth].hCapPort->eCapPort))
                                                    {
                                            		    /* Mixing case: Internal Capture port is already allocated for this association */
                                            			psRsrcReq->sCapReq[uiChp][uiPrllPth].bAllocate = true;
                                                        psRsrcReq->sCapReq[uiChp][uiPrllPth].eCapPort = 
                                                            hStartedAssocCh[uiAssocId]->pPath[uiPthId]->sCapPort[uiChp][uiPrllPth].hCapPort->eCapPort;
                                                        /* uiFsTmgSrcId is not used anywhere */
                                                        bFound = true;
                                                        break;
                                                    }
                                                }
                                                if(bFound == true)
                                                    break;
                                            }
                                            if(bFound == true)
                                                break;
                                        }
                                    }
    		                    }
#endif                                
                            }
                        }
                    }
                }
                /* For Mixer-SRC Layout find the audio mode and sampling rate of 
                   master channel */
                /* Resource request for SRCs and Mixers */
                
                /* If Primary Decode Channel present in the association then it is 
                   the master, otherwise current channel is the master */
                   
                for(j=0; j<BRAP_MAX_ASSOCIATED_GROUPS; ++j)
                {
                    if(hRapCh->uiAssociationId[j] == BRAP_INVALID_VALUE)
                        continue;
                for (i=0;i<BRAP_MAX_PRI_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
                {
                        if(hRap->sAssociatedCh[hRapCh->uiAssociationId[j]].hPriDecCh[i] != NULL) 
                    {
                            hMasterCh = hRap->sAssociatedCh[hRapCh->uiAssociationId[j]].hPriDecCh[i];
                        }
                    }
                }

                if (NULL == hMasterCh)
                {
                    hMasterCh = hRapCh;
                }
                
                if((BRAP_P_UsgPath_eDecodePcmPostMixing == hRapCh->pPath[uiPth]->eUsgPath) ||
                   (BRAP_P_UsgPath_ePPBranchPostMixing == hRapCh->pPath[uiPth]->eUsgPath))
                    
                {
                    /* Currently there is no SR Conversion required in post-mixing path. 
                       At this stage we don't know the stream SR, the outputs will be defaulted 
                       to 48khz, so programming the same, this will force SRC type to 'Bypass' */
                    eInputSamplingRate = BAVC_AudioSamplingRate_e48k;
                }
                else
                {
                    BRAP_P_ConvertSrToEnum(hRapCh->uiInputSamplingRate,&eInputSamplingRate);                                                    
                }
                
                /* Resource request for SRCs and Mixers */
                ret = BRAP_P_MixerSrcRsrcLayout(hRapCh, psRsrcReq, uiPth,
                                    &(hRapCh->pPath[uiPth]->sMixingLevels[0]),
                                    &(hRapCh->sIntDst[0]),hRapCh->eInputAudMode,
                                    bLfeOn,eInputSamplingRate,bCompress);
                if(BERR_SUCCESS != ret)
                {
                    BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_MixerSrcRsrcLayout"
                        " returned %d",ret));
                    ret = BERR_TRACE(ret);
                    goto exit;
                }
        	}
            else
            {
    	        int count=0;
    			
                /* Passthru context requires 2 rbufs */
                /* Why should passthru require 2 RBUFs? */
                psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eLR].bAllocate = true;
                psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eLR].eBufDataMode = 
                    BRAP_BufDataMode_eStereoInterleaved;
                /* 1 SrcCh */
                psRsrcReq->sSrcChReq[BRAP_OutputChannelPair_eLR].bAllocate = true;
#if ( (BRAP_7405_FAMILY == 1))			
    			
                /* 1 Src */
                psRsrcReq->sSrcMixerReq[0].sSrcReq[0][0][0].bAllocate = true;
#endif
                /* 1 Mixer */
                psRsrcReq->sSrcMixerReq[0].sMixerReq[0][0].bAllocate = true;
                psRsrcReq->sSrcMixerReq[0].sMixerReq[0][0].uiNumNewInput = 1;
                psRsrcReq->sSrcMixerReq[0].sMixerReq[0][0].bInputChPair[0] = true;
                psRsrcReq->sSrcMixerReq[0].sMixerReq[0][0].uiNumNewOutput = 0;

                /* Update the mixing level info */
                /* TODO: check if sMixingLevels[0] is required to be programmed 
                   with valid values */
                hRapCh->pPath[uiPth]->sMixingLevels[0] = sMixingLevelPropInvalid;
    			count = 0;
                for(dst = 0; dst < BRAP_P_MAX_DST_PER_RAPCH; dst++)
                {
                    BRAP_ProcessingType    eAudioProcessing = BRAP_ProcessingType_eNone;

                    if(NULL == hRapCh->pDstDetails[dst])
                    {
                        continue;
                    }

                    	/* Initialize before use */
                BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));                 
                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                hRapCh->pDstDetails[dst],
                                pPvtDstDetails,
                                &uiAssocId);
                    if(BERR_SUCCESS!=ret)
                    {
                        ret =  BERR_TRACE(ret);
                        goto free_rsrc;                    
                    }
                    eAudioProcessing = pPvtDstDetails->eAudioProcessing;

                    if(BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[dst]->eAudioDst)
                    {
                        eOp = hRapCh->pDstDetails[dst]->uDstDetails.sOpDetails.eOutput[0];
                        
#if (BRAP_7405_FAMILY == 1)
                       if(((BRAP_OutputPort_eMai == eOp)||
                           ((BRAP_OutputPort_eI2s5 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
                           ((BRAP_OutputPort_eI2s6 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
                           ((BRAP_OutputPort_eI2s6 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
                           ((BRAP_OutputPort_eI2s7 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable)))&&
                          (true == hRap->sOutputSettings[eOp].bCompressed))
#else
                       if((
                           ((BRAP_OutputPort_eMai == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
                           ((BRAP_OutputPort_eI2s5 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
                           ((BRAP_OutputPort_eI2s6 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
                           ((BRAP_OutputPort_eI2s6 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
                           ((BRAP_OutputPort_eI2s7 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
    		               (BRAP_OutputPort_eI2s5 == eOp))&&
                          (true == hRap->sOutputSettings[eOp].bCompressed))
#endif                      
                    {
                        /* Got the SPDIF output port carrying compressed data */
    					/*1 Mixing Level supports only 2 compresed output port, Hence Assert*/
    					BDBG_ASSERT(count < 2);
                        hRapCh->pPath[uiPth]->sMixingLevels[0].pDstDetails[count++] = 
                            hRapCh->pDstDetails[dst];
    					psRsrcReq->sSrcMixerReq[0].sMixerReq[0][0].uiNumNewOutput++;     
                    }
                        }
                }
            }

            /* Call resource manager to allocate required resources. */
    		ret = BRAP_RM_P_AllocateResources(hRap->hRm, psRsrcReq, psRsrcGrnt);
    		if(BERR_SUCCESS != ret)
    		{
    			BDBG_ERR(("BRAP_P_OpenDecPath: Resource alloc failed with err = %d",
                    ret));
    			ret = BERR_TRACE(ret);
                goto exit;
    		}



            
            if((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eMixPath)
                ||(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eSharedPP))
            {
                for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                {
                    hRapCh->pPath[uiPth]->hRBuf[eChP] = pTempPth->hRBuf[eChP];
                    hRapCh->pPath[uiPth]->sSrcCh[eChP] = pTempPth->sSrcCh[eChP];
                }
            }
            /* Save Capport allocated in sIntDstDetails */
            if(0 != uiNumCapPath)
            {
                for(i=0;i<uiNumCapPath;i++)
                {
                    bFound = false;
                    for(j=0 ; j< BRAP_RM_P_MAX_INTERNAL_DST; j++)
                    {
                        for(k = 0; k < BRAP_RM_P_MAX_MIXING_LEVELS; k++)
                        {
                            if(hRapCh->pPath[uiPth]->sMixingLevels[k].pIntDstDetails[i] == &(hRapCh->sIntDst[j]))          
                            {
                                for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                                {
                                        hRapCh->sIntDst[j].eCapPort[eChP] = psRsrcGrnt->sCapPortGrnt[eChP][i].eCapPort;

                                        for(j=0; j < BRAP_P_MAX_DST_PER_RAPCH;j++)
                                        {
                                            if(NULL == hRapCh->pDstDetails[j])
                                            {
                                                continue;
                                            }
                                            
                                            if( (bIntCapPortFound == false) &&
                                                (BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[j]->eAudioDst))
                                            {
                                                bIntCapPortFound = true;
                                                hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.eCapPort[eChP] = psRsrcGrnt->sCapPortGrnt[eChP][i].eCapPort;
                                                BDBG_MSG(("i=%d, eChp=%d, hRapCh->pDstDetails[%d]->uDstDetails.sRBufDetails.eCapPort[%d]=%d",
                                                    i,eChP,j,eChP,hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.eCapPort[eChP]));
                                                break;
                                            }
                                        }
                                }
                                bFound =true;
                                break;
                            }                            
                        }
                        if(bFound == true)
                            break;
                    }
                }
            }

            /* Open all internal module handles */
            ret = BRAP_P_OpenFmmModuleHandles(hRapCh, pAudioParams, uiPth, psRsrcGrnt);
    		if(BERR_SUCCESS != ret)
    		{
    			BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_OpenFmmModuleHandles"
                   " failed %d", ret));
    			ret = BERR_TRACE(ret); 
                goto free_rsrc;
    		}

            /* Update the resource grant structure in hRapCh */
            ret = BRAP_RM_P_UpdateResrcGrant(&(hRapCh->pPath[uiPth]->sRsrcGrnt), 
                                             psRsrcGrnt);
    		if(BERR_SUCCESS != ret)
    		{
    			BDBG_ERR(("BRAP_P_OpenDecPath: UpdateResrcGrant failed %d", ret));
    			ret = BERR_TRACE(ret); 
                goto free_rsrc;
    		}

            /* Update the resource grant structure in hRapCh to hold the output
               ports and spdifFm (if any) */
            ret = BRAP_P_UpdateOpResrcGrant(hRapCh, hRapCh->pPath[uiPth], 
                &(hRapCh->pPath[uiPth]->sRsrcGrnt));
            if(BERR_SUCCESS != ret)
    		{
    			BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_UpdateOpResrcGrant failed %d",
                   ret));
    			ret = BERR_TRACE(ret); 
                goto free_rsrc;
    		}        

            /* Prepare linkage info among the resources in the same path */
            ret = BRAP_P_LinkFmmModuleHandles(hRapCh, uiPth);
    		if(BERR_SUCCESS != ret)
    		{
    			BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_LinkFmmModuleHandles"
                   " failed %d", ret));
    			ret = BERR_TRACE(ret); 
                goto free_rsrc;
    		}
        }
        else
        {
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
            if(BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh))
            {   
                if(hRapCh->eChannelType == BRAP_ChannelType_eDecode)
                {
                    for(i=0; i<BRAP_P_MAX_FW_STG_INPUTS; i++)
                    {
                        if(hRapCh->hMultiStreamDecoder->bDRAMBuffersUsed[i] == false)
                            break;
                    }
                    if(i == BRAP_P_MAX_FW_STG_INPUTS)
                    {
                        BDBG_ERR(("No free DRAM buffer found for InterTask buffer usage"));
                        ret = BRAP_ERR_BAD_DEVICE_STATE;
                        goto free_rsrc;
                    }
                    uiFreeIndex = i;
                    
                    if(BRAP_P_IsMs10UsageMode(hRapCh))
                    {
                        uiNumBuffers = 2;
                    }
                    else
                    {
                        uiNumBuffers = 6; /* Currently 5.1 for MS11 */
                    }
                    i =0;
                    while(i < uiNumBuffers)
                    {
                        ret = BRAP_P_GetRbufFromPool(hRapCh,NULL,hRapCh->pPath[uiPth],false,0,0,&sRBufSettings, 0);          
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret); 
                            goto free_rsrc;
                        }   
                        if(sRBufSettings.sExtSettings.uiSize < BRAP_AF_P_INTERTASK_IOBUFFER_SIZE)
                        {
                            BDBG_ERR(("Buffer size required (%d) for interTask DRAM  is less than required(%d)"
                                ,sRBufSettings.sExtSettings.uiSize,BRAP_AF_P_INTERTASK_IOBUFFER_SIZE));
                            ret = BERR_TRACE(BERR_INVALID_PARAMETER); 
                            goto free_rsrc;                                
                        }
                        hRapCh->hMultiStreamDecoder->ui32InterTaskIoBufferAddress[uiFreeIndex][i] = (uint32_t)sRBufSettings.sExtSettings.pBufferStart;
                        i++;
                    }
                    hRapCh->hMultiStreamDecoder->uiNumValidIOBuffer[uiFreeIndex] = uiNumBuffers;
                }
            }
#endif      
        }
    }
    else /* if watchdog */
    {
        if(true == bFMMPathAllocated)
        {    
            /* Open all internal module handles */
            ret = BRAP_P_OpenFmmModuleHandles(hRapCh, pAudioParams, uiPth, 
                    &(hRapCh->pPath[uiPth]->sRsrcGrnt));
    		if(BERR_SUCCESS != ret)
    		{
    			BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_OpenFmmModuleHandles"
                   " failed %d", ret));
    			ret = BERR_TRACE(ret); 
                goto free_rsrc;
    		}
#if (BRAP_P_WATERMARK_WORKAROUND == 0)
#if (BRAP_P_EDGE_TRIG_INTRPT == 1)
            if (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
            {
                /* Unmask the Free Mark interrupt */
                ret = BRAP_P_UnmaskInterrupt(hRapCh, BRAP_Interrupt_eFmmRbufFreeByte);
                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_UnmaskInterrupt() returned err(%d)",ret));
                    ret = BERR_TRACE(ret);
                    goto free_rsrc;
                }
            }
#endif
#endif            
        }
    }
        
    if((BERR_SUCCESS == ret) && (false == bWdgRecovery))
    {
        /* Increment the open count */
        hRapCh->pPath[uiPth]->uiPthOpenCnt++;

        BDBG_MSG(("BRAP_P_OpenDecPath: hRapCh->pPath[uiPth=%d]->uiPthOpenCnt = %d",
            uiPth, hRapCh->pPath[uiPth]->uiPthOpenCnt));
    }

    if(BERR_SUCCESS == ret)
    {
        /* Exit successfully */
        goto exit;
    }
    
free_rsrc:
    /* Free resources */    
    BRAP_RM_P_FreeResources(hRap->hRm, psRsrcGrnt,true);
    if(BERR_SUCCESS != ret)
	{
		BDBG_ERR(("Free Resource failed with err = %d",ret));
		ret = BERR_TRACE(ret);
	}
	
exit: 

    BDBG_LEAVE(BRAP_P_OpenDecPath);    
    return ret;
}

/**************************************************************************
Summary:
    Private function that closes a decode path.
**************************************************************************/
BERR_Code 
BRAP_P_CloseDecPath(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
    const unsigned int          uiPth       	/* [in] Path idx corresponding 
                                                   to pPath[] array element */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    bool                    bWdgRecovery = false;
    unsigned int            i = 0;
    bool                    bFMMPathAllocated = true;
   
    BDBG_ENTER(BRAP_P_CloseDecPath); 
    BDBG_MSG(("BRAP_P_CloseDecPath CALLED!!!"));
    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth]);

    if((BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath) &&
       (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType))
    {
        BDBG_MSG(("CloseDecPath: Returning success for PCMPB compress path\n"));
        BDBG_LEAVE(BRAP_P_CloseDecPath);
        return BERR_SUCCESS;        
    }
    
    /* Error state check */
    if (0 == hRapCh->pPath[uiPth]->uiPthOpenCnt)
    { 
        /* This should never happen. If it does, it means the system
           has gone into an invalid state!!!!*/
        BDBG_ERR (("BRAP_P_CloseDecPath: SM Path open count is already 0"));
        return BERR_TRACE (BERR_NOT_SUPPORTED);
    }

    /* Decrement the open count */
    hRapCh->pPath[uiPth]->uiPthOpenCnt--;

    BDBG_MSG(("BRAP_P_CloseDecPath: For uiPth=%d New uiPthOpenCnt = %d", 
        uiPth, hRapCh->pPath[uiPth]->uiPthOpenCnt));

    /* If the new open count is not 0, do not close the resources instead 
       return success */
    if(0 != hRapCh->pPath[uiPth]->uiPthOpenCnt)
    {
        BDBG_MSG(("BRAP_P_CloseDecPath: uiPthOpenCnt = %d so not closing resources!"));
        BDBG_LEAVE(BRAP_P_CloseDecPath);
        return BERR_SUCCESS;
    }

    /* For MS10, MS11 the decode channels output to sepearate task(FW Mixer) through DRAM and not FMM */
    ret = BRAP_P_IsFMMPathAllocated(hRapCh, uiPth, &bFMMPathAllocated);
    if(BERR_SUCCESS!=ret)
    {
        BDBG_ERR(("BRAP_P_IsFMMPathAllocated returned Error!"));
        ret = BERR_TRACE(ret);
        goto exit;
    }    
    
    if(bFMMPathAllocated == true)
    {
#if (BRAP_P_WATERMARK_WORKAROUND == 0)
#if (BRAP_P_EDGE_TRIG_INTRPT == 0)
    	if (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
    	{
    	    /* Mask the Free Mark interrupt */
    	    ret = BRAP_P_MaskInterrupt(hRapCh, BRAP_Interrupt_eFmmRbufFreeByte);
    		if(ret != BERR_SUCCESS)
    		{
    			BDBG_ERR(("BRAP_PB_Stop: BRAP_P_MaskInterrupt() returned err(%d)",ret));	
                        return BERR_TRACE (ret);            
    		}
    	}
#endif
#endif
        
        /* Check if this is a watchdog recovery. */
    	bWdgRecovery = BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap);

        /* Unlink FMM modules */
        ret = BRAP_P_UnlinkFmmModuleHandles(hRapCh, uiPth);
    	if(BERR_SUCCESS != ret)
    	{
    		BDBG_ERR(("BRAP_P_CloseDecPath: UnlinkFmmModuleHandles failed %d", ret));
    		ret = BERR_TRACE(ret); 
    	}


        /* Remove output ports and spdifFm (if any) from the resource grant 
           structure in hRapCh. This action is just opposite to what is done in
           BRAP_P_UpdateOpResrcGrant() */
        ret = BRAP_P_ResetOpResrcGrant(hRapCh->hRap, 
                                       hRapCh->pPath[uiPth],
                                       &(hRapCh->pPath[uiPth]->sRsrcGrnt));
    	if(BERR_SUCCESS != ret)
    	{
    		BDBG_ERR(("BRAP_P_CloseDecPath: ResetOpResrcGrant failed err=%d", ret));
    		ret = BERR_TRACE(ret); 
    	}

        /* Close all internal module handles */
        ret = BRAP_P_CloseFmmModuleHandles(hRapCh, uiPth);
    	if(BERR_SUCCESS != ret)
    	{
    		BDBG_ERR(("BRAP_P_CloseDecPath: CloseFmmModuleHandles failed %d", ret));
    		ret = BERR_TRACE(ret); 
    	}
#if (BRAP_7405_FAMILY == 1)            	                
        if(((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
            &&(hRapCh->bOpenTimeWrToRbuf == true)
            &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
        {
            /* Free all resources allocated during OpenDecPath() */
                ret = BRAP_RM_P_FreeResources(hRapCh->hRap->hRm, &(hRapCh->pPath[uiPth]->sRsrcGrnt),false);
        	if(BERR_SUCCESS != ret)
        	{
        		BDBG_ERR(("BRAP_P_CloseDecPath: Resource free failed err = %d",ret));
        		ret = BERR_TRACE(ret);
        	}

                 /* Reset the resource grant structure for this path */
                BRAP_RM_P_InitResourceGrant(&(hRapCh->pPath[uiPth]->sRsrcGrnt),false);
        }
        else
#endif
        {            
            /* Free all resources allocated during OpenDecPath() */
                ret = BRAP_RM_P_FreeResources(hRapCh->hRap->hRm, &(hRapCh->pPath[uiPth]->sRsrcGrnt),true);
        	if(BERR_SUCCESS != ret)
        	{
        		BDBG_ERR(("BRAP_P_CloseDecPath: Resource free failed err = %d",ret));
        		ret = BERR_TRACE(ret);
        	}

                 /* Reset the resource grant structure for this path */
                BRAP_RM_P_InitResourceGrant(&(hRapCh->pPath[uiPth]->sRsrcGrnt),true);
        }
    }
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
    else
    {
        BRAP_P_ReturnRBufToPool(hRapCh,hRapCh->pPath[uiPth],false,0,0);    
        i=0;
        while(i < hRapCh->hMultiStreamDecoder->uiNumValidIOBuffer[hRapCh->uiFWMixerIpIndex])
        {            
            hRapCh->hMultiStreamDecoder->ui32InterTaskIoBufferAddress[hRapCh->uiFWMixerIpIndex][i] = (uint32_t)NULL;
            i++;
        }        
        hRapCh->hMultiStreamDecoder->uiNumValidIOBuffer[hRapCh->uiFWMixerIpIndex] = 0;        
        hRapCh->hMultiStreamDecoder->bDRAMBuffersUsed[hRapCh->uiFWMixerIpIndex] = false;        
    }
#endif
exit:    
    /* Reset misc channel handle elements.
       Note: This is exactly reverse of what is done in OpenDecPath() */
    if(false == bWdgRecovery) 
    {
        if(BRAP_ChannelType_eDecode == hRapCh->eChannelType)
        {        
            hRapCh->uiXptChannelNo = BRAP_INVALID_VALUE;
        }

        for(i=0; i<BRAP_RM_P_MAX_MIXING_LEVELS; i++)
        {
            hRapCh->pPath[uiPth]->sMixingLevels[i] = sMixingLevelPropInvalid;
        }

        for(i=0; i<BRAP_RM_P_MAX_INTERNAL_DST; i++)
        {
            hRapCh->sIntDst[i] = sInternalDst;
        }
    }
    
    BDBG_LEAVE(BRAP_P_CloseDecPath);    
    return ret;
}

/**************************************************************************
Summary:
    Private function that opens a Capture path.
**************************************************************************/
BERR_Code 
BRAP_P_OpenCapPath(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */
    const unsigned int          uiPth       	/* [in] Path idx corresponding 
                                                   to pPath[] array element */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    bool                    bWdgRecovery = false;
    BRAP_Handle             hRap = NULL;
    BRAP_ChannelType        eChType = BRAP_ChannelType_eMax;
    BRAP_RM_P_ResrcReq      *psRsrcReq = NULL;
    BRAP_RM_P_ResrcGrant    *psRsrcGrnt = NULL;
    unsigned int            i =0, j = 0;
    bool                    bRbuAllocated = false;
    BRAP_P_OpAudModProp     sOpAudModeProp;
    BRAP_OutputChannelPair  eChP = BRAP_OutputChannelPair_eMax;
    unsigned int            uiInPth = 0;

#if BRAP_P_WATERMARK_WORKAROUND==1
	BTMR_Settings sTimerSettings;
#endif    

    BDBG_ENTER(BRAP_P_OpenCapPath);

    /* Check if this is a watchdog recovery. */
    hRap = hRapCh->hRap;
    BDBG_ASSERT(hRap);
    bWdgRecovery = BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap);
    BDBG_ASSERT(hRapCh->pPath[uiPth]);

    if(false == bWdgRecovery)
    {
    /* Check if the path has already been opened. If yes, just increment the 
       count and return success. */
    if(0 != hRapCh->pPath[uiPth]->uiPthOpenCnt)
    {
        /* Increment the open count */
        hRapCh->pPath[uiPth]->uiPthOpenCnt++;

        BDBG_MSG(("BRAP_P_OpenCapPath: Cap Path %d was already open. " 
                "New open count = %d", uiPth, hRapCh->pPath[uiPth]->uiPthOpenCnt));

        /* Return success */
        BDBG_LEAVE (BRAP_P_OpenCapPath);
        return BERR_SUCCESS;
    }
    
	/* Malloc large structures */
	psRsrcReq = hRap->sOpenTimeMallocs.psResrcReq;
	if ( NULL==psRsrcReq )
	{
			return BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
	}
        BKNI_Memset(psRsrcReq, 0, sizeof(BRAP_RM_P_ResrcReq));     
	psRsrcGrnt = hRap->sOpenTimeMallocs.psResrcGrant;
	if ( NULL==psRsrcGrnt )
	{
			return BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
	}
        BKNI_Memset(psRsrcGrnt, 0, sizeof(BRAP_RM_P_ResrcGrant));         
	
    /* Invalid init the resource request */
    BRAP_RM_P_InitResourceReq(psRsrcReq);

    psRsrcReq->ePath = hRapCh->pPath[uiPth]->eUsgPath;

    /* Copy internal capPort resource request from the earlier path */
    uiInPth = hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx;

    if((BRAP_INVALID_VALUE != uiInPth) && (NULL != hRapCh->pPath[uiInPth]))
    {
        /* Copy the internal CapPort request */
        for(eChP=0; eChP<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
        {
            for(i=0;i<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH;i++)
            {
                if((hRapCh->pPath[uiInPth]->sOutPathProp[i].uiPathIdx == uiPth)&&
                   (BRAP_CapInputPort_eMax != 
                    hRapCh->pPath[uiInPth]->sRsrcGrnt.sCapPortGrnt[eChP][i].eCapPort))
                {
                    psRsrcReq->sCapReq[eChP][0].bAllocate = true;
                    psRsrcReq->sCapReq[eChP][0].eCapPort = 
                        hRapCh->pPath[uiInPth]->sRsrcGrnt.sCapPortGrnt[eChP][i].eCapPort;
                }
            }
        }
    }
    }

    eChType = hRapCh->eChannelType;        
    if(false == bWdgRecovery) 
    {
        if((BRAP_ChannelType_eDecode == eChType)||
           (BRAP_ChannelType_ePcmPlayback == eChType))
        {
            /* In case of external SPDIF/HDMI In we require 1 Destination channel and 2 Ring buffers 
            The SPDIF/HDMI might require 1 or 2 buffers depending on the input which can change on the
            fly and so we allocate 2 ring buffers as we will not be able to allocate later */

            if ( ((BRAP_CapInputPort_eSpdif == hRapCh->eCapInputPort) ||
                 (BRAP_CapInputPort_eHdmi == hRapCh->eCapInputPort) ||
                 (BRAP_CapInputPort_eRfAudio == hRapCh->eCapInputPort) ||
                 (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort) ||                 
                 (BRAP_CapInputPort_eExtI2s0 == hRapCh->eCapInputPort))&&
                 (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource)&&
                 (0 == uiPth)
               )
            {
    		    /* Rbuf */
    			psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eCaptureLR].bAllocate = true;
                psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eCaptureLR].eBufDataMode = BRAP_BufDataMode_eStereoNoninterleaved;
                /* DstCh */
                psRsrcReq->sDstChReq[BRAP_OutputChannelPair_eCaptureLR].bAllocate = true;
                /* Allocate the External Capture port */
                if((BRAP_CapInputPort_eRfAudio == hRapCh->eCapInputPort) ||
                   (BRAP_CapInputPort_eSpdif == hRapCh->eCapInputPort) ||  
                   (BRAP_CapInputPort_eHdmi == hRapCh->eCapInputPort) ||                     
                   (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort) ||
                   (BRAP_CapInputPort_eExtI2s0 == hRapCh->eCapInputPort))
                {
                        psRsrcReq->sCapReq[BRAP_OutputChannelPair_eCaptureLR][0].bAllocate = true;
                        psRsrcReq->sCapReq[BRAP_OutputChannelPair_eCaptureLR][0].eCapPort = 
                                                            pAudioParams->eCapInputPort;
                }
            }
            /* For the case of Ringbuffer as audio source only ringbuffers need to be allocated. 
               Application will directly write the data into these buffers */
            else if((BRAP_AudioSource_eRingBuffer == hRapCh->eAudioSource) &&
                    (0 == uiPth))
            {
    		    /* Rbuf */
    			psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eCaptureLR].bAllocate = true;
                psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eCaptureLR].eBufDataMode = BRAP_BufDataMode_eStereoNoninterleaved;
            }
            /* This is a temporary fix for SPDIF/HDMI In bringup for 3563. 
            Needs to be fixed properly later for a case like transcode of captured
            SPDIF data */
            else 
            {
                /* Check if Rbuf and DstCh already allocated at Add_destination time */
                for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
                {
                    if(NULL == hRapCh->pDstDetails[i])
                    {
                        continue;
                    }

                    if((BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst) &&
                       (hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.uiRBufId[0] != BRAP_INVALID_VALUE))
                    {
                        bRbuAllocated = true;                    
                        break;
                    }
                    else
                    {
                        bRbuAllocated = false;
                    }
                }
    		    BDBG_MSG(("bRbuAllocated > %d", bRbuAllocated));
                if(bRbuAllocated == false)
                {                     
                    /* Prepare resource request for rbuf and dstch */
                    for(i = 0; i < BRAP_RM_P_MAX_INTERNAL_DST; i++)
                    {
                        if(hRapCh->sIntDst[i].eInputAudMode < BRAP_OutputMode_eLast)
                        {
                            ret = BRAP_P_GetAudOpModeProp(hRapCh->sIntDst[i].eInputAudMode, 
                                                           hRapCh->sIntDst[i].bLfeOn, 
                                                           &sOpAudModeProp);
                    		if(BERR_SUCCESS != ret)
                    		{
                    			BDBG_ERR(("BRAP_P_GetAudOpModeProp failed with err = %d", ret));
                    			ret = BERR_TRACE(ret);
                                goto exit;
                    		}

                            /* Resource request for Rbufs and SrcChs */
                            for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                        	{
                    			/* For the input audio mode, this audio channel exists, 
                    			   so RBuf is required to be allocated */
                        		if(sOpAudModeProp.bChnExists[eChP*2] == true)
                        		{
                        		    /* Rbuf */
                        			psRsrcReq->sRbufReq[eChP].bAllocate = true;
                                    psRsrcReq->sRbufReq[eChP].eBufDataMode = 
                                        BRAP_BufDataMode_eStereoNoninterleaved;
                                    /* DstCh */
                                    psRsrcReq->sDstChReq[eChP].bAllocate = true;
                      		    }
                            }
                        }
                    }
                }
            }
        }
#if (BRAP_7550_FAMILY != 1)        
        else if(BRAP_ChannelType_ePcmCapture == eChType)
        {
            if(false == hRap->bInPortSettingValid[pAudioParams->eCapInputPort])
            {
                BDBG_ERR((" BRAP_P_OpenCapPath:Capture Input not configured ."
                          " Before starting configure it"));
                ret = BERR_TRACE(BRAP_ERR_DEVICE_UNINTIALIZED);
		        goto exit;
            }
            
            /* Check the Cpture Mode */
            if(BRAP_CaptureMode_eCaptureOnly == pAudioParams->eCapMode)
            {
                /*Rbuf and DstCh should have been allocated at Add destination */
                /* Check for them */
                for(i=0 ; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
                {
                    if(NULL == hRapCh->pDstDetails[i])
                    {
                        continue;
                    }

                    if((BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst) &&
                       (hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.uiRBufId[0] != BRAP_INVALID_VALUE))
                    {
                        bRbuAllocated = true;                    
                        break;
                    }
                    else
                    {
                        bRbuAllocated = false;
                    }
                }
                if(bRbuAllocated == false)
                {
                    BDBG_ERR(("BRAP_P_OpenCapPath: Please Add RBUF as destination"
                              " before starting Capture channel in Cap_only mode"));
                    ret = BERR_TRACE(BERR_NOT_INITIALIZED);
		            goto exit;
                }
                /* Allocate the External Capture port */
                psRsrcReq->sCapReq[BRAP_OutputChannelPair_eLR][0].bAllocate = true;
                psRsrcReq->sCapReq[BRAP_OutputChannelPair_eLR][0].eCapPort = 
                                                    pAudioParams->eCapInputPort;
            }
            else if (BRAP_CaptureMode_eFullDuplex == pAudioParams->eCapMode)
            {
                /* Check if Rbuf has been allocated,If not prepare the request */
                for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
                {
                    if(NULL == hRapCh->pDstDetails[i])
                    {
                        continue;
                    }

                    if((BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst) &&
                       (hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.uiRBufId[0] != BRAP_INVALID_VALUE))
                    {
                        bRbuAllocated = true;                    
                        break;
                    }
                    else
                    {
                        bRbuAllocated = false;
                    }
                }
                if ((false == bRbuAllocated) || (0 == uiPth) )
                {
                    /* Rbuf Request */
                    psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eLR].bAllocate = true;
                    psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eLR].eBufDataMode=
                        hRap->sInputSettings[pAudioParams->eCapInputPort].eBufDataMode;

                    /* DSTCH request */
                    psRsrcReq->sDstChReq[BRAP_OutputChannelPair_eLR].bAllocate = true;

                    /* Only for 0th path we have external capture possible */
                    /* Add request for External Port */
                    psRsrcReq->sCapReq[BRAP_OutputChannelPair_eLR][0].bAllocate = true;
                    psRsrcReq->sCapReq[BRAP_OutputChannelPair_eLR][0].eCapPort = 
                                                        pAudioParams->eCapInputPort;
                    
                    bRbuAllocated = false;

                }
#if (BRAP_3548_FAMILY == 1)
                if ( (BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource) &&
                     (BRAP_CapInputPort_eAdc == pAudioParams->eCapInputPort) &&
                     (0 == uiPth)
                   )
                {
                    /* 
                        Add request for internal capture Port and an SRC in this capture path 
                        This is a requirment in ADC that the input first go through the SRC for
                        downsampling and then be routed to Dstch Buffers (otherwise DRAM/DSP cannot
                        handle it)
                    */
                    psRsrcReq->sCapReq[BRAP_OutputChannelPair_eLR][1].bAllocate = true;
                    psRsrcReq->sCapReq[BRAP_OutputChannelPair_eLR][1].eCapPort = BRAP_CapInputPort_eMax;

                    psRsrcReq->sSrcMixerReq[0].sSrcReq[0][0][0].bAllocate = true;
                    psRsrcReq->sSrcMixerReq[0].sSrcReq[0][0][0].sReallocateSrc.uiSrcBlkId = BRAP_RM_P_INVALID_INDEX;
                    psRsrcReq->sSrcMixerReq[0].sSrcReq[0][0][0].sReallocateSrc.uiSrcId = BRAP_RM_P_INVALID_INDEX;                
                }
#endif                            
            }
        }
#endif

        /* Allocate the Resources */
        ret = BRAP_RM_P_AllocateResources(hRap->hRm, psRsrcReq, psRsrcGrnt);
		if(BERR_SUCCESS != ret)
		{
			BDBG_ERR(("BRAP_P_OpenCapPath: Resource alloc failed with err = %d",
                ret));
			ret = BERR_TRACE(ret);
            goto exit;
		}

        /* Open all internal module handles */
        ret = BRAP_P_OpenFmmModuleHandles(hRapCh,pAudioParams, uiPth, psRsrcGrnt);
		if(BERR_SUCCESS != ret)
		{
			BDBG_ERR(("BRAP_P_OpenCapPath: BRAP_P_OpenFmmModuleHandles"
               " failed %d", ret));
			ret = BERR_TRACE(ret); 
            goto free_rsrc;
		}

        /* Consider already allocated FMM modules */
    	if(true == bRbuAllocated)
    	{
    		for(j=0; j < BRAP_P_MAX_DST_PER_RAPCH; j++)
    		{
    			if( hRapCh->pDstDetails[j] != NULL &&
                    hRapCh->pDstDetails[j]->eAudioDst == BRAP_AudioDst_eRingBuffer )
    			{
                     ret = BRAP_P_GetAudOpModeProp(hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.eAudioMode, 
                                                   hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.bLfeOn, 
                                                   &sOpAudModeProp);
                     
                    for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                	{
                		if(sOpAudModeProp.bChnExists[eChP*2] == true)
                		{
                		    /* Find valid Rbuf Id and store the Rbuf handle */
                            if( BRAP_INVALID_VALUE != 
                                hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.uiRBufId[eChP*2])
                            {
            			 	    psRsrcGrnt->uiRbufId[eChP*2] = 
                                 hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.uiRBufId[eChP*2];
                				hRapCh->pPath[uiPth]->hRBuf[eChP*2] = 
                                    hRap->hFmm[0]->hRBuf[psRsrcGrnt->uiRbufId[eChP*2]];                                
                            }
                            if( BRAP_INVALID_VALUE != 
                                hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.uiRBufId[eChP*2+1])
                            {
            			 	    psRsrcGrnt->uiRbufId[eChP*2+1] = 
                                 hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.uiRBufId[eChP*2+1];
                                hRapCh->pPath[uiPth]->hRBuf[eChP*2+1] = 
                                    hRap->hFmm[0]->hRBuf[psRsrcGrnt->uiRbufId[eChP*2+1]];
                            }

                		    /* Find valid DstCh Id and store the DstCh handle */
                            if(BRAP_INVALID_VALUE != 
                                hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.uiDstChId[eChP])
                            {
                			 	psRsrcGrnt->uiDstChId[eChP] = 
                                 hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.uiDstChId[eChP];
                				hRapCh->pPath[uiPth]->sDstCh[eChP].hDstCh = 
                                    hRap->hFmm[0]->hDstCh[psRsrcGrnt->uiDstChId[eChP]];
                            }
                        }
                    }
    			}
    		}
    	}

        /* Update the resource grant structure in hRapCh */
        ret = BRAP_RM_P_UpdateResrcGrant(&(hRapCh->pPath[uiPth]->sRsrcGrnt), 
                                         psRsrcGrnt);
		if(BERR_SUCCESS != ret)
		{
			BDBG_ERR(("BRAP_P_OpenCapPath: UpdateResrcGrant failed %d", ret));
			ret = BERR_TRACE(ret); 
            goto free_rsrc;
		}
        /* Update the resource grant structure in hRapCh for Rbuf and DstCh 
           added at Add_destination time */
            /* TODO*/

        /* Prepare linkage info among the resources in the same path */
        ret = BRAP_P_LinkFmmModuleHandles(hRapCh, uiPth);
		if(BERR_SUCCESS != ret)
		{
			BDBG_ERR(("BRAP_P_OpenCapPath: BRAP_P_LinkFmmModuleHandles"
               " failed %d", ret));
			ret = BERR_TRACE(ret); 
            goto free_rsrc;
		}        
    }
    else /* Watchdog */
    {
        /* Open all internal module handles */
        ret = BRAP_P_OpenFmmModuleHandles(hRapCh,pAudioParams, uiPth, 
                &(hRapCh->pPath[uiPth]->sRsrcGrnt));
		if(BERR_SUCCESS != ret)
		{
			BDBG_ERR(("BRAP_P_OpenCapPath: BRAP_P_OpenFmmModuleHandles"
               " failed %d", ret));
			ret = BERR_TRACE(ret); 
            goto free_rsrc;
		}
    }

#if BRAP_P_WATERMARK_WORKAROUND==1
    for(i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
    if((pAudioParams->eCapMode == BRAP_CaptureMode_eCaptureOnly) ||
           ((hRapCh->pPath[uiPth]->pDstDetails[i] != NULL) && 
            (hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst == BRAP_AudioDst_eRingBuffer))
            ) 
    {

        BTMR_GetDefaultTimerSettings(&sTimerSettings);
        sTimerSettings.type = BTMR_Type_eCountDown;
        sTimerSettings.cb_isr = (BTMR_CallbackFunc) BRAP_P_FmmDstRbufFullWaterMark_isr;
        sTimerSettings.pParm1 = hRapCh;
        sTimerSettings.parm2 = 0;
        sTimerSettings.exclusive = false;

#ifdef AUTOTRAP
        ret = BTMR_CreateTimer (hRap->hTmr, &hRapCh->hTimer1, &sTimerSettings);
#else
        ret = BTMR_CreateTimer (hRap->hTmr, &hRapCh->hTimer, &sTimerSettings);
#endif /* AUTOTRAP */
        if ( ret != BERR_SUCCESS )
        {
    		BDBG_ERR(("BRAP_P_OpenCapPath: Create Timer Failed"));
    		ret = BERR_TRACE(ret);
    		goto free_rsrc;
        }
            break;
        }        
    }        
#endif

    if((BERR_SUCCESS == ret) && (false == bWdgRecovery))
    {
        /* Increment the open count */
        hRapCh->pPath[uiPth]->uiPthOpenCnt++;

        BDBG_MSG(("BRAP_P_OpenCapPath: hRapCh->pPath[uiPth=%d]->uiPthOpenCnt = %d",
            uiPth, hRapCh->pPath[uiPth]->uiPthOpenCnt));
        
        /* Exit successfully */
        goto exit;
    }
    
    if(BERR_SUCCESS == ret)
    {
        /* Exit successfully */
        goto exit;
    }
    
free_rsrc:
    /* Free resources */    
    BRAP_RM_P_FreeResources(hRap->hRm, psRsrcGrnt,true);
    if(BERR_SUCCESS != ret)
	{
		BDBG_ERR(("Free Resource failed with err = %d",ret));
		ret = BERR_TRACE(ret);
	}

exit:
	
    BDBG_LEAVE(BRAP_P_OpenCapPath);    
    return ret;
}

/**************************************************************************
Summary:
    Private function that closes a capture path.
**************************************************************************/
BERR_Code 
BRAP_P_CloseCapPath(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
    const unsigned int          uiPth       	/* [in] Path idx corresponding 
                                                   to pPath[] array element */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_P_OpAudModProp     sOpAudModeProp;
    BRAP_OutputChannelPair  eChP = BRAP_OutputChannelPair_eMax;
    unsigned int            i = 0;
   
    BDBG_ENTER(BRAP_P_CloseCapPath); 
    BDBG_MSG(("BRAP_P_CloseCapPath CALLED!!!"));
    BDBG_ASSERT(hRapCh->pPath[uiPth]);

    /* Error state check */
    if (0 == hRapCh->pPath[uiPth]->uiPthOpenCnt)
    { 
        /* This should never happen. If it does, it means the system
           has gone into an invalid state!!!!*/
        BDBG_ERR (("BRAP_P_CloseCapPath: SM Path open count is already 0"));
        return BERR_TRACE (BERR_NOT_SUPPORTED);
    }

    /* Decrement the open count */
    hRapCh->pPath[uiPth]->uiPthOpenCnt--;

    BDBG_MSG(("BRAP_P_CloseCapPath: For uiPth=%d New uiPthOpenCnt = %d", 
        uiPth, hRapCh->pPath[uiPth]->uiPthOpenCnt));

    /* If the new open count is not 0, do not close the resources instead 
       return success */
    if(0 != hRapCh->pPath[uiPth]->uiPthOpenCnt)
    {
        BDBG_MSG(("BRAP_P_CloseCapPath: uiPthOpenCnt = %d so not closing resources!"));
        BDBG_LEAVE(BRAP_P_CloseCapPath);
        return BERR_SUCCESS;
    }


#if (BRAP_P_WATERMARK_WORKAROUND==1)
    /* Destroy the timer */
    for(i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
#ifdef AUTOTRAP
        if ((NULL != hRapCh->hTimer1) &&
            ((hRapCh->pPath[uiPth]->pDstDetails[i] != NULL) && 
             (hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst 
              == BRAP_AudioDst_eRingBuffer)))
        {
            ret = BTMR_DestroyTimer(hRapCh->hTimer1);
            if (ret != BERR_SUCCESS)
            {
                BDBG_ERR (("BRAP_P_CloseCapPath: BTMR_DestroyTimer Failed"));
                ret = BERR_TRACE(ret);
            }
            hRapCh->hTimer1 = NULL;
        }
#else
        if ((NULL != hRapCh->hTimer) &&
            ((hRapCh->pPath[uiPth]->pDstDetails[i] != NULL) && 
             (hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst 
              == BRAP_AudioDst_eRingBuffer)))
        {
            ret = BTMR_DestroyTimer(hRapCh->hTimer);
            if (ret != BERR_SUCCESS)
            {
                BDBG_ERR (("BRAP_P_CloseCapPath: BTMR_DestroyTimer Failed"));
                ret = BERR_TRACE(ret);
            }
            hRapCh->hTimer = NULL;
        }
#endif /* AUTOTRAP */
    }
#endif

    /* Unlink FMM modules */
    ret = BRAP_P_UnlinkFmmModuleHandles(hRapCh, uiPth);
	if(BERR_SUCCESS != ret)
	{
		BDBG_ERR(("BRAP_P_CloseCapPath: UnlinkFmmModuleHandles failed %d", ret));
		ret = BERR_TRACE(ret); 
	}

    /* Close all internal module handles */
    ret = BRAP_P_CloseFmmModuleHandles(hRapCh, uiPth);
	if(BERR_SUCCESS != ret)
	{
		BDBG_ERR(("BRAP_P_CloseCapPath: CloseFmmModuleHandles failed %d", ret));
		ret = BERR_TRACE(ret); 
	}

	for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
	{
        if(NULL == hRapCh->pDstDetails[i])
        {
            continue;
        }
	
		if(BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst)
		{
             ret = BRAP_P_GetAudOpModeProp(hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.eAudioMode, 
                                           hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.bLfeOn, 
                                           &sOpAudModeProp);
            for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
        	{
        		if(sOpAudModeProp.bChnExists[eChP*2] == true)
        		{
        		    /* 
        		        This is required so that the Ring Buffers and Destination Channels that are allocated at runtime
        		        is not freed by Resource Manager.
                    */
                    
        		    /* Rbuf */
                    if (hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.uiRBufId[eChP*2] == hRapCh->pPath[uiPth]->sRsrcGrnt.uiRbufId[eChP*2])
    			 	    hRapCh->pPath[uiPth]->sRsrcGrnt.uiRbufId[eChP*2] = BRAP_RM_P_INVALID_INDEX;
                    if (hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.uiRBufId[eChP*2+1] == hRapCh->pPath[uiPth]->sRsrcGrnt.uiRbufId[eChP*2+1])
    			 	    hRapCh->pPath[uiPth]->sRsrcGrnt.uiRbufId[eChP*2+1] = BRAP_RM_P_INVALID_INDEX;
                    /* DstCh */
                    if (hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.uiDstChId[eChP] == hRapCh->pPath[uiPth]->sRsrcGrnt.uiDstChId[eChP])
    			 	    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDstChId[eChP] = BRAP_RM_P_INVALID_INDEX;
                }
            }
		}
	}
    

    /* Free all resources allocated during OpenDecPath() */
    ret = BRAP_RM_P_FreeResources(hRapCh->hRap->hRm, &(hRapCh->pPath[uiPth]->sRsrcGrnt),true);
	if(BERR_SUCCESS != ret)
	{
		BDBG_ERR(("BRAP_P_CloseCapPath: Resource free failed err = %d",ret));
		ret = BERR_TRACE(ret);
	}

    /* Reset the resource grant structure for this path */
    BRAP_RM_P_InitResourceGrant(&(hRapCh->pPath[uiPth]->sRsrcGrnt),true);

    BDBG_LEAVE(BRAP_P_CloseCapPath);    
    return ret;
}


/***************************************************************************
Summary:
    Private function that checks if a stream type is supported or not.
****************************************************************************/
BERR_Code 
BRAP_P_IsStreamTypeSupported(
    BAVC_StreamType     eStreamType
    )
{
    BERR_Code ret = BERR_SUCCESS;
    
	/* Check Transport Stream type: 
       NOTE: This  list should be constantly updated to refelct current status
       for each platform */
    switch(eStreamType)
    {
        /* Break with success for supported stream types */
        case BAVC_StreamType_eMpeg1System:
        case BAVC_StreamType_eTsMpeg:
        case BAVC_StreamType_eDssEs:
        case BAVC_StreamType_eDssPes:
        case BAVC_StreamType_ePS:
        case BAVC_StreamType_ePes:
        case BAVC_StreamType_eEs:
         break;
        case BAVC_StreamType_eBes:
        case BAVC_StreamType_eCms:
        default:
            BDBG_ERR(("BRAP_DEC_Start: Stream type %d not supported",
                eStreamType));
            return BERR_TRACE(BERR_NOT_SUPPORTED);
    }
    return ret;
}

/***************************************************************************
Summary:
    Private function that identifies and prepares the various usage paths 
    required for this channel.

    This function should also populate the inlink, outlink, self link
    for all the paths required in this channel.

    TODO: Keep updating this algorithm. Refer 7440_fmm_usage.doc for preparing
    this decision matrix.
    
    ALGORITHM: 
    1. Identify which all paths are required
    * DEC PATH: 
        (DecDSP0)->Rbuf to OP/CAP
        DEC or PB channels
        These output ports do not carry 
        a) transcoded/encoded data
        b) watermark detection
        c) speaker mngt (valid only for OP carrying multichannel PCM) 
         
    * TRANS PATH:
        Compressed 
        Shared Rbuf to Capture port
        DEC and PB channels    
            
    * CAP PATH:
        Capture port to Rbuf or OutputPort
        DEC or PB or CAP channels
        delay balance, VWM detection, transcoding
            
    * ENC PATH:
        ENC, DEC, PB
        Encoding/Transcoding enabled
        
    * SM PATH:
        DEC, PB
        SM enabled

    2. Update the pPath[] in hRapCh.        
**************************************************************************/
BERR_Code BRAP_P_GetPathIndex(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed */	
        unsigned int                    uiBranchId,     /* [in] path number */
        unsigned int                    uiCloneOp,      /* [in] Number of clone OP without any path */
        unsigned int                    *uipPthIndex     /* [out] Give the path index*/
)
{
    unsigned int j=0;
    BERR_Code   ret=BERR_SUCCESS;
    /*Find Path which is having cloned port */
    if(0 == uiBranchId )
    {
        for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
        {
            if((hRapCh->pPath[j] != NULL) &&
               ((hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)||
                (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodeCompress)))
            {
                *uipPthIndex= j;
            }
        }
        if(j == BRAP_P_MAX_PATHS_IN_A_CHAN)
            ret = BERR_INVALID_PARAMETER;
    }
    else
    {
        if (((BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource)&&
            ((BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)||
             (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort)||
             (BRAP_CapInputPort_eAdc == pAudioParams->eCapInputPort)||                 
              (BRAP_CapInputPort_eExtI2s0 == pAudioParams->eCapInputPort))) ||
            (BRAP_AudioSource_eRingBuffer == pAudioParams->eAudioSource))
        {
            /*One capture path and one decpcm or decComp path */
            *uipPthIndex = uiBranchId+1-uiCloneOp;
        }
        else
        {
            /*Either one decpcm or deccmp path*/
            *uipPthIndex= uiBranchId-uiCloneOp;
        }
    }
    return ret;
}

BERR_Code
BRAP_P_GetInputPathIndexForAssociation(
            BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
            unsigned int                uiAssociationId,
            unsigned int                *uipPthIndex     /* [out] Give the path index*/	
	)
{
    BERR_Code   ret=BERR_SUCCESS;
    unsigned int i = 0;

    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(uipPthIndex);    
    
    for(i = 0 ; i< BRAP_P_MAX_PATHS_IN_A_CHAN; i++)
    {
        if(hRapCh->pPath[i] == NULL)
            continue;
        if(hRapCh->pPath[i]->uiAssocId == uiAssociationId)
        {
           *uipPthIndex = i;
            break;
        }
    }

    if(i >=BRAP_P_MAX_PATHS_IN_A_CHAN)
    {
        BDBG_ERR(("ERROR!!! No path feeding to Association %d ",uiAssociationId));
        ret = BERR_INVALID_PARAMETER;
    }

    return ret;
}

BRAP_ChannelHandle
BRAP_P_GetRapChHandle(
        BRAP_AssociatedChannelHandle    hAssociatedCh   /* [in] Association handle */
        )
{
    unsigned int        i=0;
    BRAP_ChannelHandle  hRapCh;  
    
    BDBG_ENTER(BRAP_P_GetRapChHandle);
    BDBG_ASSERT(hAssociatedCh);

    for(i=0;i<BRAP_MAX_PRI_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
    {
        hRapCh = hAssociatedCh->hPriDecCh[i];
        if(BRAP_P_IsPointerValid((void *)hRapCh))
        {
            return hRapCh;
        }
    }
    for(i=0;i<BRAP_MAX_SEC_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
    {
        hRapCh = hAssociatedCh->hSecDecCh[i];
        if(BRAP_P_IsPointerValid((void *)hRapCh))
        {
            return hRapCh;
        }
    }
    for(i=0;i<BRAP_MAX_PB_CHAN_IN_ASSOCIATED_GRP;i++)
    {
        hRapCh = hAssociatedCh->hPBCh[i];
        if(BRAP_P_IsPointerValid((void *)hRapCh))
        {
            return hRapCh;
        }
    }
    for(i=0;i<BRAP_MAX_CAP_CHAN_IN_ASSOCIATED_GRP;i++)
    {
        hRapCh = hAssociatedCh->hCapCh[i];
        if(BRAP_P_IsPointerValid((void *)hRapCh))
        {
            return hRapCh;
        }
    }  
        
    BDBG_LEAVE(BRAP_P_GetRapChHandle);
    return NULL;    
}

BERR_Code
    BRAP_P_FormPostMixingPathsForSubsequentDestinations(
        unsigned int                uiDstnIndex,    /* [in] Destination index in RapCh */
        unsigned int                uiPth,          /* [in] Index to form the Path from */
        unsigned int                uiAssocId,      /* [in]*/
    	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */        
        BRAP_ChannelHandle              hRapCh      /* [in] RAP Channel handle */
        )
{
    BERR_Code       ret = BERR_SUCCESS;
    bool    bCompress=false,bIndepPathRequire=false,bDownmixPathRequire=false;
    bool    bBranchCloned=false, flag=false, bMixPathRequire=false;
    bool    bPrimary[BRAP_MAX_ASSOCIATED_GROUPS];
    unsigned int uiClonedBranch=BRAP_INVALID_VALUE, m=0, uiLastStage=0, j=0, k=0, l=0, n=0; 
    unsigned int ui32MasterBranchId=0, ui32MasterStageId=0, uiCloneAssocId=0, uiDestCount=0;
    unsigned int uiCloneBranchId[BRAP_P_MAX_DST_PER_RAPCH], uiCloneOp=0;
    BRAP_P_DstDetails       *pPvtDstDetails = NULL;
    BRAP_ProcessingType     eAudioProcessing = BRAP_ProcessingType_eNone;    
    BRAP_ChannelHandle      hStartedRapCh[BRAP_MAX_ASSOCIATED_GROUPS];    
    #if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1) 
    BRAP_P_UsgPath         ePathType = BRAP_P_UsgPath_eMax;  
    #endif    

    BDBG_ASSERT(hRapCh);
    BDBG_ENTER(BRAP_P_FormPostMixingPathsForSubsequentDestinations);

    for(j=0; j<BRAP_MAX_ASSOCIATED_GROUPS; j++)
    {
        hStartedRapCh[j]=NULL;
    }
    
    /* Malloc large structures */
    pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
    if ( NULL==pPvtDstDetails )
    {
        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        goto end;                
    }
    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));     

    /* Get the started channel (if any) from the association 
    We are not using bPrimary */
    ret = BRAP_P_GetStartedChannel(hRapCh, bPrimary, hStartedRapCh);
    if(BERR_SUCCESS != ret)
    {
        ret = BERR_TRACE(ret);
        goto end;        
    }
    
    for(uiDstnIndex=uiDstnIndex+1; uiDstnIndex<BRAP_P_MAX_DST_PER_RAPCH; ++uiDstnIndex)
    {
        if(BRAP_P_BRANCH_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage, uiDstnIndex))
        {   
            bCompress = false;                        
            BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));                    
            ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                            hRapCh->pDstDetails[uiDstnIndex],
                                            pPvtDstDetails,
                                            &m);
            if(BERR_SUCCESS!=ret)
            {
                ret = BERR_TRACE(ret);
                goto end;
            }
            if(!(BRAP_P_IsAssociationNWValid(pPvtDstDetails)))
                continue;
            
            if(m != uiAssocId)
            {
                BDBG_ERR(("Muliple Association Networks not supported per channel"));
                ret = BERR_NOT_SUPPORTED;
                goto end;                            
            }

            for(m =0; m < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; m++)
            {
                if(NULL == pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m])
                    break;

                eAudioProcessing = pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m]->sProcessingStageSettings.eAudioProcessing;

                BDBG_MSG(("pPvtDstDetails->eAudProcessing[j] = %d",eAudioProcessing));
                    if((BRAP_ProcessingType_eConvertDdpToAc3  == eAudioProcessing)
                    ||(BRAP_ProcessingType_eWmaProPassThru == eAudioProcessing)                                                                      
                    ||(BRAP_ProcessingType_eEncodeDts== eAudioProcessing)
                    ||(BRAP_ProcessingType_eEncodeAc3==eAudioProcessing)
                    ||(BRAP_ProcessingType_eGenericPassthru==eAudioProcessing)
                    ||(BRAP_ProcessingType_eEncodeMp3==eAudioProcessing)
                    ||(BRAP_ProcessingType_ePassthru==eAudioProcessing))
                {
                    bCompress = true;
                }
            }
            if(m>0)
            {
                uiLastStage = m -1;
            }
            else
            {
                uiLastStage = BRAP_INVALID_VALUE;
                BDBG_ERR(("Network must have one valid stage"));
                ret = BERR_TRACE(BERR_INVALID_PARAMETER);
                goto end;                            
            }

            if(NULL == hStartedRapCh[uiAssocId])
            {
                bIndepPathRequire = false;      
                bDownmixPathRequire = false;                
                bBranchCloned = flag = bMixPathRequire = false;
                uiClonedBranch = BRAP_INVALID_VALUE;                            
                for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
                {
                    uiCloneBranchId[k] = BRAP_INVALID_VALUE;
                }
                for(j = 0; j < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; j++)
                {
                    if(!(BRAP_P_STAGE_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage,uiDstnIndex,j)))  
                        break;
                }
                if((true == hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][j-1].bCloneStage)) 
                {
                    flag = true;
                }

                /*If its Mai and Muxselector is not Mai, then dont create path for it */
                if( (!((hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                        &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eMai)
                        &&(hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiSettings.eMaiMuxSelector != BRAP_OutputPort_eMai)))
                    ||(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) )
                {                
                    if(flag == false)
                    {
                        bBranchCloned = false;
                    }
                    else
                    {
                        ui32MasterBranchId = k= hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].ui32MasterBranchId;
                        ui32MasterStageId = l= hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].ui32MasterStageId;
                        m=0;
                        /* Check if the current branch is a clone of complete master branch */
                        if(!(BRAP_P_STAGE_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage,k,l+1)))           
                        {
                            bBranchCloned = true;
                            uiCloneBranchId[m]=k;
                            m++;
                            k++;
                        }

                        /* Now check if the branches between Current and Master branch are similar to current branch.
                        This is done by checking if the last stage is cloned, and its Master stage/branch id 
                        is same as that of last stage id of current branch. Just to make clear, here 
                        Current Branch/Stage Id is : uiDstnIndex/uiLastStage
                        Master Branch/Stage Id is : ui32MasterBranchId/ui32MasterStageId
                        And we looping on K, which is between ui32MasterBranchId and uiDstnIndex */
                        for(; k<uiDstnIndex; ++k)
                        {
                            if(!(BRAP_P_STAGE_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage,k,l+1)))
                            {   
                                if((true == hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][l].bCloneStage)
                                    &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][l].ui32MasterBranchId == ui32MasterBranchId)
                                    &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][l].ui32MasterStageId == ui32MasterStageId))
                                {
                                    bBranchCloned = true;
                                    uiCloneBranchId[m]=k;
                                    m++;
                                } 
                            }
                        }

                        /* Now if there  are branches which are cloned to current then, Are they in same
                        association? If no then Create a Mix Path corresponding to them , if not created 
                        already.*/
                        if(bBranchCloned == true)
                        {                        
                            if(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                            {                    
                                for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                                {
                                    if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                        break;
                                    
                                    k = uiCloneBranchId[m];
                                    /* For cloned branch */
                                    
                                    if((hRapCh->eChannelOutputMode == BRAP_OutputMode_e2_0)
                                        ||(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == 
                                        hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort))
                                    {
                                        bDownmixPathRequire = false;
                                        uiClonedBranch = k;
                                        break;
                                    }
                                    else if (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0)
                                    {
                                        bDownmixPathRequire = true;
                                    }
                                }
                            }

#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)                                  
                            if((false == bDownmixPathRequire))
                            {
                                for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                                {
                                    if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                        break;
                                    
                                    k = uiCloneBranchId[m];
                                    /* For cloned branch */
                                    /*If the Destination has Indepdelay Enabled then create similar path to its cloned.*/

                                    if((hRapCh->bIndepDelayEnabled == true)
                                        &&((hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) ||
                                           (hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) ||
                                           (hRapCh->eChannelOutputMode == BRAP_OutputMode_e2_0) ||
                                           (hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == 
                                               hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort))
                                      )
                                    {
                                        bIndepPathRequire = true;
                                        uiClonedBranch = k;                                                                                
                                        break;
                                    }
                                    else
                                    {
                                        bIndepPathRequire = false;
                                        uiClonedBranch = k;                                            
                                    }
                                }
                            }
#endif                        
                            if((false == bIndepPathRequire)&&(false == bDownmixPathRequire))
                            {
                                for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                                {
                                    if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                        break;
                                    
                                    k = uiCloneBranchId[m];
                                    /* For cloned branch */
                                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                    &(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails),
                                                                    pPvtDstDetails,
                                                                    &uiCloneAssocId);
                                    if(BERR_SUCCESS!=ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto end;                
                                    }
                                    /* For this branch */
                                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                    &(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails),
                                                                    pPvtDstDetails,
                                                                    &uiAssocId);
                                    if(BERR_SUCCESS!=ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto end;                
                                    }
                                    if(uiAssocId == uiCloneAssocId)
                                    {
                                        bMixPathRequire = false;
                                        uiClonedBranch = k;
                                        break;
                                    }
                                    else
                                    {
                                        bMixPathRequire = true;
                                    }
                                }
                            }
                        }
                    } /*if(j == BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED)*/
                }                        
                else
                {
                    bBranchCloned = true;
                    for(k =0; k<uiDstnIndex; ++k)
                    {
                        if((BRAP_P_BRANCH_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage,k)))
                        {   
                            if((hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][0].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                                &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]
                                != BRAP_OutputPort_eMai)
                                &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]
                                == hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiSettings.eMaiMuxSelector))
                            {
                                uiClonedBranch = k;
                                BDBG_MSG(("################Coming here k =%d",k));
                            }
                        }
                    }
                } /*if(bBranchCloned == true)*/
                
                BDBG_MSG(("bBranchCloned=%d uiAssocId=%d uiCloneAssocId=%d",
                bBranchCloned,uiAssocId,uiCloneAssocId));
                
                if(((false == bBranchCloned)&&(BRAP_P_BRANCH_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage,uiDstnIndex)))
                    ||((true == bBranchCloned) && (true == bDownmixPathRequire)))
                {

                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                    ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                    ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;                            
                        }
                    }
                    if( (((hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                          &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == true))
                         ||((hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) 
                            &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sRBufDetails.eAudioMode== BRAP_OutputMode_e2_0)))
                        && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0) )    /* Capture to rbuf is required in stereo mode as of now */
                    {
                    
                        BDBG_MSG(("BRAP_P_UsgPath_eDownmixedPath"));                                        
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                            BRAP_P_UsgPath_eDownmixedPath,
                                            BRAP_INVALID_VALUE, 
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);
                    }
                    else
                    {
                        BDBG_MSG(("BRAP_P_UsgPath_ePPBranch"));
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                            BRAP_P_UsgPath_ePPBranchPostMixing,
                                            BRAP_INVALID_VALUE, 
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);
                    }
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp; 
                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh; 
                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;

                    uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][0].hValidDestHandle->sExtDstDetails);
                    BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));  
                    uiPth++;
                } /*if((false == bBranchCloned)&&*/
                else if ((true == bBranchCloned) && (true == bMixPathRequire))
                {   
                    /*Find the Path which is having cloned port */
                    ret = BRAP_P_GetPathIndex(hRapCh,pAudioParams,k,uiCloneOp,&m);


                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                    ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                    ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;                            
                        }
                    }   
                    if((hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                        &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == true)
                        && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))
                    {
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                            BRAP_P_UsgPath_eDownmixedMixPath,
                                            BRAP_INVALID_VALUE, 
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);
                        BDBG_MSG(("BRAP_P_UsgPath_eDownmixedMixPath uiPth=%d",uiPth));
                    }
                    else
                    {
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                            BRAP_P_UsgPath_eMixPath,
                                            BRAP_INVALID_VALUE, 
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);        
                        BDBG_MSG(("BRAP_P_UsgPath_eMixPath uiPth=%d",uiPth));
                    }
                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                    /*Mark the path which is cloned for this stage as mix*/
                    BDBG_MSG(("Input to mix path uiPth=%d",m));
                    hRapCh->pPath[m]->bMixPath = true;
                    hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = m;
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[m]->sRsrcGrnt.uiDspId;
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[m]->sRsrcGrnt.uiDspContextId;
                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[m]->hDsp; 
                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[m]->hDspCh; 

                    /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                    uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][0].hValidDestHandle->sExtDstDetails);
                    BDBG_MSG(("Adding Output port %d to  Mix PCM Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0]));                      
                    ++uiPth;
                } /*else if ((true == bBranchCloned) &&(uiAssocId != uiCloneAssocId))*/
                else
                {
                    /* If Independent delay is on, then a corresponding path is created for the destination. Otherwise
                    no path is created for this destination. So add this destination to a corresponding existing path.*/
                    uiCloneOp++;
                    flag = false;
                    for(m =0 ; m < uiPth ; m++)
                    {
                        uiDestCount = hRapCh->pPath[m]->uiDestcount;
                        
                        for(n =0 ; n < uiDestCount ; n++)
                        {
                            if(hRapCh->pPath[m]->pDstDetails[n] == 
                                &(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiClonedBranch][0].hValidDestHandle->sExtDstDetails))
                            {
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)          
                                if(bIndepPathRequire == true)
                                {/* Create a Path */
                                
                                    switch(hRapCh->pPath[m]->eUsgPath)
                                    {
                                        case BRAP_P_UsgPath_eDecodePcmPostMixing:
                                        case BRAP_P_UsgPath_eDecodeCompressPostMixing:    
                                        case BRAP_P_UsgPath_ePPBranchPostMixing:
                                        case BRAP_P_UsgPath_eMixPath:
                                            ePathType = BRAP_P_UsgPath_ePPBranchPostMixing;
                                            break;
                                        case BRAP_P_UsgPath_eDownmixedPath:
                                        case BRAP_P_UsgPath_eDownmixedMixPath:                                            
                                            ePathType = BRAP_P_UsgPath_eDownmixedPath;
                                            break;
                                        default:
                                            ePathType = BRAP_P_UsgPath_ePPBranchPostMixing;
                                            break;
                                    }
                                    
                                    if(NULL == hRapCh->pPath[uiPth])
                                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                    ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                    ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                                        
                                        if(BERR_SUCCESS != ret)
                                        {
                                            ret = BERR_TRACE(ret);
                                            goto end;                            
                                        }
                                    }
                                    BDBG_MSG(("BRAP_P_UsgPath = %d",ePathType));
                                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                        ePathType,
                                                        BRAP_INVALID_VALUE, 
                                                        uiPth,
                                                        BRAP_INVALID_VALUE,0);

                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp; 
                                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh; 
                                    hRapCh->pPath[uiPth]->uiMasterpathId = m;
                                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                                    uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][0].hValidDestHandle->sExtDstDetails);
                                    
                                    if(hRapCh->pPath[uiPth]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eOutputPort)
                                    {
                                        BDBG_MSG(("Adding Output port %d to  Path type = %d", 
                                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                      
                                    }
                                    else if(hRapCh->pPath[uiPth]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                                    {
                                        BDBG_MSG(("Adding Capture port %d to  Path type = %d", 
                                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                      
                                    }
                                    uiPth++;                                    
                                }
                                else
#endif                                    
                                {                                        
                                    hRapCh->pPath[m]->pDstDetails[uiDestCount] = &(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails);                                
                                    if(hRapCh->pPath[m]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eOutputPort)
                                    {
                                        BDBG_MSG(("Adding Output port %d to  Path type = %d", 
                                            hRapCh->pPath[m]->pDstDetails[uiDestCount]->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[m]->eUsgPath));
                                    }
                                    else if(hRapCh->pPath[m]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                                    {
                                        BDBG_MSG(("Adding Capture port %d to  Path type = %d", 
                                            hRapCh->pPath[m]->pDstDetails[uiDestCount]->uDstDetails.sRBufDetails.eCapPort[0],hRapCh->pPath[m]->eUsgPath));
                                    }
                                    hRapCh->pPath[m]->uiDestcount++;
                                }
                                flag =true;
                                break;
                            }
                        }
                        if(true == flag)
                            break;
                    }
                }
            }
            else
            {
                for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                {
                    if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                        (NULL == hRapCh->pPath[uiPth])&& 
                        (NULL != hStartedRapCh[uiAssocId]->pPath[j]))
                    {
                        for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
                        {
                            if(hStartedRapCh[uiAssocId]->pPath[j]->pDstDetails[k] == hRapCh->pDstDetails[uiDstnIndex])
                                break;
                        }
                        if(k == BRAP_P_MAX_DST_PER_RAPCH)
                            continue;

                        l = uiPth;
                        /* For Independent delay disabled case no need to form separate 
                           paths unless the data carried to the ports is different */
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)
                        if((hRapCh->bIndepDelayEnabled == false) &&
                           (hStartedRapCh[uiAssocId]->pPath[j] == hRapCh->pPath[uiPth-1]))
                            l = uiPth-1;
#else
                        if(hStartedRapCh[uiAssocId]->pPath[j] == hRapCh->pPath[uiPth-1])
                            l = uiPth-1;
#endif
                        
                        hRapCh->pPath[l] = hStartedRapCh[uiAssocId]->pPath[j];
                        for(k=0; k<BRAP_P_MAX_IN_PARALLEL_FMM_PATH; k++)
                        {
                            if(BRAP_INVALID_VALUE == hRapCh->pPath[l]->sInPathProp[k].uiPathIdx)
                                break;
                        }
                        hRapCh->pPath[l]->sInPathProp[k].uiPathIdx = l-1;
                        hRapCh->pPath[l-1]->sOutPathProp[0].uiPathIdx = l;                                            

                        BDBG_MSG(("Copying path: hRapCh->pPath[l =%d]->eUsgPath =%d, StrtdPathIndex=%d",
                        l, hRapCh->pPath[l]->eUsgPath,j));
                        uiPth=l+1;
                        break;                            
                    }
                } 
#if 0                    
                if(bCompress == true)
                {
                    for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                    {
                        if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                           (hRapCh->pPath[uiPth] == NULL)&&
                           (NULL != hStartedRapCh[uiAssocId]->pPath[j])&& 
                           (hStartedRapCh[uiAssocId]->pPath[j]->uiAssocId == uiAssocId))
                        {
                            bool    bStartedPathFound=false;
                            if(BRAP_P_UsgPath_eDecodeCompressPostMixing == hStartedRapCh[uiAssocId]->pPath[j]->eUsgPath)
                            {
                                bStartedPathFound = true;
                            }
                            else if(BRAP_P_UsgPath_ePPBranchPostMixing == hStartedRapCh[uiAssocId]->pPath[j]->eUsgPath)
                            {
                                bool    bStartedPathOutputCompress=false;
                                BRAP_P_IsPathOutputCompress(hStartedRapCh[uiAssocId],j,&bStartedPathOutputCompress);
                                if(bStartedPathOutputCompress == true)
                                    bStartedPathFound = true;
                            }

                            if(bStartedPathFound == true)
                            {
                                hRapCh->pPath[uiPth] = hStartedRapCh[uiAssocId]->pPath[j];
                                
                                BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                                uiPth, hRapCh->pPath[uiPth]->eUsgPath));                                            
                                uiPth++;                    
                                break;
                            }
                        }
                    }                            
                }
                else
                {
                    for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                    {
                        if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                            (NULL == hRapCh->pPath[uiPth])&& 
                            (NULL != hStartedRapCh[uiAssocId]->pPath[j])&& 
                            ((BRAP_P_UsgPath_ePPBranchPostMixing == hStartedRapCh[uiAssocId]->pPath[j]->eUsgPath)
                            ||(BRAP_P_UsgPath_eDecodePcmPostMixing== hStartedRapCh[uiAssocId]->pPath[j]->eUsgPath))&&
                            (hStartedRapCh[uiAssocId]->pPath[j]->uiAssocId == uiAssocId))
                        {
                            hRapCh->pPath[uiPth] = hStartedRapCh[uiAssocId]->pPath[j];
                            for(k=0; k<BRAP_P_MAX_IN_PARALLEL_FMM_PATH; k++)
                            {
                                if(BRAP_INVALID_VALUE == hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx)
                                    break;
                            }
                            hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx = uiPth-1;
                            hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;                                            

                            BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                            uiPth, hRapCh->pPath[uiPth]->eUsgPath));
                            uiPth++;
                            break;                            
                        }
                    }                            
                }
#endif                
            }
        } /* if(BRAP_P_BRANCH_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage, uiDstnIndex)) */
    } /* for(uiDstnIndex=uiDstnIndex+1; i<BRAP_P_MAX_DST_PER_RAPCH; ++i) */                
end:
    
    return ret;
    BDBG_ENTER(BRAP_P_FormPostMixingPathsForSubsequentDestinations);
}

BERR_Code 
BRAP_P_GetChannelPaths(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */
    unsigned int                *uiNumCapPath   /* [out] True if capture path
                                                   present in channel */
    )
{
    BERR_Code ret = BERR_SUCCESS;
    unsigned int uiPth = 0;
    unsigned int i = 0,uiAssocId=0,k=0,l=0,m=0,uiCloneAssocId=0;
    unsigned int j = 0,n=0,uiCloneOp=0,uiCloneBranchId[BRAP_P_MAX_DST_PER_RAPCH];
    BRAP_ChannelHandle hStartedAssoCh[BRAP_MAX_ASSOCIATED_GROUPS];
    bool bPrimary[BRAP_MAX_ASSOCIATED_GROUPS];
    BRAP_DSPCHN_P_Settings	*pDspChSettings = NULL;
    bool bBranchCloned=false, flag=false, bMixPathRequire=false,bDownmixPathRequire = false;
    BRAP_ProcessingType    eAudioProcessing = BRAP_ProcessingType_eNone;
    BRAP_P_DstDetails       *pPvtDstDetails = NULL;
    bool bCompress = false, bAssociationNWDstnFound = false;
    unsigned int                    ui32MasterBranchId = BRAP_INVALID_VALUE;
    unsigned int                    ui32MasterStageId = BRAP_INVALID_VALUE; 
    unsigned int    uiLastStage = BRAP_INVALID_VALUE;
    unsigned int    uiDestCount = 0;
    BRAP_ProcessingStageHandle  hAudProcessing = NULL;
    BRAP_ProcessingType             eAudProc = BRAP_ProcessingType_eMax;
    unsigned int uiClonedBranch = BRAP_INVALID_VALUE;
#if 0    
    bool bSpdifMaiPresent= false;
    unsigned int uiSpdifMaiPathindex =BRAP_INVALID_VALUE;        
#endif    
    #if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1) 
    BRAP_P_UsgPath         ePathType = BRAP_P_UsgPath_eMax;  
    #endif
    bool                bIndepPathRequire = false;
#if (BRAP_DYNAMIC_PORT_SWITCHING == 1)
    bool                bBranchFoundForDummy = false;
#endif

        
    BDBG_ENTER(BRAP_P_GetChannelPaths);

    if(true == BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap))
    {
        /* Copying  uiNumCapPath from hRapCh */
        *uiNumCapPath = hRapCh->uiNumCapPath;
        BDBG_MSG(("Under Watchdog Recovery - not doing anything"));    
        BDBG_LEAVE(BRAP_P_GetChannelPaths);
        ret = BERR_SUCCESS;
        goto end;
    }
    
    pDspChSettings = ( BRAP_DSPCHN_P_Settings *) BKNI_Malloc( sizeof( BRAP_DSPCHN_P_Settings ));
    if ( NULL==pDspChSettings )
    {
        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        goto end;        
    }            
    BKNI_Memset(pDspChSettings, 0, sizeof(BRAP_DSPCHN_P_Settings));         
    /* Form the DSP Channel Settings */
    ret = BRAP_DSPCHN_P_GetDefaultSettings(pDspChSettings);
    if(BERR_SUCCESS != ret)
    {
        BDBG_ERR(("DSPCHN_P_GetDefaultSettings: returned %d", ret));
        ret = BERR_TRACE(ret); 
        goto end;        
    }         
#ifdef RAP_VIDEOONDSP_SUPPORT
    if(hRapCh->eChannelType == BRAP_ChannelType_eVideoDecode)
    {
        if(NULL == hRapCh->pPath[uiPth])
          {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                    ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                    ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif              
              if(BERR_SUCCESS != ret)
              {
                  ret = BERR_TRACE(ret);
                  goto end;
              }            
          }
          BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                  BRAP_P_UsgPath_eVideoDecode,
                                                  BRAP_INVALID_VALUE,
                                                  uiPth,
                                                  uiPth+1,0);
          hRapCh->pPath[uiPth]->uiAssocId = BRAP_INVALID_VALUE;                
          /* Instantiate the DSP Channel corresponding to the DSP context resource 
          manager has allocated */
          ret = BRAP_DSPCHN_P_Open( &(hRapCh->pPath[uiPth]->hDspCh),
                                    hRapCh,
                                    true,
                                    pDspChSettings);
          if(BERR_SUCCESS != ret)
          {
              BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
              ret = BERR_TRACE(ret);
              goto end;
          }
          return ret;
    }
#endif
    
    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
        {
        hStartedAssoCh[uiAssocId]=NULL;
        bPrimary[uiAssocId]=false;
    }
    
    *uiNumCapPath = 0;
    BDBG_MSG(("*uiNumCapPath > %d", *uiNumCapPath));

    /* Get the started channel (if any) from the association 
    We are not using bPrimary */
    ret = BRAP_P_GetStartedChannel(hRapCh, bPrimary, hStartedAssoCh);
    if(BERR_SUCCESS != ret)
    {
        ret = BERR_TRACE(ret);
        goto end;        
    }

    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
    {
        if(hRapCh->uiAssociationId[uiAssocId] != BRAP_INVALID_VALUE)
        {
            BDBG_MSG(("BRAP_P_GetChannelPaths: hRapCh = 0x%x hStartedAssoCh[uiAssocId=%d] = 0x%x",
                hRapCh,hRapCh->uiAssociationId[uiAssocId],hStartedAssoCh[hRapCh->uiAssociationId[uiAssocId]]));
        }
    }
    
    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
    {
        if(hStartedAssoCh[uiAssocId])
        {
            for(j=0; j < BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
            {
                if(hStartedAssoCh[uiAssocId]->pPath[j] != NULL)
                {
                    BDBG_MSG(("hStartedAssoCh[uiAssocId=%d]->pPath[j=%d]->eUsgPath = %d",
                    uiAssocId,j, hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath));
                }
            }
        }
    }
    if(BERR_SUCCESS != ret)
    {
        ret = BERR_TRACE(ret);
        goto end;        
    }
    
    /* Malloc large structures */
    pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
    if ( NULL==pPvtDstDetails )
    {
        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        goto end;                
    }
    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));     
        
    /*
    Look if the input source to decode is external capture port then add capture 
    path.
    Now decide if the channel is associated with two different association.
        1)If it going in two association than decide for which assocaiton we have 
        to create DECPCM path and for other association we have to create DECMix
        path. To decide the path type we have to use information of O/P associated 
        with the association.

        2)If it is not the part of two assocaition then it will be the usual case.

        To decide for different path

        We will take all different output port on the channel. Search the association 
        in which this output port is added. If it is associated with an association 
        where we are not mixing any other channel than look the other already existed 
        path in the channel. If their is any DecPCm path is already in system than 
        create PP path otherwise create DECPCM path. 
        If the association in which the output port is added having any other 
        channel to mix and that channel is already started than search the for 
        the path which is having same OP added in already started channel and 
        copy the links. 
        If the association in which the output port is added having any other channel 
        to mix and that channel not started and if this branch is having any output 
        port cloing than we create one Mix path & one PP path otherwise we create PP path.

        Post-Mixing path: The subsequent path after mixing(HW/FW) viz., eDecodePcmPostMixing/..
            Normal case: eDecodePcm/ePPBranch/..-->eCapture-->eDecodePcmPostMixing/..
            Decoder Output to DRAM: eDecodePcm/ePPBranch/..-->eDecodePcmPostMixing/..
            In the above cases the paths before Post-Mixing eDecodePcm,ePPBranch,..
            will not have destination details as they are feeding to any destination directly.
        Channel Network: Audio network in eDecodePcm,ePPBranch,..
        Association Network: Audio network in eDecodePcmPostMixing/..
        Currently one Association Network supported per Raptor Channel.
    */

    if(BRAP_ChannelType_eDecode == hRapCh->eChannelType)
    {
        if(BRAP_P_NETWORK_VALID(hRapCh->sChAudProcessingStage))
        {
            for(j=0; j<BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED; j++)
            {
                if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,0,j)))
                    break;
            }
            j--;

            if(hRapCh->sChAudProcessingStage[0][j].hValidDestHandle != NULL)
            {
                ret = BRAP_P_GetAssocId(hRapCh,
                                        &(hRapCh->sChAudProcessingStage[0][j].hValidDestHandle->sExtDstDetails),
                                        &uiAssocId );    
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;
                }            
            }
            else /* Path feeding to Post-Mixing path */
            {         
                ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                hRapCh->pDstDetails[0],
                                                pPvtDstDetails,
                                                &uiAssocId);
                if(BERR_SUCCESS!=ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;                
                }
                if(BRAP_P_IsAssociationNWValid(pPvtDstDetails))
                {
                    bAssociationNWDstnFound = true;
                }
                else
                {
                    BDBG_ERR(("Error! Destination not found either on"
                        " Channel Network or Association Network "));
                    ret = BERR_NOT_SUPPORTED;
                    goto end;                    
                }
            }

            bCompress = false;
            
            for(k =1; k < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; k++)
            {
                hAudProcessing = hRapCh->sChAudProcessingStage[0][k].hAudioProcessing;                
                if(NULL == hAudProcessing)
                    break;
                eAudProc = hAudProcessing->sProcessingStageSettings.eAudioProcessing;
                
                BDBG_MSG(("pPvtDstDetails->eAudProcessing[j] = %d",eAudProc));
                if((BRAP_ProcessingType_eConvertDdpToAc3  == eAudProc)
                    ||(BRAP_ProcessingType_eWmaProPassThru == eAudProc)                        
                    ||(BRAP_ProcessingType_eEncodeDts== eAudProc)
                    ||(BRAP_ProcessingType_eGenericPassthru==eAudProc)                    
                    ||(BRAP_ProcessingType_eEncodeAc3==eAudProc)
                    ||(BRAP_ProcessingType_eEncodeMp3==eAudProc)
                    ||(BRAP_ProcessingType_ePassthru==eAudProc))
                {
                       bCompress = true;
                       break;
                }

            }
            /*Check if the source to decode is SPDIF/HDMI/I2S or Ringbuffer*/
            if (((BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource)&&
                ((BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)||
                (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort)||
                (BRAP_CapInputPort_eAdc == pAudioParams->eCapInputPort)||                 
                  (BRAP_CapInputPort_eExtI2s0 == pAudioParams->eCapInputPort))) ||
                (BRAP_AudioSource_eRingBuffer == pAudioParams->eAudioSource))
            {
                /* This means that we have SPDIF/HDMI/I2S or Ringbuffer as the source 
                for the decode. So we have to create a capture path and then a 
                Decode path to handle this case */
                if(NULL == hRapCh->pPath[uiPth])
                {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                    ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                    ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                    if(BERR_SUCCESS != ret)
                    {
                        ret = BERR_TRACE(ret);
                        goto end;
                    }            
                }
                BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                        BRAP_P_UsgPath_eCapture,
                                                        BRAP_INVALID_VALUE,
                                                        uiPth,
                                                        uiPth+1,0);
                hRapCh->pPath[uiPth]->uiAssocId = BRAP_INVALID_VALUE;                
                /* Instantiate the DSP Channel corresponding to the DSP context resource 
                manager has allocated */
                ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                            &hRapCh,
                                            true,
                                            pDspChSettings);
                if(BERR_SUCCESS != ret)
                {
                    BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                    ret = BERR_TRACE(ret);
                    goto end;
                }

                hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;
                uiPth++;
                if((BRAP_DSPCHN_DecodeMode_eDecode == pAudioParams->sDspChParams.eDecodeMode)
                    &&(bCompress == false))
                {
                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        {
                            BDBG_ERR(("Malloc Path falled"));
                            ret = BERR_TRACE(ret);
                            goto end;                            
                        }            
                    }
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                            BRAP_P_UsgPath_eDecodePcm,
                                                            uiPth-1,
                                                            uiPth,
                                                            BRAP_INVALID_VALUE,0);
                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                    /* Before we update the resource grant, let us take out the DSP resources & put it in here */
                    /* DSP was allocated in path 0, but now moved to path 1 */ 
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp;
                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh;

                    /*Populating Destination to Path. This was earlier done in DistributeDest() func.
                      Don't populate if there is an Association network, as eDecodePCMPostMixing path feeds directly to Destination */
                    if(bAssociationNWDstnFound == false)
                    {
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[0][0].hValidDestHandle->sExtDstDetails);
                        BDBG_MSG(("Adding Output port %d to Decode PCM Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0]));  
                    }
                    uiPth++;            
                }
                else if((BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode)
                            ||(bCompress == true))
                {
                    /* In case of a SPDIF/HDMI we need to add DecodeCompress path also 
                    to handle the digital passthru case. Compressed In -> Compressed Out */            

                    if ((BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)||
                    (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort))
                    {
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                            ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                            ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                goto end;                                
                            }
                        }
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                BRAP_P_UsgPath_eDecodeCompress,
                                                                uiPth-1,
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        /* Before we update the resource grant, let us take out the DSP resources & put it in here */
                        /* DSP was allocated in path 0, but now moved to path 2 */ 
                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                        hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp;
                        hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh;                

                      /* Don't populate if there is an Association network, as eDecodeCompressPostMixing path feeds directly to Destination */
                        if(bAssociationNWDstnFound == false)
                        {
                            uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[0][0].hValidDestHandle->sExtDstDetails);
                            BDBG_MSG(("Adding Output port %d to Decode Compress Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0]));
                        }
                        uiPth++;  
                    }
                }
            } /* if ((BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource)*/
            else
            {
                if((BRAP_DSPCHN_DecodeMode_eDecode == pAudioParams->sDspChParams.eDecodeMode)
                    &&(bCompress == false))
                {
                    uiPth = 0;
                    BDBG_MSG(("BRAP_P_GetChannelPaths: Decode Mode "));
                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;
                        }
                    }
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                            BRAP_P_UsgPath_eDecodePcm,
                                                            BRAP_INVALID_VALUE,
                                                            uiPth,
                                                            BRAP_INVALID_VALUE,0);
                    /* Instantiate the DSP Channel corresponding to the DSP context resource 
                    manager has allocated */
                    BDBG_MSG(("BRAP_P_UsgPath_eDecodePcm uiPth=%d",uiPth));
                    
                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                    
                    ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                                &hRapCh,
                                                true,
                                                pDspChSettings);
                    if(BERR_SUCCESS != ret)
                    {
                        ret = BERR_TRACE(ret);
                        BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                        goto end;
                    }
                    hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;
                    
                      /* Don't populate Destination details if there is an Association network followed.
                         It is eDecodePCMPostMixing path that feeds directly to Destination */
                    if(bAssociationNWDstnFound == false)
                    {
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[0][0].hValidDestHandle->sExtDstDetails);
                        BDBG_MSG(("Adding Output port %d to Decode PCM Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0]));  
                    }
                    uiPth++;
                }
                else if((BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode)
                        ||(bCompress == true))
                {
                    uiPth = 0;
                    BDBG_MSG(("BRAP_P_GetChannelPaths: Pass thru Mode "));
                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;                            
                        }
                    }
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                            BRAP_P_UsgPath_eDecodeCompress,
                                                            BRAP_INVALID_VALUE,
                                                            uiPth,
                                                            BRAP_INVALID_VALUE,0);
                    BDBG_MSG(("BRAP_P_UsgPath_eDecodeCompress uiPth=%d",uiPth));                    

                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                    /* Instantiate the DSP Channel corresponding to the DSP context resource 
                    manager has allocated */
                    ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                                &hRapCh,
                                                true,
                                                pDspChSettings);
                    if(BERR_SUCCESS != ret)
                    {
                        ret = BERR_TRACE(ret);
                        BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                        goto end;
                    }
                    hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;

                    /* Don't populate if there is an Association network, as eDecodeCompressPostMixing path feeds directly to Destination */
                    if(bAssociationNWDstnFound == false)
                    {
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[0][0].hValidDestHandle->sExtDstDetails);
                        BDBG_MSG(("Adding Output port %d to Decode Compress Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0]));  
                    }
                    uiPth++;
                }
            } /*else((BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource)*/            

            for(i=1; i<BRAP_P_MAX_DST_PER_RAPCH; i++)
            {   
                if(!(BRAP_P_BRANCH_VALID(hRapCh->sChAudProcessingStage,i)))                
                {
                    break;
                }

                bIndepPathRequire = false;      

                bDownmixPathRequire = false;                
                bBranchCloned = flag = bMixPathRequire = false;
                uiClonedBranch = BRAP_INVALID_VALUE;                            
                for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
                {
                    uiCloneBranchId[k] = BRAP_INVALID_VALUE;
                }
                for (j = 0; j < BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED; j++)
                {
                    if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,i,j)))  
                        break;
                }
                if((true == hRapCh->sChAudProcessingStage[i][j-1].bCloneStage)) 
                {
                    flag = true;
                }


                /* Last valid stage id */
                uiLastStage  = j -1;   
                if(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle != NULL)
                {
                    ret = BRAP_P_GetAssocId(hRapCh,
                                            &(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails)
                                            ,&uiAssocId );
                    if(BERR_SUCCESS != ret)
                    {
                        ret = BERR_TRACE(ret);
                        goto end;
                    }                    
                }
                else
                {
                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                    hRapCh->pDstDetails[i],
                                                    pPvtDstDetails,
                                                    &uiAssocId);
                    if(BERR_SUCCESS!=ret)
                    {
                        ret = BERR_TRACE(ret);
                        goto end;                
                    }
                    if(BRAP_P_IsAssociationNWValid(pPvtDstDetails))
                    {
                        /* If DecodePCM/PPBranch path corresponding to Post-Mixing path 
                           is already formed then go to next destination */
                        if(bAssociationNWDstnFound == true)
                            continue; 
                    }
                    else
                    {
                        BDBG_ERR(("Error! Destination not found either on"
                            " Channel Network or Association Network "));
                        ret = BERR_NOT_SUPPORTED;
                        goto end;                    
                    }
                }                

            /*If its Mai and Muxselector is not Mai, then dont create path for it */
                if( (!((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                    &&(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eMai)
                    &&(hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiSettings.eMaiMuxSelector != BRAP_OutputPort_eMai)))
                    ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) )
                {                
                if(flag == false)
                {
                    bBranchCloned = false;
                }
                else
                {
                    ui32MasterBranchId = k= hRapCh->sChAudProcessingStage[i][uiLastStage].ui32MasterBranchId;
                    ui32MasterStageId = l= hRapCh->sChAudProcessingStage[i][uiLastStage].ui32MasterStageId;
                    m=0;
                    /* Check if the current branch is the clone of master branch of last stage of the current branch */
                    if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,l+1)))           
                    {
                        bBranchCloned = true;
                        uiCloneBranchId[m]=k;
                        m++;
                        k++;
                    }

                    /* Now check if the branches between Master branch and current branch is similar to current  branch.
                    This is done by checking if the last stage is cloned, and its Master stage/branch id 
                    is same as that of last stage id of current branch. Just to make clear, here 
                    Current Branch/Stage Id is : i/uiLastStage
                    Master Branch/Stage Id is : ui32MasterBranchId/ui32MasterStageId
                    And we looping on K, which is between ui32MasterBranchId and i*/                                    
                    for(; k<i; ++k)
                    {
                        if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,l+1)))
                        {   
                                if((true == hRapCh->sChAudProcessingStage[k][l].bCloneStage)
                                    &&(hRapCh->sChAudProcessingStage[k][l].ui32MasterBranchId == ui32MasterBranchId)
                                    &&(hRapCh->sChAudProcessingStage[k][l].ui32MasterStageId == ui32MasterStageId)
                                    &&(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,l+1))))
                            {
                                bBranchCloned = true;
                                uiCloneBranchId[m]=k;
                                m++;
                            } 
                        }
                    }

                    /* Now if there  are branches which are cloned to current then, Are they in same
                    association? If no then Create a Mix Path corresponding to them , If not created 
                    already.*/
                    if(bBranchCloned == true)
                    {                        
                        if(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                        {                    
                            for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                            {
                                if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                    break;
                                
                                k = uiCloneBranchId[m];
                                /* For cloned branch */
                                
                                            if((hRapCh->eChannelOutputMode == BRAP_OutputMode_e2_0)
                                                ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == 
                                    hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort))
                                {
                                    bDownmixPathRequire = false;
                                    uiClonedBranch = k;
                                    break;
                                }
                                else if (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0)
                                {
                                    bDownmixPathRequire = true;
                                }
                            }
                        }

#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)                                  
                        if((false == bDownmixPathRequire))
                        {                        
                        /*If its Mai and Muxselector is not Mai, then dont create path for it */
                            if( (!((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                                &&(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eMai)
                                &&(hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiSettings.eMaiMuxSelector != BRAP_OutputPort_eMai)))
                                ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) )
                            {
                            for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                            {
                                if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                    break;
                                
                                k = uiCloneBranchId[m];
                                /* For cloned branch */
                                /*If the Destination has Indepdelay Enabled then create similar path to its cloned.*/

#if (BRAP_DYNAMIC_PORT_SWITCHING != 1)
                                if((hRapCh->bIndepDelayEnabled == true)
                                    &&((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer)
                                       ||((hRapCh->sChAudProcessingStage[k][l].hValidDestHandle != NULL) &&
                                          (hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer))
                                           ||(hRapCh->eChannelOutputMode == BRAP_OutputMode_e2_0)
                                       ||((hRapCh->sChAudProcessingStage[k][l].hValidDestHandle != NULL) &&
                                          (hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == 
                                           hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort)))
                                  )
                                {
                                    bIndepPathRequire = true;
                                    uiClonedBranch = k;                                                                                
                                    break;
                                }
                                else
                                {
                                    bIndepPathRequire = false;
                                    uiClonedBranch = k;                                            
                                }
#else
                                if( (hRapCh->bIndepDelayEnabled == true) &&
                                    ((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                                     (hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                                     (hRapCh->hRap->sOutputSettings[hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]].iDelay != 
                                     hRapCh->hRap->sOutputSettings[hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]].iDelay))
                                    )
                                {
                                    bIndepPathRequire = true;
                                    uiClonedBranch = k;                                                                                
                                    break;                                    
                                }
                                else if( (hRapCh->bIndepDelayEnabled == true) &&
                                         ((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                                         (hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                                         (hRapCh->hRap->sOutputSettings[hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]].iDelay == 
                                          hRapCh->hRap->sOutputSettings[hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]].iDelay))
                                        )
                                {
                                    switch(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0])
                                    {
                                        case BRAP_OutputPort_eMax:
                                            BDBG_ERR(("BRAP_DEC_Start: Output port type %d not supported", BRAP_OutputPort_eMax));
                                            return BERR_TRACE(BERR_NOT_SUPPORTED);                               
                                            break;
                                        case BRAP_OutputPort_eDac2:
                                            for(j=(i-1); j>=k; j--)
                                            {
                                                if((hRapCh->sChAudProcessingStage[j][0].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                                                   (hRapCh->sChAudProcessingStage[j][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eDac1))
                                                {
                                                    bIndepPathRequire = false;
                                                    uiClonedBranch = j;
                                                    bBranchFoundForDummy = true;
                                                    break;                                                        
                                                }
                                            }
                                            if(j<k)
                                            {
                                                BDBG_ERR(("No Master port added corresponding to DAC2 output port"));
                                                return BERR_TRACE(BERR_NOT_SUPPORTED);                                                                                                                               
                                            }
                                            break;
                                        case BRAP_OutputPort_eI2s1: 
                                            for(j=(i-1); j>=k; j--)
                                            {
                                                if((hRapCh->sChAudProcessingStage[j][0].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                                                   (hRapCh->sChAudProcessingStage[j][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eI2s4))
                                                {
                                                    bIndepPathRequire = false;
                                                    uiClonedBranch = j;
                                                    bBranchFoundForDummy = true;                                                        
                                                    break;                                                        
                                                }
                                            }
                                            if(j<k)
                                            {
                                                BDBG_ERR(("No Master port added corresponding to I2S1 output port"));
                                                return BERR_TRACE(BERR_NOT_SUPPORTED);                                                                                                                               
                                            }
                                            break;
                                        default:
                                            bIndepPathRequire = true;
                                            uiClonedBranch = k;
                                            break;
                                    }
                                    BDBG_MSG(("Output Port = %d, bIndepPathRequire=%d, uiClonedBranch=%d",
                                        hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0],
                                        bIndepPathRequire,uiClonedBranch));
                                    /*if(bIndepPathRequire == true)*/
                                        break;
                                }                              
                                /* Assumption: There will be no two ringbuffer destinations */
                                else if( (hRapCh->bIndepDelayEnabled == true) &&
                                         (hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) 
                                        )
                                {
                                    /* If it is a dummy capture for SPDIF */
                                    if(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sRBufDetails.bDontPauseWhenFull == true)
                                    {
                                        for(j=(i-1); j>=k; j--)
                                        {
                                            if((hRapCh->sChAudProcessingStage[j][0].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                                               (hRapCh->sChAudProcessingStage[j][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eSpdif))
                                            {
                                                bIndepPathRequire = false;
                                                uiClonedBranch = j;
                                                bBranchFoundForDummy = true;
                                                break;                                                        
                                            }
                                        }
                                        if(j<k)
                                        {
                                            BDBG_ERR(("No Master port added corresponding to DAC2 output port"));
                                            return BERR_TRACE(BERR_NOT_SUPPORTED);                                                                                                                               
                                        }                                    
                                    }
                                }                                
                                else
                                {
                                    bIndepPathRequire = false;
                                    uiClonedBranch = k;                                            
                                }                                     
#endif
                            }
                        }                        
                    }
#endif                        
                        if((false == bIndepPathRequire)
                            &&(false == bDownmixPathRequire)
#if (BRAP_DYNAMIC_PORT_SWITCHING == 1)
                            &&(false == bBranchFoundForDummy)
#endif
                            )
                        {
                            for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                            {
                                if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                    break;
                                
                                k = uiCloneBranchId[m];
                                /* For cloned branch */
                                ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                                &(hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails),
                                                                                pPvtDstDetails,
                                                                                &uiCloneAssocId);
                                if(BERR_SUCCESS!=ret)
                                {
                                    ret = BERR_TRACE(ret);
                                    goto end;                
                                }
                                /* For this branch */
                                ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                                    &(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails),
                                                                                    pPvtDstDetails,
                                                                                    &uiAssocId);
                                if(BERR_SUCCESS!=ret)
                                {
                                    ret = BERR_TRACE(ret);
                                    goto end;                
                                }
                                if(uiAssocId == uiCloneAssocId)
                                {
                                    bMixPathRequire = false;
                                    uiClonedBranch = k;
                                    break;
                                }
                                else
                                {
                                    bMixPathRequire = true;
                                }
                            }
                        }
                        }
                    } /*if(j == BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED)*/
                }                        
                else
                {
                    bBranchCloned = true;
                    for(k =0; k<i; ++k)
                    {
                        if((BRAP_P_BRANCH_VALID(hRapCh->sChAudProcessingStage,k)))
                        {   
                            if((hRapCh->sChAudProcessingStage[k][0].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                                &&(hRapCh->sChAudProcessingStage[k][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]
                                != BRAP_OutputPort_eMai)
                                &&(hRapCh->sChAudProcessingStage[k][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]
                                == hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiSettings.eMaiMuxSelector))
                            {
                                uiClonedBranch = k;
                                BDBG_MSG(("################Coming here k =%d",k));
                            }
                        }
                    }
                } /*if(bBranchCloned == true)*/
                
                BDBG_MSG(("bBranchCloned=%d uiAssocId=%d uiCloneAssocId=%d",
                bBranchCloned,uiAssocId,uiCloneAssocId));
                if(((false == bBranchCloned)&&(BRAP_P_BRANCH_VALID(hRapCh->sChAudProcessingStage,i)))
                    ||((true == bBranchCloned) && (true == bDownmixPathRequire)))
                {

                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;                            
                        }
                    }
                    if( (((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                          &&(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == true))
                         ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer))
                        && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0) )    /* Capture to rbuf is required in stereo mode as of now */
                    {
                    
/*                        if(uiLastStage == 0)*/
                        {
                            BDBG_MSG(("BRAP_P_UsgPath_eDownmixedPath"));                                        
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_eDownmixedPath,
                                                                    BRAP_INVALID_VALUE, 
                                                                    uiPth,
                                                                    BRAP_INVALID_VALUE,0);
                        }
                    }
                    else
                    {
                    BDBG_MSG(("BRAP_P_UsgPath_ePPBranch"));
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                            BRAP_P_UsgPath_ePPBranch,
                                                            BRAP_INVALID_VALUE, 
                                                            uiPth,
                                                            BRAP_INVALID_VALUE,0);
                    }
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp; 
                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh; 
                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;

                    uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails);
                    BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));  
                    uiPth++;
                } /*if((false == bBranchCloned)&&*/
                else if ((true == bBranchCloned) && (true == bMixPathRequire))
                {   
                    /*Find the Path which is having cloned port */
                    ret = BRAP_P_GetPathIndex(hRapCh,pAudioParams,k,uiCloneOp,&m);


                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;                            
                        }
                    }   
                    if((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                        &&(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == true)
                        && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))
                    {
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                            BRAP_P_UsgPath_eDownmixedMixPath,
                                                            BRAP_INVALID_VALUE, 
                                                            uiPth,
                                                            BRAP_INVALID_VALUE,0);
                    BDBG_MSG(("BRAP_P_UsgPath_eDownmixedMixPath uiPth=%d",uiPth));                    
                    }
                    else
                    {
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                            BRAP_P_UsgPath_eMixPath,
                                                            BRAP_INVALID_VALUE, 
                                                            uiPth,
                                                            BRAP_INVALID_VALUE,0);        
                    BDBG_MSG(("BRAP_P_UsgPath_eMixPath uiPth=%d",uiPth));                    
                    }
                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                    /*Mark the path which is cloned for this stage as mix*/
                    BDBG_MSG(("Input to mix path uiPth=%d",m));
                    hRapCh->pPath[m]->bMixPath = true;
                    hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = m;
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[m]->sRsrcGrnt.uiDspId;
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[m]->sRsrcGrnt.uiDspContextId;
                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[m]->hDsp; 
                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[m]->hDspCh; 

                    /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                    uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails);
                    BDBG_MSG(("Adding Output port %d to  Mix PCM Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0]));                      
                    ++uiPth;
                } /*else if ((true == bBranchCloned) &&(uiAssocId != uiCloneAssocId))*/
                else
                {
                    /* If Independent delay is on, then a corresponding path is created for the destination. Otherwise
                    no path is created for this destination. So add this destination to the path it belong.*/
                    uiCloneOp++;
                    flag = false;
                    for(m =0 ; m < uiPth ; m++)
                    {
                        uiDestCount = hRapCh->pPath[m]->uiDestcount;
                        
                        for(n =0 ; n < uiDestCount ; n++)
                        {
                            
                            if(hRapCh->pPath[m]->pDstDetails[n] == 
                                &(hRapCh->sChAudProcessingStage[uiClonedBranch][0].hValidDestHandle->sExtDstDetails))
                            {
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)          
                                if(bIndepPathRequire == true)
                                {/* Create a Path */
                                
                                    switch(hRapCh->pPath[m]->eUsgPath)
                                    {
                                        case BRAP_P_UsgPath_eDecodePcm:
                                        case BRAP_P_UsgPath_eDecodeCompress:                                            
                                        case BRAP_P_UsgPath_ePPBranch:                                            
                                        case BRAP_P_UsgPath_eMixPath:                                            
                                        case BRAP_P_UsgPath_eSharedPP:                                                            
                                            ePathType = BRAP_P_UsgPath_ePPBranch;
                                            break;
                                        case BRAP_P_UsgPath_eDownmixedPath:
                                        case BRAP_P_UsgPath_eDownmixedMixPath:                                            
                                            ePathType = BRAP_P_UsgPath_eDownmixedPath;
                                            break;
                                        default:
                                            ePathType = BRAP_P_UsgPath_ePPBranch;
                                            break;
                                    }
                                    
                                    if(NULL == hRapCh->pPath[uiPth])
                                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                                                   
                                        if(BERR_SUCCESS != ret)
                                        {
                                            ret = BERR_TRACE(ret);
                                            goto end;                            
                                        }
                                    }
                                    BDBG_MSG(("BRAP_P_UsgPath = %d",ePathType));
                                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                            ePathType,
                                                                            BRAP_INVALID_VALUE, 
                                                                            uiPth,
                                                                            BRAP_INVALID_VALUE,0);

                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp; 
                                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh; 
                                    hRapCh->pPath[uiPth]->uiMasterpathId = m;

                                    uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails);

                                    /* Get the Assoc Id corresponding to the Destination this path is feeding and update it in pPath */
                                    ret = BRAP_P_GetAssocId(hRapCh,
                                                &(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails),
                                                &uiAssocId );    
                                    if(BERR_SUCCESS != ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto end;
                                    }
                                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                                    
                                    if(hRapCh->pPath[uiPth]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eOutputPort)
                                    {
                                        BDBG_MSG(("Adding Output port %d to  Path type = %d", 
                                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                      
                                    }
                                    else if(hRapCh->pPath[uiPth]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                                    {
                                        BDBG_MSG(("Adding Capture port %d to  Path type = %d", 
                                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                      
                                    }
                                    uiPth++;                                    
                                    
                                }
                                else
#endif                                    
                                {                                        
                                    hRapCh->pPath[m]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails);                                
                                    if(hRapCh->pPath[m]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eOutputPort)
                                    {
                                        BDBG_MSG(("Adding Output port %d to  Path type = %d", 
                                            hRapCh->pPath[m]->pDstDetails[uiDestCount]->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[m]->eUsgPath));
                                    }
                                    else if(hRapCh->pPath[m]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                                    {
                                        BDBG_MSG(("Adding Capture port %d to  Path type = %d", 
                                            hRapCh->pPath[m]->pDstDetails[uiDestCount]->uDstDetails.sRBufDetails.eCapPort[0],hRapCh->pPath[m]->eUsgPath));
                                    }
                                    hRapCh->pPath[m]->uiDestcount++;
                                }
                                flag =true;
                                break;
                            }
                        }
                        if(true == flag)
                            break;
                    }
                }
            } /*for(i=1; i<BRAP_P_MAX_DST_PER_RAPCH; i++)*/
            BDBG_MSG(("Checking for Internal capture path"));
            /* See if any added destination needs Internal Capture Path */
            for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
            {
                if(NULL == hRapCh->pDstDetails[i])
                    continue;
                
                BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));
                
                BDBG_MSG(("hRapCh->pDstDetails[i]=%x",hRapCh->pDstDetails[i]));
                /*Find the audio procsssing for the destination of the row on association network*/
                ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                    hRapCh->pDstDetails[i],
                                                                    pPvtDstDetails,
                                                                    &uiAssocId);
                if(BERR_SUCCESS!=ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;                
                }
                BDBG_MSG(("BRAP_P_GetChannelPath: Internal capture path 1"));
                if(BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst)
                {
                    if(NULL == hStartedAssoCh[uiAssocId])
                    {
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                            ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                            ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                            if(BERR_SUCCESS != ret)
                            { 
                                ret =  BERR_TRACE(ret);
                                goto end;                                
                            }
                        }                        
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                                                BRAP_P_UsgPath_eCapture,
                                                                BRAP_INVALID_VALUE,
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        
                        BDBG_MSG(("BRAP_P_UsgPath_eCapture uiPth=%d",uiPth));
                        
                        hRapCh->pPath[uiPth]->uiAssocId = BRAP_INVALID_VALUE;
                        flag =false;
                        for (j =0;j< BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            for(k =0 ; k < hRapCh->pPath[j]->uiDestcount ; k++)
                            {                                
                                if(hRapCh->pPath[j]->pDstDetails[k] ==NULL)
                                    break;
                                else if(hRapCh->pPath[j]->pDstDetails[k]  == hRapCh->pDstDetails[i])
                                {                                    
                                    hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                                    /* Set the out path index of previous path */
                                    hRapCh->pPath[j]->sOutPathProp[0].uiPathIdx = uiPth;
                                    flag =true;
                                    break;
                                }
                            }
                            if(flag == true)
                                break;                       
                        }
                        
                        /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] =  hRapCh->pDstDetails[i];
                        
                    }
                    else
                    {
                        /* Copy the relevant path from the started channel */
                        for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                        {
                            if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                                (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                                (BRAP_P_UsgPath_eCapture == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath)&&
                                (hStartedAssoCh[uiAssocId]->pPath[j]->uiAssocId == BRAP_INVALID_VALUE))
                            {
                                hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                break;                            
                            }
                        }
                        BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                        uiPth, hRapCh->pPath[uiPth]->eUsgPath));
                    }
                    (*uiNumCapPath)++;                
                    uiPth++;
                }
            }

        } /* if((true == hRapCh->sChAudProcessingStage[0][0].bCloneStage)*/

        /* Allocating the path for association network.
           ToDo: Algorithm */
        for(l=0; l<BRAP_MAX_ASSOCIATED_GROUPS; ++l)
        {        
            if(hRapCh->uiAssociationId[l] == BRAP_INVALID_VALUE)
                continue;

            uiAssocId = hRapCh->uiAssociationId[l];                

            if(BRAP_P_NETWORK_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage))
            {
                BDBG_MSG(("Allocating the path for Association Network"));            
                
                bCompress = false;     
                BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));

                for(i=0; i<BRAP_P_MAX_DST_PER_RAPCH; i++)
                {
                    if(NULL != hRapCh->pDstDetails[i])
                    {
                        ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                        hRapCh->pDstDetails[i],
                                                        pPvtDstDetails,
                                                        &m);
                        if(BERR_SUCCESS!=ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;                
                        }
                        if((m == uiAssocId) && (BRAP_P_IsAssociationNWValid(pPvtDstDetails)))
                        {
                            break;
                        }
                    }            
                }
                if(i >= BRAP_P_MAX_DST_PER_RAPCH)
                {
                    BDBG_MSG(("No destination found in Association Network"));
                    ret = BERR_NOT_SUPPORTED;
                    goto end;
                }

                m = BRAP_INVALID_VALUE;

            /* Check if the Path outputs the compress data  */
            for(m =0; m < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; m++)
            {
                if(NULL == pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m])
                    break;

                eAudioProcessing = pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m]->sProcessingStageSettings.eAudioProcessing;

                BDBG_MSG(("pPvtDstDetails->eAudProcessing[j] = %d",eAudioProcessing));

                if((BRAP_ProcessingType_eConvertDdpToAc3  == eAudioProcessing)
                    ||(BRAP_ProcessingType_eWmaProPassThru == eAudioProcessing)                              
                    ||(BRAP_ProcessingType_eEncodeDts== eAudioProcessing)
                    ||(BRAP_ProcessingType_eGenericPassthru==eAudioProcessing)                        
                    ||(BRAP_ProcessingType_eEncodeAc3==eAudioProcessing)
                    ||(BRAP_ProcessingType_eEncodeMp3==eAudioProcessing)
                    ||(BRAP_ProcessingType_ePassthru==eAudioProcessing))
                {
                    bCompress = true;
                    break;
                }
            }
            /* Last valid stage of association network */
            if(m>0)
            {
                uiLastStage = m -1;
            }
            else
            {
                uiLastStage = BRAP_INVALID_VALUE;
                BDBG_ERR(("Network must have one valid stage"));
                ret = BERR_TRACE(BERR_INVALID_PARAMETER);
                goto end;
            }
                
            if(BRAP_AudioDst_eMax != hRapCh->pDstDetails[i]->eAudioDst)
            {
                if(NULL == hStartedAssoCh[uiAssocId])
                {
                    BRAP_AssociatedChannelHandle hAssociation;
                    hAssociation = &(hRapCh->hRap->sAssociatedCh[uiAssocId]);
           
                    /* Capture path not required for Decode channel, for MS10/11 */
                    if(!(BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh)))
                    {
                        for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; ++k)
                        {
                            if(!(BRAP_P_BRANCH_VALID(hRapCh->sChAudProcessingStage,k)))
                            {
                                break;
                            }
                            for(m=0; m<BRAP_MAX_PP_PER_BRANCH_SUPPORTED; ++m)
                            {
                                if(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,m))
                                {
                                    continue;
                                }
                                else
                                    break;
                            }
                            /*Valid stage is before this value of m so subtract 1*/
                            m--;
                            
                            /*Get the path index*/
                            if(hRapCh->sChAudProcessingStage[k][m].hValidDestHandle == pPvtDstDetails)
                            {
                                ret = BRAP_P_GetInputPathIndexForAssociation(hRapCh,uiAssocId,&j);
                                if(BERR_SUCCESS != ret)
                                { 
                                    ret = BERR_TRACE(ret);
                                    goto end;                            
                                }
                                break;
                            }
                        } /*for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; ++k)*/
                        
                        if(k >= BRAP_P_MAX_DST_PER_RAPCH)
                        {
                            ret = BERR_NOT_SUPPORTED;
                            BDBG_ERR(("Valid Destination not found in Channel Processing stage"));
                            goto end;                            
                        }
                
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                            if(BERR_SUCCESS != ret)
                            { 
                                ret = BERR_TRACE(ret);
                                goto end;                            
                            }
                        }                        
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                            BRAP_P_UsgPath_eCapture,
                                            BRAP_INVALID_VALUE,
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);
                        BDBG_MSG(("BRAP_P_UsgPath_eCapture uiPth=%d",uiPth));
                        
                        /* Link current and previous path */
                        if((j < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                            (hRapCh->pPath[j] != NULL))
                        {
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                            hRapCh->pPath[j]->sOutPathProp[0].uiPathIdx = uiPth;
                        }
                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;

                        (*uiNumCapPath)++;                
                        uiPth++;
                    }

                    if(true == bCompress)
                    {
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                            ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                            ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                            if(BERR_SUCCESS != ret)
                            { 
                                ret = BERR_TRACE(ret);
                                goto end;                                
                            }
                        }
                        BDBG_MSG(("BRAP_P_UsgPath_eDecodeCompressPostMixing uiPth=%d",uiPth));                            
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                            BRAP_P_UsgPath_eDecodeCompressPostMixing,
                                            BRAP_INVALID_VALUE,
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);

                        /* Instantiate the DSP Channel corresponding to the DSP context resource 
                        manager has allocated */
                        ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                                    &hAssociation,
                                                    false,
                                                    pDspChSettings);
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret);
                            BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                            goto end;
                        }
                        hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;
                        
                        hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = uiPth-1;
                        hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;
                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        hRapCh->pPath[uiPth]->pDstDetails[hRapCh->pPath[uiPth]->uiDestcount++] = hRapCh->pDstDetails[0];
                        uiPth++;                    
                    }
                    else
                    {
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                            ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                            ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                            if(BERR_SUCCESS != ret)
                            { 
                                ret = BERR_TRACE(ret);
                                goto end;                                       
                            }
                        }
                        BDBG_MSG(("BRAP_P_UsgPath_eDecodePcmPostMixing uiPth=%d",uiPth));
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                            BRAP_P_UsgPath_eDecodePcmPostMixing,
                                            BRAP_INVALID_VALUE,
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);

                            /* Instantiate the DSP Channel corresponding to the DSP context resource 
                            manager has allocated */
                            
                            ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                                        &hAssociation,
                                                        false,
                                                        pDspChSettings);
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                                goto end;
                            }
                            hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;
                        
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = uiPth-1;
                            hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;
                            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                            hRapCh->pPath[uiPth]->pDstDetails[hRapCh->pPath[uiPth]->uiDestcount++] = hRapCh->pDstDetails[0];
                            BDBG_MSG(("Adding OutputPort %d to Path = %d",
                                hRapCh->pPath[uiPth]->pDstDetails[hRapCh->pPath[uiPth]->uiDestcount-1]->uDstDetails.sOpDetails.eOutput[0],uiPth));                         
                            uiPth++;
                        }              
                    } /*if(NULL == hStartedAssoCh[uiAssocId])*/
                    else
                    {
                        /* Copy the relevant path from the started channel */
                        for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                        {
                            if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                                (NULL == hRapCh->pPath[uiPth])&&
                                (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                                (BRAP_P_UsgPath_eDecodePcmPostMixing == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath)&&
                                (hStartedAssoCh[uiAssocId]->pPath[j]->uiAssocId == uiAssocId))
                            {
                                hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                for(k=0; k<BRAP_P_MAX_IN_PARALLEL_FMM_PATH; k++)
                                {
                                    if(BRAP_INVALID_VALUE == hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx)
                                        break;
                                }
                                hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx = uiPth-1;
                                hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;
                                BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                                uiPth, hRapCh->pPath[uiPth]->eUsgPath));                                
                                uiPth++;
                                break;                            
                            }
                        }
                    }
                } /* if(BRAP_AudioDst_eMax != hRapCh->pDstDetails[i]->eAudioDst) */

                if(BRAP_P_MAX_PATHS_IN_A_CHAN <= uiPth)
                {
                    ret = BERR_TRACE(BERR_NOT_SUPPORTED);                
                    BDBG_ERR(("No Free slot available to form Post Mixing Paths"));
                    goto end;
                }
                
                /* Check for more destinations connected to Association Network */
                ret = BRAP_P_FormPostMixingPathsForSubsequentDestinations(i, uiPth, uiAssocId, pAudioParams,hRapCh);
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    BDBG_ERR(("FormPostMixingPathsForSubsequentDestinations failed with err = %d", ret));
                    goto end;
                }
            } /* if(BRAP_P_NETWORK_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage)) */
        } /* for(l=0; l<BRAP_MAX_ASSOCIATED_GROUPS; ++l) */
    } /* if(BRAP_ChannelType_eDecode == hRapCh->eChannelType) */
    
    else if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
    {
#if 0    
        bSpdifMaiPresent = false;
        uiSpdifMaiPathindex =BRAP_INVALID_VALUE;
#endif        
        uiPth = 0;
        m=0;
        bAssociationNWDstnFound=false;
        BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));                    
        if(hRapCh->pDstDetails[0] == NULL)
        {
            BDBG_ERR(("There should atleast one valid destination."));
            ret = BERR_TRACE(BERR_INVALID_PARAMETER);
            goto end;
        }
        ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                        hRapCh->pDstDetails[0],
                                        pPvtDstDetails,
                                        &uiAssocId);
        if(BERR_SUCCESS!=ret)
        {
            ret = BERR_TRACE(ret);
            goto end;
        }
        if(BRAP_P_IsAssociationNWValid(pPvtDstDetails))
        {
            bAssociationNWDstnFound = true;
        }        

        if(NULL == hRapCh->pPath[uiPth])
        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                            ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                            ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif              
            if(BERR_SUCCESS != ret)
            {
                ret =  BERR_TRACE(ret);
                goto end;                
            }
        }
        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                            BRAP_P_UsgPath_eDecodePcm,
                            BRAP_INVALID_VALUE,
                            uiPth,
                            BRAP_INVALID_VALUE,0);
        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;

          /* Populate only if there is no Association network, since eDecodePCMPostMixing path feeds directly to Destination */
        if(bAssociationNWDstnFound == false)
        {
            uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[0];
#if 0            
            if(( hRapCh->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eOutputPort)
                &&((hRapCh->pDstDetails[0]->uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eSpdif)
                      ||(hRapCh->pDstDetails[0]->uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eMai)))
            {
                bSpdifMaiPresent =true;
                uiSpdifMaiPathindex=uiPth;
            }
#endif            
                BDBG_MSG(("Adding Output port %d to  Path type = %d", 
                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));
        }
        
        uiPth++;

#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)                         
        /*Populating Destination to Path. This was earlier done in DistributeDest() func */
        if(hRapCh->bIndepDelayEnabled == true)
        {
            for(m = 1 ; m < BRAP_P_MAX_DST_PER_RAPCH ; m++)
            {
            if( hRapCh->pDstDetails[m] != NULL)
            {
                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                    hRapCh->pDstDetails[m],
                                                    pPvtDstDetails,
                                                    &uiAssocId);
                    if(BERR_SUCCESS!=ret)
                    {
                        ret = BERR_TRACE(ret);
                        goto end;
                    }
                    if(BRAP_P_IsAssociationNWValid(pPvtDstDetails))
                    {
                        /* If DecodePCM/PPBranch path corresponding to Post-Mixing path 
                           is already formed then go to next destination */
                        if(bAssociationNWDstnFound == true)
                            continue; 
                    }
                    
                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                                           
                        if(BERR_SUCCESS != ret)
                        {
                            ret =  BERR_TRACE(ret);
                            goto end;                
                        }
                    }
                    
/*Disabling This Code because when HDMI and SPDIF is taking data from same SRC, IT is causing audio loss due to MIXER Rate Err*/                    
#if 0                    
                    if(( hRapCh->pDstDetails[m]->eAudioDst == BRAP_AudioDst_eOutputPort)
                        &&((hRapCh->pDstDetails[m]->uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eSpdif)
                              ||(hRapCh->pDstDetails[m]->uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eMai)))
                    {
                        if(true == bSpdifMaiPresent)
                        {
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_eSharedPP,
                                                                    BRAP_INVALID_VALUE,
                                                                    uiPth,
                                                                    BRAP_INVALID_VALUE,0);
                            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        
                            uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[m];
                            hRapCh->pPath[uiPth]->uiMasterpathId = 0;
                            k=uiSpdifMaiPathindex;
                            hRapCh->pPath[k]->bMixPath = true;
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = k;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[k]->sRsrcGrnt.uiDspId;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[k]->sRsrcGrnt.uiDspContextId;
                            hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[k]->hDsp; 
                            hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[k]->hDspCh;                     
                            BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));
                        }
                        else
                        {
                            bSpdifMaiPresent = true;
                            uiSpdifMaiPathindex = uiPth;
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_ePPBranch,
                                                                    BRAP_INVALID_VALUE,
                                                                    uiPth,
                                                                    BRAP_INVALID_VALUE,0);
                            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        
                            uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[m];
                            hRapCh->pPath[uiPth]->uiMasterpathId = 0;
                            
                            k=0;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[k]->sRsrcGrnt.uiDspId;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[k]->sRsrcGrnt.uiDspContextId;
                            hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[k]->hDsp; 
                            hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[k]->hDspCh;                     
                            BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                
                        }
                    }
                    else
#endif                        
                    {
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_ePPBranch,
                                                                    BRAP_INVALID_VALUE,
                                                                    uiPth,
                                                                    BRAP_INVALID_VALUE,0);
                            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        
                            uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[m];
                            hRapCh->pPath[uiPth]->uiMasterpathId = 0;
                            
                            k=0;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[k]->sRsrcGrnt.uiDspId;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[k]->sRsrcGrnt.uiDspContextId;
                            hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[k]->hDsp; 
                            hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[k]->hDspCh;                     
                            BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                
                    }    
                    uiPth++;                
            }
        }
        }
         else
#endif            
        {
            for(m = 1; m < BRAP_P_MAX_DST_PER_RAPCH ; m++)
            {
                if( hRapCh->pDstDetails[m] != NULL)
                {        
                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                    hRapCh->pDstDetails[m],
                                                    pPvtDstDetails,
                                                    &uiAssocId);
                    if(BERR_SUCCESS!=ret)
                    {
                        ret = BERR_TRACE(ret);
                        goto end;
                    }
                    if(BRAP_P_IsAssociationNWValid(pPvtDstDetails))
                    {
                        /* If Destination details corresponding to Post-Mixing path are already 
                           populated in DecodePCM/PPBranch path then go to next destination */
                        if(bAssociationNWDstnFound == true)
                            continue;
                        else
                            bAssociationNWDstnFound = true;
                    }
                    
                    uiDestCount = hRapCh->pPath[uiPth -1]->uiDestcount++;
                    hRapCh->pPath[uiPth -1]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[m];
                    BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth -1]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth -1]->eUsgPath));                                                  
                }
            }
        }



        /* See if any added destination needs Internal Capture Path */
        for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
        {
            if(NULL == hRapCh->pDstDetails[i])
                continue;
            /* Find the association ID for the destination */
            BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));           
            
            ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                hRapCh->pDstDetails[i],
                                                                pPvtDstDetails,
                                                                &uiAssocId);
            if(BERR_SUCCESS!=ret)
            {
                ret = BERR_TRACE(ret);
                goto end;                
            }

            if(BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst)
            {
                if(NULL == hStartedAssoCh[uiAssocId])
                {
                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
										ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
										ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        { 
                            ret = BERR_TRACE(ret);
                            goto end;                            
                        }
                    }                        
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                                            BRAP_P_UsgPath_eCapture,
                                                            BRAP_INVALID_VALUE,
                                                            uiPth,
                                                            BRAP_INVALID_VALUE,0);
                        hRapCh->pPath[uiPth]->uiAssocId = BRAP_INVALID_VALUE;
                        flag =false;
                        for (j =0;j< BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            for(k =0 ; k < hRapCh->pPath[j]->uiDestcount ; k++)
                            {                                
                                if(hRapCh->pPath[j]->pDstDetails[k] ==NULL)
                                    break;
                                else if(hRapCh->pPath[j]->pDstDetails[k]  == hRapCh->pDstDetails[i])
                                {                                    
                                    hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                                    /* Set the out path index of previous path */
                                    hRapCh->pPath[j]->sOutPathProp[0].uiPathIdx = uiPth;
                                    flag =true;
                                    break;
                                }
                            }
                            if(flag == true)
                                break;                       
                        }
                         /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;                         
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[i];
                }
                else
                {
                    flag = false;
                    /* Copy the relevant path from the started channel */
                    for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                    {
                        if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                            (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                            (BRAP_P_UsgPath_eCapture == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath))
                        {
                            for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
                            {
                                if(hStartedAssoCh[uiAssocId]->pPath[j]->pDstDetails[k] == 
                                            hRapCh->pDstDetails[i])
                                { 
                                    hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                    BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                                    uiPth, hRapCh->pPath[uiPth]->eUsgPath));
                                    uiPth++;                                    
                                    flag = true;
                                    break;
                                }
                            }
                            if (flag == true)
                            break;                            
                        }
                    }
                }
                (*uiNumCapPath)++;                
                uiPth++;   
            }
        }
            
        /******* Association Network *******/
        for(l=0; l<BRAP_MAX_ASSOCIATED_GROUPS; ++l)
        {
            if(hRapCh->uiAssociationId[l] == BRAP_INVALID_VALUE)
                continue;
            
            uiAssocId = hRapCh->uiAssociationId[l];

            /*Check for association network*/
            if(BRAP_P_NETWORK_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage))
            {   
                BDBG_MSG(("Allocating the path for Association Network"));            
                i=0;
                bCompress = false;
                BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));                    

                for(i=0; i<BRAP_P_MAX_DST_PER_RAPCH; i++)
                {
                    if(NULL != hRapCh->pDstDetails[i])
                    {
                        ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                        hRapCh->pDstDetails[i],
                                                        pPvtDstDetails,
                                                        &m);
                        if(BERR_SUCCESS!=ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;                
                        }
                        if((m == uiAssocId) && (BRAP_P_IsAssociationNWValid(pPvtDstDetails)))
                        {
                            break;
                        }
                    }            
                }
                if(i >= BRAP_P_MAX_DST_PER_RAPCH)
                {
                    BDBG_MSG(("No destination found in Association Network"));
                    ret = BERR_NOT_SUPPORTED;
                    goto end;
                }

                m = BRAP_INVALID_VALUE;

                /* Check if the Path outputs the compress data  */
                for(m =0; m < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; m++)
                {
                    if(NULL == pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m])
                        break;

                    eAudioProcessing = pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m]->sProcessingStageSettings.eAudioProcessing;

                    BDBG_MSG(("pPvtDstDetails->eAudProcessing[j] = %d",eAudioProcessing));

                    if((BRAP_ProcessingType_eConvertDdpToAc3  == eAudioProcessing)
                        ||(BRAP_ProcessingType_eWmaProPassThru == eAudioProcessing)                              
                        ||(BRAP_ProcessingType_eEncodeDts== eAudioProcessing)
                        ||(BRAP_ProcessingType_eGenericPassthru==eAudioProcessing)
                        ||(BRAP_ProcessingType_eEncodeAc3==eAudioProcessing)
                        ||(BRAP_ProcessingType_eEncodeMp3==eAudioProcessing)
                        ||(BRAP_ProcessingType_ePassthru==eAudioProcessing))
                    {
                        bCompress = true;
                    }
                }
                if(m>0)
                {
                    uiLastStage = m -1;
                }
                else
                {
                    uiLastStage = BRAP_INVALID_VALUE;
                    BDBG_ERR(("Network must have one valid stage"));
                    ret = BERR_TRACE(BERR_INVALID_PARAMETER);
                    goto end;                    
                }
                
                if(BRAP_AudioDst_eMax != hRapCh->pDstDetails[i]->eAudioDst)
                {
                    if(NULL == hStartedAssoCh[uiAssocId])
                    {
                        BRAP_AssociatedChannelHandle hAssociation;
                        hAssociation = &(hRapCh->hRap->sAssociatedCh[uiAssocId]);
 
                        for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; ++k)
                            { 
                            if(!(BRAP_P_BRANCH_VALID(hRapCh->sChAudProcessingStage,k)))
                            {
                                break;
                            }
                            for(m=0; m<BRAP_MAX_PP_PER_BRANCH_SUPPORTED; ++m)
                            {
                                if(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,m))
                                {
                                    continue;
                                }
                                else
                                    break;
                            }
                            /*Valid stage is before this value of m so subtract 1*/
                            m--;
                            
                            /*Get the path index*/
                            if(hRapCh->sChAudProcessingStage[k][m].hValidDestHandle == pPvtDstDetails)
                            {
                                ret = BRAP_P_GetInputPathIndexForAssociation(hRapCh,uiAssocId,&j);
                                if(BERR_SUCCESS != ret)
                                { 
                                    ret = BERR_TRACE(ret);
                                    goto end;                            
                                }
                                break;
                            }
                        } /*for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; ++k)*/
                        if(k >= BRAP_P_MAX_DST_PER_RAPCH)
                        {
                            ret = BERR_NOT_SUPPORTED;
                            BDBG_ERR(("Valid Destination not found in Channel Processing stage"));
                            goto end;                            
                        }
                        
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                            if(BERR_SUCCESS != ret)
                            { 
                                ret =  BERR_TRACE(ret);
                                goto end;                                    
                            }
                        }
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                            BRAP_P_UsgPath_eCapture,
                                            BRAP_INVALID_VALUE,
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);
                        flag = false;
                        /* Link current and previous path */
                        if((j < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                           (hRapCh->pPath[j] != NULL))
                        {
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                            for(n=0; n<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; ++n)
                            {
                                if(hRapCh->pPath[j]->sOutPathProp[n].uiPathIdx == BRAP_INVALID_VALUE)
                                {
                                    /* Set the out path index of previous path */
                                    hRapCh->pPath[j]->sOutPathProp[n].uiPathIdx = uiPth;
                                    flag = true;
                                    break;                            
                                }
                            }
                        }
                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        (*uiNumCapPath)++;                
                        uiPth++;
                        
                        if(true == bCompress)
                        {
                            /*Now allocate BRAP_P_UsgPath_eDecodeCompressPostMixing because 
                            first row of association network is available*/
                            if(NULL == hRapCh->pPath[uiPth])
                            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                                if(BERR_SUCCESS != ret)
                                {
                                    ret = BERR_TRACE(ret);
                                    goto end;                    
                                }
                            }
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_eDecodeCompressPostMixing,
                                                                    BRAP_INVALID_VALUE,
                                                                    uiPth,
                                                                    BRAP_INVALID_VALUE,0);

                            /* Instantiate the DSP Channel corresponding to the DSP context resource 
                            manager has allocated */
                            
                            ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                                        &hAssociation,
                                                        false,
                                                        pDspChSettings);
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                                goto end;
                            }
                            hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;

                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = uiPth-1;
                            for(n=0; n<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; ++n)
                            {
                                if(hRapCh->pPath[uiPth-1]->sOutPathProp[n].uiPathIdx == BRAP_INVALID_VALUE)
                                {
                                    /* Set the out path index of previous path */
                                    hRapCh->pPath[uiPth-1]->sOutPathProp[n].uiPathIdx = uiPth;
                                    flag = true;
                                    break;                            
                                }
                            }
                            hRapCh->pPath[uiPth-1]->uiAssocId = uiAssocId;                        
                            hRapCh->pPath[uiPth]->pDstDetails[hRapCh->pPath[uiPth]->uiDestcount++] =
                                &(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage]->hDestHandle[0]->sExtDstDetails);                                                                        
                            BDBG_MSG(("Adding OutputPort %d to Path = %d",
                                hRapCh->pPath[uiPth]->pDstDetails[hRapCh->pPath[uiPth]->uiDestcount -1]->uDstDetails.sOpDetails.eOutput[0],uiPth));
                            
                            uiPth++;
                        }
                        else
                        {
                            if(NULL == hRapCh->pPath[uiPth])
                            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                                if(BERR_SUCCESS != ret)
                                { 
                                    ret = BERR_TRACE(ret);
                                    goto end;                                
                                }
                            }                        
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                                BRAP_P_UsgPath_eDecodePcmPostMixing,
                                                BRAP_INVALID_VALUE,
                                                uiPth,
                                                BRAP_INVALID_VALUE,0);

                            /* Instantiate the DSP Channel corresponding to the DSP context resource 
                            manager has allocated */
                            
                            ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                                        &hAssociation,
                                                        false,
                                                        pDspChSettings);
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                                goto end;
                            }
                            hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;

                            /* Update Inlink and Outlink */
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = uiPth-1;
                            for(n=0; n<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; ++n)
                            {
                                if(hRapCh->pPath[uiPth-1]->sOutPathProp[n].uiPathIdx == BRAP_INVALID_VALUE)
                                {
                                    /* Set the out path index of previous path */
                                    hRapCh->pPath[uiPth-1]->sOutPathProp[n].uiPathIdx = uiPth;
                                    flag = true;
                                    break;                            
                                }
                            }
                            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                            hRapCh->pPath[uiPth]->pDstDetails[hRapCh->pPath[uiPth]->uiDestcount++] =
                                &(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage]->hDestHandle[0]->sExtDstDetails);                                                                        
                            BDBG_MSG(("Adding OutputPort %d to Path = %d",
                                hRapCh->pPath[uiPth]->pDstDetails[hRapCh->pPath[uiPth]->uiDestcount -1]->uDstDetails.sOpDetails.eOutput[0],uiPth)); 
                            
                            uiPth++;   
                        }                      
                    } /*if(NULL == hStartedAssoCh[uiAssocId])*/
                    else
                    {                    
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
/* Currently MS11 usage mode at max has 2 decode and 1 PB channels, 
   and no resources are shared among them as decode channels output to DRAM and PB to RBUF.
   ToDo: If multiple PB channels per Assoc need to be supported */
                        if(BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh))
                        {
                            if(NULL == hRapCh->pPath[uiPth])
                            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                                                            
                                if(BERR_SUCCESS != ret)
                                { 
                                    ret =  BERR_TRACE(ret);
                                    goto end;                                    
                                }
                            }
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                                BRAP_P_UsgPath_eCapture,
                                                BRAP_INVALID_VALUE,
                                                uiPth,
                                                BRAP_INVALID_VALUE,0);
                            flag = false;
                            for (j =0;j< BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                            {
                                if(NULL == hRapCh->pPath[j])
                                {
                                    continue;
                                }
                                if(hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)
                                {
                                    hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                                    for(n=0; n<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; ++n)
                                    {
                                        if(hRapCh->pPath[j]->sOutPathProp[n].uiPathIdx == BRAP_INVALID_VALUE)
                                        {
                                            /* Set the out path index of previous path */
                                            hRapCh->pPath[j]->sOutPathProp[n].uiPathIdx = uiPth;
                                            flag = true;
                                            break;                            
                                        }
                                    }
                                }
                                if(flag == true)
                                {
                                    break;
                                }
                            }
                            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                            (*uiNumCapPath)++;                
                            uiPth++;
                        }
#endif                    
                        /* Copy the relevant path from the started channel */
                        for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                        {
                            if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                               (NULL == hRapCh->pPath[uiPth])&&
                               (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                               (hStartedAssoCh[uiAssocId]->pPath[j]->pDstDetails[0] == hRapCh->pDstDetails[i]))
                            {
                                hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                for(k=0; k<BRAP_P_MAX_IN_PARALLEL_FMM_PATH; k++)
                                {
                                    if(BRAP_INVALID_VALUE == hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx)
                                        break;
                                }
                                hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx = uiPth-1;
                                hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;
                                BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                                uiPth, hRapCh->pPath[uiPth]->eUsgPath));                                
                                uiPth++;
                                break;                            
                            }
                        }
                    }
                } /*if(((BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[i]->eAudioDst)&&*/

                /* Check for more destinations connected to Association Network */
                ret = BRAP_P_FormPostMixingPathsForSubsequentDestinations(i, uiPth, uiAssocId, pAudioParams,hRapCh);
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    BDBG_ERR(("FormPostMixingPathsForSubsequentDestinations failed with err = %d", ret));
                    goto end;
                }           
            } /* if(BRAP_P_NETWORK_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage)) */
        } /* for(l=0; l<BRAP_MAX_ASSOCIATED_GROUPS; ++l) */
    } /* else if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType) */

    else if(BRAP_ChannelType_ePcmCapture == hRapCh->eChannelType)
    {
        if(BRAP_CaptureMode_eCaptureOnly == pAudioParams->eCapMode)
        {
            uiPth = 0;
            if(NULL == hRapCh->pPath[uiPth])
            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;                    
                }
            }
            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                    BRAP_P_UsgPath_eCapture,
                                                    BRAP_INVALID_VALUE,
                                                    uiPth,
                                                    BRAP_INVALID_VALUE,0);
            uiPth++;

           
           /* See if any added destination needs Internal Capture Path */
            for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
            {
                if(NULL == hRapCh->pDstDetails[i])
                    continue;
                BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));                    
                ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                    hRapCh->pDstDetails[i],
                                                                    pPvtDstDetails,
                                                                    &uiAssocId);
                if(BERR_SUCCESS!=ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;
                }

                if(BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst)
                {
                    if(NULL == hStartedAssoCh[uiAssocId])
                    {
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                goto end;                                
                            }
                        }
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                BRAP_P_UsgPath_eCapture,
                                                                BRAP_INVALID_VALUE,
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        hRapCh->pPath[uiPth]->uiAssocId = BRAP_INVALID_VALUE;
                        flag =false;
                        for (j =0;j< BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            for(k =0 ; k < hRapCh->pPath[j]->uiDestcount ; k++)
                            {                                
                                if(hRapCh->pPath[j]->pDstDetails[k] ==NULL)
                                    break;
                                else if(hRapCh->pPath[j]->pDstDetails[k]  == hRapCh->pDstDetails[i])
                                {                                    
                                    hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                                    /* Set the out path index of previous path */
                                    hRapCh->pPath[j]->sOutPathProp[0].uiPathIdx = uiPth;
                                    flag =true;
                                    break;
                                }
                            }
                            if(flag == true)
                                break;                       
                        }
                        
                        /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[i];

                    }
                    else
                    {
                        flag = false;
                        /* Copy the relevant path from the started channel */
                        for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                        {
                            if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                            (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                            (BRAP_P_UsgPath_eCapture == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath))
                            {
                                for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
                                {
                                    if(hStartedAssoCh[uiAssocId]->pPath[j]->pDstDetails[k] == 
                                    hRapCh->pDstDetails[i])
                                    {
                                        hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                        flag = true;
                                        break;
                                    }
                                }
                            }
                        }
                        BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                        uiPth, hRapCh->pPath[uiPth]->eUsgPath));
                    }
                    (*uiNumCapPath)++;                
                    uiPth++;
                }
            }
        }
        else if(BRAP_CaptureMode_eFullDuplex == pAudioParams->eCapMode)
        {
            if(BRAP_P_NETWORK_VALID(hRapCh->sChAudProcessingStage))
            {
                for(j=0; j<BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED; j++)
                {
                    if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,0,j)))
                        break;
                }
                j--;        
                ret = BRAP_P_GetAssocId(hRapCh,
                                        &(hRapCh->sChAudProcessingStage[0][j].hValidDestHandle->sExtDstDetails),
                                        &uiAssocId );    
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;
                }

            }
            else if ( hRapCh->pDstDetails[0] != NULL)
            {
                ret = BRAP_P_GetAssocId(hRapCh,
                                        (hRapCh->pDstDetails[0]),
                                        &uiAssocId );    
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;
                }
            }
            else
            {
                BDBG_ERR(("No destination added to Capture Ch"));
                BDBG_ASSERT(0);
            }
            
            uiPth = 0;
            if(NULL == hRapCh->pPath[uiPth])
            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;                    
                }
            }
            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                    BRAP_P_UsgPath_eCapture,
                                                    BRAP_INVALID_VALUE,
                                                    uiPth,
                                                    (uiPth+1),0);
            hRapCh->pPath[uiPth]->uiAssocId = BRAP_INVALID_VALUE;
            
            /* Instantiate the DSP Channel corresponding to the DSP context resource 
            manager has allocated */
            ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                        &hRapCh,
                                        true,
                                        pDspChSettings);
            if(BERR_SUCCESS != ret)
            {
                ret = BERR_TRACE(ret);
                BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                goto end;
            }
            hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;
            
            uiPth++;
            if(NULL == hRapCh->pPath[uiPth])
            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;                    
                }
            }
            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                    BRAP_P_UsgPath_eDecodePcm,
                                                    (uiPth -1),
                                                    uiPth,
                                                    BRAP_INVALID_VALUE,0);

            /* Before we update the resource grant, let us take out the DSP resources & put it in here */
            /* DSP was allocated in path 0, but now moved to path 1 */ 
            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
            hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp;
            hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh;
            
            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;            

#if ((BRAP_3548_FAMILY == 1) || (BRAP_7405_FAMILY == 1))
            if((BRAP_P_NETWORK_VALID(hRapCh->sChAudProcessingStage)))
            {
                /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[0][0].hValidDestHandle->sExtDstDetails);
                BDBG_MSG(("Adding Output port %d to Decode PCM Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount]->uDstDetails.sOpDetails.eOutput[0]));  
                uiPth++;

                /* Start Multi Branch code */
                for(i=1; i<BRAP_P_MAX_DST_PER_RAPCH; i++)
                {   
                    if(!(BRAP_P_BRANCH_VALID(hRapCh->sChAudProcessingStage,i)))                
                    {
                        break;
                    }
        #if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)                 
                    bIndepPathRequire = false;      
        #endif
                    bDownmixPathRequire = false;                
                    bBranchCloned = flag = bMixPathRequire = false;
                    uiClonedBranch = BRAP_INVALID_VALUE;                            
                    for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
                    {
                        uiCloneBranchId[k] = BRAP_INVALID_VALUE;
                    }
                    for (j = 0; j < BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED; j++)
                    {
                        if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,i,j)))  
                            break;
                    }
                    if((true == hRapCh->sChAudProcessingStage[i][j-1].bCloneStage)) 
                    {
                            flag = true;
                    }

                    /* Last valid stage id */
                        uiLastStage  = j -1;   

                    ret = BRAP_P_GetAssocId(hRapCh,
                                &(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails),
                                &uiAssocId );    
                    if(BERR_SUCCESS != ret)
                    {
                        ret = BERR_TRACE(ret);
                        goto end;
                    }
                    
                    if(flag == false)
                    {
                        bBranchCloned = false;
                    }
                    else
                    {
                        ui32MasterBranchId = k= hRapCh->sChAudProcessingStage[i][uiLastStage].ui32MasterBranchId;
                        ui32MasterStageId = l= hRapCh->sChAudProcessingStage[i][uiLastStage].ui32MasterStageId;
                        m=0;
                        /* Check if the current branch is the clone of master branch of last stage of the current branch */
                        if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,l+1)))           
                        {
                            bBranchCloned = true;
                            uiCloneBranchId[m]=k;
                            m++;
                            k++;
                        }
                        /* Now check if the branches between Master branch and current branch is similar to current  branch.
                        This is done by checking if the last stage is cloned, and its Master stage/branch id 
                        is same as that of last stage id of current branch. Just to make clear, here 
                        Current Branch/Stage Id is : i/uiLastStage
                        Master Branch/Stage Id is : ui32MasterBranchId/ui32MasterStageId
                        And we looping on K, which is between ui32MasterBranchId and i*/                                    
                        for(; k<i; ++k)
                        {
                            if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,l+1)))
                        {   
                                if((true == hRapCh->sChAudProcessingStage[k][l].bCloneStage)
                                    &&(hRapCh->sChAudProcessingStage[k][l].ui32MasterBranchId == ui32MasterBranchId)
                                    &&(hRapCh->sChAudProcessingStage[k][l].ui32MasterStageId == ui32MasterStageId)
                                    &&(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,l+1))))
                            {
                                bBranchCloned = true;
                                uiCloneBranchId[m]=k;
                                m++;
                            } 
                        }
                        }
                        /* Now if there  are branches which are cloned to current then, Are they in same
                        association? If no then Create a Mix Path corresponding to them , If not created 
                        already.*/
                        if(bBranchCloned == true)
                        {
                            if(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                            {                    
                            for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                            {
                                if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                    break;
                                
                                k = uiCloneBranchId[m];
                                /* For cloned branch */
                                    
                                    if((hRapCh->eChannelOutputMode ==BRAP_OutputMode_e2_0)
                                        ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == 
                                        hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort))
                                    {
                                        bDownmixPathRequire = false;
                                        uiClonedBranch = k;
                                        break;
                                    }
                                    else if (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0)
                                    {
                                        bDownmixPathRequire = true;
                                    }
                                }
                            }
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)                                  
                            if((false == bDownmixPathRequire))
                            {                        
                            /*If its Mai and Muxselector is not Mai, then dont create path for it */
                                if( (!((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                                       &&(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eMai)
                                       &&(hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiSettings.eMaiMuxSelector != BRAP_OutputPort_eMai)))
                                    ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) )
                                {
                                       for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                                        {
                                            if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                                break;
                                            
                                            k = uiCloneBranchId[m];
                                            /* For cloned branch */
                                            /*If the Destination has Indepdelay Enabled then create similar path to its cloned.*/
                                            if((hRapCh->bIndepDelayEnabled == true)
                                                &&((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer)
                                                   ||(hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer)
                                                   ||(hRapCh->eChannelOutputMode ==BRAP_OutputMode_e2_0)
                                                   ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == 
                                                      hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort))
                                              )
                                                {
                                                    bIndepPathRequire = true;
                                                    uiClonedBranch = k;                                                                                
                                                    break;
                                                }
                                                else
                                                {
                                                    bIndepPathRequire = false;
                                                    uiClonedBranch = k;                                            
                                                }
                                        }                        
                                    }                        
                                }
#endif                        
                            
                            if((false == bIndepPathRequire)
                                &&(false == bDownmixPathRequire))
                            {
                                for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                                {
                                    if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                        break;
                                    
                                    k = uiCloneBranchId[m];
                                    /* For cloned branch */
                                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                                    &(hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails),
                                                                                    pPvtDstDetails,
                                                                                    &uiCloneAssocId);
                                    if(BERR_SUCCESS!=ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto end;                
                                    }
                                    /* For this branch */
                                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                                        &(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails),
                                                                                        pPvtDstDetails,
                                                                                        &uiAssocId);
                                    if(BERR_SUCCESS!=ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto end;                
                                    }
                                    if(uiAssocId == uiCloneAssocId)
                                    {
                                        bMixPathRequire = false;
                                        uiClonedBranch = k;                                
                                        break;
                                    }
                                    else
                                    {
                                        bMixPathRequire = true;
                                    }
                                }
                            }                            
                        } /*if(bBranchCloned == true)*/
                    } /*if(j == BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED)*/
                    BDBG_MSG(("bBranchCloned=%d uiAssocId=%d uiCloneAssocId=%d",
                    bBranchCloned,uiAssocId,uiCloneAssocId));
                    if(((false == bBranchCloned)&&(BRAP_P_BRANCH_VALID(hRapCh->sChAudProcessingStage,i)))
                        ||((true == bBranchCloned) && (true == bDownmixPathRequire)))
                    {

                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                goto end;                            
                            }
                        }
                        if((((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                             &&(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == true))
                            ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer))
                           && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))    /* Capture to rbuf is required in stereo mode as of now */
                        {
                        
    /*                        if(uiLastStage == 0)*/
                            {
                                BDBG_MSG(("BRAP_P_UsgPath_eDownmixedPath"));                                        
                                BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                        BRAP_P_UsgPath_eDownmixedPath,
                                                                        BRAP_INVALID_VALUE, 
                                                                        uiPth,
                                                                        BRAP_INVALID_VALUE,0);
                            }
                        }
                        else
                    {
                        BDBG_MSG(("BRAP_P_UsgPath_ePPBranch"));
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                BRAP_P_UsgPath_ePPBranch,
                                                                BRAP_INVALID_VALUE, 
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        }
                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                        hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp; 
                        hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh; 
                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;

                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails);
                        BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[m]->eUsgPath));  
                        uiPth++;
                    } /*if((false == bBranchCloned)&&*/
                    else if ((true == bBranchCloned) && (true == bMixPathRequire))
                    {   
                        /*Find the Path which is having cloned port */
                        ret = BRAP_P_GetPathIndex(hRapCh,pAudioParams,k,uiCloneOp,&m);
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                goto end;                            
                            }
                        }   
                        if((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                            &&(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == true)
                            && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))
                        {
                            BDBG_MSG(("BRAP_P_UsgPath_eDownmixedMixPath uiPth=%d",uiPth));                        
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_eDownmixedMixPath,
                                                                BRAP_INVALID_VALUE, 
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        }
                        else
                        {
                            BDBG_MSG(("BRAP_P_UsgPath_eMixPath uiPth=%d",uiPth));                       
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                BRAP_P_UsgPath_eMixPath,
                                                                BRAP_INVALID_VALUE, 
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        
                        }
                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        /*Mark the path which is cloned for this stage as mix*/
                        BDBG_MSG(("Input to mix path uiPth=%d",m));
                        hRapCh->pPath[m]->bMixPath = true;
                        hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = m;
                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[m]->sRsrcGrnt.uiDspId;
                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[m]->sRsrcGrnt.uiDspContextId;
                        hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[m]->hDsp; 
                        hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[m]->hDspCh; 

                        /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails);
                        BDBG_MSG(("Adding Output port %d to Mix PCM Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0]));  

                        ++uiPth;
                    } /*else if ((true == bBranchCloned) &&(uiAssocId != uiCloneAssocId))*/
                    else
                    {
                        /* If Independent delay is on, then a corresponding path is created for the destination. Otherwise
                        no path is created for this destination. So add this destination to the path it belong.*/
                        uiCloneOp++;
                        flag = false;
                        for(m =0 ; m < uiPth ; m++)
                        {
                            uiDestCount = hRapCh->pPath[m]->uiDestcount;
                            
                            for(n =0 ; n < uiDestCount ; n++)
                            {
                                
                                if(hRapCh->pPath[m]->pDstDetails[n] == 
                                    &(hRapCh->sChAudProcessingStage[uiClonedBranch][0].hValidDestHandle->sExtDstDetails))
                                {
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)          
                                    if(bIndepPathRequire == true)
                                    {/* Create a Path */

                                        switch(hRapCh->pPath[m]->eUsgPath)
                                        {
                                            case BRAP_P_UsgPath_eDecodePcm:
                                            case BRAP_P_UsgPath_eDecodeCompress:                                            
                                            case BRAP_P_UsgPath_ePPBranch:                                            
                                            case BRAP_P_UsgPath_eMixPath:                                            
                                            case BRAP_P_UsgPath_eSharedPP:                                                                          
                                                ePathType = BRAP_P_UsgPath_ePPBranch;
                                                break;
                                            case BRAP_P_UsgPath_eDownmixedPath:
                                            case BRAP_P_UsgPath_eDownmixedMixPath:                                            
                                                ePathType = BRAP_P_UsgPath_eDownmixedPath;
                                                break;
                                            default:
                                                ePathType = BRAP_P_UsgPath_ePPBranch;
                                                break;
                                        }
                                        
                                        if(NULL == hRapCh->pPath[uiPth])
                                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                                            if(BERR_SUCCESS != ret)
                                            {
                                                ret = BERR_TRACE(ret);
                                                goto end;                            
                                            }
                                        }
                                        BDBG_MSG(("BRAP_P_UsgPath = %d",ePathType));
                                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                                ePathType,
                                                                                BRAP_INVALID_VALUE, 
                                                                                uiPth,
                                                                                BRAP_INVALID_VALUE,0);

                                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                                        hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp; 
                                        hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh; 
                                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                                        hRapCh->pPath[uiPth]->uiMasterpathId = m;

                                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails);
                                        BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));  
                                        uiPth++;                                    
                                        
                                    }
                                    else
#endif                                    
                                    {                                        
                                    hRapCh->pPath[m]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails);                                
                                        BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[m]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[m]->eUsgPath));                                      
                                    hRapCh->pPath[m]->uiDestcount++;
                                    }
                                    flag =true;
                                    break;
                                }
                            }
                            if(true == flag)
                                break;
                        }
                    }
                }    
            }
            else
            /* End Multi Branch code */ 
#endif
            {
                if( hRapCh->pDstDetails[0] != NULL)
                {
                    uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[0];
                    BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                                  
                }
                
                uiPth++;

#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)                         
        /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                if(hRapCh->bIndepDelayEnabled == true)
                {
                    for(m = 1 ; m < BRAP_P_MAX_DST_PER_RAPCH ; m++)
                    {
                        if( hRapCh->pDstDetails[m] != NULL)
                        {
                                ret = BRAP_P_GetAssocId(hRapCh,
                                                        (hRapCh->pDstDetails[m]),
                                                        &uiAssocId );    
                                if(BERR_SUCCESS != ret)
                                {
                                    ret = BERR_TRACE(ret);
                                    goto end;
                                }

                        
                                if(NULL == hRapCh->pPath[uiPth])
                                {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                                    if(BERR_SUCCESS != ret)
                                    {
                                        ret =  BERR_TRACE(ret);
                                        goto end;                
                                    }
                                }
                                BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                        BRAP_P_UsgPath_eSharedPP,
                                                                        BRAP_INVALID_VALUE,
                                                                        uiPth,
                                                                        BRAP_INVALID_VALUE,0);
                                hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                            
                            uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[m];
/*                            hRapCh->pPath[uiPth]->uiMasterpathId = 1;*/

                            k=uiPth-1;
                            hRapCh->pPath[k]->bMixPath = true;
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = k;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[k]->sRsrcGrnt.uiDspId;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[k]->sRsrcGrnt.uiDspContextId;
                            hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[k]->hDsp; 
                            hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[k]->hDspCh; 
                            
                            BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                                                  
                            uiPth++;                
                        }
                    }
                }
                else
#endif            
                {
                    for(m = 1 ; m < BRAP_P_MAX_DST_PER_RAPCH ; m++)
                    {
                        if( hRapCh->pDstDetails[m] != NULL)
                        {        
                            uiDestCount = hRapCh->pPath[uiPth -1]->uiDestcount++;
                            hRapCh->pPath[uiPth -1]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[m];
                            BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth -1]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth -1]->eUsgPath));                                                  
                        }
                    }
                }
            }

            /* See if any added destination needs Internal Capture Path */
            for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
            {
                if(NULL == hRapCh->pDstDetails[i])
                    continue;
                if(BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst)
                {
                    BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));                    
                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                        hRapCh->pDstDetails[i],
                                                                        pPvtDstDetails,
                                                                        &uiAssocId);
                    if(BERR_SUCCESS!=ret)
                    {
                        ret = BERR_TRACE(ret);
                        goto end;
                    }
                    if(NULL == hStartedAssoCh[uiAssocId])
                    {
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                goto end;                                
                            }
                        }
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                BRAP_P_UsgPath_eCapture,
                                                                BRAP_INVALID_VALUE,
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        hRapCh->pPath[uiPth]->uiAssocId = BRAP_INVALID_VALUE;
                        flag =false;
                        for (j =0;j< BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            for(k =0 ; k < hRapCh->pPath[j]->uiDestcount ; k++)
                            {                                
                                if(hRapCh->pPath[j]->pDstDetails[k] ==NULL)
                                    break;
                                else if(hRapCh->pPath[j]->pDstDetails[k]  == hRapCh->pDstDetails[i])
                                {                                    
                                    hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                                    /* Set the out path index of previous path */
                                    hRapCh->pPath[j]->sOutPathProp[0].uiPathIdx = uiPth;
                                    flag =true;
                                    break;
                                }
                            }
                            if(flag == true)
                                break;                       
                        }

                        /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;                        
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[i];
                        
                    }
                    else
                    {
                        flag = false;
                        /* Copy the relevant path from the started channel */
                        for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                        {
                            if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                            (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                            (BRAP_P_UsgPath_eCapture == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath))
                            {
                                for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
                                {
                                    if(hStartedAssoCh[uiAssocId]->pPath[j]->pDstDetails[k] == 
                                    hRapCh->pDstDetails[i])
                                    {
                                        hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                        flag = true;
                                        break;
                                    }
                                }
                            }
                        }
                        BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                        uiPth, hRapCh->pPath[uiPth]->eUsgPath));
                    }
                    (*uiNumCapPath)++;
                    uiPth++;
                }
            } /*for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)*/
        }
        (*uiNumCapPath)++;
        
        /*Check for association network*/
        for(l=0; l<BRAP_MAX_ASSOCIATED_GROUPS; ++l)
        {
            if(hRapCh->uiAssociationId[l] == BRAP_INVALID_VALUE)
                continue;
            
            uiAssocId = hRapCh->uiAssociationId[l];
            /*Check for association network*/
            if(BRAP_P_NETWORK_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage))
            {
                i=0;
                bCompress = false;
                if(NULL != hRapCh->pDstDetails[i])
                {
                BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));
                /*Find the audio procsssing for the destination of the row on association network*/
                ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                    hRapCh->pDstDetails[i],
                                                                    pPvtDstDetails,
                                                                    &m);
                if(BERR_SUCCESS!=ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;                
                }
                if(m != uiAssocId)
                {
                    continue;
                }
                /* Check if the Path outputs the compress data  */
                if(BRAP_P_IsAssociationNWValid(pPvtDstDetails))
                {
                    for(m =0; m < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; m++)
                    {
                        if(NULL == pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m])
                            break;
                        eAudioProcessing = pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m]->sProcessingStageSettings.eAudioProcessing;

                        BDBG_MSG(("pPvtDstDetails->eAudProcessing[j] = %d",eAudioProcessing));

                        if((BRAP_ProcessingType_eConvertDdpToAc3  == eAudioProcessing)
                        ||(BRAP_ProcessingType_eWmaProPassThru == eAudioProcessing)                              
                        ||(BRAP_ProcessingType_eEncodeDts== eAudioProcessing)
                        ||(BRAP_ProcessingType_eEncodeAc3==eAudioProcessing)
                        ||(BRAP_ProcessingType_eGenericPassthru==eAudioProcessing)
                        ||(BRAP_ProcessingType_eEncodeMp3==eAudioProcessing)
                        ||(BRAP_ProcessingType_ePassthru==eAudioProcessing))
                        {
                            bCompress = true;
                        }
                    }
                }
                }

                if(m>0)
                {
                    uiLastStage = m -1;
                }
                else
                {
                    uiLastStage = BRAP_INVALID_VALUE;
                    BDBG_ERR(("Network must have one valid stage"));
                    ret = BERR_TRACE(BERR_INVALID_PARAMETER);
                    goto end;                    
                }
                
                if(((BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[i]->eAudioDst)) ||
                (BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst))
                {
                    if(NULL == hStartedAssoCh[uiAssocId])
                    {
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                goto end;                            
                            }
                        }
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                BRAP_P_UsgPath_eCapture,
                                                                BRAP_INVALID_VALUE,
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        flag = false;
                        for (j =0;j< BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            if(hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)
                            {
                                hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                                for(n=0; n<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; ++n)
                                {
                                    if(hRapCh->pPath[j]->sOutPathProp[n].uiPathIdx == BRAP_INVALID_VALUE)
                                    {
                                        /* Set the out path index of previous path */
                                        hRapCh->pPath[j]->sOutPathProp[n].uiPathIdx = uiPth;
                                        flag = true;
                                        break;
                                    }
                                }
                            }
                        }
                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        (*uiNumCapPath)++;
                        uiPth++;
                        if(true == bCompress)
                        {
                            /*Now allocate BRAP_P_UsgPath_eDecodeCompressPostMixing because 
                            first row of association network is available*/
                            if(NULL == hRapCh->pPath[uiPth])
                            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                                
                                if(BERR_SUCCESS != ret)
                                {
                                    ret = BERR_TRACE(ret);
                                    goto end;                                
                                }
                            }
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_eDecodeCompressPostMixing,
                                                                    BRAP_INVALID_VALUE,
                                                                    uiPth,
                                                                    BRAP_INVALID_VALUE,0);
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = uiPth-1;
                            hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;
                            hRapCh->pPath[uiPth-1]->uiAssocId = uiAssocId;

                        /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                            if(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage] != NULL)
                            {
                                for(m = 0 ; m < BRAP_P_MAX_DEST_PER_PROCESSING_STAGE ; m++)
                                {
                                    hRapCh->pPath[uiPth]->pDstDetails[m] =
                                        &(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage]->hDestHandle[m]->sExtDstDetails);
                                }                        
                            }  
                            
                            uiPth++;
                        }
                        else
                        {
                            if(NULL == hRapCh->pPath[uiPth])
                            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                                
                                if(BERR_SUCCESS != ret)
                                {
                                    ret = BERR_TRACE(ret);
                                    goto end;                                       
                                }
                            }
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_eDecodePcmPostMixing,
                                                                    BRAP_INVALID_VALUE,
                                                                    uiPth,
                                                                    BRAP_INVALID_VALUE,0);
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = uiPth-1;
                            hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;
                            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;

                            /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                            if(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage] != NULL)
                            {
                                for(m = 0 ; m < BRAP_P_MAX_DEST_PER_PROCESSING_STAGE ; m++)
                                {
                                    hRapCh->pPath[uiPth]->pDstDetails[m] =
                                        &(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage]->hDestHandle[m]->sExtDstDetails);
                                }                        
                            }  

                            uiPth++;   
                        }                       
                    } /*if(NULL == hStartedAssoCh[uiAssocId])*/
                    else
                    {
                        /* Copy the relevant path from the started channel */
                        for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                        {
                            if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                            (NULL == hRapCh->pPath[uiPth])&&
                            (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                            (BRAP_P_UsgPath_eDecodePcmPostMixing == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath)&&
                            (hStartedAssoCh[uiAssocId]->pPath[j]->uiAssocId == uiAssocId))
                            {
                                hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                for(k=0; k<BRAP_P_MAX_IN_PARALLEL_FMM_PATH; k++)
                                {
                                    if(BRAP_INVALID_VALUE == hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx)
                                        break;
                                }
                                hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx = uiPth-1;
                                hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;                                
                                BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                                uiPth, hRapCh->pPath[uiPth]->eUsgPath));
                                uiPth++;
                                break;
                            }
                        }
                    }
                } /*if(((BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[i]->eAudioDst)&&*/
                break;
            } /*if((true == hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[0][0].bCloneStage)||*/
        } /* for(l=0; (l<BRAP_MAX_ASSOCIATED_GROUPS) && (hRapCh->uiAssociationId[l] != BRAP_INVALID_VALUE); ++l)*/
        for(l=0; l<BRAP_MAX_ASSOCIATED_GROUPS; ++l)
        {
            if(hRapCh->uiAssociationId[l] == BRAP_INVALID_VALUE)
                continue;
            
            uiAssocId = hRapCh->uiAssociationId[l];
            /*Check for association network*/
            if(BRAP_P_NETWORK_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage))
            {
                /*Check for other network node on association and if any other branch
                exist than create BRAP_P_UsgPath_ePPBranchPostMixing path for them*/
                for(i=1; i<BRAP_P_MAX_DST_PER_RAPCH; ++i)
                {
                    if((BRAP_P_BRANCH_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage, i))&&
                        (NULL != hRapCh->pDstDetails[i]))
                    {
                        /*Find the audio procsssing for the destination of the row on 
                        association network*/
                        bCompress = false;              
                        BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));                    
                        ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                            hRapCh->pDstDetails[i],
                                                                            pPvtDstDetails,
                                                                            &m);
                        if(BERR_SUCCESS!=ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;
                        }
                        if(m != uiAssocId)
                            continue;
                        /* Check if the Path outputs the compress data  */
                        if(BRAP_P_IsAssociationNWValid(pPvtDstDetails))
                        {
                            for(m =0; m < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; m++)
                            {
                                if(NULL == pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m])
                                    break; 

                                eAudioProcessing = pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m]->sProcessingStageSettings.eAudioProcessing;

                                BDBG_MSG(("pPvtDstDetails->eAudProcessing[j] = %d",eAudioProcessing));

                                if((BRAP_ProcessingType_eConvertDdpToAc3  == eAudioProcessing)
                                    ||(BRAP_ProcessingType_eWmaProPassThru == eAudioProcessing)                              
                                    ||(BRAP_ProcessingType_eEncodeDts== eAudioProcessing)
                                    ||(BRAP_ProcessingType_eEncodeAc3==eAudioProcessing)
                                    ||(BRAP_ProcessingType_eGenericPassthru==eAudioProcessing)                                    
                                    ||(BRAP_ProcessingType_eEncodeMp3==eAudioProcessing)
                                    ||(BRAP_ProcessingType_ePassthru==eAudioProcessing))
                                {
                                    bCompress = true;
                                }
                            }
                        }
                        if(m>0)
                        {
                            uiLastStage = m -1;
                        }
                        else
                        {
                            uiLastStage = BRAP_INVALID_VALUE;
                            BDBG_ERR(("Network must have one valid stage"));
                            ret = BERR_TRACE(BERR_INVALID_PARAMETER);
                            goto end;                    
                        }
                        if(((BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[i]->eAudioDst)) ||
                            (BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst))
                        {
                            if(true == bCompress)
                            {
                                if(NULL == hStartedAssoCh[uiAssocId])
                                {
                                    if(NULL == hRapCh->pPath[uiPth])
                                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                                        
                                        if(BERR_SUCCESS != ret)
                                        {
                                            ret = BERR_TRACE(ret);
                                            goto end;                                        
                                        }
                                    }
                                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                            BRAP_P_UsgPath_ePPBranchPostMixing,
                                                                            BRAP_INVALID_VALUE,
                                                                            uiPth,
                                                                            BRAP_INVALID_VALUE,0);
                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = 
                                    hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = 
                                    hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp;
                                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh;
                                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                                    for(m = (uiPth-1); m > 0 ; m--)
                                    {
                                        /* Currently assumed all PCM carrying ports will be connected to same stage 
                                           ToDo: To make this generic like PPBranch path */
                                        if((hRapCh->pPath[m]!=NULL) &&
                                           (hRapCh->pPath[m]->eUsgPath == BRAP_P_UsgPath_eDecodeCompressPostMixing))
                                        {
                                            hRapCh->pPath[uiPth]->uiMasterpathId = m;
                                            break;
                                        }
                                    }

                                    /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                                    if(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage] != NULL)
                                    {
                                        for(m = 0 ; m < BRAP_P_MAX_DEST_PER_PROCESSING_STAGE ; m++)
                                        {
                                            hRapCh->pPath[uiPth]->pDstDetails[m] =
                                                &(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage]->hDestHandle[m]->sExtDstDetails);
                                        }                        
                                    }                                     
                                    
                                    uiPth++;
                                } /*if(NULL == hStartedAssoCh)*/
                                else
                                {
                                    /* Copy the relevant path from the started channel 
                                    We will search the first BRAP_P_UsgPath_ePPBranchPostMixing 
                                    and once we find it. We will keep on searching the other 
                                    BRAP_P_UsgPath_ePPBranchPostMixing and copy them.*/
                                    for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                                    {
                                        if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                                            (hRapCh->pPath[uiPth] == NULL)&&
                                            (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                                            (BRAP_P_UsgPath_eDecodeCompressPostMixing == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath)&&
                                            (hStartedAssoCh[uiAssocId]->pPath[j]->uiAssocId == uiAssocId))
                                        {
                                            /*Find one path and copy it in hRapCh */
                                            hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                            BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                                            uiPth, hRapCh->pPath[uiPth]->eUsgPath));                                            
                                            uiPth++;                    
                                            break;
                                        }
                                    }
                                } /*else if(NULL == hStartedAssoCh)*/
                            } 
                            else
                            {
                                if(NULL == hStartedAssoCh[uiAssocId])
                                {
                                    if(NULL == hRapCh->pPath[uiPth])
                                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                                        if(BERR_SUCCESS != ret)
                                        { 
                                            ret = BERR_TRACE(ret);
                                            goto end;                                        
                                        }
                                    }
                                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                                                            BRAP_P_UsgPath_ePPBranchPostMixing,
                                                                            BRAP_INVALID_VALUE,
                                                                            uiPth,
                                                                            BRAP_INVALID_VALUE,0);
                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = 
                                    hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = 
                                    hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp;
                                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh;
                                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                                    for(m = (uiPth-1); m > 0 ; m--)
                                    {
                                        /* Currently assumed all PCM carrying ports will be connected to same stage 
                                           ToDo: To make this generic like PPBranch path */
                                        if((hRapCh->pPath[m]!=NULL) &&
                                           (hRapCh->pPath[m]->eUsgPath == BRAP_P_UsgPath_eDecodePcmPostMixing))
                                        {
                                            hRapCh->pPath[uiPth]->uiMasterpathId = m;
                                            break;
                                        }
                                    }
                                    
                                    /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                                    if(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage] != NULL)
                                    {
                                        for(m = 0 ; m < BRAP_P_MAX_DEST_PER_PROCESSING_STAGE ; m++)
                                        {
                                            hRapCh->pPath[uiPth]->pDstDetails[m] =
                                                &(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage]->hDestHandle[m]->sExtDstDetails);
                                        }                        
                                    }                            
                                    
                                    uiPth++;
                                } /*if(NULL == hStartedAssoCh)*/
                                else
                                {
                                    /* Copy the relevant path from the started channel 
                                    We will search the first BRAP_P_UsgPath_ePPBranchPostMixing 
                                    and once we find it. We will keep on searching the other 
                                    BRAP_P_UsgPath_ePPBranchPostMixing and copy them.*/
                                    for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                                    {
                                        if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                                            (NULL == hRapCh->pPath[uiPth])&& 
                                            (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                                            ((BRAP_P_UsgPath_ePPBranchPostMixing == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath)
                                            ||(BRAP_P_UsgPath_eDecodePcmPostMixing== hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath))
                                            &&(hStartedAssoCh[uiAssocId]->pPath[j]->uiAssocId == uiAssocId))
                                        {
                                            /*Find one path and copy it in hRapCh */
                                            hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                            for(k=0; k<BRAP_P_MAX_IN_PARALLEL_FMM_PATH; k++)
                                            {
                                                if(BRAP_INVALID_VALUE == hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx)
                                                    break;
                                            }
                                            hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx = uiPth-1;
                                            hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;                                            
                                            BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                                            uiPth, hRapCh->pPath[uiPth]->eUsgPath));                                            
                                            uiPth++;                    
                                            break;                            
                                        }
                                    }
                                } /*else if(NULL == hStartedAssoCh)*/
                            }
                        } /*if(((BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[i]->eAudioDst)&&*/
                    } /*if((true == hRapCh->hRap->sAssociatedCh[hRapCh->uiAssociationId]*/
                } /* for(i=1; i<BRAP_MAX_PP_PER_BRANCH_SUPPORTED; ++i)*/
            } /* if((true==hRapCh->hRap->sAssociatedCh[hRapCh->uiAssociationId].sAudProcessingStage[0][0].bCloneStage)*/
        } /*for(l=0; (l<BRAP_MAX_ASSOCIATED_GROUPS) && (hRapCh->uiAssociationId[l] != BRAP_INVALID_VALUE); ++l)*/      
    } /*else if(BRAP_ChannelType_ePcmCapture == hRapCh->eChannelType) */
    hRapCh->uiNumCapPath = *uiNumCapPath;
    BDBG_MSG(("*uiNumCapPath > %d", *uiNumCapPath));

    BDBG_MSG(("===================================================="));    
    BDBG_MSG(("Channel Paths formed: "));
    for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
    {
        if(hRapCh->pPath[j] != NULL)
        {
            BDBG_MSG(("hRapCh->pPath[%d]->eUsgPath = %d",j,hRapCh->pPath[j]->eUsgPath));        
            for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
            {
                if(hRapCh->pPath[j]->pDstDetails[k]!=NULL)
                {
                    if(hRapCh->pPath[j]->pDstDetails[k]->eAudioDst == BRAP_AudioDst_eOutputPort)
                    {
                        BDBG_MSG(("Path = %d, Op = %d", 
                        j, hRapCh->pPath[j]->pDstDetails[k]->uDstDetails.sOpDetails.eOutput[0]));
                    }
                    else if(hRapCh->pPath[j]->pDstDetails[k]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                    {
                        BDBG_MSG(("Path = %d, Capture Port = %d",
                            j,hRapCh->pPath[j]->pDstDetails[k]->uDstDetails.sRBufDetails.eCapPort[0]));
                    }
                    else 
                        BDBG_MSG(("Invalid Destination"));
                }
            }
        }
        else
            break;
    }
    BDBG_MSG(("Number of Paths: %d", j));
    BDBG_MSG(("===================================================="));    
    
end:    
    if(pDspChSettings)
        BKNI_Free(pDspChSettings);

    
    BDBG_LEAVE(BRAP_P_GetChannelPaths);
    return ret;
}

BERR_Code 
BRAP_P_UngetChannelPaths(
	BRAP_ChannelHandle 			hRapCh		    /* [in] RAP Channel handle */
    )
{
    BERR_Code ret = BERR_SUCCESS;
    unsigned int uiPth = 0;
    unsigned int path =0 ;
    unsigned int i=0;
    
    BDBG_ENTER(BRAP_P_UngetChannelPaths);

    if((NULL != hRapCh->pPath[0])
        &&(NULL != hRapCh->pPath[0]->hDspCh))
    {
        /* First Make NULL all the hDspCh Handle stored in the Path which is same as hRapCh->pPath[0]->hDspCh */
        for(uiPth=1; uiPth<BRAP_P_MAX_PATHS_IN_A_CHAN; uiPth++)
        {
            if(NULL == hRapCh->pPath[uiPth])
            {
                continue;
            }
            if(hRapCh->pPath[0]->hDspCh == hRapCh->pPath[uiPth]->hDspCh)
            {
                hRapCh->pPath[uiPth]->hDspCh = NULL;
            }
        }
        /* Now close DSPCHN for Path 0 */        
        BRAP_DSPCHN_P_Close(hRapCh->pPath[0]->hDspCh);
        hRapCh->pPath[0]->hDspCh =NULL;
    }

    for(uiPth=0; uiPth<BRAP_P_MAX_PATHS_IN_A_CHAN; uiPth++)
    {
        if(NULL == hRapCh->pPath[uiPth])
        {
            continue;
        }
        if((BRAP_ChannelType_eDecode == hRapCh->eChannelType
#if((BRAP_7405_FAMILY == 1))
			||(BRAP_ChannelType_ePcmCapture== hRapCh->eChannelType)
			||(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
#endif
			) &&
           (0 == uiPth) && 
           ((BRAP_P_UsgPath_eDecodePcm == hRapCh->pPath[uiPth]->eUsgPath)||
#if((BRAP_7405_FAMILY == 1))
           (BRAP_P_UsgPath_eCapture== hRapCh->pPath[uiPth]->eUsgPath)||
#endif			
            (BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath)))
        {
            /* Initialize sMixingLevels and pDstDetails with Invalid values */

            for(i = 0; i < BRAP_RM_P_MAX_MIXING_LEVELS; i++)
            {
                hRapCh->pPath[uiPth]->sMixingLevels[i] = sMixingLevelPropInvalid;
            }
            for(i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
            {
                hRapCh->pPath[uiPth]->pDstDetails[i] = NULL;
            }
            hRapCh->pPath[uiPth]->uiDestcount = 0;            
#if (BRAP_7405_FAMILY == 1)            		
            if(((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
                &&(hRapCh->bOpenTimeWrToRbuf == true)
                &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
                    continue;
#endif             
        }

        /* Close the PostMixing(loopback) path's hDspCh 
           'uiPth' is eDecodePcmPostMixing/eDecodeCompressPostMixing */   
        if((0 == hRapCh->pPath[uiPth]->uiPthOpenCnt) &&
           (NULL != hRapCh->pPath[uiPth]->hDspCh))
        {     
            /* Make hDspCh=NULL for all the subsequent paths of 'uiPth' 
               which have 'hDspCh' copied from 'uiPth' */
            for(i=uiPth+1; i<BRAP_P_MAX_PATHS_IN_A_CHAN; i++)
            {
                if(NULL == hRapCh->pPath[i])
                {
                    continue;
                }
                if(hRapCh->pPath[uiPth]->hDspCh == hRapCh->pPath[i]->hDspCh)
                {
                    hRapCh->pPath[i]->hDspCh = NULL;
                }
            }
            /* Now close DSPCHN for Path uiPth */          
            BRAP_DSPCHN_P_Close(hRapCh->pPath[uiPth]->hDspCh);
            hRapCh->pPath[uiPth]->hDspCh =NULL;            
        }
        
        if(hRapCh->pPath[uiPth]->uiPthOpenCnt == 0)
        {
            BDBG_MSG(("Freeing path hRapCh->pPath[uiPth=%d]->uiPthOpenCnt = %d",
                uiPth, hRapCh->pPath[uiPth]->uiPthOpenCnt));
            
            if((BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)&&
            (BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath))
            {
                BDBG_MSG(("Not freeing DecComp path for PCM PB \n"));
                /* Do not free compressed path in PCM PB channel */
            }
            else
            {
                /* Reset path */
                for (path =0 ; path < BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; path++)
                {
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], BRAP_P_UsgPath_eMax,
                    BRAP_INVALID_VALUE, BRAP_INVALID_VALUE, BRAP_INVALID_VALUE,path);
                }
                /* Free path memory */
                BRAP_P_FreePath(&(hRapCh->pPath[uiPth]));   
            }
        }
        hRapCh->pPath[uiPth] = NULL;
    }

    BDBG_LEAVE(BRAP_P_UngetChannelPaths);
    return ret;
}


/***************************************************************************
Summary:
    Private function that initializes SrcChHandleInfo with invalid values.  
**************************************************************************/
void 
BRAP_P_InitSrcChHandleInfo(
    BRAP_P_SrcChHandleInfo  *pSrcChInfo
    )
{
    BRAP_P_LinkInfo         sLinkInfo;

    BDBG_ASSERT(pSrcChInfo);
    
    /* sLinkInfo */
    sLinkInfo.eRsrcType = BRAP_P_Rsrc_eMax;
    sLinkInfo.uiLevel = BRAP_INVALID_VALUE;
    sLinkInfo.eChnPair = BRAP_OutputChannelPair_eMax;
    sLinkInfo.uiPrlPth = BRAP_INVALID_VALUE; 
    sLinkInfo.uiMixerOutput = BRAP_INVALID_VALUE;

    /* sSrcChInfo */
    pSrcChInfo->bValid = false;         
    pSrcChInfo->sSrcChInLink = sLinkInfo;
    pSrcChInfo->sSrcChSelfLink = sLinkInfo;
    pSrcChInfo->hSrcCh = NULL;
    pSrcChInfo->sSrcChOutLink = sLinkInfo;

    return;
}

/***************************************************************************
Summary:
    Private function that initializes DstChHandleInfo with invalid values.  
**************************************************************************/
static void  
BRAP_P_InitDstChHandleInfo(
    BRAP_P_DstChHandleInfo  *pDstChInfo
    )
{
    BRAP_P_LinkInfo         sLinkInfo;

    BDBG_ASSERT(pDstChInfo);
    
    /* sLinkInfo */
    sLinkInfo.eRsrcType = BRAP_P_Rsrc_eMax;
    sLinkInfo.uiLevel = BRAP_INVALID_VALUE;
    sLinkInfo.eChnPair = BRAP_OutputChannelPair_eMax;
    sLinkInfo.uiPrlPth = BRAP_INVALID_VALUE;   
	sLinkInfo.uiMixerOutput = BRAP_INVALID_VALUE;		

    /* sDstChInfo */
    pDstChInfo->bValid = false;         
    pDstChInfo->sDstChInLink = sLinkInfo;
    pDstChInfo->sDstChSelfLink= sLinkInfo;
    pDstChInfo->hDstCh = NULL;
    pDstChInfo->sDstChOutLink= sLinkInfo;

    return;
}

/***************************************************************************
Summary:
    Private function that initializes SrcHandleInfo with invalid values.  
**************************************************************************/
static void  
BRAP_P_InitSrcHandleInfo(
    BRAP_P_SrcHandleInfo  *pSrcInfo,
    unsigned int          uiSrcCscdIndex
    )
{
    BRAP_P_LinkInfo         sLinkInfo;
    int i = 0;

    BDBG_ASSERT(pSrcInfo);
    
    /* sLinkInfo */
    sLinkInfo.eRsrcType = BRAP_P_Rsrc_eMax;
    sLinkInfo.uiLevel = BRAP_INVALID_VALUE;
    sLinkInfo.eChnPair = BRAP_OutputChannelPair_eMax;
    sLinkInfo.uiPrlPth = BRAP_INVALID_VALUE;   
	sLinkInfo.uiMixerOutput = BRAP_INVALID_VALUE;

    /* sSrcInfo */
    pSrcInfo->bValid = false;
    pSrcInfo->sSrcInLink  = sLinkInfo;
    pSrcInfo->sSrcSelfLink = sLinkInfo;
    pSrcInfo->hSrc[uiSrcCscdIndex] = NULL; 

    for(i = 0; i < BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
    {
        pSrcInfo->sSrcOutLink[i] = sLinkInfo;
    }

    return;
}

/***************************************************************************
Summary:
    Private function that initializes SrcEqHandleInfo with invalid values.  
**************************************************************************/
static void  
BRAP_P_InitSrcEqHandleInfo(
    BRAP_P_SrcEqHandleInfo  *pSrcEqInfo,
    unsigned int          uiSrcCscdIndex
    )
{
    BRAP_P_LinkInfo         sLinkInfo;
    int i = 0;

    BDBG_ASSERT(pSrcEqInfo);
    
    /* sLinkInfo */
    sLinkInfo.eRsrcType = BRAP_P_Rsrc_eMax;
    sLinkInfo.uiLevel = BRAP_INVALID_VALUE;
    sLinkInfo.eChnPair = BRAP_OutputChannelPair_eMax;
    sLinkInfo.uiPrlPth = BRAP_INVALID_VALUE;   
	sLinkInfo.uiMixerOutput = BRAP_INVALID_VALUE;

    /* sSrcInfo */
    pSrcEqInfo->bValid = false;
    pSrcEqInfo->sSrcEqInLink  = sLinkInfo;
    pSrcEqInfo->sSrcEqSelfLink = sLinkInfo;
    pSrcEqInfo->hSrcEq[uiSrcCscdIndex] = NULL; 

    for(i = 0; i < BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
    {
        pSrcEqInfo->sSrcEqOutLink[i] = sLinkInfo;
    }

    return;
}

/***************************************************************************
Summary:
    Private function that initializes MixerHandleInfo with invalid values.  
**************************************************************************/
static void  
BRAP_P_InitMixerHandleInfo(
    BRAP_P_MixerHandleInfo  *pMixerInfo
    )
{
    BRAP_P_LinkInfo         sLinkInfo;
    int i = 0;

    BDBG_ASSERT(pMixerInfo);
    
    /* sLinkInfo */
    sLinkInfo.eRsrcType = BRAP_P_Rsrc_eMax;
    sLinkInfo.uiLevel = BRAP_INVALID_VALUE;
    sLinkInfo.eChnPair = BRAP_OutputChannelPair_eMax;
    sLinkInfo.uiPrlPth = BRAP_INVALID_VALUE;   
	sLinkInfo.uiMixerOutput = BRAP_INVALID_VALUE;		

    /* sMixerInfo */
    pMixerInfo->bValid = false; 
    for(i = 0; i < BRAP_RM_P_MAX_MIXER_INPUTS; i++)
    {
        pMixerInfo->sMixerInLink[i] = sLinkInfo;
    }
    pMixerInfo->sMixerSelfLink = sLinkInfo;
    pMixerInfo->hMixer = NULL;
    for(i = 0; i < BRAP_RM_P_MAX_MIXER_OUTPUTS; i++)
    {
        pMixerInfo->sMixerOutLink[i] = sLinkInfo;
    }
    
    return;
}


/***************************************************************************
Summary:
    Private function that initializes OutputHandleInfo with invalid values.  
**************************************************************************/
static void  
BRAP_P_InitOpHandleInfo(
    BRAP_P_OpHandleInfo  *pOpInfo
    )
{
    BRAP_P_LinkInfo         sLinkInfo;
 
    BDBG_ASSERT(pOpInfo);
    
    /* sLinkInfo */
    sLinkInfo.eRsrcType = BRAP_P_Rsrc_eMax;
    sLinkInfo.uiLevel = BRAP_INVALID_VALUE;
    sLinkInfo.eChnPair = BRAP_OutputChannelPair_eMax;
    sLinkInfo.uiPrlPth = BRAP_INVALID_VALUE;   
	sLinkInfo.uiMixerOutput = BRAP_INVALID_VALUE;	

    /* sOpInfo */
    pOpInfo->bValid = false;
    pOpInfo->sOpInLink = sLinkInfo; 
    pOpInfo->sOpSelfLink = sLinkInfo;
    pOpInfo->hSpdifFm = NULL;
    pOpInfo->hOp = NULL;
    pOpInfo->hMaiOp = NULL;
    

    return;
}
  
/***************************************************************************
Summary:
    Private function that initializes CapPortHandleInfo with invalid values.  
**************************************************************************/
static void  
BRAP_P_InitCapPortHandleInfo(
    BRAP_P_CapPortHandleInfo  *pCapPortInfo
    )
{
    BRAP_P_LinkInfo         sLinkInfo;

    BDBG_ASSERT(pCapPortInfo);
    
    /* sLinkInfo */
    sLinkInfo.eRsrcType = BRAP_P_Rsrc_eMax;
    sLinkInfo.uiLevel = BRAP_INVALID_VALUE;
    sLinkInfo.eChnPair = BRAP_OutputChannelPair_eMax;
    sLinkInfo.uiPrlPth = BRAP_INVALID_VALUE;   
	sLinkInfo.uiMixerOutput = BRAP_INVALID_VALUE;		

    /* sCapInfo */
    pCapPortInfo->bValid = false;
    pCapPortInfo->sCapPortInLink = sLinkInfo;
    pCapPortInfo->sCapPortSelfLink = sLinkInfo;
    pCapPortInfo->hCapPort = NULL;
    pCapPortInfo->sCapPortoutLink = sLinkInfo;
    
    return;
}
 
/***************************************************************************
Summary:
    Private function that initializes Raptor channel handle with invalid 
    values.  
**************************************************************************/
BERR_Code 
BRAP_P_InitRapChannelHandle(
    BRAP_ChannelHandle  hRapCh,  /* [in] Rap channel handle to be inited to 
                                   invalid values */
BRAP_Handle 			    hRap		    /* [in] The Raptor Audio handle*/
                                   
    )
{
    int i = 0, j = 0, k = 0, l = 0;
    BRAP_P_SrcChHandleInfo  sSrcChInfo;
    BRAP_P_DstChHandleInfo  sDstChInfo;
	BRAP_P_SrcHandleInfo    sSrcInfo;
    BRAP_P_MixerHandleInfo  sMixerInfo;
    BRAP_P_SrcEqHandleInfo  sSrcEqInfo;
    BRAP_P_OpHandleInfo     sOpInfo;
    BRAP_P_CapPortHandleInfo sCapInfo;
    BRAP_P_AppIntCbInfo     sAppCbInfo;
    BRAP_RM_P_ResrcGrant    *psRsrcGrnt;
    BRAP_P_ChannelAudioProcessingStage sTempStage;
    BERR_Code ret = BERR_SUCCESS;
	
#if (BRAP_OPEN_TIME_RBUF_ALLOCATION==1)	
    BRAP_P_RBufMem          sRbufMem;
#endif

    BDBG_ENTER(BRAP_P_InitRapChannelHandle);

	psRsrcGrnt = hRap->sOpenTimeMallocs.psResrcGrant;
	if( NULL==psRsrcGrnt )
	{
		return BERR_TRACE( BERR_OUT_OF_SYSTEM_MEMORY );
	}
        BKNI_Memset(psRsrcGrnt, 0, sizeof(BRAP_RM_P_ResrcGrant));             
    /* RM Grant */
    BRAP_RM_P_InitResourceGrant(psRsrcGrnt,true);
    
    /* sSrcChInfo */
    BRAP_P_InitSrcChHandleInfo(&sSrcChInfo);    

    /* sDstChInfo */
    BRAP_P_InitDstChHandleInfo(&sDstChInfo);    

    /* sSrcInfo */
    for(i = 0; i < BRAP_RM_P_MAX_SRC_IN_CASCADE; i++)
    {
        BRAP_P_InitSrcHandleInfo(&sSrcInfo, i);    
    }

    /* sMixerInfo */
    BRAP_P_InitMixerHandleInfo(&sMixerInfo);

    /* sSrcEqInfo */
    for(i = 0; i < BRAP_RM_P_MAX_SRC_IN_CASCADE; i++)
    {
        BRAP_P_InitSrcEqHandleInfo(&sSrcEqInfo, i);    
    }

    /* sOpInfo */
    BRAP_P_InitOpHandleInfo(&sOpInfo);
    
    /* sCapInfo */
    BRAP_P_InitCapPortHandleInfo(&sCapInfo);

    /* sAppCbInfo */
    sAppCbInfo.iParm2 = BRAP_INVALID_VALUE;
    sAppCbInfo.pParm1 = NULL;
    sAppCbInfo.pfAppCb = NULL;

    /* Channel handle */    
    hRapCh->hChip = NULL;
    hRapCh->hRegister = NULL;
    hRapCh->hHeap = NULL;
    hRapCh->hInt = NULL; 
    hRapCh->hRap = NULL;		
    hRapCh->uiXptChannelNo = BRAP_INVALID_VALUE;
    hRapCh->eChannelType = BRAP_ChannelType_eMax;
    hRapCh->uiChannelNo = BRAP_INVALID_VALUE; 
    hRapCh->eChannelSubType = BRAP_ChannelSubType_eMax;
    hRapCh->eAudioSource = BRAP_AudioSource_eMax;
    hRapCh->eSamplingRate = BAVC_AudioSamplingRate_eUnknown;    
    hRapCh->bGateOpened= false;
    hRapCh->uiModeValue = BRAP_INVALID_VALUE;
    
    for(i = 0; i < BRAP_P_MAX_PATHS_IN_A_CHAN; i++)
    {
        hRapCh->pPath[i] = NULL;
    }

#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
    for(i = 0; i < BRAP_P_MAX_PATHS_IN_A_CHAN; i++)
    {
    	/* Allocate an Path handle memory during open time */
    	hRapCh->pMemPath[i] = (BRAP_P_ObjectHandles *)BKNI_Malloc(sizeof(BRAP_P_ObjectHandles));
    	if(NULL == hRapCh->pMemPath[i])
    	{
    		BDBG_ERR(("pPath open channel Memory allocation failed"));
    		ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
    	}
        BKNI_Memset(hRapCh->pMemPath[i],0,sizeof(BRAP_P_ObjectHandles));    
    }   
#endif	

    hRapCh->bSimulModeConfig = false; 
    hRapCh->hDSPCallback = NULL;
    hRapCh->hFMMCallback = NULL;
    for(i = 0; i < BRAP_Interrupt_eMaxInterrupts; i++)
    {
        hRapCh->sAppIntCbInfo[i] = sAppCbInfo; 
    }
    hRapCh->ui32FmmIntMask = 0;
    hRapCh->ui32FmmBFIntMask = 0;
    hRapCh->ui32DspIntMask = 0; 
    hRapCh->ui32AsynIntMask = 0;
    hRapCh->sTrickModeState.uiFrameAdvResidualTime = 0;	
    hRapCh->sTrickModeState.bAudioPaused = false;
    
    hRapCh->eState = BRAP_P_State_eInvalid;
    hRapCh->bStopinvoked = false;
    

    for(i = 0; i < BRAP_MAX_ASSOCIATED_GROUPS; i++)
    {
        hRapCh->uiAssociationId[i] = BRAP_INVALID_VALUE;
    }

    for(i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        hRapCh->pDstDetails[i] = NULL;
    }
    
    hRapCh->uiInputSamplingRate = BRAP_INVALID_VALUE; 
    hRapCh->eInputAudMode = BRAP_OutputMode_eLast;
    hRapCh->bInputLfeOn = false;

    for(i=0;i<BRAP_OutputChannelPair_eMax;i++)
    {
        hRapCh->sGainInfo.ui32LeftGain[i] = BRAP_MIXER_P_DEFAULT_SCALING_COEFF;
        hRapCh->sGainInfo.ui32RightGain[i]= BRAP_MIXER_P_DEFAULT_SCALING_COEFF;
    }

    for(i=0;i<BRAP_RM_P_MAX_INTERNAL_DST;i++)
    {
        hRapCh->sIntDst[i] = sInternalDst;
    }


#if (BRAP_OPEN_TIME_RBUF_ALLOCATION==1)
    /* sChanRBufPool */
    sRbufMem.bUsed = false;
    sRbufMem.pRBufPtr = NULL;
    sRbufMem.uiSize = 0;

    for(i = 0; i < BRAP_MAX_FW_PROC_BRANCHES; i++)
    {
        for(j = 0; j < BRAP_MAX_OUT_CH_PER_FW_PROC_BRANCH; j++)
        {
            hRapCh->sChanRBufPool.sDecOutRBuf[i][j] = sRbufMem;
        }/* for j */
    }/* for i */

    for(i = 0; i < BRAP_MAX_DEC_CHAN_WITH_CAPPORT_SOURCE; i++)
    {
        for(j = 0; j < BRAP_MAX_IN_CH_PER_FW_PROC_BRANCH; j++)
        {
            hRapCh->sChanRBufPool.sDecInRBuf[i][j] = sRbufMem;
        }/* for j */
    }/* for i */

    for(i = 0; i < BRAP_P_MAX_RBUF_PER_PBCH; i++)
    {
        hRapCh->sChanRBufPool.sPbRBuf[i] = sRbufMem;
    }/* for i */

#endif
    sTempStage.bCloneStage = false;
    sTempStage.bDecoderStage = false;
    sTempStage.bInternalProcessingStage = false;    
    sTempStage.hAudioProcessing = NULL;
    sTempStage.hValidDestHandle = NULL;
    for(i=0;i<BRAP_P_MAX_DEST_PER_PROCESSING_STAGE;i++)    
    {
        sTempStage.hDestHandle[i] = NULL;
    }
    sTempStage.ui32MasterBranchId = BRAP_INVALID_VALUE;
    sTempStage.ui32MasterStageId = BRAP_INVALID_VALUE;
    sTempStage.ui32CitBranchId = BRAP_INVALID_VALUE;
    sTempStage.ui32CitStageId = BRAP_INVALID_VALUE;

    for (i=0;i<BRAP_P_MAX_DST_PER_RAPCH;i++)
    {
        for(j=0;j<BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED;j++)
        {
            hRapCh->sChAudProcessingStage[i][j] = sTempStage;
        }
    }
    for(l=0;l<BRAP_RM_P_MAX_MIXER_PER_DP_BLCK * BRAP_RM_P_MAX_DP_BLCK;l++)
    {
        for(k=0;k<BRAP_P_MAX_DST_PER_RAPCH;k++)
        {
            hRapCh->sScalingInfo.eOp[l][k] = BRAP_OutputPort_eMax;
            for(i=0;i<BRAP_OutputChannelPair_eMax;i++)
            {
                hRapCh->sScalingInfo.sScalingInfo[l][k].ui32LeftGain[i] = BRAP_MIXER_P_DEFAULT_SCALING_COEFF;
                hRapCh->sScalingInfo.sScalingInfo[l][k].ui32RightGain[i]= BRAP_MIXER_P_DEFAULT_SCALING_COEFF;
            }
        }
    }

    hRapCh->uiPBRate = BRAP_DSPCHN_PLAYBACKRATE_NORMAL;
    hRapCh->eChannelOutputMode = BRAP_OutputMode_e2_0;
	
    hRapCh->hMultiStreamDecoder = NULL;
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT    
    hRapCh->uiFWMixerIpIndex = BRAP_INVALID_VALUE;
#endif

    BDBG_LEAVE(BRAP_P_InitRapChannelHandle);
    return ret;
}

/*****************************************************************************
Summary:
    Private function that initializes Destination Details with invalid values.  
******************************************************************************/
void 
BRAP_P_InitDestination(
    BRAP_P_DstDetails  *psDstDetails  /* [in] Raptor Destination to be inited to 
                                        invalid values */
    )
{
    unsigned int j=0, k=0;
    BRAP_P_AppIntCbInfo     sAppCbInfo;    

    BDBG_ENTER(BRAP_P_InitDestination);
    BDBG_ASSERT(psDstDetails);

    /* sAppCbInfo */
    sAppCbInfo.iParm2 = BRAP_INVALID_VALUE;
    sAppCbInfo.pParm1 = NULL;
    sAppCbInfo.pfAppCb = NULL;

    psDstDetails->sExtDstDetails.eAudioDst = BRAP_AudioDst_eMax;
    psDstDetails->hAssociation = NULL;
    psDstDetails->ui32FmmIntMask = 0;
    psDstDetails->hFmmBf1Callback = NULL;
    psDstDetails->hFmmBf2Callback = NULL;        
    psDstDetails->hParentDestHandle = NULL;
    psDstDetails->uiForkingStage = BRAP_INVALID_VALUE;
    psDstDetails->eAudioProcessing = BRAP_ProcessingType_eMax;
    for(j=0; j<BRAP_MAX_PP_PER_BRANCH_SUPPORTED; j++)
    {
        psDstDetails->eAudProcessing[j] = BRAP_ProcessingType_eMax;
    }
    for(j=0; j<(BRAP_P_MAX_RAPCH_PER_DST+ 1); j++)
    {
        psDstDetails->psProcessingSettings[j] = NULL;
    }        
    for(j=0; j < BRAP_DestinationInterrupt_eMax; j++)
    {
        psDstDetails->sAppIntCbInfo[j] = sAppCbInfo; 
    }        
    for(j=0; j<BRAP_OutputChannelPair_eMax; j++)
    {
        for(k=0; k<BRAP_P_MAX_MIXERS_CONTROLS_IN_DATA_PATH; k++)
        {
            psDstDetails->uiLtVolume[j][k] = 0x800000; 
            psDstDetails->uiRtVolume[j][k] = 0x800000;
            psDstDetails->uiLtBalance[j][k] = 0x800000; 
            psDstDetails->uiRtBalance[j][k] = 0x800000;
            psDstDetails->bMute[j] = false;
        }
    }
    psDstDetails->hEqualizer = NULL; 
    BDBG_LEAVE(BRAP_P_InitDestination);        
}

BERR_Code BRAP_P_GetAudOpModeProp(
    BRAP_OutputMode     eOpMode,        /* [in] Output mode */
    bool                bLfeOn,         /* [in] if LFE is on/off */
    BRAP_P_OpAudModProp *pOpModeProp    /* [out] OpMode property structure
                                           passed by reference */    
    )
{
    BERR_Code ret = BERR_SUCCESS;
    
    BDBG_ENTER(BRAP_P_GetAudOpModeProp);
    BDBG_ASSERT(pOpModeProp);

    BDBG_MSG(("BRAP_P_GetAudOpModeProp: eOpMode = %d, bLfeOn = %d",
        eOpMode, bLfeOn));

    if(eOpMode > BRAP_OutputMode_e3_4)    
    {
        BDBG_ERR(("BRAP_P_GetAudOpModeProp: eOpMode %d not supported", eOpMode));
        /* Check if this eOpMode is valid. If valid, check if 
           sOutputAudModeProp[] has supported details and re-adjust the if
           condition above */
        return BERR_TRACE(BERR_NOT_SUPPORTED);           
    }
    
    *pOpModeProp = sOutputAudModeProp[eOpMode];
    if(true == bLfeOn)
    {
        pOpModeProp->bChnExists[BRAP_P_LFE_CHAN_INDEX] = true;
        pOpModeProp->ui8ChanBits |= 0x1 << 2; /* 2 = 8 - lfe(5) - 1 */
        pOpModeProp->uiNoChannels++;
    }    

    BDBG_LEAVE(BRAP_P_GetAudOpModeProp);
    return ret;
}

/***************************************************************************
Summary: 
    This function gives the absolute value corresponding to the enum 
    BAVC_AudioSamplingRate 
**************************************************************************/ 
BERR_Code BRAP_P_ConvertSR (
    BAVC_AudioSamplingRate   eSR,   /* [in] samping rate enum */
    unsigned int            *uiSR   /* [out] sampling rate unsigned value */
)
{
    BERR_Code err = BERR_SUCCESS;
    BDBG_ASSERT(uiSR);

    switch(eSR)
    {
    	case BAVC_AudioSamplingRate_e32k:   *uiSR = 32000; break;
        case BAVC_AudioSamplingRate_e44_1k: *uiSR = 44100; break;
        case BAVC_AudioSamplingRate_e48k:   *uiSR = 48000; break;
        case BAVC_AudioSamplingRate_e96k:   *uiSR = 96000; break;
        case BAVC_AudioSamplingRate_e16k:   *uiSR = 16000; break;
        case BAVC_AudioSamplingRate_e22_05k:*uiSR = 22050; break;
        case BAVC_AudioSamplingRate_e24k:   *uiSR = 24000; break;
        case BAVC_AudioSamplingRate_e64k:   *uiSR = 64000; break;
        case BAVC_AudioSamplingRate_e88_2k: *uiSR = 88200; break;
        case BAVC_AudioSamplingRate_e128k:  *uiSR = 128000; break;
        case BAVC_AudioSamplingRate_e176_4k:*uiSR = 176400; break;
        case BAVC_AudioSamplingRate_e192k:  *uiSR = 192000; break;
        case BAVC_AudioSamplingRate_e8k:    *uiSR = 8000; break;
        case BAVC_AudioSamplingRate_e12k:   *uiSR = 12000; break;
        case BAVC_AudioSamplingRate_e11_025k:  *uiSR = 11025; break;
        case BAVC_AudioSamplingRate_eUnknown: 
        default:
            BDBG_MSG(("BRAP_P_ConvertSR: Not supported eSR = %d, Forcing it to 48000", eSR));
            *uiSR = 48000;break;
    }
    return err;        
}

/***************************************************************************
Summary: 
    This function gives the enum corresponding to the absolute value of 
    BAVC_AudioSamplingRate 
**************************************************************************/    
BERR_Code BRAP_P_ConvertSrToEnum (
    unsigned int            uiSR,   /* [in] sampling rate unsigned value */
    BAVC_AudioSamplingRate  *eSR    /* [out] samping rate enum */
)
{
    BERR_Code err = BERR_SUCCESS;
    BDBG_ASSERT(eSR);

    switch(uiSR)
    {
    	case 32000:     *eSR = BAVC_AudioSamplingRate_e32k;     break;
        case 44100:     *eSR = BAVC_AudioSamplingRate_e44_1k;   break;
        case 48000:     *eSR = BAVC_AudioSamplingRate_e48k;     break;
        case 96000:     *eSR = BAVC_AudioSamplingRate_e96k;     break;
        case 16000:     *eSR = BAVC_AudioSamplingRate_e16k;     break;
        case 22050:     *eSR = BAVC_AudioSamplingRate_e22_05k;  break;
        case 24000:     *eSR = BAVC_AudioSamplingRate_e24k;     break;
        case 64000:     *eSR = BAVC_AudioSamplingRate_e64k;     break;
        case 88200:     *eSR = BAVC_AudioSamplingRate_e88_2k;   break;
        case 128000:    *eSR = BAVC_AudioSamplingRate_e128k;    break;
        case 176400:    *eSR = BAVC_AudioSamplingRate_e176_4k;  break;
        case 192000:    *eSR = BAVC_AudioSamplingRate_e192k;    break;
        case 8000:      *eSR = BAVC_AudioSamplingRate_e8k;      break;
        case 12000:     *eSR = BAVC_AudioSamplingRate_e12k;     break;
        case 11025:     *eSR = BAVC_AudioSamplingRate_e11_025k; break;
        default:
            BDBG_ERR(("BRAP_P_ConvertSrToEnum: Not supported uiSR = %d, Forcing it to BAVC_AudioSamplingRate_e48k", uiSR));
               *eSR = BAVC_AudioSamplingRate_e48k; break;
    }
    return err;        
}

/***************************************************************************
Summary:
    Private function that gets the mixer associated to a output port
    
**************************************************************************/
BERR_Code
BRAP_P_GetMixerForOpPort (
    BRAP_Handle         hRap,       /*[in] Rap Handle */
    BRAP_OutputPort     eOpType,    /*[in] Output Port */
    BRAP_MIXER_P_Handle *phMixer,   /*[out] Mixer Handle */
    unsigned int        *puiMixerOp
)
{
    BERR_Code               ret=BERR_SUCCESS;
    BRAP_ChannelHandle      hRapCh= NULL;
    BRAP_OP_P_Handle        hOp = NULL;
    int                     i=0,j=0,k=0,l=0;
    bool                    bFound = false;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
#if BRAP_P_EQUALIZER
    BRAP_OutputChannelPair  eChSrcEq = BRAP_OutputChannelPair_eMax;
    unsigned int            lvlSrcEq = 0, ppSrcEq = 0;
#endif
    unsigned int            lvl =0, pp = 0;

    BDBG_ENTER(BRAP_P_GetMixerForOpPort);

    BDBG_ASSERT(hRap);
    BDBG_ASSERT(phMixer);
    BDBG_ASSERT(puiMixerOp);


    /* Find the channel which is outputing to this port */
    for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
    {
        hRapCh = hRap->hRapDecCh[i];
        if ( hRapCh != NULL )
        {
            for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
            {
                for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                {
                    for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                    {
                        if(NULL == hRapCh->pPath[j])
                        {
                            continue;
                        }
                        
                        hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                        if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                        {
                            bFound = true;
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
            if(true==bFound)
            {
                break;
            }
        }
    }

    if (false == bFound)
    {

        for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
        {
            hRapCh = hRap->hRapCapCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }   
        }
    
    }

    /* If not found in Dec channel, check for PB channels */
    if(false == bFound)
    {
        for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
        {
            hRapCh = hRap->hRapPbCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
        }
    }

    /* If this output port is not found in any of the active channels, return
       Error */
    if((false == bFound) || (NULL == hRapCh->pPath[j]))
    {
        BDBG_MSG(("BRAP_SetOutputVolume: The Output Port %d is not Active",eOpType));
        /*
            This was earlier as BERR_TRACE(BERR_INVALID_PARAMETER);
            But on customer request this has been changed to only return without the trace
            The Trace was throwing an error message on the console.
        */
        return BERR_INVALID_PARAMETER;
    }

    /* If found, find the Mixer for the given Output Port */
	if(BRAP_P_Rsrc_eMixer==hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
	    eChPair = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvl = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    pp = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;

	    /* Get the Handle for the Mixer feeding to the Output port */
	    *phMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;

	    *puiMixerOp = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiMixerOutput;

	}
#if BRAP_P_EQUALIZER
    /* If found, find the Mixer for the given Output Port */
	else if(BRAP_P_Rsrc_eSrcEq == hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
	    
        /* For Equalizer case it is like MIXER->SRC->OP*/	    
	    eChSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvlSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    ppSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;

        eChPair = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.eChnPair;
        lvl = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiLevel;
        pp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiPrlPth;

	    /* Get the Handle for the Mixer feeding to the Output port */
	    *phMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;

	    *puiMixerOp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiMixerOutput;

	}
#endif    
	else if(BRAP_P_Rsrc_eSrcCh == hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
		*phMixer = NULL;
		ret = BERR_SUCCESS;
	}
	else
		ret=BERR_INVALID_PARAMETER;
    
	
    BDBG_LEAVE(BRAP_P_GetMixerForOpPort);
    return ret;
}

/***************************************************************************
Summary:
    Private function that gets the mixer associated to an output port and which mixer of the 
    cascaded mixers is defined by the mixer level, an input parameter.
    
**************************************************************************/
BERR_Code
BRAP_P_GetCustomMixerForOpPort (
    BRAP_Handle         hRap,       /*[in] Rap Handle */
    BRAP_OutputPort     eOpType,    /*[in] Output Port */
    const unsigned int  uiMixerLevel,    
    BRAP_MIXER_P_Handle *phMixer,   /*[out] Mixer Handle */
    unsigned int        *puiMixerOp
)
{
    BERR_Code               ret=BERR_SUCCESS;
    BRAP_ChannelHandle      hRapCh= NULL;
    BRAP_OP_P_Handle        hOp = NULL;
    int                     i=0,j=0,k=0,l=0;
    bool                    bFound = false;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
#if BRAP_P_EQUALIZER
    BRAP_OutputChannelPair  eChSrcEq = BRAP_OutputChannelPair_eMax;
    unsigned int            lvlSrcEq = 0, ppSrcEq = 0;
#endif
    unsigned int            lvl =0, pp = 0;

    BDBG_ENTER(BRAP_P_GetCustomMixerForOpPort);

    BDBG_ASSERT(hRap);
    BDBG_ASSERT(phMixer);
    BDBG_ASSERT(puiMixerOp);


    /* Find the channel which is outputing to this port */
    for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
    {
        hRapCh = hRap->hRapDecCh[i];
        if ( hRapCh != NULL )
        {
            for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
            {
                for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                {
                    for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                    {
                        if(NULL == hRapCh->pPath[j])
                        {
                            continue;
                        }
                        
                        hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                        if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                        {
                            bFound = true;
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
            if(true==bFound)
            {
                break;
            }
        }
    }

    if (false == bFound)
    {

        for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
        {
            hRapCh = hRap->hRapCapCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }   
        }
    
    }

    /* If not found in Dec channel, check for PB channels */
    if(false == bFound)
    {
        for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
        {
            hRapCh = hRap->hRapPbCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
        }
    }

    /* If this output port is not found in any of the active channels, return
       Error */
    if((false == bFound) || (NULL == hRapCh->pPath[j]))
    {
        BDBG_MSG(("BRAP_SetOutputVolume: The Output Port %d is not Active",eOpType));
        /*
            This was earlier as BERR_TRACE(BERR_INVALID_PARAMETER);
            But on customer request this has been changed to only return without the trace
            The Trace was throwing an error message on the console.
        */
        return BERR_INVALID_PARAMETER;
    }
#if BRAP_P_EQUALIZER
    /* If found, find the Mixer for the given Output Port */
	if(BRAP_P_Rsrc_eSrcEq == hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
	    
        /* For Equalizer case it is like MIXER->SRC->OP*/	    
	    eChSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvlSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    ppSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;

        eChPair = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.eChnPair;
        lvl = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiLevel;
        pp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiPrlPth;

	    /* Get the Handle for the Mixer feeding to the Output port */
        if (NULL != hRapCh->pPath[j]->sMixer[lvl-uiMixerLevel][eChPair][pp].hMixer)
            *phMixer = hRapCh->pPath[j]->sMixer[lvl-uiMixerLevel][eChPair][pp].hMixer;    

	    *puiMixerOp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiMixerOutput;
	}
	else if(BRAP_P_Rsrc_eSrcCh == hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
		*phMixer = NULL;
		ret = BERR_SUCCESS;
	}
	else
		ret=BERR_INVALID_PARAMETER;
#else
    /* If found, find the Mixer for the given Output Port */
	if(BRAP_P_Rsrc_eMixer==hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
	    eChPair = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvl = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    pp = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;

	    /* Get the Handle for the Mixer feeding to the Output port */
        if (NULL != hRapCh->pPath[j]->sMixer[lvl-uiMixerLevel][eChPair][pp].hMixer)
            *phMixer = hRapCh->pPath[j]->sMixer[lvl-uiMixerLevel][eChPair][pp].hMixer;    

	    *puiMixerOp = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiMixerOutput;

	}
	else if(BRAP_P_Rsrc_eSrcCh == hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
		*phMixer = NULL;
		ret = BERR_SUCCESS;
	}
	else
		ret=BERR_INVALID_PARAMETER;
#endif    
	
    BDBG_LEAVE(BRAP_P_GetCustomMixerForOpPort);
    return ret;
}

/***************************************************************************
Summary:
    Private function that gets the mixer associated to a ring buffer
    
**************************************************************************/
#if ((BRAP_3548_FAMILY == 1) || (BRAP_7405_FAMILY == 1))
BERR_Code BRAP_P_GetMixerForRBuf(
    BRAP_Handle         hRap,       /*[in] Rap Handle */
    unsigned int     	uiRBufId,   /*[in] Ring Buffer Id */
    BRAP_MIXER_P_Handle *phMixer,    /*[out] Mixer Handle */
    unsigned int        *puiMixerOp    
)
{
    BERR_Code               ret=BERR_SUCCESS;

    BRAP_ChannelHandle      hRapCh= NULL;
    BRAP_RBUF_P_Handle	    hRBuf;
	BRAP_CAPPORT_P_Handle   hCapPort=NULL;  /* Capture Port handle */
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    unsigned int            lvl =0, pp = 0;    
#if BRAP_P_EQUALIZER
    BRAP_OutputChannelPair   eChSrcEq = BRAP_OutputChannelPair_eMax;
    unsigned int            lvlSrcEq = 0, ppSrcEq = 0;    
#endif
    int                     i=0,j=0,k=0,l=0;	
    bool                    bCapPort_found = false, bMixer_found = false;	

    BDBG_ENTER(BRAP_P_GetMixerForRBuf);

    BDBG_ASSERT(hRap);
    BDBG_ASSERT(phMixer);

    /* Find the channel which feeds to this ringbuffer */
	for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
	{
		hRapCh = hRap->hRapDecCh[i];
		if ( hRapCh != NULL )
		{
			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
			{
				if(NULL == hRapCh->pPath[j])
				{
					continue;
				}
				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
				{
					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
					{
						hRBuf = hRapCh->pPath[j]->hRBuf[k];
						if( hRBuf != NULL )
						{
							if ( hRBuf->uiIndex == uiRBufId )
							{
								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
								{
									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
									if (hCapPort != NULL)
									{
										bCapPort_found = true;						
										break;
									}
								}
								if (true == bCapPort_found)
								{
									break;						
								}								
							}
						}
					}
				}
				if (true == bCapPort_found)
				{
					break;
				}
		    }
			if( true==bCapPort_found )
			{
				break;
			}
		}	
	}

    /* If not found the required capture port in decode channel, look in capture channel */
    if( false == bCapPort_found )
    {
    	for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
    	{
    		hRapCh = hRap->hRapCapCh[i];
    		if ( hRapCh != NULL )
    		{
    			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
    			{
    				if(NULL == hRapCh->pPath[j])
    				{
    					continue;
    				}
    				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
    				{
    					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
    					{
    						hRBuf = hRapCh->pPath[j]->hRBuf[k];
    						if( hRBuf != NULL )
    						{
    							if ( hRBuf->uiIndex == uiRBufId )
    							{
    								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
    								{
    									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
    									if (hCapPort != NULL)
    									{
    										bCapPort_found = true;						
    										break;
    									}
    								}
    								if (true == bCapPort_found)
    								{
    									break;						
    								}								
    							}
    						}
    					}
    				}
    				if (true == bCapPort_found)
    				{
						break;
					}
				}
    			if( true==bCapPort_found )
    			{
    				break;
    			}
    		}	
    	}    
    }

    /* Not found the required capture port in capture channel also, look in playback channel */
    if( false == bCapPort_found )
    {
    	for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
    	{
    		hRapCh = hRap->hRapPbCh[i];
    		if ( hRapCh != NULL )
    		{
    			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
    			{
    				if(NULL == hRapCh->pPath[j])
    				{
    					continue;
    				}
    				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
    				{
    					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
    					{
    						hRBuf = hRapCh->pPath[j]->hRBuf[k];
    						if( hRBuf != NULL )
    						{
    							if ( hRBuf->uiIndex == uiRBufId )
    							{
    								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
    								{
    									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
    									if (hCapPort != NULL)
    									{
    										bCapPort_found = true;						
    										break;
    									}
    								}
    								if (true == bCapPort_found)
    								{
    									break;						
    								}								
    							}
    						}
    					}
    				}
    				if (true == bCapPort_found)
    				{
    					break;
    				}
    			}
    			if( true==bCapPort_found )
    			{
    				break;
    			}
    		}	
    	}    
    }

    /* Capture port is found, now find the corresponding mixer */
	if (true == bCapPort_found)
	{
		for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
		{
			if(NULL == hRapCh->pPath[j])
			{
				continue;
			}
			if((hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodePcm) ||
               (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_ePPBranch))
			{
				for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
				{
					if(hCapPort == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort)
					{
						bMixer_found = true;
						break;
					}
				}
				if (true == bMixer_found)
    			{
    				break;
    			}
    		}	
    	}    
    }
    
	/* If mixer or Capture Port for this Ring Buffer Id is not found in any of the active channels,
	    return Error */
	if((false == bCapPort_found) || (false == bMixer_found) || (NULL == hRapCh->pPath[j]))
	{
		BDBG_MSG(("BRAP_P_GetMixerForRBuf: The Ring Buffer Id %d is not Active",uiRBufId));
		return BERR_INVALID_PARAMETER;
	}
    /* Find the Mixer for the Capture Port that feeds the given Rbuf */
	if(BRAP_P_Rsrc_eMixer == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eRsrcType)
	{
	    eChPair = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eChnPair;
	    lvl = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiLevel;
	    pp = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiPrlPth;
        *puiMixerOp = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            *phMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
		BDBG_MSG(("BRAP_P_GetMixerForRBuf: Mixer Handle = %d", *phMixer));
	}
#if BRAP_P_EQUALIZER
    /* Find the SRC for the Capture Port that feeds the given Rbuf, then the corresponding Mixer */
	else if(BRAP_P_Rsrc_eSrcEq == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eRsrcType)
	{
	    eChSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eChnPair;
	    lvlSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiLevel;
	    ppSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiPrlPth;

        eChPair = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.eChnPair;
        lvl = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiLevel;
        pp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiPrlPth;
        
        *puiMixerOp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            *phMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
		BDBG_MSG(("BRAP_P_GetMixerForRBuf: Mixer Handle = %d", *phMixer));
	}
#endif
	else
		ret=BERR_INVALID_PARAMETER;


    BDBG_LEAVE(BRAP_P_GetMixerForRBuf);
    return ret;
}

#endif

BERR_Code BRAP_P_MixingAssociation( 
    BRAP_ChannelHandle          hRapCh,         /* [in] Rap channel Handle */
    unsigned int uiAssocId,
    bool            *bMixing     /*TRUE = If mixing is happening in Association */)
{
    BERR_Code   ret =BERR_SUCCESS;
    unsigned int    uiNoRapChannel = 0;
    unsigned int i;
    BDBG_ENTER(BRAP_P_MixingAssociation);
    BDBG_ASSERT(hRapCh);
    for(i=0 ; i < BRAP_MAX_PRI_DEC_CHAN_IN_ASSOCIATED_GRP ; i++)
    {
        if(hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[i] != NULL)
        {
            uiNoRapChannel++;
        }
    }

    for(i=0 ; i < BRAP_MAX_SEC_DEC_CHAN_IN_ASSOCIATED_GRP ; i++)
    {
        if(hRapCh->hRap->sAssociatedCh[uiAssocId].hSecDecCh[i] != NULL)
        {
            uiNoRapChannel++;
        }
    }

    for(i=0 ; i < BRAP_MAX_PB_CHAN_IN_ASSOCIATED_GRP ; i++)
    {
        if(hRapCh->hRap->sAssociatedCh[uiAssocId].hPBCh[i] != NULL)
        {
            uiNoRapChannel++;
        }
    }

    for(i=0 ; i < BRAP_MAX_CAP_CHAN_IN_ASSOCIATED_GRP ; i++)
    {
        if(hRapCh->hRap->sAssociatedCh[uiAssocId].hCapCh[i] != NULL)
        {
            uiNoRapChannel++;
        }
    }
    if(uiNoRapChannel > 1)
    {
        *bMixing = true;
    }
    else
    {
        *bMixing = false;
    }
    BDBG_LEAVE(BRAP_P_MixingAssociation);
    return ret;
}

/***************************************************************************
Summary:
    Private function that programs the scaling and panning coefficients for 
    a mixer    
**************************************************************************/
BERR_Code BRAP_P_ProgramCoefficients(
    BRAP_ChannelHandle          hRapCh,         /* [in] Rap channel Handle */
    const BRAP_MixingCoef	    *pMixingCoeff   /* [in] Mixing Coeff passed 
	                                               during channel start time */
)
{
    BERR_Code                       ret=BERR_SUCCESS;
    int                             chPair = 0,path=0, i=0,j=0,k=0,l =0;
    unsigned int                    uiLvl = 0, uiPp = 0;
    unsigned int                    uiLvl1 = 0, uiPp1 = 0;
    BRAP_OutputChannelPair          eChP = BRAP_OutputChannelPair_eMax;
    BRAP_OutputChannelPair          eChP1 = BRAP_OutputChannelPair_eMax;
    BRAP_P_MixerCoefficientsInfo    sMixingInfo;
    bool                            bProgrammingDone = false, bMixingInHW = true;
    BRAP_RM_P_MixerGrant            sTempMixerGrnt;
    BRAP_RM_P_ResrcGrant            *psTempGrant;
    unsigned int                    m=0 , n=0;
    BRAP_MIXER_P_Handle     hMixer = NULL;
    BRAP_GainControl    sGain;    
     bool bCompress  = false;
    BDBG_ENTER(BRAP_P_ProgramCoefficients);
    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(pMixingCoeff);

    /*Algo:
        1. Prepare the gain coefficents for all the channl pairs.
        2. for(chPair=0; all the channel pairs)
        {
            Trace the mixer for applying these coefficents
            if (hRapCh->pPath[0].sSrcCh[chPair]!=Invalid)
           
                go to the next level. Access the Resource connected to the 
                SrcCh's outlink info and find if mixer is connected.
                keep repeating untill get the first mixer.
                Note: One SRC can feed to multiple mixer inputs. For all calculate 
                      the new coeff and apply accordingly.

            for(spth = 0 to end)
                get the first mixers for each channel pairs
            
                Prepare -
                struct[per chp]
                {
                    hMixer[each SRC can feed to 4 mixers]
                    coeff0
                    coeff1
                }

                Pass this to MIXER API.
        }
    */

#ifdef RAP_MULTISTREAM_DECODER_SUPPORT  
    if(BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh))
    {
        bMixingInHW = false;
    }
#endif
    if(bMixingInHW == true)
    {
    	psTempGrant = hRapCh->hRap->sOpenTimeMallocs.psResrcGrant;
    	if( NULL==psTempGrant )
    	{
    		ret = BERR_TRACE( BERR_OUT_OF_SYSTEM_MEMORY );
                    goto error;        
    	}
            BKNI_Memset(psTempGrant, 0, sizeof(BRAP_RM_P_ResrcGrant));             	
        /* TODO: For compressed channel, return error */
        
        for(i=0;i<BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC;i++)
        {
            sMixingInfo.hMixer[i] = NULL;
            for (j=0;j<BRAP_OutputChannelPair_eMax;j++)
            {
                sMixingInfo.uiMixerIp[i][j] = BRAP_INVALID_VALUE;
                sMixingInfo.sCoeff0[i][j].ui32Left  = BRAP_INVALID_VALUE;
                sMixingInfo.sCoeff0[i][j].ui32Right = BRAP_INVALID_VALUE;
                sMixingInfo.sCoeff1[i][j].ui32Left  = BRAP_INVALID_VALUE;
                sMixingInfo.sCoeff1[i][j].ui32Right = BRAP_INVALID_VALUE;
            }
        }
        
        /* Trace all the paths to find first mixer where these coefficents can be 
           applied */
        for (path=0;path<BRAP_P_MAX_PATHS_IN_A_CHAN;path++)
        {
            if((NULL == hRapCh->pPath[path]))/* || (BRAP_P_UsgPath_eDecodePcm != hRapCh->pPath[path]->eUsgPath))*/
            {
                continue;
            }
            if(hRapCh->pPath[path]->uiAssocId == BRAP_INVALID_VALUE)
            {
                continue;
            }
            bCompress  = false;        
            BRAP_P_IsPathOutputCompress(hRapCh,path,&bCompress);
            for(chPair =0 ; chPair < BRAP_OutputChannelPair_eMax; chPair++)
            {
                /* Reset the sMixingInfo */
                for(i=0;i<BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC;i++)
                {
                    sMixingInfo.hMixer[i] = NULL;
                    for (j=0;j<BRAP_OutputChannelPair_eMax;j++)
                    {
                        sMixingInfo.uiMixerIp[i][j] = BRAP_INVALID_VALUE;
                        sMixingInfo.sCoeff0[i][j].ui32Left  = BRAP_INVALID_VALUE;
                        sMixingInfo.sCoeff0[i][j].ui32Right = BRAP_INVALID_VALUE;
                        sMixingInfo.sCoeff1[i][j].ui32Left  = BRAP_INVALID_VALUE;
                        sMixingInfo.sCoeff1[i][j].ui32Right = BRAP_INVALID_VALUE;
                    }
                }
                
                /* If channel pair present */
                if (true == hRapCh->pPath[path]->sSrcCh[chPair].bValid)
                {
                    BDBG_MSG(("BRAP_P_ProgramCoefficients: Path_id = %d",path));
                    /* Go to the SRC next to the srcch */
                    uiLvl =hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.uiLevel;
                    uiPp =hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.uiPrlPth;
                    eChP =hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.eChnPair;


                    BDBG_MSG(("BRAP_P_ProgramCoefficients: Src Lvl = %d"
                              "Prll_Path = %d, Chan_Pair = %d ",
                              uiLvl,uiPp,eChP));
                    
                    /* for every Mixer connected to a SRC in Parallel */
                    for(i=0;i<BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC;i++)
                    {
#if (BRAP_7550_FAMILY != 1)
                        BDBG_MSG(("sSrcOutLink[%d].eRsrcType =%d",i,hRapCh->pPath[path]->sSrc[uiLvl][eChP][uiPp].sSrcOutLink[i].eRsrcType));
                        /* If valid resource and its a mixer */
                        if(BRAP_P_Rsrc_eMixer == 
                            hRapCh->pPath[path]->sSrc[uiLvl][eChP][uiPp].
                                                          sSrcOutLink[i].eRsrcType)
                        {
                            /* Get the level, pp and channel pair for the mixer */
                            uiLvl1 = 
                                hRapCh->pPath[path]->sSrc[uiLvl][eChP][uiPp].
                                                            sSrcOutLink[i].uiLevel;
                            uiPp1 = 
                                hRapCh->pPath[path]->sSrc[uiLvl][eChP][uiPp].
                                                            sSrcOutLink[i].uiPrlPth;
                            eChP1 =
                                hRapCh->pPath[path]->sSrc[uiLvl][eChP][uiPp].
                                                            sSrcOutLink[i].eChnPair;
#else                        
                        BDBG_MSG(("sSrcChOutLink.eRsrcType =%d",hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.eRsrcType));
                        /* If valid resource and its a mixer */
                        if(BRAP_P_Rsrc_eMixer == 
                            hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.eRsrcType)
                        {
                            /* Get the level, pp and channel pair for the mixer */
                            uiLvl1 = hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.uiLevel;
                            uiPp1 = hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.uiPrlPth;
                            eChP1 = hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.eChnPair;
#endif                           
                            BDBG_MSG(("BRAP_P_ProgramCoefficients: Mixer Lvl = %d"
                                      "Prll_Path = %d, Chan_Pair = %d ",
                                      uiLvl1,uiPp1,eChP1));
                            
                            /* Store the handle */
                            sMixingInfo.hMixer[i] = 
                            hRapCh->pPath[path]->sMixer[uiLvl1][eChP1][uiPp1].hMixer;                           

                            /* Find the Mixer Input for this channel pair */
                            *psTempGrant = hRapCh->pPath[path]->sRsrcGrnt;

                            sTempMixerGrnt = 
                                psTempGrant->sSrcMixerGrnt[uiLvl1].sMixerGrant
                                                                     [eChP1][uiPp1];

                            sMixingInfo.uiMixerIp[i][chPair] = 
                                              sTempMixerGrnt.uiMixerInputId[chPair];
                            switch(eChP1)
                            {
                                case BRAP_OutputChannelPair_eLR:
                                    switch(chPair)
                                    {
                                        case BRAP_OutputChannelPair_eLR:
                                            m=0; n=0;
                                            break;
                                        case BRAP_OutputChannelPair_eLRSurround:
                                            m=0; n=2;
                                            break;
                                        case BRAP_OutputChannelPair_eCentreLF:
                                            m=0; n=4;
                                            break;
                                        case BRAP_OutputChannelPair_eLRRear:
                                            m=0; n=6;
                                            break;
                                        case BRAP_OutputChannelPair_eMax:
                                        default:
                                            BDBG_ASSERT(0);
                                    }
                                    break;
                                case BRAP_OutputChannelPair_eLRSurround:
                                    switch(chPair)
                                    {
                                        case BRAP_OutputChannelPair_eLR:
                                            m=2; n=0;
                                            break;
                                        case BRAP_OutputChannelPair_eLRSurround:
                                            m=2; n=2;
                                            break;
                                        case BRAP_OutputChannelPair_eCentreLF:
                                            m=2; n=4;
                                            break;
                                        case BRAP_OutputChannelPair_eLRRear:
                                            m=2; n=6;
                                            break;
                                        case BRAP_OutputChannelPair_eMax:
                                        default:
                                            BDBG_ASSERT(0);
                                    }
                                    break;
                                case BRAP_OutputChannelPair_eCentreLF:
                                    switch(chPair)
                                    {
                                        case BRAP_OutputChannelPair_eLR:
                                            m=4; n=0;
                                            break;
                                        case BRAP_OutputChannelPair_eLRSurround:
                                            m=4; n=2;
                                            break;
                                        case BRAP_OutputChannelPair_eCentreLF:
                                            m=4; n=4;
                                            break;
                                        case BRAP_OutputChannelPair_eLRRear:
                                            m=4; n=6;
                                            break;
                                        case BRAP_OutputChannelPair_eMax:
                                        default:
                                            BDBG_ASSERT(0);
                                    }
                                    break;
                                case BRAP_OutputChannelPair_eLRRear:
                                    switch(chPair)
                                    {
                                        case BRAP_OutputChannelPair_eLR:
                                            m=6; n=0;
                                            break;
                                        case BRAP_OutputChannelPair_eLRSurround:
                                            m=6; n=2;
                                            break;
                                        case BRAP_OutputChannelPair_eCentreLF:
                                            m=6; n=4;
                                            break;
                                        case BRAP_OutputChannelPair_eLRRear:
                                            m=6; n=6;
                                            break;
                                        case BRAP_OutputChannelPair_eMax:
                                        default:
                                            BDBG_ASSERT(0);
                                    }
                                    break;
                                case BRAP_OutputChannelPair_eMax:
                                default:
                                    BDBG_ASSERT(0);
                            }
                            sMixingInfo.sCoeff0[i][chPair].ui32Left  = pMixingCoeff->ui32Coef[m][n];
                            sMixingInfo.sCoeff0[i][chPair].ui32Right = pMixingCoeff->ui32Coef[m][(n+1)];
                            sMixingInfo.sCoeff1[i][chPair].ui32Left  = pMixingCoeff->ui32Coef[(m+1)][n];
                            sMixingInfo.sCoeff1[i][chPair].ui32Right = pMixingCoeff->ui32Coef[(m+1)][(n+1)];

                            BDBG_MSG(("InputChp=%d, OutputChp=%d, m=%d,n=%d",chPair,eChP1,m,n));
                            BDBG_MSG(("LeftCoeff0=0x%x, RightCoeff0=0x%x, LeftCoeff1=0x%x,RightCoeff1=0x%x",
                                      pMixingCoeff->ui32Coef[m][n],pMixingCoeff->ui32Coef[m][n+1],
                                      pMixingCoeff->ui32Coef[m+1][n],pMixingCoeff->ui32Coef[m+1][n+1]));
                            
                    
                            hMixer = sMixingInfo.hMixer[i];
                            if(hMixer != NULL)
                            {
                                if((false == hMixer->bCompress))
                                {
                                    for(l =0 ; l < BRAP_RM_P_MAX_MIXER_OUTPUTS; l++)
                                    {
                                        if(hRapCh->pPath[path]->sMixer[uiLvl1][eChP1][uiPp1].sMixerOutLink[l].eRsrcType == BRAP_P_Rsrc_eOpPort)
                                        {
                                            uiLvl = hRapCh->pPath[path]->sMixer[uiLvl1][eChP1][uiPp1].sMixerOutLink[l].uiLevel;
                                            eChP= hRapCh->pPath[path]->sMixer[uiLvl1][eChP1][uiPp1].sMixerOutLink[l].eChnPair;
                                            uiPp = hRapCh->pPath[path]->sMixer[uiLvl1][eChP1][uiPp1].sMixerOutLink[l].uiPrlPth;                

                                            if(hRapCh->pPath[path]->sOp[eChP][uiPp].sOpInLink.eRsrcType == BRAP_P_Rsrc_eMixer)
                                            {
                                                if((hRapCh->pPath[path]->sOp[eChP][uiPp].sOpInLink.uiLevel== uiLvl1)
                                                &&(hRapCh->pPath[path]->sOp[eChP][uiPp].sOpInLink.eChnPair == eChP1))
                                                {
                                                    BDBG_MSG(("Setting scaling coeffiecients for O/P %d",hRapCh->pPath[path]->sOp[eChP][uiPp].hOp->eOutputPort));

                                                    /* Find free location to keep coeff */
                                                    for(j=0;j<BRAP_P_MAX_DST_PER_RAPCH;j++)
                                                    {
                                                        if((hRapCh->sScalingInfo.eOp[hMixer->uiDpIndex*hMixer->uiMixerIndex][j]== BRAP_OutputPort_eMax)||
                                                        (hRapCh->sScalingInfo.eOp[hMixer->uiDpIndex*hMixer->uiMixerIndex][j]== hRapCh->pPath[path]->sOp[eChP][uiPp].hOp->eOutputPort))
                                                            break;
                                                    }
                                                    if(BRAP_P_MAX_DST_PER_RAPCH == j)
                                                    {
                                                        BDBG_ERR(("No space to keep Gain coeff!!"));
                                                            ret =  BERR_INVALID_PARAMETER;
                                                            goto error;
                                                    }

                                                    for(k =0 ; k< BRAP_OutputChannelPair_eMax;k++)
                                                    {
                                                        sGain.ui32LeftGain[k] = sMixingInfo.sCoeff0[i][k].ui32Left;
                                                        sGain.ui32RightGain[k] = sMixingInfo.sCoeff1[i][k].ui32Right;                                    
                                                    }                                
                                                    hRapCh->sScalingInfo.sScalingInfo[hMixer->uiDpIndex*hMixer->uiMixerIndex][j] = sGain;
                                                    hRapCh->sScalingInfo.eOp[hMixer->uiDpIndex*hMixer->uiMixerIndex][j] = hRapCh->pPath[path]->sOp[eChP][uiPp].hOp->eOutputPort;                                

                                                }
                                            }
                                        }   
                                    }
                                }
                            }                     
#if (BRAP_7550_FAMILY != 1)                        
                        }
#else
                        }
#endif
                    }
                    if(bCompress == true)
                    {
                        for(i=0;i<BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC;i++)
                        {
                            for (j=0;j<BRAP_OutputChannelPair_eMax;j++)
                            {
                                if((sMixingInfo.sCoeff0[i][j].ui32Left != BRAP_INVALID_VALUE))
                                {
                                    sMixingInfo.sCoeff0[i][j].ui32Left = BRAP_MIXER_P_DEFAULT_SCALING_COEFF;
                                }
                                if((sMixingInfo.sCoeff0[i][j].ui32Right != BRAP_INVALID_VALUE))
                                {
                                    sMixingInfo.sCoeff0[i][j].ui32Right = 0;
                                }                        
                                if((sMixingInfo.sCoeff1[i][j].ui32Left != BRAP_INVALID_VALUE))
                                {
                                    sMixingInfo.sCoeff1[i][j].ui32Left = 0;
                                }                        
                                if((sMixingInfo.sCoeff1[i][j].ui32Right != BRAP_INVALID_VALUE))
                                {
                                    sMixingInfo.sCoeff1[i][j].ui32Right = BRAP_MIXER_P_DEFAULT_SCALING_COEFF;
                                }                            
                            }
                        }
                    }
                }            


                /* Call the Mixer API to program the coeffients for this 
                   channel pair */
                ret = BRAP_MIXER_P_ProgramPingPongCoeff(&sMixingInfo,
                                                        &bProgrammingDone);
                if(BERR_SUCCESS != ret)
                {
                    BDBG_ERR(("BRAP_P_ProgramCoefficients: Returned Error"));
                    ret = BERR_TRACE(ret);
            	goto error;
                }
            }
        }/* for eChPair */
    }
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT      
    else /* Configure FW Mixer PP */
    {
        if(!(BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap)))
        {
                if((BRAP_P_IsPointerValid((void *)hRapCh->hMultiStreamDecoder))
            &&(hRapCh->eState == BRAP_P_State_eStarted))
            {
                for(j =0 ; j < BRAP_MAX_PP_SUPPORTED; j++)
                {                
                    if(hRapCh->hRap->hAudioProcessingStageHandle[j]->sProcessingStageSettings.eAudioProcessing == BRAP_ProcessingType_eFwMixer)
                    {     
                        BRAP_ProcessingStageSettings * psProcessingStageSettings =NULL;                    
                        psProcessingStageSettings=(BRAP_ProcessingStageSettings *)BKNI_Malloc(sizeof(BRAP_ProcessingStageSettings));
                        if( NULL==psProcessingStageSettings)
                        {
                            ret = BERR_TRACE(BERR_OUT_OF_DEVICE_MEMORY);
                            goto error;        
                        }                     
                            ret =BRAP_GetCurrentProcessingStageSettings(hRapCh->hRap->hAudioProcessingStageHandle[j],psProcessingStageSettings );
                        if(ret != BERR_SUCCESS)
                        {
                            BDBG_ERR(("BRAP_P_ProgramCoefficients: BRAP_GetDefaultProcessingStageSettings() returned err(%d)",ret));	
                            goto error;
                        }                     
                        ret =BRAP_SetProcessingStageSettings(hRapCh->hRap->hAudioProcessingStageHandle[j],psProcessingStageSettings);                    
                        if(ret != BERR_SUCCESS)
                        {
                            BDBG_ERR(("BRAP_P_ProgramCoefficients: BRAP_SetProcessingStageSettings() returned err(%d)",ret));	
                            goto error;
                        } 
                        BKNI_Free( psProcessingStageSettings );                               
                        break;
                    }
                }
            }
        }
    }
#endif    
    
error:	
    BDBG_LEAVE(BRAP_P_ProgramCoefficients);
    return ret;
}

#if (BRAP_DYNAMIC_PORT_SWITCHING == 1)
/***************************************************************************
Summary:
    Private function that gets the mixer associated to a output port
    
**************************************************************************/
BERR_Code
BRAP_P_FindAndDisableMixerOutputForOpPort (
    BRAP_Handle         hRap,       /*[in] Rap Handle */
    BRAP_OutputPort     eOpType,    /*[in] Output Port */
    bool                *pbParentMixerRuns /*[out]*/
)
{
    BERR_Code               ret=BERR_SUCCESS;
    BRAP_ChannelHandle      hRapCh= NULL;
    BRAP_OP_P_Handle        hOp = NULL;
    int                     i=0,j=0,k=0,l=0;
    bool                    bFound = false;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    BRAP_OutputChannelPair  eChPairCscd = BRAP_OutputChannelPair_eMax;
#if BRAP_P_EQUALIZER
    BRAP_OutputChannelPair  eChSrcEq = BRAP_OutputChannelPair_eMax;
    unsigned int            lvlSrcEq = 0, ppSrcEq = 0;
#endif
    unsigned int            lvl =0, pp = 0, lvlCscd = 0, ppCscd = 0;
    BRAP_MIXER_P_Handle     hMixer;
    BRAP_MIXER_P_Handle     hMixerCscd;    
    unsigned int            uiMixerOutput=0, ui32RegVal=0;

    BDBG_ENTER(BRAP_P_FindAndDisableMixerOutputForOpPort);

    BDBG_ASSERT(hRap);

    *pbParentMixerRuns = false;

    /* Find the channel which is outputing to this port */
    for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
    {
        hRapCh = hRap->hRapDecCh[i];
        if ( hRapCh != NULL )
        {
            for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
            {
                for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                {
                    for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                    {
                        if(NULL == hRapCh->pPath[j])
                        {
                            continue;
                        }
                        
                        hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                        if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                        {
                            bFound = true;
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
            if(true==bFound)
            {
                break;
            }
        }
    }

    if (false == bFound)
    {
        for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
        {
            hRapCh = hRap->hRapCapCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }   
        }
    
    }

    /* If not found in Dec and Cap channel, check for PB channels */
    if(false == bFound)
    {
        for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
        {
            hRapCh = hRap->hRapPbCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
        }
    }

    /* If this output port is not found in any of the active channels, return
       Error */
    if((false == bFound) || (NULL == hRapCh->pPath[j]))
    {
        BDBG_MSG(("BRAP_SetOutputVolume: The Output Port %d is not Active",eOpType));
        /*
            This was earlier as BERR_TRACE(BERR_INVALID_PARAMETER);
            But on customer request this has been changed to only return without the trace
            The Trace was throwing an error message on the console.
        */
        return BERR_INVALID_PARAMETER;
    }

    /* If found, find the Mixer for the given Output Port */
	if(BRAP_P_Rsrc_eMixer==hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
	    eChPair = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvl = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    pp = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;
        uiMixerOutput = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndDisableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));

        if((true == hMixer->sParams.bOutputEnable0) &&
           (true == hMixer->sParams.bOutputEnable1))
        {
    	    /* Get the Handle for the Mixer feeding to the Output port */
            if(uiMixerOutput == 0)
            {
    	        hMixer->sParams.bOutputEnable0 = false;
                *pbParentMixerRuns = true;
            }
            else if(uiMixerOutput == 1)
            {
    	        hMixer->sParams.bOutputEnable1 = false;
                *pbParentMixerRuns = true;                
            }
            else
            {
                BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
        		ret=BERR_INVALID_PARAMETER;
                goto exit;            
            }        
        }
        else
        {

            hMixerCscd = hMixer;
            while((*pbParentMixerRuns == false) && 
                  (hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eRsrcType == BRAP_P_Rsrc_eMixer))
            {
                eChPairCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eChnPair;
                lvlCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiLevel;
                ppCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiPrlPth;
                hMixerCscd = hRapCh->pPath[j]->sMixer[lvlCscd][eChPairCscd][ppCscd].hMixer;

                if((true == hMixerCscd->sParams.bOutputEnable0) &&
                   (true == hMixerCscd->sParams.bOutputEnable1))
                {
                    BDBG_ERR(("Cascade Mixer running"));
                    *pbParentMixerRuns = true;  
                    break;
                }

                eChPair = eChPairCscd;
                lvl = lvlCscd;
                pp = ppCscd;
            }

            if(*pbParentMixerRuns == true)
            {
        	    /* Get the Handle for the Mixer feeding to the Output port */
                if(uiMixerOutput == 0)
                {
        	        hMixer->sParams.bOutputEnable0 = false;
                }
                else if(uiMixerOutput == 1)
                {
        	        hMixer->sParams.bOutputEnable1 = false;
                }
                else
                {
                    BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
            		ret=BERR_INVALID_PARAMETER;
                    goto exit;            
                }            
            }
        }
    }
#if BRAP_P_EQUALIZER
    /* If found, find the Mixer for the given Output Port */
	else if(BRAP_P_Rsrc_eSrcEq == hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
        /* For Equalizer case it is like MIXER->SRC->OP*/	    
	    eChSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvlSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    ppSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;

        eChPair = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.eChnPair;
        lvl = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiLevel;
        pp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiPrlPth;
        uiMixerOutput = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndDisableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));

        if((true == hMixer->sParams.bOutputEnable0) &&
           (true == hMixer->sParams.bOutputEnable1))
        {
    	    /* Get the Handle for the Mixer feeding to the Output port */
            if(uiMixerOutput == 0)
            {
    	        hMixer->sParams.bOutputEnable0 = false;
                *pbParentMixerRuns = true;
            }
            else if(uiMixerOutput == 1)
            {
    	        hMixer->sParams.bOutputEnable1 = false;
                *pbParentMixerRuns = true;                
            }
            else
            {
                BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
        		ret=BERR_INVALID_PARAMETER;
                goto exit;            
            }        
        }
        else
        {

            hMixerCscd = hMixer;
            while((*pbParentMixerRuns == false) && 
                  (hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eRsrcType == BRAP_P_Rsrc_eMixer))
            {
                eChPairCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eChnPair;
                lvlCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiLevel;
                ppCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiPrlPth;
                hMixerCscd = hRapCh->pPath[j]->sMixer[lvlCscd][eChPairCscd][ppCscd].hMixer;

                if((true == hMixerCscd->sParams.bOutputEnable0) &&
                   (true == hMixerCscd->sParams.bOutputEnable1))
                {
                    *pbParentMixerRuns = true;  
                    break;
                }

                eChPair = eChPairCscd;
                lvl = lvlCscd;
                pp = ppCscd;
            }

            if(*pbParentMixerRuns == true)
            {
        	    /* Get the Handle for the Mixer feeding to the Output port */
                if(uiMixerOutput == 0)
                {
        	        hMixer->sParams.bOutputEnable0 = false;
                    *pbParentMixerRuns = true;
                }
                else if(uiMixerOutput == 1)
                {
        	        hMixer->sParams.bOutputEnable1 = false;
                    *pbParentMixerRuns = true;                
                }
                else
                {
                    BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
            		ret=BERR_INVALID_PARAMETER;
                    goto exit;            
                }            
            }
        }
	}
#endif
	else
    {
		BDBG_ERR(("No mixer connected to this destination"));
		ret=BERR_INVALID_PARAMETER;        
        goto exit;
    }

    if(*pbParentMixerRuns == true)
    {
        /* Read the Output Enable Register */
        ui32RegVal = BRAP_Read32 (hMixer->hRegister,
                                   (hMixer->ui32DpOffset 
                                    + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA));

        /* Disable Mixer output */
        switch (hMixer->uiMixerIndex)
        {
            case 0:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT1_ENA, Disable);
                }
                break;
            case 1:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT1_ENA, Disable);
                }
                break;
            case 2:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT1_ENA, Disable);
                }
                break;
            case 3:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT1_ENA, Disable);
                }
                break;
            case 4:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT1_ENA, Disable);
                }
                break;
            case 5:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT1_ENA, Disable);
                }
                break;
            case 6:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT1_ENA, Disable);
                }
                break;
            case 7:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT1_ENA, Disable);
                }
                break;
            default:
                BDBG_ERR(("BRAP_MIXER_P_Start: Invalid Mixer Index %d",hMixer->uiMixerIndex));
                return BERR_TRACE (BERR_INVALID_PARAMETER);
        }

        BRAP_Write32 ( hMixer->hRegister,
                               (hMixer->ui32DpOffset 
                                + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA), ui32RegVal);

        /* Stop the Output Ports */
        switch(eOpType)
        {
            case BRAP_OutputPort_eDac1:
                ret = BRAP_OP_P_Stop( hOp );

                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_OP_P_Stop: returned error for DAC1 port"));
                    ret = BERR_TRACE(ret);        
                    goto exit;        
                }
                break;

            case BRAP_OutputPort_eI2s4:
                ret = BRAP_OP_P_Stop( hOp );

                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_OP_P_Stop: returned error for DAC1 port"));
                    ret = BERR_TRACE(ret);        
                    goto exit;        
                }
                break;                                    

            case BRAP_OutputPort_eSpdif:
                ret = BRAP_OP_P_Stop( hOp );

                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_OP_P_Stop: returned error for DAC1 port"));
                    ret = BERR_TRACE(ret);        
                    goto exit;        
                }
                break;

            default:
                BDBG_ERR(("Mixer cannot be disabled for Output Port %d", eOpType));
                break;
        }    
    }

exit:        
    BDBG_LEAVE(BRAP_P_FindAndDisableMixerOutputForOpPort);
    return ret;
}


/***************************************************************************
Summary:
    Private function that gets the mixer associated to a output port
    
**************************************************************************/
BERR_Code
BRAP_P_FindAndDisableMixerOutputForRbuf (
    BRAP_Handle         hRap,              /*[in] Rap Handle */
    unsigned int     	uiRBufId,          /*[in] Ring Buffer Id */
    bool                *pbParentMixerRuns /*[out]*/
)
{
    BERR_Code               ret=BERR_SUCCESS;

    BRAP_ChannelHandle      hRapCh= NULL;
    BRAP_RBUF_P_Handle	    hRBuf;
	BRAP_CAPPORT_P_Handle   hCapPort=NULL;  /* Capture Port handle */
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    BRAP_OutputChannelPair  eChPairCscd = BRAP_OutputChannelPair_eMax;    
    unsigned int            lvl =0, pp = 0, lvlCscd = 0, ppCscd = 0;    
#if BRAP_P_EQUALIZER
    BRAP_OutputChannelPair   eChSrcEq = BRAP_OutputChannelPair_eMax;
    unsigned int            lvlSrcEq = 0, ppSrcEq = 0;    
#endif
    int                     i=0,j=0,k=0,l=0;	
    bool                    bCapPort_found = false, bMixer_found = false;
    BRAP_MIXER_P_Handle     hMixer;
    BRAP_MIXER_P_Handle     hMixerCscd;    
    unsigned int            uiMixerOutput=0, ui32RegVal=0;
    
    BDBG_ENTER(BRAP_P_FindAndDisableMixerOutputForRbuf);

    BDBG_ASSERT(hRap);

    /* Find the channel which feeds to this ringbuffer */
	for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
	{
		hRapCh = hRap->hRapDecCh[i];
		if ( hRapCh != NULL )
		{
			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
			{
				if(NULL == hRapCh->pPath[j])
				{
					continue;
				}
				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
				{
					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
					{
						hRBuf = hRapCh->pPath[j]->hRBuf[k];
						if( hRBuf != NULL )
						{
							if ( hRBuf->uiIndex == uiRBufId )
							{
								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
								{
									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
									if (hCapPort != NULL)
									{
										bCapPort_found = true;						
										break;
									}
								}
								if (true == bCapPort_found)
								{
									break;						
								}								
							}
						}
					}
				}
				if (true == bCapPort_found)
				{
					break;
				}
		    }
			if( true==bCapPort_found )
			{
				break;
			}
		}	
	}

    /* If not found the required capture port in decode channel, look in capture channel */
    if( false == bCapPort_found )
    {
    	for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
    	{
    		hRapCh = hRap->hRapCapCh[i];
    		if ( hRapCh != NULL )
    		{
    			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
    			{
    				if(NULL == hRapCh->pPath[j])
    				{
    					continue;
    				}
    				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
    				{
    					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
    					{
    						hRBuf = hRapCh->pPath[j]->hRBuf[k];
    						if( hRBuf != NULL )
    						{
    							if ( hRBuf->uiIndex == uiRBufId )
    							{
    								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
    								{
    									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
    									if (hCapPort != NULL)
    									{
    										bCapPort_found = true;						
    										break;
    									}
    								}
    								if (true == bCapPort_found)
    								{
    									break;						
    								}								
    							}
    						}
    					}
    				}
    				if (true == bCapPort_found)
    				{
						break;
					}
				}
    			if( true==bCapPort_found )
    			{
    				break;
    			}
    		}	
    	}    
    }

    /* Not found the required capture port in capture channel also, look in playback channel */
    if( false == bCapPort_found )
    {
    	for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
    	{
    		hRapCh = hRap->hRapPbCh[i];
    		if ( hRapCh != NULL )
    		{
    			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
    			{
    				if(NULL == hRapCh->pPath[j])
    				{
    					continue;
    				}
    				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
    				{
    					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
    					{
    						hRBuf = hRapCh->pPath[j]->hRBuf[k];
    						if( hRBuf != NULL )
    						{
    							if ( hRBuf->uiIndex == uiRBufId )
    							{
    								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
    								{
    									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
    									if (hCapPort != NULL)
    									{
    										bCapPort_found = true;						
    										break;
    									}
    								}
    								if (true == bCapPort_found)
    								{
    									break;						
    								}								
    							}
    						}
    					}
    				}
    				if (true == bCapPort_found)
    				{
    					break;
    				}
    			}
    			if( true==bCapPort_found )
    			{
    				break;
    			}
    		}	
    	}    
    }

    /* Capture port is found, now find the corresponding mixer */
	if (true == bCapPort_found)
	{
		for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
		{
			if(NULL == hRapCh->pPath[j])
			{
				continue;
			}
			if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)
			{
				for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
				{
					if(hCapPort == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort)
					{
						bMixer_found = true;
						break;
					}
				}
				if (true == bMixer_found)
    			{
    				break;
    			}
    		}	
    	}    
    }
    
	/* If mixer or Capture Port for this Ring Buffer Id is not found in any of the active channels,
	    return Error */
	if((false == bCapPort_found) || (false == bMixer_found) || (NULL == hRapCh->pPath[j]))
	{
		BDBG_MSG(("BRAP_P_FindAndDisableMixerOutputForRbuf: The Ring Buffer Id %d is not Active",uiRBufId));
		return BERR_INVALID_PARAMETER;
	}

    /* Find the Mixer for the Capture Port that feeds the given Rbuf */
	if(BRAP_P_Rsrc_eMixer == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eRsrcType)
	{
	    eChPair = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eChnPair;
	    lvl = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiLevel;
	    pp = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiPrlPth;
        uiMixerOutput = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndDisableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));

        if((true == hMixer->sParams.bOutputEnable0) &&
           (true == hMixer->sParams.bOutputEnable1))
        {
    	    /* Get the Handle for the Mixer feeding to the Output port */
            if(uiMixerOutput == 0)
            {
    	        hMixer->sParams.bOutputEnable0 = false;
                *pbParentMixerRuns = true;
            }
            else if(uiMixerOutput == 1)
            {
    	        hMixer->sParams.bOutputEnable1 = false;
                *pbParentMixerRuns = true;                
            }
            else
            {
                BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
        		ret=BERR_INVALID_PARAMETER;
                goto exit;            
            }
        }
        else
        {

            hMixerCscd = hMixer;
            while((*pbParentMixerRuns == false) && 
                  (hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eRsrcType == BRAP_P_Rsrc_eMixer))
            {
                BDBG_ERR(("In while"));
                eChPairCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eChnPair;
                lvlCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiLevel;
                ppCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiPrlPth;
                hMixerCscd = hRapCh->pPath[j]->sMixer[lvlCscd][eChPairCscd][ppCscd].hMixer;

                if((true == hMixerCscd->sParams.bOutputEnable0) &&
                   (true == hMixerCscd->sParams.bOutputEnable1))
                {
                    BDBG_ERR(("Cascade Mixer running"));
                    *pbParentMixerRuns = true;  
                    break;
                }

                eChPair = eChPairCscd;
                lvl = lvlCscd;
                pp = ppCscd;
            }

            if(*pbParentMixerRuns == true)
            {
        	    /* Get the Handle for the Mixer feeding to the Output port */
                if(uiMixerOutput == 0)
                {
        	        hMixer->sParams.bOutputEnable0 = false;
                }
                else if(uiMixerOutput == 1)
                {
        	        hMixer->sParams.bOutputEnable1 = false;
                }
                else
                {
                    BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
            		ret=BERR_INVALID_PARAMETER;
                    goto exit;            
                }            
            }
        }
	}    
#if BRAP_P_EQUALIZER
    /* Find the SRC for the Capture Port that feeds the given Rbuf, then the corresponding Mixer */
	else if(BRAP_P_Rsrc_eSrcEq == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eRsrcType)
	{
	    eChSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eChnPair;
	    lvlSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiLevel;
	    ppSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiPrlPth;

        eChPair = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.eChnPair;
        lvl = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiLevel;
        pp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiPrlPth;

        uiMixerOutput = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiMixerOutput;
        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndDisableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));

        if((true == hMixer->sParams.bOutputEnable0) &&
           (true == hMixer->sParams.bOutputEnable1))
        {
    	    /* Get the Handle for the Mixer feeding to the Output port */
            if(uiMixerOutput == 0)
            {
    	        hMixer->sParams.bOutputEnable0 = false;
                *pbParentMixerRuns = true;
            }
            else if(uiMixerOutput == 1)
            {
    	        hMixer->sParams.bOutputEnable1 = false;
                *pbParentMixerRuns = true;                
            }
            else
            {
                BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
        		ret=BERR_INVALID_PARAMETER;
                goto exit;            
            }        
        }
        else
        {

            hMixerCscd = hMixer;
            while((*pbParentMixerRuns == false) && 
                  (hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eRsrcType == BRAP_P_Rsrc_eMixer))
            {
                eChPairCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eChnPair;
                lvlCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiLevel;
                ppCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiPrlPth;
                hMixerCscd = hRapCh->pPath[j]->sMixer[lvlCscd][eChPairCscd][ppCscd].hMixer;

                if((true == hMixerCscd->sParams.bOutputEnable0) &&
                   (true == hMixerCscd->sParams.bOutputEnable1))
                {
                    *pbParentMixerRuns = true;  
                    break;
                }

                eChPair = eChPairCscd;
                lvl = lvlCscd;
                pp = ppCscd;
            }

            if(*pbParentMixerRuns == true)
            {
        	    /* Get the Handle for the Mixer feeding to the Output port */
                if(uiMixerOutput == 0)
                {
        	        hMixer->sParams.bOutputEnable0 = false;
                    *pbParentMixerRuns = true;
                }
                else if(uiMixerOutput == 1)
                {
        	        hMixer->sParams.bOutputEnable1 = false;
                    *pbParentMixerRuns = true;                
                }
                else
                {
                    BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
            		ret=BERR_INVALID_PARAMETER;
                    goto exit;            
                }            
            }
        }
	}
#endif
	else
    {
		BDBG_ERR(("No mixer connected to this destination"));
		ret=BERR_INVALID_PARAMETER;        
        goto exit;
    }

    if(*pbParentMixerRuns == true)
    {
        /* Read the Output Enable Register */
        ui32RegVal = BRAP_Read32 (hMixer->hRegister,
                                   (hMixer->ui32DpOffset 
                                    + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA));

        /* Disable Mixer output */
        switch (hMixer->uiMixerIndex)
        {
            case 0:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT1_ENA, Disable);
                }
                break;
            case 1:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT1_ENA, Disable);
                }
                break;
            case 2:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT1_ENA, Disable);
                }
                break;
            case 3:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT1_ENA, Disable);
                }
                break;
            case 4:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT1_ENA, Disable);
                }
                break;
            case 5:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT1_ENA, Disable);
                }
                break;
            case 6:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT1_ENA, Disable);
                }
                break;
            case 7:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT1_ENA, Disable);
                }
                break;
            default:
                BDBG_ERR(("BRAP_MIXER_P_Start: Invalid Mixer Index %d",hMixer->uiMixerIndex));
                return BERR_TRACE (BERR_INVALID_PARAMETER);
        }

        BRAP_Write32 ( hMixer->hRegister,
                               (hMixer->ui32DpOffset 
                                + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA), ui32RegVal);

        /* Stop the Capture Port*/
        ret = BRAP_CAPPORT_P_Stop(hCapPort);    

        if(ret != BERR_SUCCESS)
        {
            BDBG_ERR(("BRAP_CAPPORT_P_Stop: returned error for Capture port %d", hCapPort->eCapPort));
            ret = BERR_TRACE(ret);        
            goto exit;        
        }   
    }
    
exit:        
    BDBG_LEAVE(BRAP_P_FindAndDisableMixerOutputForRbuf);
    return ret;
}

/***************************************************************************
Summary:
    Private function that gets the mixer associated to a output port
    
**************************************************************************/
BERR_Code
BRAP_P_FindAndEnableMixerOutputForOpPort (
    BRAP_Handle         hRap,       /*[in] Rap Handle */
    BRAP_OutputPort     eOpType,    /*[in] Output Port */
    bool                *pbParentMixerRuns /*[out]*/
)
{
    BERR_Code               ret=BERR_SUCCESS;
    BRAP_ChannelHandle      hRapCh= NULL;
    BRAP_OP_P_Handle        hOp = NULL;
    int                     i=0,j=0,k=0,l=0;
    bool                    bFound = false;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
#if BRAP_P_EQUALIZER
    BRAP_OutputChannelPair  eChSrcEq = BRAP_OutputChannelPair_eMax;
    unsigned int            lvlSrcEq = 0, ppSrcEq = 0;
#endif
    unsigned int            lvl =0, pp = 0;
    BRAP_MIXER_P_Handle     hMixer;
#if 0
    unsigned int            lvlCscd = 0, ppCscd = 0
    BRAP_MIXER_P_Handle     hMixerCscd;
    BRAP_OutputChannelPair  eChPairCscd = BRAP_OutputChannelPair_eMax;
#endif
    unsigned int            uiMixerOutput=0, ui32RegVal=0;

    BDBG_ENTER(BRAP_P_FindAndEnableMixerOutputForOpPort);

    BDBG_ASSERT(hRap);

    *pbParentMixerRuns = false;

    /* Find the channel which is outputing to this port */
    for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
    {
        hRapCh = hRap->hRapDecCh[i];
        if ( hRapCh != NULL )
        {
            for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
            {
                for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                {
                    for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                    {
                        if(NULL == hRapCh->pPath[j])
                        {
                            continue;
                        }
                        
                        hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                        if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                        {
                            bFound = true;
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
            if(true==bFound)
            {
                break;
            }
        }
    }

    if (false == bFound)
    {

        for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
        {
            hRapCh = hRap->hRapCapCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }   
        }
    
    }

    /* If not found in Dec and Cap channel, check for PB channels */
    if(false == bFound)
    {
        for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
        {
            hRapCh = hRap->hRapPbCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
        }
    }

    /* If this output port is not found in any of the active channels, return
       Error */
    if((false == bFound) || (NULL == hRapCh->pPath[j]))
    {
        BDBG_MSG(("BRAP_SetOutputVolume: The Output Port %d entry is not present",eOpType));
        /*
            This was earlier as BERR_TRACE(BERR_INVALID_PARAMETER);
            But on customer request this has been changed to only return without the trace
            The Trace was throwing an error message on the console.
        */
        return BERR_INVALID_PARAMETER;
    }

    /* If found, find the Mixer for the given Output Port */
	if(BRAP_P_Rsrc_eMixer==hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
	    eChPair = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvl = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    pp = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;
        uiMixerOutput = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndEnableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));

 
	    /* Get the Handle for the Mixer feeding to the Output port */
        if(uiMixerOutput == 0)
        {
            if(true == hMixer->sParams.bOutputEnable1)
            {
                *pbParentMixerRuns = true;            
            }
            else
            {
                BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
        		ret=BERR_NOT_SUPPORTED;
                goto exit;                  
            }
        }
        else if(uiMixerOutput == 1)
        {
            if(true == hMixer->sParams.bOutputEnable1)
            {
                *pbParentMixerRuns = true;            
            }
            else
            {
                BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
        		ret=BERR_NOT_SUPPORTED;
                goto exit;                  
            }            
        }
        else
        {
            BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }

        if(hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerOutLink[!(uiMixerOutput)].eRsrcType == BRAP_P_Rsrc_eOpPort)
        {
            switch(eOpType)
            {
                case BRAP_OutputPort_eDac1:
                    ret = BRAP_OP_P_Start(hOp, &(hOp->uOpParams.sDac));

                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_OP_P_Start: returned error for DAC1 port"));
                        ret = BERR_TRACE(ret);        
                        goto exit;        
                    }
                    break;

                case BRAP_OutputPort_eI2s4:
                    ret = BRAP_OP_P_Start(hOp, &(hOp->uOpParams.sI2s));

                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_OP_P_Start: returned error for DAC1 port"));
                        ret = BERR_TRACE(ret);        
                        goto exit;        
                    }
                    break;                                    

                case BRAP_OutputPort_eSpdif:
                    ret = BRAP_OP_P_Start(hOp, &(hOp->uOpParams.sSpdif));

                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_OP_P_Start: returned error for DAC1 port"));
                        ret = BERR_TRACE(ret);        
                        goto exit;        
                    }
                    break; 

                default:
                    BDBG_ERR(("Mixer cannot be enabled for Output Port %d", eOpType));
                    break;                    
            }         
        }
        else
        {
            BDBG_ERR(("Op InLink and Mixer Outlink dont match"));
    		ret=BERR_NOT_SUPPORTED;
            goto exit;                              
        }
#if 0        
        else if(hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerOutLink[!(uiMixerOutput)].eRsrcType == BRAP_P_Rsrc_eMixer)
        {

            hMixerCscd = hMixer;
            while((*pbParentMixerRuns == false) && 
                  (hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eRsrcType == BRAP_P_Rsrc_eMixer))
            {
                BDBG_ERR(("In while"));
                eChPairCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eChnPair;
                lvlCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiLevel;
                ppCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiPrlPth;
                uiMixerOutput = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiMixerOutput;
                hMixerCscd = hRapCh->pPath[j]->sMixer[lvlCscd][eChPairCscd][ppCscd].hMixer;                

        	    /* Get the Handle for the Mixer feeding to the Output port */
                if(uiMixerOutput == 0)
                {
                    if(true != hMixerCscd->sParams.bOutputEnable0)
                    {
                        BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
                		ret=BERR_NOT_SUPPORTED;
                        goto exit;                  
                    }
                }
                else if(uiMixerOutput == 1)
                {
                    if(true != hMixerCscd->sParams.bOutputEnable1)
                    {
                        BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
                		ret=BERR_NOT_SUPPORTED;
                        goto exit;                  
                    }            
                }
                else
                {
                    BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
            		ret=BERR_INVALID_PARAMETER;
                    goto exit;            
                }

                eChPair = eChPairCscd;
                lvl = lvlCscd;
                pp = ppCscd;
            }

            if(*pbParentMixerRuns == true)
            {
        	    /* Get the Handle for the Mixer feeding to the Output port */
                if(uiMixerOutput == 0)
                {
        	        hMixer->sParams.bOutputEnable0 = false;
                }
                else if(uiMixerOutput == 1)
                {
        	        hMixer->sParams.bOutputEnable1 = false;
                }
                else
                {
                    BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
            		ret=BERR_INVALID_PARAMETER;
                    goto exit;            
                }            
            }
        }
#if BRAP_P_EQUALIZER        
        else if(hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerOutLink[!(uiMixerOutput)].eRsrcType == BRAP_P_Rsrc_eSrcEq)
        {
        }
#endif 
#endif
    }
#if BRAP_P_EQUALIZER
    /* If found, find the Mixer for the given Output Port */
	else if(BRAP_P_Rsrc_eSrcEq == hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
        /* For Equalizer case it is like MIXER->SRC->OP*/	    
	    eChSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvlSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    ppSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;

        eChPair = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.eChnPair;
        lvl = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiLevel;
        pp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiPrlPth;
        uiMixerOutput = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndEnableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));
 
	    /* Get the Handle for the Mixer feeding to the Output port */
        if(uiMixerOutput == 0)
        {
            if(true == hMixer->sParams.bOutputEnable1)
            {
                *pbParentMixerRuns = true;            
            }
            else
            {
                BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
        		ret=BERR_NOT_SUPPORTED;
                goto exit;                  
            }
        }
        else if(uiMixerOutput == 1)
        {
            if(true == hMixer->sParams.bOutputEnable1)
            {
                *pbParentMixerRuns = true;            
            }
            else
            {
                BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
        		ret=BERR_NOT_SUPPORTED;
                goto exit;                  
            }            
        }
        else
        {
            BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }

        if(hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerOutLink[!(uiMixerOutput)].eRsrcType == BRAP_P_Rsrc_eOpPort)
        {
            switch(eOpType)
            {
                case BRAP_OutputPort_eDac1:
                    ret = BRAP_OP_P_Start(hOp, &(hOp->uOpParams.sDac));

                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_OP_P_Start: returned error for DAC1 port"));
                        ret = BERR_TRACE(ret);        
                        goto exit;        
                    }
                    break;

                case BRAP_OutputPort_eI2s4:
                    ret = BRAP_OP_P_Start(hOp, &(hOp->uOpParams.sI2s));

                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_OP_P_Start: returned error for DAC1 port"));
                        ret = BERR_TRACE(ret);        
                        goto exit;        
                    }
                    break;                                    

                case BRAP_OutputPort_eSpdif:
                    ret = BRAP_OP_P_Start(hOp, &(hOp->uOpParams.sSpdif));

                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_OP_P_Start: returned error for DAC1 port"));
                        ret = BERR_TRACE(ret);        
                        goto exit;        
                    }
                    break; 

                default:
                    BDBG_ERR(("Mixer cannot be enabled for Output Port %d", eOpType));
                    break;                      
            }         
        }
        else
        {
            BDBG_ERR(("Op InLink and Mixer Outlink dont match"));
    		ret=BERR_NOT_SUPPORTED;
            goto exit;                              
        }
	}
#endif
	else
    {
		BDBG_ERR(("No mixer connected to this destination"));
		ret=BERR_INVALID_PARAMETER;        
        goto exit;
    }

    if(*pbParentMixerRuns == true)
    {
        /* Read the Output Enable Register */
        ui32RegVal = BRAP_Read32 (hMixer->hRegister,
                                   (hMixer->ui32DpOffset 
                                    + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA));

        /* Disable Mixer output */
        switch (hMixer->uiMixerIndex)
        {
            case 0:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT1_ENA, Disable);
                }
                break;
            case 1:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT1_ENA, Disable);
                }
                break;
            case 2:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT1_ENA, Disable);
                }
                break;
            case 3:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT1_ENA, Disable);
                }
                break;
            case 4:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT1_ENA, Disable);
                }
                break;
            case 5:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT1_ENA, Disable);
                }
                break;
            case 6:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT1_ENA, Disable);
                }
                break;
            case 7:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT1_ENA, Disable);
                }
                break;
            default:
                BDBG_ERR(("BRAP_MIXER_P_Start: Invalid Mixer Index %d",hMixer->uiMixerIndex));
                return BERR_TRACE (BERR_INVALID_PARAMETER);
        }

        BRAP_Write32 ( hMixer->hRegister,
                               (hMixer->ui32DpOffset 
                                + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA), ui32RegVal);
    
    }

exit:        
    BDBG_LEAVE(BRAP_P_FindAndEnableMixerOutputForOpPort);
    return ret;
}


/***************************************************************************
Summary:
    Private function that gets the mixer associated to a output port
    
**************************************************************************/
BERR_Code
BRAP_P_FindAndEnableMixerOutputForRbuf (
    BRAP_Handle         hRap,              /*[in] Rap Handle */
    unsigned int     	uiRBufId,          /*[in] Ring Buffer Id */
    bool                *pbParentMixerRuns /*[out]*/
)
{
    BERR_Code               ret=BERR_SUCCESS;

    BRAP_ChannelHandle      hRapCh= NULL;
    BRAP_RBUF_P_Handle	    hRBuf;
	BRAP_CAPPORT_P_Handle   hCapPort=NULL;  /* Capture Port handle */
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    unsigned int            lvl =0, pp = 0;    
    int                     i=0,j=0,k=0,l=0;	
    bool                    bCapPort_found = false, bMixer_found = false;
    BRAP_MIXER_P_Handle     hMixer;
#if 0
    unsigned int            lvlCscd = 0, ppCscd = 0;
    BRAP_MIXER_P_Handle     hMixerCscd;
    unsigned int            lvlSrcEq = 0, ppSrcEq = 0;    
    BRAP_OutputChannelPair  eChPairCscd = BRAP_OutputChannelPair_eMax;    
#if BRAP_P_EQUALIZER
    BRAP_OutputChannelPair   eChSrcEq = BRAP_OutputChannelPair_eMax;
#endif    
#endif
    unsigned int            uiMixerOutput=0, ui32RegVal=0;
    
    BDBG_ENTER(BRAP_P_FindAndEnableMixerOutputForRbuf);

    BDBG_ASSERT(hRap);

    /* Find the channel which feeds to this ringbuffer */
	for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
	{
		hRapCh = hRap->hRapDecCh[i];
		if ( hRapCh != NULL )
		{
			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
			{
				if(NULL == hRapCh->pPath[j])
				{
					continue;
				}
				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
				{
					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
					{
						hRBuf = hRapCh->pPath[j]->hRBuf[k];
						if( hRBuf != NULL )
						{
							if ( hRBuf->uiIndex == uiRBufId )
							{
								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
								{
									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
									if (hCapPort != NULL)
									{
										bCapPort_found = true;						
										break;
									}
								}
								if (true == bCapPort_found)
								{
									break;						
								}								
							}
						}
					}
				}
				if (true == bCapPort_found)
				{
					break;
				}
		    }
			if( true==bCapPort_found )
			{
				break;
			}
		}	
	}

    /* If not found the required capture port in decode channel, look in capture channel */
    if( false == bCapPort_found )
    {
    	for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
    	{
    		hRapCh = hRap->hRapCapCh[i];
    		if ( hRapCh != NULL )
    		{
    			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
    			{
    				if(NULL == hRapCh->pPath[j])
    				{
    					continue;
    				}
    				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
    				{
    					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
    					{
    						hRBuf = hRapCh->pPath[j]->hRBuf[k];
    						if( hRBuf != NULL )
    						{
    							if ( hRBuf->uiIndex == uiRBufId )
    							{
    								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
    								{
    									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
    									if (hCapPort != NULL)
    									{
    										bCapPort_found = true;						
    										break;
    									}
    								}
    								if (true == bCapPort_found)
    								{
    									break;						
    								}								
    							}
    						}
    					}
    				}
    				if (true == bCapPort_found)
    				{
						break;
					}
				}
    			if( true==bCapPort_found )
    			{
    				break;
    			}
    		}	
    	}    
    }

    /* Not found the required capture port in capture channel also, look in playback channel */
    if( false == bCapPort_found )
    {
    	for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
    	{
    		hRapCh = hRap->hRapPbCh[i];
    		if ( hRapCh != NULL )
    		{
    			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
    			{
    				if(NULL == hRapCh->pPath[j])
    				{
    					continue;
    				}
    				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
    				{
    					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
    					{
    						hRBuf = hRapCh->pPath[j]->hRBuf[k];
    						if( hRBuf != NULL )
    						{
    							if ( hRBuf->uiIndex == uiRBufId )
    							{
    								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
    								{
    									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
    									if (hCapPort != NULL)
    									{
    										bCapPort_found = true;						
    										break;
    									}
    								}
    								if (true == bCapPort_found)
    								{
    									break;						
    								}								
    							}
    						}
    					}
    				}
    				if (true == bCapPort_found)
    				{
    					break;
    				}
    			}
    			if( true==bCapPort_found )
    			{
    				break;
    			}
    		}	
    	}    
    }

    /* Capture port is found, now find the corresponding mixer */
	if (true == bCapPort_found)
	{
		for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
		{
			if(NULL == hRapCh->pPath[j])
			{
				continue;
			}
			if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)
			{
				for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
				{
					if(hCapPort == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort)
					{
						bMixer_found = true;
						break;
					}
				}
				if (true == bMixer_found)
    			{
    				break;
    			}
    		}	
    	}    
    }
    
    
	/* If mixer or Capture Port for this Ring Buffer Id is not found in any of the active channels,
	    return Error */
	if((false == bCapPort_found) || (false == bMixer_found) || (NULL == hRapCh->pPath[j]))
	{
		BDBG_MSG(("BRAP_P_FindAndEnableMixerOutputForRbuf: The Ring Buffer Id %d is not Active",uiRBufId));
		return BERR_INVALID_PARAMETER;
	}

    /* Find the Mixer for the Capture Port that feeds the given Rbuf */
	if(BRAP_P_Rsrc_eMixer == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eRsrcType)
	{
	    eChPair = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eChnPair;
	    lvl = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiLevel;
	    pp = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiPrlPth;
        uiMixerOutput = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndEnableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));

	    /* Get the Handle for the Mixer feeding to the Output port */
        if(uiMixerOutput == 0)
        {
            if(true == hMixer->sParams.bOutputEnable1)
            {
                *pbParentMixerRuns = true;            
            }
            else
            {
                BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
        		ret=BERR_NOT_SUPPORTED;
                goto exit;                  
            }
        }
        else if(uiMixerOutput == 1)
        {
            if(true == hMixer->sParams.bOutputEnable1)
            {
                *pbParentMixerRuns = true;            
            }
            else
            {
                BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
        		ret=BERR_NOT_SUPPORTED;
                goto exit;                  
            }            
        }
        else
        {
            BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }

        if(*pbParentMixerRuns == true)
        {
            if(hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerOutLink[!(uiMixerOutput)].eRsrcType == BRAP_P_Rsrc_eCapPort)
            {
                *pbParentMixerRuns = true;
                ret = BRAP_CAPPORT_P_Start(hCapPort, &hCapPort->sParams);    

                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_CAPPORT_P_Stop: returned error for Capture port %d", hCapPort->eCapPort));
                    ret = BERR_TRACE(ret);        
                    goto exit;        
                }         
            }
            else
            {
                BDBG_ERR(("Capture Port InLink and Mixer Outlink dont match"));
        		ret=BERR_NOT_SUPPORTED;
                goto exit;                              
            }
        }
    }
#if 0    
#if BRAP_P_EQUALIZER
    /* Find the SRC for the Capture Port that feeds the given Rbuf, then the corresponding Mixer */
	else if(BRAP_P_Rsrc_eSrcEq == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eRsrcType)
	{
	    eChSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eChnPair;
	    lvlSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiLevel;
	    ppSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiPrlPth;

        eChPair = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.eChnPair;
        lvl = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiLevel;
        pp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiPrlPth;

        uiMixerOutput = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiMixerOutput;
        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndEnableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));

        if((true == hMixer->sParams.bOutputEnable0) &&
           (true == hMixer->sParams.bOutputEnable1))
        {
    	    /* Get the Handle for the Mixer feeding to the Output port */
            if(uiMixerOutput == 0)
            {
    	        hMixer->sParams.bOutputEnable0 = false;
                *pbParentMixerRuns = true;
            }
            else if(uiMixerOutput == 1)
            {
    	        hMixer->sParams.bOutputEnable1 = false;
                *pbParentMixerRuns = true;                
            }
            else
            {
                BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
        		ret=BERR_INVALID_PARAMETER;
                goto exit;            
            }        
        }
        else
        {

            hMixerCscd = hMixer;
            while((*pbParentMixerRuns == false) && 
                  (hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eRsrcType == BRAP_P_Rsrc_eMixer))
            {
                eChPairCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eChnPair;
                lvlCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiLevel;
                ppCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiPrlPth;
                hMixerCscd = hRapCh->pPath[j]->sMixer[lvlCscd][eChPairCscd][ppCscd].hMixer;

                if((true == hMixerCscd->sParams.bOutputEnable0) &&
                   (true == hMixerCscd->sParams.bOutputEnable1))
                {
                    *pbParentMixerRuns = true;  
                    break;
                }

                eChPair = eChPairCscd;
                lvl = lvlCscd;
                pp = ppCscd;
            }

            if(*pbParentMixerRuns == true)
            {
        	    /* Get the Handle for the Mixer feeding to the Output port */
                if(uiMixerOutput == 0)
                {
        	        hMixer->sParams.bOutputEnable0 = false;
                    *pbParentMixerRuns = true;
                }
                else if(uiMixerOutput == 1)
                {
        	        hMixer->sParams.bOutputEnable1 = false;
                    *pbParentMixerRuns = true;                
                }
                else
                {
                    BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
            		ret=BERR_INVALID_PARAMETER;
                    goto exit;            
                }            
            }
        }
	}
#endif
#endif
	else
    {
		BDBG_ERR(("No mixer connected to this destination"));
		ret=BERR_INVALID_PARAMETER;        
        goto exit;
    }

    if(*pbParentMixerRuns == true)
    {
        /* Read the Output Enable Register */
        ui32RegVal = BRAP_Read32 (hMixer->hRegister,
                                   (hMixer->ui32DpOffset 
                                    + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA));

        /* Disable Mixer output */
        switch (hMixer->uiMixerIndex)
        {
            case 0:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT1_ENA, Disable);
                }
                break;
            case 1:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT1_ENA, Disable);
                }
                break;
            case 2:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT1_ENA, Disable);
                }
                break;
            case 3:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT1_ENA, Disable);
                }
                break;
            case 4:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT1_ENA, Disable);
                }
                break;
            case 5:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT1_ENA, Disable);
                }
                break;
            case 6:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT1_ENA, Disable);
                }
                break;
            case 7:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT1_ENA, Disable);
                }
                break;
            default:
                BDBG_ERR(("BRAP_MIXER_P_Start: Invalid Mixer Index %d",hMixer->uiMixerIndex));
                return BERR_TRACE (BERR_INVALID_PARAMETER);
        }

        BRAP_Write32 ( hMixer->hRegister,
                               (hMixer->ui32DpOffset 
                                + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA), ui32RegVal);
    }

exit:        
    BDBG_LEAVE(BRAP_P_FindAndEnableMixerOutputForRbuf);
    return ret;
}

#endif


#if (BRAP_OPEN_TIME_RBUF_ALLOCATION==1)

void   BRAP_P_SearchAndFreeRbuf(
    BRAP_ChannelHandle hRapCh,
	unsigned int 				uiFwProcBranchId,/* [in] FW Processing Branch Id */
    unsigned int 				uiCapPortSrcId,	 /* [in] Capture Port Source Id */    
    void *pBufferPtr    
    )
{
    unsigned int    i = 0;

		        /* Returning Device Rbuf to Pool */
    /* sInRBuf */
    for(i=0; i < BRAP_MAX_DEVICE_INPUT_BUFFER; i++)
    {
        if(hRapCh->hRap->sDeviceRBufPool.sInputBuffer[i].pRBufPtr == pBufferPtr)
        {
            hRapCh->hRap->sDeviceRBufPool.sInputBuffer[i].bUsed=false;
            goto end;
        }
    } 
    /* sOutRBuf */        
    for(i=0; i < BRAP_MAX_DEVICE_OUTPUT_BUFFER; i++)
    {
        if(hRapCh->hRap->sDeviceRBufPool.sOutputBuffer[i].pRBufPtr == pBufferPtr)
        {
            hRapCh->hRap->sDeviceRBufPool.sOutputBuffer[i].bUsed=false;
            goto end;
        }
    }
    /* sDestRBuf */    
    for(i = 0; i< BRAP_OutputChannelPair_eMax*2; i++)
    {
        if(hRapCh->hRap->sDeviceRBufPool.sDestRBuf[i].pRBufPtr == pBufferPtr)
        {
            hRapCh->hRap->sDeviceRBufPool.sDestRBuf[i].bUsed=false;
            goto end;
        }
    }
			        /* sHbrRBuf */
    for(i = 0; i< BRAP_NUM_HBR_BUFFERS;i++)
			        {
        if(hRapCh->hRap->sDeviceRBufPool.sHbrRBuf[i].pRBufPtr == pBufferPtr)
        {
            hRapCh->hRap->sDeviceRBufPool.sHbrRBuf[i].bUsed=false;
            goto end;
        }
    }

				/* Returning Channel Rbuf to Pool */
    /* sDecOutRBuf */    
    for(i = 0; i< BRAP_MAX_OUT_CH_PER_FW_PROC_BRANCH; i++)
    {
        if(hRapCh->sChanRBufPool.sDecOutRBuf[uiFwProcBranchId][i].pRBufPtr == pBufferPtr)
        {
            hRapCh->sChanRBufPool.sDecOutRBuf[uiFwProcBranchId][i].bUsed=false;
            goto end;
        }
    }
    /* sDecInRBuf */    
    for(i = 0; i < BRAP_MAX_IN_CH_PER_FW_PROC_BRANCH; i++)
    {
        if(hRapCh->sChanRBufPool.sDecInRBuf[uiCapPortSrcId][i].pRBufPtr == pBufferPtr)
        {
            hRapCh->sChanRBufPool.sDecInRBuf[uiCapPortSrcId][i].bUsed=false;
            goto end;            
        }
    }
    /* sPbRBuf */    
    for(i=0; i < BRAP_P_MAX_RBUF_PER_PBCH; i++)
    {
        if(hRapCh->sChanRBufPool.sPbRBuf[i].pRBufPtr == pBufferPtr)
        {
	        hRapCh->sChanRBufPool.sPbRBuf[i].bUsed=false;
            goto end;
        }
    } 

    BDBG_WRN(("The Ring Buffer %#x can't be returned to the buffer pool",pBufferPtr));
end:
    return;
}


/***************************************************************************
Summary:
    Private function that returns the RBuf from Ring Buffer Pool.
***************************************************************************/
void
BRAP_P_ReturnRBufToPool(
    BRAP_ChannelHandle hRapCh,
    BRAP_P_ObjectHandles 		*pPath,			/* [in] Path id */
	bool						bIsDestRbuf,	/* [in] 1= Destination RBuf Type
												   0 =  Other RBuf Type */
	unsigned int 				uiFwProcBranchId,/* [in] FW Processing Branch Id */
	unsigned int 				uiCapPortSrcId	 /* [in] Capture Port Source Id */
    )
{
	unsigned int    i = 0;
    void *pTemp =NULL;
    BDBG_ENTER(BRAP_P_ReturnRBufToPool);
    BDBG_ASSERT(hRapCh);

    if(bIsDestRbuf == true) /*Destination Rbuf */
    {
        for(i=0; i<BRAP_P_MAX_DST_PER_RAPCH; i++)
        {
            if(NULL == hRapCh->pDstDetails[i]) 
            {
				continue;
            }
            if(BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst)
            {
                hRapCh->hRap->sDeviceRBufPool.sDestRBuf[0].bUsed=false;
                hRapCh->hRap->sDeviceRBufPool.sDestRBuf[1].bUsed=false;
                break;
            }
        }
    }
    else
    {
        for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNELS; i++)
        {
            if(pPath->hRBuf[i] == NULL)
            continue;
            pTemp =pPath->hRBuf[i]->sSettings.sExtSettings.pBufferStart;
            if(pTemp != NULL)
            {
                BRAP_P_SearchAndFreeRbuf(hRapCh,uiFwProcBranchId,uiCapPortSrcId,pTemp);
            }            
        }/* for i */	
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT    
        if((hRapCh->hMultiStreamDecoder != NULL)
            &&(hRapCh->uiFWMixerIpIndex != BRAP_INVALID_VALUE)
            &&(hRapCh->uiFWMixerIpIndex < BRAP_P_MAX_FW_STG_INPUTS)
            &&(hRapCh->hMultiStreamDecoder->uiNumValidIOBuffer[hRapCh->uiFWMixerIpIndex] < BRAP_AF_P_MAX_CHANNELS))
        {
            for(i = 0; i < hRapCh->hMultiStreamDecoder->uiNumValidIOBuffer[hRapCh->uiFWMixerIpIndex]; i++)
            {
                pTemp = (void *)hRapCh->hMultiStreamDecoder->ui32InterTaskIoBufferAddress[hRapCh->uiFWMixerIpIndex][i];
                if(pTemp != NULL)
                {
                    BRAP_P_SearchAndFreeRbuf(hRapCh,uiFwProcBranchId,uiCapPortSrcId,pTemp);
    			}
    	    } /* for i */
        }
#endif        
	}
    
    BDBG_LEAVE(BRAP_P_ReturnRBufToPool);    
    return;
}

/***************************************************************************
Summary:
    Private function that gets the RBuf from Ring Buffer Pool.
***************************************************************************/
BERR_Code BRAP_P_GetRbufFromPool(
	BRAP_ChannelHandle 			hRapCh,			/* [in] Channel Handle */
	const BRAP_ChannelParams 	*pAudioParams, 	/* [in] Audio params passed 
	                                               during channel start time */
	BRAP_P_ObjectHandles 		*pPath,			/* [in] Path id */
	bool						bIsDestRbuf,	/* [in] 1= Destination RBuf Type
												   0 =  Other RBuf Type */
	unsigned int 				uiFwProcBranchId,   /* [in] FW Processing Branch Id */
	unsigned int 				uiCapPortSrcId,	 /* [in] Capture Port Source Id */
	BRAP_RBUF_P_Settings 		*pRBufSettings,     /* [out] Ring Buffer Settings */
	unsigned int                uiChannelNo         /* [in] Input Channel from 
	                                                   the channel pair */
	)
{
	int i = 0;
	BRAP_P_RBufMem *pRbufMem = NULL;
 
    BSTD_UNUSED(uiChannelNo);

	BDBG_ENTER(BRAP_P_GetRbufFromPool);
	
	BDBG_ASSERT(hRapCh);
	BDBG_ASSERT(pRBufSettings);
  
	if(bIsDestRbuf == true) /*Destination Rbuf */
	{
		for(i = 0;i<BRAP_OutputChannelPair_eMax*2;i++)
		{
			pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sDestRBuf[i]);
			if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr != NULL))
			{
				pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
				pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                            pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FULL_BYTE_MARK;
				pRbufMem->bUsed = true;
				goto exit;
			}
		}
		BDBG_ERR(("Not enough RBuf available for Destination RBuf"));
		return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
	}
	else
	{
		BDBG_ASSERT(pPath);
		switch(hRapCh->eChannelType)
		{
			case BRAP_ChannelType_eDecode:
				switch(pPath->eUsgPath)
				{
                    case BRAP_P_UsgPath_eDecodePcmPostMixing:
                    case BRAP_P_UsgPath_eDecodeCompressPostMixing:
                    case BRAP_P_UsgPath_ePPBranchPostMixing:                        
                        for(i = 0;i<BRAP_MAX_DEVICE_OUTPUT_BUFFER;i++)
                        {
                            pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sOutputBuffer[i]);
                            if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                            {
                                pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                                pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                pRbufMem->bUsed = true;
                                pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
                                goto exit;
                            }
                        }
                        BDBG_ERR(("Not enough RBuf available for output of Post mixing Task "));
                        return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
                        break;                        
                    case BRAP_P_UsgPath_eDecodePcm:
                    case BRAP_P_UsgPath_eDecodeCompress:
                    case BRAP_P_UsgPath_ePPBranch:
                    case BRAP_P_UsgPath_eDownmixedPath:
                        if((BRAP_P_UsgPath_eDecodeCompress==pPath->eUsgPath)
                            &&(true==hRapCh->hRap->sDeviceRBufPool.pExtRBufPoolSettings->bHbrMode)
                            && ( (hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].bHbrEnable == true)
                            ||(hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].bHbrEnable == true))
                            &&(true==BRAP_P_IsMaiFedByPath(pPath)))
                        {
    						for(i = 0;i<BRAP_NUM_HBR_BUFFERS;i++)
    						{
    							pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sHbrRBuf[i]);
    							if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
    							{
    								pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
    								pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
    								pRbufMem->bUsed = true;
    								pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
    								goto exit;
    							}
					        }
                        }
#ifdef RAP_BTSC_SUPPORT
                        else if((true==BRAP_P_IsDacFedByPath(pPath))&&((BRAP_P_IsPPPresentOnOutput(hRapCh,BRAP_ProcessingType_eBtsc,BRAP_OutputPort_eDac0))
                                ||(BRAP_P_IsPPPresentOnOutput(hRapCh,BRAP_ProcessingType_eBtsc,BRAP_OutputPort_eDac1))
                                ||(BRAP_P_IsPPPresentOnOutput(hRapCh,BRAP_ProcessingType_eBtsc,BRAP_OutputPort_eDac2))))
                        {
                            for(i = 0;i<BRAP_NUM_HBR_BUFFERS;i++)
                            {
                                pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sHbrRBuf[i]);
                                if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                                {
                                    pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                                    pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                    pRbufMem->bUsed = true;
                                    pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;                                                    
                                    goto exit;
                                }
                            }                                        
                        }

#endif                                    
                        else
                        {
                            for(i = 0;i<BRAP_MAX_OUT_CH_PER_FW_PROC_BRANCH;i++)
                            {
                                pRbufMem = &(hRapCh->sChanRBufPool.sDecOutRBuf[uiFwProcBranchId][i]);
                                if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                                {
                                	pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                                	pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                	pRbufMem->bUsed = true;
                                	pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
                                	goto exit;
                                }
                            }
                        }
						BDBG_ERR(("Not enough RBuf available for DEC channel decode path output buffer"));
						return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
						break;
					case BRAP_P_UsgPath_eCapture:
						if((pPath->sOutPathProp[0].uiPathIdx != BRAP_INVALID_VALUE) && 
						   (pPath->sOutPathProp[0].uiPathIdx < BRAP_P_MAX_PATHS_IN_A_CHAN))
						{
						    BDBG_ASSERT(hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]);
							switch(hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]->eUsgPath)
							{
								case BRAP_P_UsgPath_eDecodeCompress:
								case BRAP_P_UsgPath_eDecodePcm:
									for(i = 0;i<BRAP_MAX_IN_CH_PER_FW_PROC_BRANCH;i++)
									{
										pRbufMem  =  &(hRapCh->sChanRBufPool.sDecInRBuf[uiCapPortSrcId][i]);
										if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
										{
											pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
											pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                                                            pRbufMem->bUsed = true;
											pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
											goto exit;
										}
									}
									BDBG_ERR(("Not enough RBuf available for DEC channel cap path buffer"));
									return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
									break;
                                case BRAP_P_UsgPath_eDecodePcmPostMixing:
            					case BRAP_P_UsgPath_eDecodeCompressPostMixing:
                                case BRAP_P_UsgPath_ePPBranchPostMixing:                        
                                    for(i = 0;i<BRAP_MAX_DEVICE_INPUT_BUFFER;i++)
                                    {
                                        pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sInputBuffer[i]);
                                        if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                                        {
                                            pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                                            pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                            pRbufMem->bUsed = true;
                                            pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
                                            goto exit;
                                        }
                                    }
                                    BDBG_ERR(("Not enough RBuf available for Input of Post mixing Task "));
                                    return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
                                    break;
								default:										
									BDBG_ERR(("Unsupported out path %d for a cappath",hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]->eUsgPath));
									return BERR_TRACE(BERR_NOT_SUPPORTED);
									break;
							}/* switch out eUsgPath */
						}/* if */
						break;
                    case BRAP_P_UsgPath_eMixPath:
                    case BRAP_P_UsgPath_eSharedPP:                        
                    case BRAP_P_UsgPath_eDownmixedMixPath:                                                                
                        break;
					default:
						BDBG_ERR(("Invalid Usage Path = %d",pPath->eUsgPath));
						return BERR_TRACE(BERR_NOT_SUPPORTED);					
				} /* switch DEC ch eUsgPath */
				break;
		    case BRAP_ChannelType_ePcmPlayback:
				switch(pPath->eUsgPath)
				{
					case BRAP_P_UsgPath_eDecodePcm:
                    case BRAP_P_UsgPath_ePPBranch:
                		BDBG_ASSERT(pAudioParams);                        
						for(i = 0;i<BRAP_P_MAX_RBUF_PER_PBCH;i++)
						{
							pRbufMem = &(hRapCh->sChanRBufPool.sPbRBuf[i]);
							if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
							{
								pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
								pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
								pRbufMem->bUsed = true;
								pRBufSettings->sExtSettings.uiWaterMark = pAudioParams->sBufParams.uiWaterMark;
								goto exit;
							}
						}
						BDBG_ERR(("Not enough RBuf available for PB buffer for decode path"));
						return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
						break;
					case BRAP_P_UsgPath_eDecodePcmPostMixing:
					case BRAP_P_UsgPath_eDecodeCompressPostMixing:                        
                    case BRAP_P_UsgPath_ePPBranchPostMixing:                        
                        for(i = 0;i<BRAP_MAX_DEVICE_OUTPUT_BUFFER;i++)
                        {
                            pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sOutputBuffer[i]);
                        	if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                        	{
                        		pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                        		pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                        		pRbufMem->bUsed = true;
                        		pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
                        		goto exit;
                        	}
                        }
                        BDBG_ERR(("Not enough RBuf available for output of Post mixing Task "));
						return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);                        
                     break;
					case BRAP_P_UsgPath_eCapture:
						if((pPath->sOutPathProp[0].uiPathIdx != BRAP_INVALID_VALUE) && 
						   (pPath->sOutPathProp[0].uiPathIdx < BRAP_P_MAX_PATHS_IN_A_CHAN))
						{
						    BDBG_ASSERT(hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]);
							switch(hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]->eUsgPath)
							{
                                case BRAP_P_UsgPath_eDecodePcmPostMixing:
            					case BRAP_P_UsgPath_eDecodeCompressPostMixing:
                                case BRAP_P_UsgPath_ePPBranchPostMixing:                        
                                    for(i = 0;i<BRAP_MAX_DEVICE_INPUT_BUFFER;i++)
                                    {
                                        pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sInputBuffer[i]);
                                        if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                                        {
                                            pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                                            pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                            pRbufMem->bUsed = true;
                                            pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
                                            goto exit;
                                        }
                                    }
                                    BDBG_ERR(("Not enough RBuf available for Input of Post mixing Task "));
                                    return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
                                    break;					
				
								default:										
									BDBG_ERR(("Invalid Usage Path"));
									return BERR_TRACE(BERR_INVALID_PARAMETER);
							}
						}
						break;
                    case BRAP_P_UsgPath_eMixPath:
                    case BRAP_P_UsgPath_eSharedPP:                        
                        break;
					default:
						BDBG_ERR(("Invalid Usage Path = %d",pPath->eUsgPath));
						return BERR_TRACE(BERR_NOT_SUPPORTED);						
				}
				break;
			case BRAP_ChannelType_ePcmCapture:
				switch(pPath->eUsgPath)
				{
					case BRAP_P_UsgPath_eDecodePcm:
                    case BRAP_P_UsgPath_ePPBranch:                     
						for(i = 0;i<BRAP_MAX_OUT_CH_PER_FW_PROC_BRANCH;i++)
						{
							pRbufMem = &(hRapCh->sChanRBufPool.sDecOutRBuf[uiFwProcBranchId][i]);
							if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
							{
								pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
								pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
								pRbufMem->bUsed = true;
								pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
								goto exit;
							}
						}
                        break;
                    case BRAP_P_UsgPath_eDecodePcmPostMixing:
                    case BRAP_P_UsgPath_eDecodeCompressPostMixing:
                    case BRAP_P_UsgPath_ePPBranchPostMixing:                        
                        for(i = 0;i<BRAP_MAX_DEVICE_OUTPUT_BUFFER;i++)
                        {
                            pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sOutputBuffer[i]);
                            if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                            {
                                pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                                pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                pRbufMem->bUsed = true;
                                pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
                                goto exit;
                            }
                        }
                        BDBG_ERR(("Not enough RBuf available for output of Post mixing Task "));
                        return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
                        break;                          
					case BRAP_P_UsgPath_eCapture:
						if((pPath->sOutPathProp[0].uiPathIdx != BRAP_INVALID_VALUE) && 
						   (pPath->sOutPathProp[0].uiPathIdx < BRAP_P_MAX_PATHS_IN_A_CHAN))
						{
						    BDBG_ASSERT(hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]);
							switch(hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]->eUsgPath)
							{
								case BRAP_P_UsgPath_eDecodeCompress:
								case BRAP_P_UsgPath_eDecodePcm:
									for(i = 0;i<BRAP_MAX_IN_CH_PER_FW_PROC_BRANCH;i++)
									{
										pRbufMem = &(hRapCh->sChanRBufPool.sDecInRBuf[uiCapPortSrcId][i]);
										if(pRbufMem->bUsed == false && pRbufMem->pRBufPtr!=NULL)
										{
											pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
											pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
											pRbufMem->bUsed = true;
											pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
											goto exit;
										}
									}
									BDBG_ERR(("Not enough RBuf available for CAP ch decode in path"));
									return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
									break;
                                case BRAP_P_UsgPath_eDecodePcmPostMixing:
            					case BRAP_P_UsgPath_eDecodeCompressPostMixing:
                                case BRAP_P_UsgPath_ePPBranchPostMixing:                        
                                    for(i = 0;i<BRAP_MAX_DEVICE_INPUT_BUFFER;i++)
                                    {
                                        pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sInputBuffer[i]);
                                        if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                                        {
                                            pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                                            pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                            pRbufMem->bUsed = true;
                                            pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
                                            goto exit;
                                        }
                                    }
                                    BDBG_ERR(("Not enough RBuf available for Input of Post mixing Task "));
                                    return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
                                    break;                                    
								default:										
									BDBG_ERR(("Invalid Out Usage Path %d OutPathArrIdx = %d",
										 hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]->eUsgPath, pPath->sOutPathProp[0].uiPathIdx));
									return BERR_TRACE(BERR_NOT_SUPPORTED);
							}
						}
                        break;
					default:
						BDBG_ERR(("Invalid Usage Path = %d",pPath->eUsgPath));
						return BERR_TRACE(BERR_NOT_SUPPORTED);					
					}
				break;
			default:
				BDBG_ERR(("Invalid Channel Type = %d",hRapCh->eChannelType));
				return BERR_TRACE(BERR_NOT_SUPPORTED);
		}/* switch chtype */
	}/* if bIsDestRbuf */

exit:	
	BDBG_LEAVE(BRAP_P_GetRbufFromPool);
	return BERR_SUCCESS;
}

#endif

/**************************************************************************
Summary:
    Private function that opens FMM module handles for a particular path.
    Note: Output and SpdifFm module handles are not opened here.
**************************************************************************/
BERR_Code BRAP_P_OpenFmmModuleHandles(
    BRAP_ChannelHandle          hRapCh,         /* [in] Channel Handle */
    const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */
    unsigned int                uiPth,          /* [in] Path id */
    BRAP_RM_P_ResrcGrant        *pRsrcGrnt      /* [in] Resources to be opened */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    BERR_Code               ret1 = BERR_SUCCESS;
    BRAP_RBUF_P_Settings    sRBufSettings;
    BRAP_MIXER_P_Settings   sMixerSettings;
    BRAP_P_ObjectHandles    *pPath = NULL;
    unsigned int            i = 0,j=0,k=0,l=0;
#if (BRAP_7550_FAMILY != 1)    
    BRAP_RM_P_SrcGrant      sTempSrcGrant;
    BRAP_SRC_P_Settings     sSrcSettings;
    BRAP_DSTCH_P_Settings   sDstChSettings; 
    BRAP_CAPPORT_P_Settings sCapPortSettings;    
#endif
    #if BRAP_P_EQUALIZER
    BRAP_RM_P_SrcEqGrant    sTempSrcEqGrant;
    #endif
    BRAP_RM_P_MixerGrant    sTempMixerGrant;
    BRAP_SRCCH_P_Settings   sSrcChSettings;
    bool                    bWdgRecovery = false;
    unsigned int            uiMixInId = 0;
    bool bCompress =false;
#if ((BRAP_3548_FAMILY == 1) )
    bool                    bLinked = false;
    unsigned int            uiLinkId = 0;
    unsigned int            uiMasterPathId = BRAP_RM_P_INVALID_INDEX;
    BRAP_P_ObjectHandles    *pMasterPath = NULL;
#endif
    
    BDBG_ENTER(BRAP_P_OpenFmmModuleHandles);

    /* Check params */
    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(pRsrcGrnt);
    BDBG_ASSERT(uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN);
    BDBG_ASSERT(hRapCh->pPath[uiPth]);

   /* Check if this is a watchdog recovery. */
	bWdgRecovery = BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap);

    pPath = hRapCh->pPath[uiPth];

#if ((BRAP_3548_FAMILY == 1) )
	if(( BRAP_ChannelType_eDecode==hRapCh->eChannelType )
		&&( BRAP_DSPCHN_DecodeMode_ePassThru==pAudioParams->sDspChParams.eDecodeMode )
		&&(BRAP_P_UsgPath_eCapture == hRapCh->pPath[uiPth]->eUsgPath)
		&&(0 == uiPth))
	{
        for(i=0;i<BRAP_RM_P_MAX_LINKAGE_SUPPORTED;i++)
        {
            if((true == hRapCh->hRap->sChLinkInfo[i].bUsedLinkage)&&
                (hRapCh == hRapCh->hRap->sChLinkInfo[i].hRapSlaveCh))
            {
                bLinked = true;
                uiLinkId = i;
                break;
            }
        }
        if((i!=BRAP_RM_P_MAX_LINKAGE_SUPPORTED)&&(true == bLinked))
        {
            for(i=0;i<BRAP_P_MAX_PATHS_IN_A_CHAN;i++)
            {
                if((BRAP_P_UsgPath_eCapture == 
                    hRapCh->hRap->sChLinkInfo[uiLinkId].hRapMasterCh->pPath[i]->eUsgPath) &&(0 == uiPth))
                {
                    uiMasterPathId = i;
                    pMasterPath = hRapCh->hRap->sChLinkInfo[uiLinkId].hRapMasterCh->pPath[i];
                    break;
                }
            }
        }
    }
#endif

     
    /* 1. Prepare settings and open Rbuf */
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNELS; i++)
    {
        if(pRsrcGrnt->uiRbufId[i] != BRAP_RM_P_INVALID_INDEX)
        {
            bCompress =false;
            BRAP_P_IsPathOutputCompress( hRapCh,uiPth,&bCompress);            
            if((bCompress == true) &&(i>=BRAP_NUM_BUFFER_FOR_COMPRESSED))
            {
                break;
            }        
            
            if(false == bWdgRecovery)
            {
                /* Get default settings */
                ret = BRAP_RBUF_P_GetDefaultSettings(&sRBufSettings);
                if(BERR_SUCCESS != ret)
                {ret = BERR_TRACE(ret);goto close_rbuf;}
#if (BRAP_7405_FAMILY == 1)            		
            if(!((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
                &&(hRapCh->bOpenTimeWrToRbuf == true)
                &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif  
            {                
#if (BRAP_OPEN_TIME_RBUF_ALLOCATION==1)
        		if(BRAP_ChannelType_eDecode == hRapCh->eChannelType) 
                {
                    sRBufSettings.bProgRdWrRBufAddr = false;
                    sRBufSettings.bRbufOfClonedPort = false;
                    /* Default values for sRBufSettings.sExtSettings:
                        pBufferStart, uiSize and uiWaterMark */
                }
                else if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
                {
                    /* TODO: Enable this code as and when more channel types are 
                       supported */
                    sRBufSettings.bProgRdWrRBufAddr = true;
                    sRBufSettings.bRbufOfClonedPort = false;
                }	
        		
#if (BRAP_INDEP_OP_DELAY_SUPPORTED ==1)
            if(hRapCh->bIndepDelayEnabled == true)
            {
                BDBG_MSG(("pPath->uiMasterpathId =%d , hRapCh->pPath[pPath->uiMasterpathId] = %#x"
                    ,pPath->uiMasterpathId,hRapCh->pPath[pPath->uiMasterpathId] ));
                if((pPath->uiMasterpathId != BRAP_INVALID_VALUE)
                    &&(hRapCh->pPath[pPath->uiMasterpathId] != NULL)
                    &&(hRapCh->pPath[pPath->uiMasterpathId]->hRBuf[i] !=NULL))
                {
                    sRBufSettings.sExtSettings = hRapCh->pPath[pPath->uiMasterpathId]->hRBuf[i]->sSettings.sExtSettings;
                    sRBufSettings.bProgRdWrRBufAddr = hRapCh->pPath[pPath->uiMasterpathId]->hRBuf[i]->sSettings.bProgRdWrRBufAddr;
                    sRBufSettings.bRbufOfClonedPort = true;
                }
                else
                {
                    ret = BRAP_P_GetRbufFromPool(hRapCh,pAudioParams,pPath,false,0,0,&sRBufSettings, i);                
                }         
            }
            else
#endif
            {
#if ((BRAP_3548_FAMILY == 1) )
                if((true == bLinked)&&(BRAP_RM_P_INVALID_INDEX != uiMasterPathId)
                    &&(BRAP_P_UsgPath_eCapture == hRapCh->pPath[uiPth]->eUsgPath)&&(0 == uiPth))
                {
                    sRBufSettings.sExtSettings = pMasterPath->hRBuf[i]->sSettings.sExtSettings;
                    sRBufSettings.bProgRdWrRBufAddr = pMasterPath->hRBuf[i]->sSettings.bProgRdWrRBufAddr;
                    sRBufSettings.bRbufOfClonedPort = true;
                }
                else
#endif
                {
                    ret = BRAP_P_GetRbufFromPool(hRapCh,pAudioParams,pPath,false,0,0,&sRBufSettings, i);
                    }                    
            }
        		if(BERR_SUCCESS != ret)
                {
                	ret = BERR_TRACE(ret);
        			goto close_rbuf;
        		}
#else
                /* Modify settings (if any) */
                if(BRAP_ChannelType_eDecode == hRapCh->eChannelType) 
                {
                    sRBufSettings.bProgRdWrRBufAddr = false;
                    sRBufSettings.bRbufOfClonedPort = false;

                    /* Default values for sRBufSettings.sExtSettings:
                        pBufferStart, uiSize and uiWaterMark */
                }
                else if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
                {
                    /* TODO: Enable this code as and when more channel types are 
                       supported */
                    sRBufSettings.bProgRdWrRBufAddr = true;
                    sRBufSettings.bRbufOfClonedPort = false;
                    if (0 == i%BRAP_RM_P_MAX_RBUFS_PER_SRCCH)
                    {
                        sRBufSettings.sExtSettings.pBufferStart = 
                                        pAudioParams->sBufParams.pLeftBufferStart;
                    }
                    else
                    {
                        sRBufSettings.sExtSettings.pBufferStart = 
                                        pAudioParams->sBufParams.pRightBufferStart;
                    }
                    sRBufSettings.sExtSettings.uiSize = 
                                                   pAudioParams->sBufParams.uiSize;
                    sRBufSettings.sExtSettings.uiWaterMark = 
                                              pAudioParams->sBufParams.uiWaterMark;
                }
#endif            
            }
    
#if (BRAP_7405_FAMILY == 1)            		
                if(!((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
                    &&(hRapCh->bOpenTimeWrToRbuf == true)
                    &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif                 
                {
                /* Open Rbuf handle */
                ret = BRAP_RBUF_P_Open( pPath->hFmm,
                                        &(pPath->hRBuf[i]),
                                        pRsrcGrnt->uiRbufId[i],
                                        &sRBufSettings);
                if(BERR_SUCCESS != ret)
                    {
                        ret = BERR_TRACE(ret);goto close_rbuf;
                    }
                }

                }/* bWdgRecovery == false */
            else
            {
#if (BRAP_7405_FAMILY == 1)            		
                if(!((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
                    &&(hRapCh->bOpenTimeWrToRbuf == true)
                    &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif             
            {
                /* Open Rbuf handle */
                ret = BRAP_RBUF_P_Open( pPath->hFmm,
                                        &(pPath->hRBuf[i]),
                                        pRsrcGrnt->uiRbufId[i],
                                        NULL);
                if(BERR_SUCCESS != ret)
                {ret = BERR_TRACE(ret);goto close_rbuf;}                
            }
            }
            
            BDBG_MSG(("Ring buffer %d opened",pRsrcGrnt->uiRbufId[i]));
        }
    }/* for i */
    /* Ring buffer open done */

    /* 2. Prepare settings and open SrcCh */
#if (BRAP_7405_FAMILY == 1)            		
                if(!((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
                    &&(hRapCh->bOpenTimeWrToRbuf == true)
                    &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif   
{
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        if(pRsrcGrnt->uiSrcChId[i] != BRAP_RM_P_INVALID_INDEX)
        {
            /* Open SrcCh handle */
            ret = BRAP_SRCCH_P_Open( pPath->hFmm,
                                    &(pPath->sSrcCh[i].hSrcCh),
                                    pRsrcGrnt->uiSrcChId[i],
                                    &sSrcChSettings);
            if(BERR_SUCCESS != ret)
            { ret =  BERR_TRACE(ret);goto close_srcch;}
            
            BDBG_MSG(("Source Channel %d opened",pRsrcGrnt->uiSrcChId[i]));
        }
    }/* for i */
    /* SrcCh Open Done */
}

#if (BRAP_7550_FAMILY !=1)
    /* 3. Prepare settings and open SRC */
    for (i=0;i<BRAP_RM_P_MAX_MIXING_LEVELS;i++)
    {
        for(j=0;j<BRAP_RM_P_MAX_SRC_IN_CASCADE;j++)
        {
            for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
            {
                for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                {
                    sTempSrcGrant = 
                                pRsrcGrnt->sSrcMixerGrnt[i].sSrcGrant[j][k][l];
                    if((sTempSrcGrant.uiSrcBlkId != BRAP_RM_P_INVALID_INDEX)&&
                       (sTempSrcGrant.uiSrcId != BRAP_RM_P_INVALID_INDEX))
                    {
                        /* Open SRC handle */
                        ret = BRAP_SRC_P_Open(pPath->hFmm,
                                              &(pPath->sSrc[i][k][l].hSrc[j]),
                                              sTempSrcGrant.uiSrcId,
                                              sTempSrcGrant.uiSrcBlkId,
                                              &sSrcSettings);
                        if(BERR_SUCCESS != ret)
                        {  ret = BERR_TRACE(ret);goto close_src;}
                        
                        BDBG_MSG(("SRC %d of SRC Block %d opened",
                               sTempSrcGrant.uiSrcId,sTempSrcGrant.uiSrcBlkId));                                              
                    }
                }/* for l */
            }/* for k */
        }/* for j */
    }/* for i */
    /* SRC open done */
#endif

    /* 4. Prepare settings and open Mixer */
    for (i=0;i<BRAP_RM_P_MAX_MIXING_LEVELS;i++)
    {
        for(j=0;j<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;j++)
        {
            for(k=0;k<BRAP_RM_P_MAX_PARALLEL_PATHS;k++)
            {
                sTempMixerGrant = pRsrcGrnt->sSrcMixerGrnt[i].sMixerGrant[j][k];
                if ((sTempMixerGrant.uiDpId != BRAP_RM_P_INVALID_INDEX)&&
                    (sTempMixerGrant.uiMixerId != BRAP_RM_P_INVALID_INDEX))
                {
                    /* Get default setting */
                    ret = BRAP_MIXER_P_GetDefaultSettings(&sMixerSettings);
                    if(BERR_SUCCESS != ret)
                    {   
                        BDBG_ERR(("Mixer GetDefaultSettings error = %d", ret));
                        ret = BERR_TRACE(ret); 
                        goto close_mixer;
                    }

                    /* Modify the settings */
                    for(l=0;l<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;l++)
                    {
                        sMixerSettings.uiMixerInput[l] = 
                            sTempMixerGrant.uiMixerInputId[l];
                        BDBG_MSG ((" sTempMixerGrant.uiMixerInputId[%d]=%d",
                                       l,sTempMixerGrant.uiMixerInputId[l]));
                    }
                    
                    /* Open mixer handle */
                    ret = BRAP_MIXER_P_Open(pPath->hFmm,
                                            &(pPath->sMixer[i][j][k].hMixer),
                                            sTempMixerGrant.uiMixerId,
                                            sTempMixerGrant.uiDpId,
                                            &sMixerSettings);
                    if(BERR_SUCCESS != ret)
                    {
                        BDBG_ERR(("Mixer Open returned error = %d", ret));
                        ret = BERR_TRACE(ret);
                        goto close_mixer;
                    }
                    BDBG_MSG(("Mixer %d of DP Block %d opened",
                             sTempMixerGrant.uiMixerId,sTempMixerGrant.uiDpId));
                }/* if */
            }/* for k */
        }/* for j */
    }/* for i */
    /* Mixer open done */

#if (BRAP_7550_FAMILY !=1)
    /* 5. Prepare settings and open DstCh */
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        if(pRsrcGrnt->uiDstChId[i] != BRAP_RM_P_INVALID_INDEX)
        {
            /* Open DstCh handle */
            ret = BRAP_DSTCH_P_Open( pPath->hFmm,
                                    &(pPath->sDstCh[i].hDstCh),
                                    pRsrcGrnt->uiDstChId[i],
                                    &sDstChSettings);
            if(BERR_SUCCESS != ret)
            { ret = BERR_TRACE(ret);goto close_dstch;}
            BDBG_MSG(("Destination Channel %d opened",pRsrcGrnt->uiDstChId[i]));
        }
    }/* for i */
    /* DstCh Open Done */

    /* 6. Open Capport */
    for(i=0;i<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;i++)
    {
        for(j=0;j<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH;j++)
        {
            if(pRsrcGrnt->sCapPortGrnt[i][j].eCapPort != BRAP_CapInputPort_eMax)
            {
                /* Open Capture Port */
                ret = BRAP_CAPPORT_P_Open(pPath->hFmm, 
                                          &(pPath->sCapPort[i][j].hCapPort),
                                          pRsrcGrnt->sCapPortGrnt[i][j].eCapPort,
                                          &sCapPortSettings);
                if(BERR_SUCCESS != ret)
                { ret = BERR_TRACE(ret);goto close_capport;}
                BDBG_MSG(("Capture Port %d opened",pRsrcGrnt->sCapPortGrnt[i][j].eCapPort));
            }
        }
    }
#endif    
#if BRAP_P_EQUALIZER    
    /* 7. Open SRC Equalizers */
    for(j=0;j<BRAP_RM_P_MAX_SRC_IN_CASCADE;j++)
    {
        for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
        {
            for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
            {
                sTempSrcEqGrant = pRsrcGrnt->sSrcEqGrant[j][k][l];
                if((sTempSrcEqGrant.uiSrcBlkId != BRAP_RM_P_INVALID_INDEX)&&
                   (sTempSrcEqGrant.uiSrcId != BRAP_RM_P_INVALID_INDEX))
                {
                    BRAP_P_DstDetails       *pPvtDstDetails;
                    unsigned int            uiAssocId = 0;
                    
                    pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
                    if ( NULL==pPvtDstDetails )
                    {
                        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
                        goto end_fmm_open;                
                    }
                    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));                       
                    /* Open SRC handle */
                    ret = BRAP_SRC_P_Open(pPath->hFmm,
                                          &(pPath->sSrcEq[k][l].hSrcEq[j]),
                                          sTempSrcEqGrant.uiSrcId,
                                          sTempSrcEqGrant.uiSrcBlkId,
                                          &sSrcSettings);
                    if(BERR_SUCCESS != ret)
                    {  ret = BERR_TRACE(ret);goto close_srceq;}
                    
                    BDBG_MSG(("SRC %d of SRC Block %d opened for Equalizer",
                           sTempSrcEqGrant.uiSrcId,sTempSrcEqGrant.uiSrcBlkId));                                              

                    /* Find the destination on this path having Equalizer and 
                       update the allocated SRC handle in that Equalizer handle
                    */
                    for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
                    {
                        /* Currently Equalizer is supported for output ports only */
                        if((NULL == pPath->pDstDetails[i]) ||
                           (BRAP_AudioDst_eOutputPort != pPath->pDstDetails[i]->eAudioDst))
                            continue;
                        
                        /* hEqualizer is present in Private structure. Get it */
                        ret = BRAP_P_GetPvtDstDetails(hRapCh,pPath->pDstDetails[i],pPvtDstDetails,&uiAssocId);
                        if(BERR_SUCCESS!=ret)
                        {
                            continue;
                        }

                        if (pPvtDstDetails->hEqualizer != NULL)
                        {
                            pPvtDstDetails->hEqualizer->hSrcEq[j][k][l][uiPth] = pPath->sSrcEq[k][l].hSrcEq[j];
                            
                            BDBG_MSG(("SRCEQ_Open: Populating hSrcEq[%d][%d][%d][%d]=0x%x"
                                " for hEqualizer=0x%x on output port %d", 
                                j,k,l,uiPth, pPvtDstDetails->hEqualizer->hSrcEq[j][k][l][uiPth], 
                                pPvtDstDetails->hEqualizer, pPvtDstDetails->sExtDstDetails.uDstDetails.
                                sOpDetails.eOutput[BRAP_OutputChannelPair_eLR]));
                            break;
                        }
                    } /* for i */  
                    if(i == BRAP_P_MAX_DST_PER_RAPCH)
                    {
                        BDBG_ERR(("None of the Destinations on this path have Equalizer,"
                            "but Equalizer allocation has been requested"));
                         ret = BERR_NOT_SUPPORTED;
                         goto close_srceq;
                    }
                }
            }/* for l */
        }/* for k */
    }/* for j */
    /* SRC-EQ open done */
#endif    

    /* If success, exit from this function */
    if(BERR_SUCCESS == ret)
    {
        goto end_fmm_open;
    }    
    
#if BRAP_P_EQUALIZER
close_srceq:    
    BDBG_ERR(("BRAP_P_OpenFmmModuleHandles: Came in close_srceq"));        
    for(j=0;j<BRAP_RM_P_MAX_SRC_IN_CASCADE;j++)
    {
        for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
        {
            for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
            {
                if(NULL != pPath->sSrcEq[k][l].hSrcEq[j])
                {
                    ret1 = BRAP_SRC_P_Close(pPath->sSrcEq[k][l].hSrcEq[j]);
                    if (ret1 != BERR_SUCCESS)
                    {
                        BDBG_ERR (("BRAP_P_OpenFmmModuleHandles: call to"
                          " BRAP_SRC_P_Close() failed. Ignoring error!!!!!"));
                        ret1 = BERR_TRACE (ret1);
                    }
		            BRAP_P_InitSrcEqHandleInfo(&(pPath->sSrcEq[k][l]), j);
                    BDBG_MSG(("SRC closed"));
                }
            }/* for l */
        }/* for k */
    }/* for j */
#endif
#if (BRAP_7550_FAMILY !=1)   
close_capport:
    BDBG_ERR(("BRAP_P_OpenFmmModuleHandles: Came in close_capport"));        
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        for(j=0;j<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH;j++)
        {
            if(NULL != pPath->sCapPort[i][j].hCapPort)
            {
                ret1 = BRAP_CAPPORT_P_Close(pPath->sCapPort[i][j].hCapPort);
                if (ret1 != BERR_SUCCESS)
                {
                    BDBG_ERR (("BRAP_P_OpenOpPathFmmModules: call to"
                      " BRAP_CAPPORT_P_Close() failed. Ignoring error!!!!!"));
                    ret1 = BERR_TRACE (ret1);
                }
    	     BRAP_P_InitCapPortHandleInfo(&(pPath->sCapPort[i][j]));
                BDBG_MSG(("CapPort closed"));
            }
        }
    }/* for i */
    
close_dstch:
    BDBG_ERR(("BRAP_P_OpenFmmModuleHandles: Came in close_dstch"));        
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        if(NULL != pPath->sDstCh[i].hDstCh)
        {
            ret1 = BRAP_DSTCH_P_Close(pPath->sDstCh[i].hDstCh);
            if (ret1 != BERR_SUCCESS)
            {
                BDBG_ERR (("BRAP_P_OpenOpPathFmmModules: call to"
                  " BRAP_DSTCH_P_Close() failed. Ignoring error!!!!!"));
                ret1 = BERR_TRACE (ret1);
            }
	     BRAP_P_InitDstChHandleInfo(&(pPath->sDstCh[i]));
            BDBG_MSG(("DstCh closed"));
        }
    }/* for i */
#endif                
    
close_mixer:
    BDBG_ERR(("BRAP_P_OpenFmmModuleHandles: Came in close_mixer"));        
    for (i=0;i<BRAP_RM_P_MAX_MIXING_LEVELS;i++)
    {
        for(j=0;j<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;j++)
        {
            for(k=0;k<BRAP_RM_P_MAX_PARALLEL_PATHS;k++)
            {
                if(NULL != pPath->sMixer[i][j][k].hMixer)
                {
                    for(l=0;l<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;l++)
                    {
                        if(pPath->sRsrcGrnt.sSrcMixerGrnt[i].sMixerGrant[j][k].
                                    uiMixerInputId[l] != BRAP_RM_P_INVALID_INDEX)
                        {
                            uiMixInId = pPath->sRsrcGrnt.sSrcMixerGrnt[i].sMixerGrant[j][k].uiMixerInputId[l];

                            ret = BRAP_MIXER_P_Close(pPath->sMixer[i][j][k].hMixer, uiMixInId);
                            if (ret != BERR_SUCCESS)
                            {
                                BDBG_ERR (("BRAP_P_CloseFmmModuleHandles: call to"
                                  " BRAP_MIXER_P_Close() failed. Ignoring error!!!!!"));
                                ret = BERR_TRACE (ret);
                            }
                            BDBG_MSG(("Mixer input %d closed", uiMixInId));
                        }
                    }/* for l */
                    BRAP_P_InitMixerHandleInfo(&(pPath->sMixer[i][j][k]));   
		        }
            }/* for k */
        }/* for j */
    }/* for i */

#if (BRAP_7550_FAMILY !=1)
close_src:
    BDBG_ERR(("BRAP_P_OpenFmmModuleHandles: Came in close_src"));        
    for (i=0;i<BRAP_RM_P_MAX_MIXING_LEVELS;i++)
    {
        for(j=0;j<BRAP_RM_P_MAX_SRC_IN_CASCADE;j++)
        {
            for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
            {
                for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                {
                    if(NULL != pPath->sSrc[i][k][l].hSrc[j])
                    {
                        ret1 = BRAP_SRC_P_Close(pPath->sSrc[i][k][l].hSrc[j]);
                        if (ret1 != BERR_SUCCESS)
                        {
                            BDBG_ERR (("BRAP_P_OpenOpPathFmmModules: call to"
                              " BRAP_SRC_P_Close() failed. Ignoring error!!!!!"));
                            ret1 = BERR_TRACE (ret1);
                        }
			   BRAP_P_InitSrcHandleInfo(&(pPath->sSrc[i][k][l]), j);
                        BDBG_MSG(("SRC closed"));
                    }
                }/* for l */
            }/* for k */
        }/* for j */
    }/* for i */
#endif

close_srcch:
    BDBG_ERR(("BRAP_P_OpenFmmModuleHandles: Came in close_srcch"));        
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        if(NULL != pPath->sSrcCh[i].hSrcCh)
        {
            ret1 = BRAP_SRCCH_P_Close(pPath->sSrcCh[i].hSrcCh);
            if (ret1 != BERR_SUCCESS)
            {
                BDBG_ERR (("BRAP_P_OpenOpPathFmmModules: call to"
                  " BRAP_SRCCH_P_Close() failed. Ignoring error!!!!!"));
                ret1 = BERR_TRACE (ret1);
            }
	     BRAP_P_InitSrcChHandleInfo(&(pPath->sSrcCh[i]));
            BDBG_MSG(("SrcCh closed"));
        }
    }/* for i */

close_rbuf:
#if (BRAP_OPEN_TIME_RBUF_ALLOCATION==1)
			/* Returning the Rbuf to global pool */
			BRAP_P_ReturnRBufToPool(hRapCh,pPath,0,0,0);
#endif

    BDBG_ERR(("BRAP_P_OpenFmmModuleHandles: Came in close_rbuf"));        
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNELS; i++)
    {
        if((pRsrcGrnt->uiRbufId[i] != BRAP_RM_P_INVALID_INDEX) &&
           (pPath->hRBuf[i] != NULL))
        {
            ret1 = BRAP_RBUF_P_Close(pPath->hRBuf[i]);
            if(BERR_SUCCESS != ret1)
            {
                BDBG_ERR (("BRAP_RBUF_P_Close() failed. Ignoring error!!!!!"));
                ret1 = BERR_TRACE(ret1);
            }
            pPath->hRBuf[i] = NULL;
            BDBG_MSG(("Ring buffer %d closed",pRsrcGrnt->uiRbufId[i]));
        }
    }/* for i */

end_fmm_open:
    BDBG_LEAVE(BRAP_P_OpenFmmModuleHandles);    
    return ret;
}

/**************************************************************************
Summary:
    Private function that closes FMM module handles for a particular path.
    Note: Output and SpdifFm module handles are not closed here.
**************************************************************************/
BERR_Code BRAP_P_CloseFmmModuleHandles(
    BRAP_ChannelHandle      hRapCh,     /* [in] Channel Handle */
    unsigned int            uiPth       /* [in] Path id */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_P_ObjectHandles    *pPath = NULL;
    unsigned int            i = 0,j=0,k=0,l=0;
    unsigned int            uiMixInId = 0;
    bool                    bRbufAllocated = false;
    
    BDBG_ENTER(BRAP_P_CloseFmmModuleHandles);

    /* Check params */
    BDBG_ASSERT(hRapCh);

    if(uiPth >= BRAP_P_MAX_PATHS_IN_A_CHAN)
    {
        BDBG_ERR(("uiPth = %d  can't be greater  or equal to than BRAP_P_MAX_PATHS_IN_A_CHAN = %d",uiPth,BRAP_P_MAX_PATHS_IN_A_CHAN));
        BDBG_ASSERT(0);
        return BERR_TRACE(BERR_INVALID_PARAMETER);
    }
    BDBG_ASSERT(hRapCh->pPath[uiPth]);
    
    pPath = hRapCh->pPath[uiPth];

#if BRAP_P_EQUALIZER
    /* close_srceq */
    BDBG_MSG(("BRAP_P_CloseFmmModuleHandles: Came in close_srceq"));        
    for(j=0;j<BRAP_RM_P_MAX_SRC_IN_CASCADE;j++)
    {
        for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
        {
            for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
            {
                if(NULL != pPath->sSrcEq[k][l].hSrcEq[j])
                {
                    BRAP_P_DstDetails       *pPvtDstDetails;
                    unsigned int            uiAssocId = 0;
                    pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
                    if ( NULL==pPvtDstDetails )
                    {
                        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
                        goto end;                
                    }
                    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));                     
                    
                    /* Find if any destination on this path is having Equalizer and 
                       invalidate the SRC handle stored in that Equalizer handle
                    */
                    for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
                    {
                        if((NULL == pPath->pDstDetails[i]) ||
                           (BRAP_AudioDst_eOutputPort != pPath->pDstDetails[i]->eAudioDst))
                            continue;
                        
                        /* hEqualizer is present in Private structure. Get it */
                        ret = BRAP_P_GetPvtDstDetails(hRapCh,pPath->pDstDetails[i],pPvtDstDetails,&uiAssocId);
                        if(BERR_SUCCESS!=ret)
                        {
                            continue;
                        }

                        if (pPvtDstDetails->hEqualizer != NULL)
                        {
                            BDBG_MSG(("SRCEQ_Close: Invalidating hSrcEq[%d][%d][%d][%d]=0x%x "
                                "of hEqualizer=0x%x on output port %d", 
                                j,k,l,uiPth, pPvtDstDetails->hEqualizer->hSrcEq[j][k][l][uiPth], 
                                pPvtDstDetails->hEqualizer, pPvtDstDetails->sExtDstDetails.uDstDetails.
                                sOpDetails.eOutput[BRAP_OutputChannelPair_eLR]));

                            pPvtDstDetails->hEqualizer->hSrcEq[j][k][l][uiPth] = NULL;
                            break;
                        }
                    }
                    
                    ret = BRAP_SRC_P_Close(pPath->sSrcEq[k][l].hSrcEq[j]);
                    if (ret != BERR_SUCCESS)
                    {
                        BDBG_ERR (("BRAP_P_CloseFmmModuleHandles: call to"
                          " BRAP_SRC_P_Close() for Equalizer failed. Ignoring error!!!!!"));
                        ret = BERR_TRACE (ret);
                    }
			        BRAP_P_InitSrcEqHandleInfo(&(pPath->sSrcEq[k][l]), j);
                    BDBG_MSG(("SRC for Equalizer closed"));
                }
            }/* for l */
        }/* for k */
    }/* for j */
#endif

    /* close_mixer: */
    for (i=0;i<BRAP_RM_P_MAX_MIXING_LEVELS;i++)
    {
        for(j=0;j<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;j++)
        {
            for(k=0;k<BRAP_RM_P_MAX_PARALLEL_PATHS;k++)
            {
                if(NULL != pPath->sMixer[i][j][k].hMixer)
                {
                    for(l=0;l<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;l++)
                    {
                        if(pPath->sRsrcGrnt.sSrcMixerGrnt[i].sMixerGrant[j][k].
                                    uiMixerInputId[l] != BRAP_RM_P_INVALID_INDEX)
                        {
                            uiMixInId = pPath->sRsrcGrnt.sSrcMixerGrnt[i].sMixerGrant[j][k].uiMixerInputId[l];

                            ret = BRAP_MIXER_P_Close(pPath->sMixer[i][j][k].hMixer, uiMixInId);
                            if (ret != BERR_SUCCESS)
                            {
                                BDBG_ERR (("BRAP_P_CloseFmmModuleHandles: call to"
                                  " BRAP_MIXER_P_Close() failed. Ignoring error!!!!!"));
                                ret = BERR_TRACE (ret);
                            }
                            BDBG_MSG(("Mixer input %d closed", uiMixInId));
                        }
                    }/* for l */
                    BRAP_P_InitMixerHandleInfo(&(pPath->sMixer[i][j][k]));    
		        }/* if hMixer */
            }/* for k */
        }/* for j */
    }/* for i */

#if (BRAP_7550_FAMILY != 1)
    /* close_src: */
    BDBG_MSG(("BRAP_P_CloseFmmModuleHandles: Came in close_src"));        
    for(i=0;i<BRAP_RM_P_MAX_MIXING_LEVELS;i++)
    {
        for(j=0;j<BRAP_RM_P_MAX_SRC_IN_CASCADE;j++)
        {
            for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
            {
                for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                {
                    if(NULL != pPath->sSrc[i][k][l].hSrc[j])
                    {
                        ret = BRAP_SRC_P_Close(pPath->sSrc[i][k][l].hSrc[j]);
                        if (ret != BERR_SUCCESS)
                        {
                            BDBG_ERR (("BRAP_P_CloseFmmModuleHandles: call to"
                              " BRAP_SRC_P_Close() failed. Ignoring error!!!!!"));
                            ret = BERR_TRACE (ret);
                        }
   			   BRAP_P_InitSrcHandleInfo(&(pPath->sSrc[i][k][l]), j);
                        BDBG_MSG(("SRC closed"));
                    }
                }/* for l */
            }/* for k */
        }/* for j */
    }/* for i */
#endif

#if (BRAP_7405_FAMILY == 1)            		
            if(!((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
                &&(hRapCh->bOpenTimeWrToRbuf == true)
                &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif  
{
    /* close_srcch: */
    BDBG_MSG(("BRAP_P_CloseFmmModuleHandles: Came in close_srcch"));        
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        if(NULL != pPath->sSrcCh[i].hSrcCh)
        {
            if((pPath->eUsgPath != BRAP_P_UsgPath_eMixPath)
                &&(pPath->eUsgPath != BRAP_P_UsgPath_eSharedPP))
            {
                ret = BRAP_SRCCH_P_Close(pPath->sSrcCh[i].hSrcCh);
                if (ret != BERR_SUCCESS)
                {
                    BDBG_ERR (("BRAP_P_CloseFmmModuleHandles: call to"
                      " BRAP_SRCCH_P_Close() failed. Ignoring error!!!!!"));
                    ret = BERR_TRACE (ret);
                }
            }
            BRAP_P_InitSrcChHandleInfo(&(pPath->sSrcCh[i]));
            BDBG_MSG(("SrcCh closed"));
        }
    }/* for i */
}
	for(j=0; j < BRAP_P_MAX_DST_PER_RAPCH; j++)
	{
        if(NULL == pPath->pDstDetails[j])
        {
            continue;
        }
		if(BRAP_AudioDst_eRingBuffer == pPath->pDstDetails[j]->eAudioDst)
		{
		    bRbufAllocated = true;
            break;
		}
	}

    /* If RBUF & DSTCH are allocated during AddDestination, don't close them here. */
    if(!((true == bRbufAllocated)&&(pPath->eUsgPath == BRAP_P_UsgPath_eCapture)&&(pPath->uiSelfPathArrIdx !=0)))
    {
#if (BRAP_7405_FAMILY == 1)            		
        if(!((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
            &&(hRapCh->bOpenTimeWrToRbuf == true)
            &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif  
        {    
#if (BRAP_OPEN_TIME_RBUF_ALLOCATION==1)
        if((pPath->eUsgPath != BRAP_P_UsgPath_eMixPath)
            &&(pPath->eUsgPath != BRAP_P_UsgPath_eSharedPP))
        {
        	BDBG_MSG(("BRAP_P_CloseFmmModuleHandles: Came in to return Rbuf to Pool"
             "eUsgPath = %d", pPath->eUsgPath));   
    	    BRAP_P_ReturnRBufToPool(hRapCh,pPath,0,0,0);
        }
#endif

        /* close_rbuf: */
        BDBG_MSG(("BRAP_P_CloseFmmModuleHandles: Came in close_rbuf"));        
        for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNELS; i++)
        {
            if(pPath->hRBuf[i] != NULL)
            {
                if((pPath->eUsgPath != BRAP_P_UsgPath_eMixPath)
                    &&(pPath->eUsgPath != BRAP_P_UsgPath_eSharedPP))
                {                
                    ret = BRAP_RBUF_P_Close(pPath->hRBuf[i]);
                    if(BERR_SUCCESS != ret)
                    {
                        BDBG_ERR (("BRAP_P_CloseFmmModuleHandles: call to "
                            "BRAP_RBUF_P_Close() failed. Ignoring error!!!!!"));
                        ret = BERR_TRACE(ret);
                    }
                }
                pPath->hRBuf[i] = NULL;
            }
        }/* for i */
        }
#if (BRAP_7550_FAMILY !=1)   
        BDBG_MSG(("BRAP_P_CloseFmmModuleHandles: Came in close_dstch"));        
        for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
        {
            if(NULL != pPath->sDstCh[i].hDstCh)
            {
                ret = BRAP_DSTCH_P_Close(pPath->sDstCh[i].hDstCh);
                if (ret != BERR_SUCCESS)
                {
                    BDBG_ERR (("BRAP_P_OpenOpPathFmmModules: call to"
                      " BRAP_DSTCH_P_Close() failed. Ignoring error!!!!!"));
                    ret = BERR_TRACE (ret);
                }
                BRAP_P_InitDstChHandleInfo(&(pPath->sDstCh[i]));
                BDBG_MSG(("DstCh closed"));
            }
        }/* for i */
#endif
    }

 #if (BRAP_7550_FAMILY !=1)   
    BDBG_MSG(("BRAP_P_CloseFmmModuleHandles: Came in close_capport"));        
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        for(j=0;j<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH;j++)
        {
            if(NULL != pPath->sCapPort[i][j].hCapPort)
            {
                ret = BRAP_CAPPORT_P_Close(pPath->sCapPort[i][j].hCapPort);
                if (ret != BERR_SUCCESS)
                {
                    BDBG_ERR (("BRAP_P_OpenOpPathFmmModules: call to"
                      " BRAP_CAPPORT_P_Close() failed. Ignoring error!!!!!"));
                    ret = BERR_TRACE (ret);
                }
                BRAP_P_InitCapPortHandleInfo(&(pPath->sCapPort[i][j]));
                BDBG_MSG(("CapPort closed"));
            }
        }
    }/* for i */
#endif
#if BRAP_P_EQUALIZER
end:
#endif
    BDBG_LEAVE(BRAP_P_CloseFmmModuleHandles);    
    return ret;
}

/**************************************************************************
Summary:
    Private function that starts FMM module handles for a particular path.
    All the params required to start a resource is also prepared here.
**************************************************************************/
BERR_Code BRAP_P_StartFmmModuleHandles(
    BRAP_ChannelHandle          hRapCh,         /* [in] Channel Handle */
  	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */
    unsigned int                uiPth,          /* [in] Path id */
    bool                        bCompress       /* [in] TRUE: if these resources
                                                   carry compressed data
                                                   FALSE : if PCM data */
    )
{
    BERR_Code               ret = BERR_SUCCESS, ret1 = BERR_SUCCESS;
    BRAP_P_ObjectHandles    *pPath = NULL;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    BRAP_OutputChannelPair  eChP = BRAP_OutputChannelPair_eMax;
    unsigned int            uiLvl = BRAP_INVALID_VALUE;
    unsigned int            uiPp = BRAP_INVALID_VALUE,uiPrp = BRAP_INVALID_VALUE;
    unsigned int            uiCsc = BRAP_INVALID_VALUE; 
    unsigned int            uiOutputBitsPerSample = 0;
    void                    *pOpParams = NULL;
    BRAP_Handle             hRap = NULL;
    BRAP_OP_P_Handle        hOp = NULL;
    BRAP_SPDIFFM_P_Handle   hSpdifFm = NULL;
    BRAP_SPDIFFM_P_Params   sSpdifFmParams;
    
#if (BRAP_7550_FAMILY !=1)
    unsigned int            uiOutputSampleRate=0;
    BRAP_SRC_P_Handle       hSrc = NULL;
    BRAP_SRC_P_Params       sSrcParams;
    BRAP_SRC_P_SrcInfo      sSrcInfo; 
	BRAP_DSTCH_P_Handle     hDstCh = NULL;
    BRAP_DSTCH_P_Params     sDstChParams;
    BRAP_CAPPORT_P_Handle   hCapPort = NULL;
    BRAP_CAPPORT_P_Params   sCapPortParams;    
#endif

    BRAP_OutputPortConfig   *pOpConfig = NULL;
    BRAP_RBUF_P_Handle      hRBuf = NULL;
    BRAP_RBUF_P_Params		sRBufParams;
    unsigned int            uiCh = BRAP_INVALID_VALUE;
    BRAP_SRCCH_P_Handle     hSrcCh = NULL;
    BRAP_SRCCH_P_Params     sSrcChParams;
    unsigned int            uiSR = 0;
    unsigned int            uiGrpId = BRAP_INVALID_VALUE;
    unsigned int            uiSRCGrpId[BRAP_RM_P_MAX_SRC_IN_CASCADE] = 
                                    {BRAP_INVALID_VALUE, BRAP_INVALID_VALUE};
    bool                    bFirst = true;
    BRAP_MIXER_P_Handle     hMixer = NULL;
    BRAP_MIXER_P_Params     sMixerParams;
    BRAP_P_MixingLevelProp  *pMixingLevel = NULL;
    unsigned int            i = 0;
    BRAP_RM_P_MixerGrant    *pMixerGrant = NULL;
    unsigned int            uiMixInId = 0;
    BRAP_OP_P_SpdifParams	sSpdifParams;
    BRAP_OP_P_I2sParams		sI2sParams;
    BRAP_OP_P_DacParams	    sDacParams;
    BRAP_OP_P_MaiParams     sMaiParams;
    uint32_t                ui32FciId = 0;
    unsigned int            uiI2sInGrp = 0;
    bool                    bLoopBack=false;
	uint32_t				ui32RegMask = 0;
	uint32_t				ui32RegVal = 0;    
	uint32_t                uiTimeOutCtr=0;
#if (BRAP_INDEP_OP_DELAY_SUPPORTED ==1)
    bool                    bMulPPEnabled = false;
#endif
    BRAP_P_DstDetails       *pPvtDstDetails =NULL;

#if (BRAP_7405_FAMILY ==1) && (BRAP_7550_FAMILY !=1)
    unsigned int            uiBlkId =0, uiBlkOffset =0; 
#endif
#if ((BRAP_3548_FAMILY ==1) || (BRAP_7405_FAMILY ==1))
    bool                    bPrimary[BRAP_MAX_ASSOCIATED_GROUPS] = {false,false,false,false};
    BRAP_ChannelHandle      hStartedChannel[BRAP_MAX_ASSOCIATED_GROUPS] = {NULL,NULL,NULL,NULL};
    unsigned int            uiAssocId =0,j=0;    
    bool                    bBreakLoop =false;
#endif
    bool                    bProgramOutputClock = false;
    BRAP_OP_P_Handle hMaiOp=NULL;
    bool    bAdaptiveRateEnable=false;



    BDBG_ENTER(BRAP_P_StartFmmModuleHandles);
     /* Check params */
    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(pAudioParams);
    BDBG_ASSERT(uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN);
    BDBG_ASSERT(hRapCh->pPath[uiPth]);
    
    hRap = hRapCh->hRap;
    pPath = hRapCh->pPath[uiPth];

    BDBG_MSG(("Entering BRAP_P_StartFmmModuleHandles"));
    
#if (BRAP_INDEP_OP_DELAY_SUPPORTED ==1)
    /* Find if MulPP is added */
    bMulPPEnabled = false;
#endif
    BDBG_MSG(("pPath = %d",pPath->eUsgPath));

    /* Start all outputs along with corresponding spdifFm */
    BDBG_MSG(("Starting Outputs"));
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            BDBG_MSG(("uiPp = %d, eChPair = %d", uiPp, eChPair));
            hOp = pPath->sOp[eChPair][uiPp].hOp;
            bProgramOutputClock = false;
            if(hOp != NULL)
            {
                if(true == hRap->bOpSettingsValid[hOp->eOutputPort])
                {
                    pOpConfig = &(hRap->sOutputSettings[hOp->eOutputPort]);
                    uiOutputBitsPerSample = pOpConfig->uiOutputBitsPerSample;
                }
                else
                {
                    BDBG_ASSERT(0);
                }

                /* Form the Output Params */
                if ( (BRAP_P_Rsrc_eMixer == pPath->sOp[eChPair][uiPp].sOpInLink.eRsrcType) ||
					 (BRAP_P_Rsrc_eSrcCh == pPath->sOp[eChPair][uiPp].sOpInLink.eRsrcType) ||
					 (BRAP_P_Rsrc_eSrcEq == pPath->sOp[eChPair][uiPp].sOpInLink.eRsrcType)
				   )
                {
                    ret = BRAP_P_PrepareFciId(hRapCh->pPath[uiPth],
                                              &(pPath->sOp[eChPair][uiPp].sOpInLink),
                                              &ui32FciId,BRAP_INVALID_VALUE,false);
                    if(ret != BERR_SUCCESS){return BERR_TRACE(ret);}
                }
                else if((BRAP_OutputPort_eI2s5 == hOp->eOutputPort)||
                        (BRAP_OutputPort_eI2s6 == hOp->eOutputPort)||
                        (BRAP_OutputPort_eI2s7 == hOp->eOutputPort)||
                        (BRAP_OutputPort_eI2s8 == hOp->eOutputPort))
                {
                    /* Do Nothing */
                }
                else
                {
                    /* BDBG_ASSERT(0); */
                }
                
            	/* Output block params */
            	switch(hOp->eOutputPort)
            	{
            		case BRAP_OutputPort_eSpdif:
              		case BRAP_OutputPort_eSpdif1:
                        BRAP_OP_P_GetDefaultParams(hOp->eOutputPort, 
                            (void *)&sSpdifParams);
#if(BRAP_7405_FAMILY == 1)
            			sSpdifParams.eTimebase = hRapCh->hRap->sOutputSettings[hOp->eOutputPort].eOutputTimebase;
#else
            			sSpdifParams.eTimebase = pAudioParams->eTimebase;
#endif
                        sSpdifParams.ui32InputFciId = ui32FciId;
                        sSpdifParams.bHbrEnable = pOpConfig->bHbrEnable;
            			pOpParams = &sSpdifParams;
            			break;
            		case BRAP_OutputPort_eI2s0:
            		case BRAP_OutputPort_eI2s1:
            		case BRAP_OutputPort_eI2s2:
            		case BRAP_OutputPort_eI2s3:
            		case BRAP_OutputPort_eI2s4:      
            		case BRAP_OutputPort_eI2s5:
            		case BRAP_OutputPort_eI2s6:
            		case BRAP_OutputPort_eI2s7:
            		case BRAP_OutputPort_eI2s8:      
                        BRAP_OP_P_GetDefaultParams(hOp->eOutputPort, (void *)&sI2sParams);               
#if(BRAP_7405_FAMILY == 1)
            			sI2sParams.eTimebase = hRapCh->hRap->sOutputSettings[hOp->eOutputPort].eOutputTimebase;
#else
            			sI2sParams.eTimebase = pAudioParams->eTimebase;
#endif
            			sI2sParams.uiBitsPerSample = uiOutputBitsPerSample;
                        sI2sParams.ui32InputFciId = ui32FciId;

                        /* For a particular parallel path, check all the channel pairs to 
                           find number of I2s in group */
                        uiPrp = pPath->sOp[eChPair][uiPp].sOpSelfLink.uiPrlPth;
                        for(eChP = 0, uiI2sInGrp=0; eChP < BRAP_OutputChannelPair_eMax; eChP++)
                        {
                            if((hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp != NULL) &&
                               ((hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s0) ||
                               (hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s1) ||
                               (hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s2) ||
                               (hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s3) ||
                               (hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s5) ||
                               (hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s6) ||
                               (hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s7) ||
                               (hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s8))                        
                               )
                            {
                                uiI2sInGrp++;
                            }
                        }/* for eChP */
    
                        /* If uiI2sInGrp is more than 1, bMulti should be set to true */
                        sI2sParams.bIsMulti = (uiI2sInGrp > 1) ? true : false;

                        /* bHbrEnable */
                        sI2sParams.bHbrEnable = pOpConfig->bHbrEnable;
                        
                        /* I2sParams prepared */
            			pOpParams = &sI2sParams;
            			break;
            		case BRAP_OutputPort_eDac0:
                    case BRAP_OutputPort_eDac1:
                    case BRAP_OutputPort_eDac2:                      
                        BRAP_OP_P_GetDefaultParams (hOp->eOutputPort, (void *)&sDacParams); 
#if(BRAP_7405_FAMILY == 1)
            			sDacParams.eTimebase =hRapCh->hRap->sOutputSettings[hOp->eOutputPort].eOutputTimebase;
#else
            			sDacParams.eTimebase = pAudioParams->eTimebase;
#endif
                        /*check if BTSC PP added on DAC0 */
                        for(i=0;i<BRAP_MAX_PP_SUPPORTED;i++)
                        {
                            if((hRap->hAudioProcessingStageHandle[i]!=NULL)&&
                                (hRap->hAudioProcessingStageHandle[i]->sProcessingStageSettings.eAudioProcessing == BRAP_ProcessingType_eBtsc))
                            {
                                for(j=0;j<BRAP_P_MAX_DEST_PER_PROCESSING_STAGE;j++)
                                {                
                                    if((hRap->hAudioProcessingStageHandle[i]->hDestHandle[j]!=NULL)&&
                                       (hRap->hAudioProcessingStageHandle[i]->hDestHandle[j]->sExtDstDetails.\
                                        eAudioDst == BRAP_AudioDst_eOutputPort)&&
                                       (hRap->hAudioProcessingStageHandle[i]->hDestHandle[j]->sExtDstDetails. \
                                        uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR] == BRAP_OutputPort_eDac0))
                                    {
                                        sDacParams.bBtscOnDAC = true;
                                    }
                                }
                            }
                        }
                        sDacParams.ui32InputFciId = ui32FciId;
            			pOpParams = &sDacParams;		
            			break;
                    case BRAP_OutputPort_eMai:
                        BRAP_OP_P_GetDefaultParams (hOp->eOutputPort, (void *)&sMaiParams); 
                        sMaiParams.uiSampleWidth = uiOutputBitsPerSample;
#if(BRAP_7405_FAMILY == 1)
                        sMaiParams.eTimebase =hRapCh->hRap->sOutputSettings[hOp->eOutputPort].eOutputTimebase;
#else
                        sMaiParams.eTimebase = pAudioParams->eTimebase;
#endif
                        sMaiParams.ui32InputFciId = ui32FciId;
                        sMaiParams.bHbrEnable = pOpConfig->bHbrEnable;
                        pOpParams = &sMaiParams;
                        break;
                    case BRAP_OutputPort_eMaiMulti0:                        
                    case BRAP_OutputPort_eMaiMulti1:                        
                    case BRAP_OutputPort_eMaiMulti2:                        
                    case BRAP_OutputPort_eMaiMulti3:
                        BRAP_OP_P_GetDefaultParams (hOp->eOutputPort, (void *)&sMaiParams); 
                        sMaiParams.ui32InputFciId = ui32FciId;                        
                        pOpParams = &sMaiParams;                            

                        break;
            		default:
            			BDBG_ERR(("BRAP_P_FormOpParams: Output port type %d not supported", 
            					  hOp->eOutputPort));
            			ret = BERR_TRACE(BRAP_ERR_OUPUT_PORT_NOT_SUPPORTED);
            	}
                if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_op;}


                /* Start corresponding spdifFm (if any) */
                hSpdifFm = pPath->sOp[eChPair][uiPp].hSpdifFm;
                if(hSpdifFm != NULL)
                {
                    /* Form spdifFm params */
               		ret = BRAP_SPDIFFM_P_GetDefaultParams (&sSpdifFmParams);
    		        if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_op;}

                    /* Note: Unlike 7400, etc. in 7440 we always set 
                       bSpdifFormat to true. If required, this can be exposed
                       to the user */
    		        sSpdifFmParams.sExtParams.bSpdifFormat = true; 
            		sSpdifFmParams.bCompressed = pOpConfig->bCompressed;

                    

                    sSpdifFmParams.uiCpToggleRate = pOpConfig->uiCpToggleRate;

    	        	sSpdifFmParams.bSeparateLRChanNum = pOpConfig->sSpdifChanStatusParams.bSeparateLRChanNum;
                    sSpdifFmParams.bUseSpdifPackedChanStatusBits = pOpConfig->bUseSpdifPackedChanStatusBits;
                    sSpdifFmParams.sSpdifPackedChanStatusBits = pOpConfig->sSpdifPackedChanStatusBits;
                    sSpdifFmParams.sChanStatusParams = pOpConfig->sSpdifChanStatusParams;

#if (BRAP_3548_FAMILY != 1) /* DDP Passthru on 3548 does not go through Mai */                    
                    if ((BRAP_P_UsgPath_eDecodeCompress== pPath->eUsgPath)
                        &&(BRAP_DSPCHN_AudioType_eAc3Plus==pAudioParams->sDspChParams.eType)
                        &&(BRAP_DSPCHN_DecodeMode_ePassThru==pAudioParams->sDspChParams.eDecodeMode))
                    {
                        sSpdifFmParams.bUseHwCBit = true;
                    }
                    else
#endif /* 3548_family != 1 */                        
                    {
                        sSpdifFmParams.bUseHwCBit = false;
                    }
                    BDBG_MSG(("Stream > %d, bUseHwCBit > %d", hSpdifFm->uiStreamIndex, sSpdifFmParams.bUseHwCBit));

                    /* TODO: - Should do this after SPDIF connect */
                    if ((BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource)  &&
                        ((BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort) ||
                         (BRAP_CapInputPort_eHdmi  == pAudioParams->eCapInputPort)))
                    {
            	    	ret = BRAP_P_GetBurstRepetitionPeriodForAlgo(
            	                        BAVC_StreamType_ePes,
            	                        BRAP_DSPCHN_AudioType_ePcm,
            	                        &sSpdifFmParams.eBurstRepPeriod);
                    }
                    else 
                    {
                        /* TODO: - Should do this after SPDIF connect */
                        
            	    	ret = BRAP_P_GetBurstRepetitionPeriodForAlgo(
            	                        pAudioParams->sDspChParams.eStreamType,
            	                        pAudioParams->sDspChParams.eType,
            	                        &sSpdifFmParams.eBurstRepPeriod);
                    }
        	    	if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_op;}
                      sSpdifFmParams.eSamplingRate = pOpConfig->eOutputSR;
                    /* Start SpdifFm handle */
               		ret = BRAP_SPDIFFM_P_Start(hRapCh, hSpdifFm, &sSpdifFmParams);
        	        if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_op;}

        	        BDBG_MSG(("Spdiffm %d - stream %d started", 
        			            hSpdifFm->uiIndex, hSpdifFm->uiStreamIndex));
#if(BRAP_7405_FAMILY == 1)
                    if(pPath->sOp[eChPair][uiPp].hMaiOp != NULL)
                    {
                        BRAP_OP_P_Handle hMaiOp = pPath->sOp[eChPair][uiPp].hMaiOp;                
                        uint32_t ui32RegValue=0;
                        if((hMaiOp->uOpSettings.sMai.sExtSettings.eMaiMuxSelector == BRAP_OutputPort_eI2s0)
                        ||(hMaiOp->uOpSettings.sMai.sExtSettings.eMaiMuxSelector == BRAP_OutputPort_eMaiMulti0)
                        ||(sSpdifFmParams.bUseHwCBit ==true))
                            
                        {
                            ui32RegValue = BRAP_Read32 (hSpdifFm->hRegister, 
                                    BCHP_AUD_FMM_MS_CTRL_FW_STREAM_CTRL_0 + hSpdifFm->ui32Offset);
                            ui32RegValue &= ~( BCHP_MASK (AUD_FMM_MS_CTRL_FW_STREAM_CTRL_0, STREAM_ENA) );    
                            ui32RegValue |= (BCHP_FIELD_ENUM (AUD_FMM_MS_CTRL_FW_STREAM_CTRL_0, 
                                                              STREAM_ENA, Disable));
                            BRAP_Write32 (hSpdifFm->hRegister, 
                                          hSpdifFm->ui32Offset + BCHP_AUD_FMM_MS_CTRL_FW_STREAM_CTRL_0,
                                          ui32RegValue);                         
                        }
                    }
#endif                       
                }/* hSpdifFm */


                /* Start Output handle */
           		ret = BRAP_OP_P_Start(hOp, pOpParams);
                if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_op;}
                BDBG_MSG(("Output port type %d started", hOp->eOutputPort));
                /* Special handling for hMaiOp tapping data from another Op */
                if(pPath->sOp[eChPair][uiPp].hMaiOp != NULL)
                {
                    hMaiOp = pPath->sOp[eChPair][uiPp].hMaiOp;
                    BRAP_OP_P_GetDefaultParams (hMaiOp->eOutputPort, (void *)&sMaiParams); 
                    sMaiParams.uiSampleWidth = uiOutputBitsPerSample;
#if(BRAP_7405_FAMILY == 1)
                    sMaiParams.eTimebase =hRapCh->hRap->sOutputSettings[hOp->eOutputPort].eOutputTimebase;
#else
                    sMaiParams.eTimebase = pAudioParams->eTimebase;
#endif
#if(BRAP_7405_FAMILY == 1)
                    if((hMaiOp->uOpSettings.sMai.sExtSettings.eMaiMuxSelector == BRAP_OutputPort_eI2s0)
                        ||(hMaiOp->uOpSettings.sMai.sExtSettings.eMaiMuxSelector == BRAP_OutputPort_eMaiMulti0))
                    {
                        sMaiParams.ui32InputFciId = 0x3FF;
                    }
                    else
#endif                        
                    {
                    sMaiParams.ui32InputFciId = ui32FciId;
                    }
                    sMaiParams.bHbrEnable = pOpConfig->bHbrEnable;
                    pOpParams = &sMaiParams;
               		ret = BRAP_OP_P_Start(hMaiOp, pOpParams);
                    if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_op;}
                    BDBG_MSG(("Output port type %d started", hMaiOp->eOutputPort));
                }

                /* Program the Output PLL for PCM Play Back Channel */


                /* 
                    Identify when output clock should be programmed by PI 
                    In other cases it is the Firmware that programs this
                */
                ret = BRAP_P_GetStartedChannel(hRapCh,bPrimary,hStartedChannel);

                if(BERR_SUCCESS != ret)
                {
                    return BERR_TRACE(ret);
                }        
                bBreakLoop =false;
                for(i=0; i < BRAP_MAX_ASSOCIATED_GROUPS; i++)
                {
                    for(j=0; j < BRAP_MAX_ASSOCIATED_GROUPS; j++)
                    {
                        if(hRap->sAssociatedCh[i].sDstDetails[j].sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == hOp->eOutputPort)
                        {
                            uiAssocId = i;
                            bBreakLoop =true; 
                            break;
                        }
                    }
                    if(bBreakLoop)
                        break;
                }

                if ( (NULL == hStartedChannel[uiAssocId]) ||
                     ((BRAP_ChannelType_eDecode == hStartedChannel[uiAssocId]->eChannelType)
                         &&(hStartedChannel[uiAssocId]->bGateOpened == false))
                    ||((BRAP_ChannelType_eDecode != hStartedChannel[uiAssocId]->eChannelType)
                        &&(BRAP_ChannelType_eDecode != hRapCh->eChannelType))
                   )
                {
                    bProgramOutputClock = true;
                }
#if (BRAP_3548_FAMILY ==1)
                if ( (hStartedChannel[uiAssocId]) &&
                     (BRAP_ChannelType_ePcmCapture == hStartedChannel[uiAssocId]->eChannelType)
                   )
                {
                    bProgramOutputClock = false;
                }

                else if ( (BRAP_ChannelType_eDecode == hRapCh->eChannelType) &&
                          (BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode) &&
                          (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) &&
                          ( (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort)||
                            (BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)
                          )
                        )
                {
                    bProgramOutputClock = true;
                }

#endif
                BDBG_MSG (("The bProgramOutputClock = %d",bProgramOutputClock));                    
                if (true == bProgramOutputClock)
                {
                    /* If there are no other started channel in the Association 
                      or if the started channel is not a decode or capture
                      then we need to program the output ourselves */

	                ret = BRAP_OP_P_ProgramOutputClock(
                            hRapCh,
                            hOp->eOutputPort,
                            pOpConfig->eOutputSR
                           );
                    
	                if(BERR_SUCCESS != ret)
	                {
	                    BDBG_ERR(("BRAP_P_StartFmmModuleHandles:BRAP_OP_P_ProgramOutputClock"
	                               "returned error"));
	                    return BERR_TRACE(ret);
	                }

#if (BRAP_7550_FAMILY != 1)                    
                        if((NULL != hStartedChannel[uiAssocId])
                            &&(bFirst == true))
                        {
                            BRAP_P_ConvertSR(pOpConfig->eOutputSR,&uiOutputSampleRate);
                            BKNI_EnterCriticalSection();
                            BRAP_P_ConfigureAssociatedChannelsSrc_isr(hRapCh,uiOutputSampleRate);
                            BKNI_LeaveCriticalSection();                            
                            bFirst = false;
                        }                   
#endif                        
                } /*NULL == hStartedChannel */
            }/* hOp */
        }/* for eChPair */
    }/* for uiPp */

    bFirst = true;
#if BRAP_P_EQUALIZER
    /* Starting SRC - Equalizers */
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        /* uiSRCGrpId[] is used to hold the group id of the SRCs for 
           a particular level and parallel path. Note: Different SRCs
           in same level, same parallel path but different channel pairs
           (0-3) form a group of SRCs */
        for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
        {
            uiSRCGrpId[uiCsc] = BRAP_INVALID_VALUE;
        }

        /* uiGrpId is used here for holding group id for mixers. Same logic
           as above for SRCs */ 
        uiGrpId = BRAP_INVALID_VALUE;            
        
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            /* Form SRC param and start SRC */
            for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
            {
                hSrc = pPath->sSrcEq[eChPair][uiPp].hSrcEq[uiCsc];

                if(hSrc != NULL)
                {
                    BRAP_OutputChannelPair  eOpChPair = BRAP_OutputChannelPair_eMax;
                    unsigned int            uiOpPp = BRAP_INVALID_VALUE;
                    BRAP_P_DstDetails       *pPvtDstDetails;
                    unsigned int            uiAssocId = 0, j=0,k=0,l=0;
                    bool                    bSrcCoeffAssigned = false;
                    
                    pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
                    if ( NULL==pPvtDstDetails )
                    {
                        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
                        goto end_fmm_start;                
                    }
                    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));                      
                    
                    /* Initialize the SRC-EQ to bypass. This will be changed if
                        the output port requests an equalizer */
                    sSrcInfo.uiNumSrc = 1;
                    sSrcInfo.eSrcType[uiCsc] = BRAP_SRC_P_Type_eBypass;

                    /* Get the output port information from Out Link of SRC-EQ */
                    eOpChPair = pPath->sSrcEq[eChPair][uiPp].sSrcEqOutLink[0].eChnPair;
                    uiOpPp = pPath->sSrcEq[eChPair][uiPp].sSrcEqOutLink[0].uiPrlPth;

                    /* Find if any destination on this channel is having Equalizer 
                       and update SRC coefficient address if already allocated.
                    */
                    for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
                    {
                        if(NULL == hRapCh->pDstDetails[i])
                            continue;
                        
                        /* hEqualizer is present in Private structure. Get it */
                        ret = BRAP_P_GetPvtDstDetails(hRapCh,hRapCh->pDstDetails[i],pPvtDstDetails,&uiAssocId);
                        if(BERR_SUCCESS!=ret)
                        {
                            continue;
                        }

                        if( (pPvtDstDetails->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                            (pPath->sOp[eOpChPair][uiOpPp].hOp != NULL) &&                             
                            (pPvtDstDetails->sExtDstDetails.uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR]
                                == pPath->sOp[eOpChPair][uiOpPp].hOp->eOutputPort)
                          )
                        {
                            if(NULL != pPvtDstDetails->hEqualizer)
                            {
                                sSrcInfo.eSrcType[uiCsc] = BRAP_SRC_P_Type_eIIR;

                                for(j=0; j<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; j++)
                                {
                                    for(k=0; k<BRAP_RM_P_MAX_PARALLEL_PATHS; k++)
                                    {
                                        for(l=0; l<BRAP_P_MAX_PATHS_IN_A_CHAN; l++)
                                        {                          
                                            if((NULL != pPvtDstDetails->hEqualizer->hSrcEq[uiCsc][j][k][l]) &&
                                               (BRAP_INVALID_VALUE != pPvtDstDetails->hEqualizer->
                                                        hSrcEq[uiCsc][j][k][l]->uiCoeffAddr))
                                            {
                                                hSrc->uiCoeffAddr = pPvtDstDetails->hEqualizer->
                                                    hSrcEq[uiCsc][j][k][l]->uiCoeffAddr;  
                                                bSrcCoeffAssigned = true;
                                                
                                                BDBG_MSG(("SRCEQ_Start: Populating the already allocated "
                                                    "Coefficient Address. uiCoeffAddr = %d, Index = %d, Block = %d",
                                        hSrc->uiCoeffAddr, hSrc->uiIndex, hSrc->uiBlkId));
                                                break;
                                            }
                                        }
                                        if(true == bSrcCoeffAssigned)
                                            break;
                                    }
                                    if(true == bSrcCoeffAssigned)
                                        break;                            
                                }
                                break;
                            }
                        }
                    } /* for i */

                    if(uiCsc > sSrcInfo.uiNumSrc)
                    {
                        ret = BERR_TRACE(BERR_NOT_SUPPORTED); 
                        goto stop_src_mixer;
                    }

                    if(BRAP_INVALID_VALUE == uiSRCGrpId[uiCsc])
                        uiSRCGrpId[uiCsc] = hSrc->uiIndex;

                    /* Form SRC params */
               		ret = BRAP_SRC_P_GetDefaultParams (&sSrcParams);
    		        if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_srceq;}

                    sSrcParams.eSrcType = sSrcInfo.eSrcType[uiCsc];
                    sSrcParams.eInputSR = sSrcInfo.eInSR[uiCsc];
                    sSrcParams.eOutputSR = sSrcInfo.eOutSR[uiCsc];
                    sSrcParams.bRampEnable = false;
                    sSrcParams.bPriorityHigh = false;
                    sSrcParams.uiGroupId = uiSRCGrpId[uiCsc];

                    ret = BRAP_P_PrepareFciId(pPath,
                            &(pPath->sSrcEq[eChPair][uiPp].sSrcEqInLink),
                            &(sSrcParams.ui32FciId), uiCsc,false);
                    if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret);goto stop_srceq;}

                    ret = BRAP_SRC_P_Start(hSrc, &sSrcParams);
                    if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_srceq;}

    	            BDBG_MSG(("Eq SRC %d in SRC Blk %d started for Equalizer", 
        			            hSrc->uiIndex, hSrc->uiBlkId)); 
                } /* hSrc != NULL */
            }/* for uiCsc */
        }/* for eChPair */
    }/* for uiPp */
#endif

    /* Start Mixers-SRCs in each level */
    BDBG_MSG(("Starting Mixer-SRCs"));
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {
            /* uiSRCGrpId[] is used to hold the group id of the SRCs for 
               a particular level and parallel path. Note: Different SRCs
               in same level, same parallel path but different channel pairs
               (0-3) form a group of SRCs */
            for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
            {
                uiSRCGrpId[uiCsc] = BRAP_INVALID_VALUE;
            }

            /* uiGrpId is used here for holding group id for mixers. Same logic
               as above for SRCs */ 
            uiGrpId = BRAP_INVALID_VALUE;            
            
            for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
            {
                pMixingLevel = &(pPath->sMixingLevels[uiLvl]);

#if (BRAP_7550_FAMILY != 1)
                /* Form SRC param and start SRC */
                for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
                {
                    hSrc = pPath->sSrc[uiLvl][eChPair][uiPp].hSrc[uiCsc];
                    if(hSrc != NULL)
                    {
        				    /* Init to invalid values */
        				    for(i = 0; i < BRAP_RM_P_MAX_SRC_IN_CASCADE; i++)
        				    {
        				        sSrcInfo.eSrcType[i] = BRAP_SRC_P_Type_eUnknown;
        				        sSrcInfo.eInSR[i] = BAVC_AudioSamplingRate_eUnknown;
        				        sSrcInfo.eOutSR[i] = BAVC_AudioSamplingRate_eUnknown;
        				    }
                        
    			        if((BRAP_ChannelType_eDecode == hRapCh->eChannelType)&&
                           (BRAP_ChannelSubType_eNone == hRapCh->eChannelSubType))
    			    	{
        				    /* For Settop kind of app */
        				    sSrcInfo.uiNumSrc = 1;
        				    sSrcInfo.eSrcType[0] = BRAP_SRC_P_Type_eBypass;
    			    	}
                        else if ( (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) &&
                            (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort))  
                        {
                            if ( (BRAP_P_UsgPath_eCapture == pPath->eUsgPath) && (0 == uiPth) )
                            {
                                /* ADC IN requires a Down 4 */
                                BDBG_MSG (("SRC needs to be in Down4 for ADC in Capture Path"));
            				    sSrcInfo.uiNumSrc = 1;
            				    sSrcInfo.eSrcType[0] = BRAP_SRC_P_Type_eDown4;
                            }
                            else
                            {
                                BDBG_MSG (("SRC needs to be in normal mode for ADC in Decode PCM Path"));                            
            				    sSrcInfo.uiNumSrc = 1;
            				    sSrcInfo.eSrcType[0] = BRAP_SRC_P_Type_eBypass;
                            }
                        }
                        else if ((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
                                   ||(BRAP_ChannelType_ePcmCapture== hRapCh->eChannelType))
                        {
                            /* Assuming that for PCM playback/Capture we will do only Lint Mode SRC */
                            sSrcInfo.uiNumSrc = 1;
                            if(pMixingLevel->eInputSR != pMixingLevel->eOutputSR)
                                sSrcInfo.eSrcType[0] = BRAP_SRC_P_Type_eLinInt;
                            else
                                sSrcInfo.eSrcType[0] = BRAP_SRC_P_Type_eBypass;

                            sSrcInfo.eInSR[0] = pMixingLevel->eInputSR;
                            sSrcInfo.eOutSR[0] = pMixingLevel->eOutputSR;                            
                        }
        			    else
    			    	{
                            ret = BRAP_SRC_P_GetRequiredSrc(
                                            &sSrcInfo,
                                            pMixingLevel->eInputSR, 
                                            pMixingLevel->eOutputSR,
                                            bCompress
                                            );                        
                            if(ret!=BERR_SUCCESS)
                            {
                                ret = BERR_TRACE(ret); 
                                goto stop_src_mixer;
                            }

    			    	}

                        if(uiCsc > sSrcInfo.uiNumSrc)
                        {
                            ret = BERR_TRACE(BERR_NOT_SUPPORTED); 
                            goto stop_src_mixer;
                        }

                        if(BRAP_INVALID_VALUE == uiSRCGrpId[uiCsc])
                            uiSRCGrpId[uiCsc] = hSrc->uiIndex;

                        /* Form SRC params */
                   		ret = BRAP_SRC_P_GetDefaultParams (&sSrcParams);
        		        if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_src_mixer;}

                        sSrcParams.eSrcType = sSrcInfo.eSrcType[uiCsc];
                        sSrcParams.eInputSR = sSrcInfo.eInSR[uiCsc];
                        sSrcParams.eOutputSR = sSrcInfo.eOutSR[uiCsc];

                        /* Scale ramp enable: If TRUE then scaling is applied to
                           a playback channel during start up. FALSE: other wise.
                           For Compressed data it should be false.*/
                        if ((true == bCompress)||  
                            ( (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) && 
                              (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort) &&
                              (BRAP_P_UsgPath_eCapture == pPath->eUsgPath) &&
                              (0 == uiPth)
                             )||
                            ((BRAP_ChannelType_eDecode == hRapCh->eChannelType )&&
                            (BRAP_ChannelSubType_eNone ==hRapCh->eChannelSubType)))
                        {
	                            sSrcParams.bRampEnable = false;
	                            sSrcParams.bPriorityHigh = false;
                    	}
 	                    else
                    	{
                            sSrcParams.bRampEnable = true;
                            /* Input sampling rate in a level will decide the high
                               or low priority for both the SRCs in cascade */
                            ret = BRAP_P_ConvertSR(pMixingLevel->eOutputSR, &uiSR);
                            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret);goto stop_src_mixer;} 

                            sSrcParams.bPriorityHigh = (uiSR >= 96000) ? true:false;
                    	}

                        sSrcParams.uiGroupId = uiSRCGrpId[uiCsc];
                        ret = BRAP_P_PrepareFciId(pPath,
                                &(pPath->sSrc[uiLvl][eChPair][uiPp].sSrcInLink),
                                &(sSrcParams.ui32FciId), uiCsc,false);
                        if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret);goto stop_src_mixer;}

#if (BRAP_7405_FAMILY ==1)
                    if(!((hRapCh->eChannelType == BRAP_ChannelType_eDecode)
                        &&(pAudioParams->sDspChParams.eDecodeMode == BRAP_DSPCHN_DecodeMode_eDecode)))
                    {
                        for(uiBlkId = 0; uiBlkId < BRAP_RM_P_MAX_SRC_BLCK; uiBlkId++)
                        {
#if ( BRAP_RM_P_MAX_SRC_BLCK > 1 )    
                            uiBlkOffset = (BCHP_AUD_FMM_SRC_CTRL1_STRM_ENA - BCHP_AUD_FMM_SRC_CTRL0_STRM_ENA) * uiBlkId;
#endif                    
                            BRAP_Write32(hRapCh->hRegister, (BCHP_AUD_FMM_SRC_CTRL0_RAMP_STEP + uiBlkOffset), hRap->uiSrcRampStepSize);   
                        }
                    }
#endif                    
                        ret = BRAP_SRC_P_Start(hSrc, &sSrcParams);
                        if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_src_mixer;}

        	            BDBG_MSG(("SRC %d in SRC Blk %d started", 
        			            hSrc->uiIndex, hSrc->uiBlkId));                        
                    }
                }/* for uiCsc */
#endif

                /* Form MIXER params and start mixer */
                hMixer = pPath->sMixer[uiLvl][eChPair][uiPp].hMixer;
                if(hMixer != NULL)
                {
                    if(BRAP_INVALID_VALUE == uiGrpId)
                        uiGrpId = hMixer->uiMixerIndex;

                    /* Form Mixer params */
               		ret = BRAP_MIXER_P_GetDefaultParams(&sMixerParams);
    		        if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_src_mixer;}

                    if ((true == bCompress)|| 
                        ( (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) && 
                          (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort) &&
                          (BRAP_P_UsgPath_eCapture == pPath->eUsgPath) &&
                          (0 == uiPth)
                        )||                        
                        ((BRAP_ChannelType_eDecode == hRapCh->eChannelType )&&
                         ( BRAP_ChannelSubType_eNone ==hRapCh->eChannelSubType )))
                    {
                        sMixerParams.bPriorityHigh = false;
                    }
                    else
                    {
                        /* Input sampling rate in a level will decide the high
                           or low priority for both the SRCs in cascade */
                        ret = BRAP_P_ConvertSR(pMixingLevel->eOutputSR, &uiSR);
                        if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret);goto stop_src_mixer;} 
                        sMixerParams.bPriorityHigh = (uiSR >= 96000) ? true : false;
                    }
                    
                    
           			sMixerParams.bCompress = bCompress;
                    sMixerParams.uiGroupId = uiGrpId;

                    pMixerGrant = &(pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].
                        sMixerGrant[eChPair][uiPp]);
                    if(pMixerGrant->uiMixerOutputId[0]!=BRAP_RM_P_INVALID_INDEX)
                    {
                        if(pMixerGrant->uiMixerOutputId[0] == 0)
                        {
                            sMixerParams.bOutputEnable0 = true;
                        }
                        else if (pMixerGrant->uiMixerOutputId[0] == 1)
                        {
                            sMixerParams.bOutputEnable1 = true;
                        }
                    }
                    if(pMixerGrant->uiMixerOutputId[1]!=BRAP_RM_P_INVALID_INDEX)
                    {
                        if(pMixerGrant->uiMixerOutputId[1] == 0)
                        {
                            sMixerParams.bOutputEnable0 = true;
                        }
                        else if (pMixerGrant->uiMixerOutputId[1] == 1)
                        {
                            sMixerParams.bOutputEnable1 = true;
                        }
                    }

                 
                    /* Soft-Limiting should be enabled only if data is uncompressed */
                    sMixerParams.bEnableSoftLimit = (bCompress == false)? 
                                            hRap->sSettings.bEnableSoftLimit : false;


                    for(i = 0; i <BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
                    {
                        uiMixInId = pMixerGrant->uiMixerInputId[i];
                        if(uiMixInId != BRAP_RM_P_INVALID_INDEX)
                        {
                            if(BRAP_P_Rsrc_eMixer ==
                                pPath->sMixer[uiLvl][eChPair][uiPp].
                                sMixerInLink[uiMixInId].eRsrcType)
                            {
                                bLoopBack=true;
                            }
                            BDBG_MSG(("Calling PrepareFciId for Mixer "));
                            ret = BRAP_P_PrepareFciId(pPath,
                                &(pPath->sMixer[uiLvl][eChPair][uiPp].sMixerInLink[uiMixInId]),
                                &(sMixerParams.ui32InputFciId[uiMixInId]), 
                                BRAP_INVALID_VALUE,bLoopBack);
                            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret);goto stop_src_mixer;}
#if (BRAP_7405_FAMILY ==1)
                            if(!((hRapCh->eChannelType == BRAP_ChannelType_eDecode)
                                &&(pAudioParams->sDspChParams.eDecodeMode == BRAP_DSPCHN_DecodeMode_eDecode)))
                            {
                                BRAP_Write32 (hRapCh->hRegister, BCHP_AUD_FMM_DP_CTRL0_VOLUME_RAMP_STEP, hRap->uiMixerRampStepSize);
                            }
#endif                    
                            ret = BRAP_MIXER_P_Start(hMixer, 
                                                    uiMixInId, &sMixerParams);
                            if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_src_mixer;}
            	            BDBG_MSG(("Mixer %d MixerIn %d in DP Blk %d started", 
            			            hMixer->uiMixerIndex, uiMixInId,
            			            hMixer->uiDpIndex));                        
                        }
                    }/* for i */
                }
            }/* for eChPair */
        }/* for uiPp */
    }/* for uiLvl */
    

/*Restoring Mute status of O/P at Mixer level*/
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            hOp = pPath->sOp[eChPair][uiPp].hOp;
            if(hOp != NULL)
            {
                BKNI_EnterCriticalSection();                
                BRAP_OP_P_MuteMixerOfOutput_isr(hRap,hOp->eOutputPort,hOp->hFmm->hRap->bOutputMute[hOp->eOutputPort]);
                BKNI_LeaveCriticalSection();
                

                if(pPath->sOp[eChPair][uiPp].hMaiOp != NULL)
                {
                    hMaiOp = pPath->sOp[eChPair][uiPp].hMaiOp;
                    BKNI_EnterCriticalSection();                    
                    BRAP_OP_P_MuteMixerOfOutput_isr(hRap,hMaiOp->eOutputPort,hMaiOp->hFmm->hRap->bOutputMute[hMaiOp->eOutputPort]);
                    BKNI_LeaveCriticalSection();                    
                }
            }
        }
    }

    
    /* Start Ring buffers */
    BDBG_MSG(("Starting RBufs"));
    for(uiCh = 0; uiCh < BRAP_RM_P_MAX_OP_CHANNELS; uiCh++)
    {
        hRBuf = pPath->hRBuf[uiCh];
        if(hRBuf != NULL)
        {
            ret = BRAP_RBUF_P_GetDefaultParams(&sRBufParams);
            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_rbuf;}

            sRBufParams.uiStartWRPoint = hRBuf->sSettings.sExtSettings.uiSize-1;
            sRBufParams.uiStartSize = hRBuf->sSettings.sExtSettings.uiSize;                     

            if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
            {

                if((pAudioParams->uiStartWRPtrLocation == BRAP_INVALID_VALUE)
                || (pAudioParams->uiStartWRPtrLocation > sRBufParams.uiStartSize -1))
                {
                    sRBufParams.uiStartWRPoint = sRBufParams.uiStartSize - 0x101; 
                }
                else
                {
                    sRBufParams.uiStartWRPoint = pAudioParams->uiStartWRPtrLocation; 
                }
    	    }

            /* TODO: For a CAP channel default sRBufParams will change */
            /* Start the ring buffer */
            ret = BRAP_RBUF_P_Start(hRBuf, &sRBufParams);
            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_rbuf;}
            
            BDBG_MSG(("Ring buffer %d started", hRBuf->uiIndex));
        }
    }/* for uiCh */

    /* Programming the application provided volume levels for destination at start time */

                    
    pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
    if ( NULL==pPvtDstDetails )
    {
        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        goto stop_rbuf;                
    }
    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));  
    
    for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        unsigned int            uiAssocId,uiMixerlevel=0;
        if(NULL == hRapCh->pDstDetails[i])
            continue;
        if(hRapCh->pDstDetails[i]->eAudioDst == BRAP_AudioDst_eRingBuffer)
        {
        BDBG_MSG(("hRapCh->pDstDetails[i]=%x",hRapCh->pDstDetails[i]));
        
        /*Find the audio procsssing for the destination of the row on association network*/
        ret = BRAP_P_GetPvtDstDetails(hRapCh,hRapCh->pDstDetails[i],pPvtDstDetails,&uiAssocId);
        if(BERR_SUCCESS!=ret)
        {
            ret = BERR_TRACE(ret);
            BKNI_Free(pPvtDstDetails);
            goto stop_rbuf;
        }

        /* call BRAP_SetDestinationVolume() only if it is a ringbuffer destination or an output port carrying pcm data */
        if( (pPvtDstDetails->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer)||
            ((pPvtDstDetails->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
            (hRap->sOutputSettings[pPvtDstDetails->sExtDstDetails.uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR]].bCompressed == false)) )
        {
            ret = BRAP_SetDestinationVolume(pPvtDstDetails,pPvtDstDetails->uiLtVolume[BRAP_OutputChannelPair_eLR][uiMixerlevel],
                                                        pPvtDstDetails->uiRtVolume[BRAP_OutputChannelPair_eLR][uiMixerlevel]);
        }
        if(BERR_SUCCESS!=ret)
        {
            ret = BERR_TRACE(ret);
            goto stop_rbuf;
        }

        ret = BRAP_SetDestinationMute(pPvtDstDetails,pPvtDstDetails->bMute[BRAP_OutputChannelPair_eLR]);
        if(BERR_SUCCESS!=ret)
        {
            ret = BERR_TRACE(ret);
            goto stop_rbuf;
        }        
    }
    }

    
    /* Start Source Channels */
    BDBG_MSG(("Starting SrcCh"));
    for(eChPair = 0, bFirst = true, uiGrpId = BRAP_INVALID_VALUE; 
        eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; 
        eChPair++)
    {
        hSrcCh = pPath->sSrcCh[eChPair].hSrcCh;
        if(hSrcCh != NULL)
        {
            if(true == bFirst)
            {
                uiGrpId = hSrcCh->uiIndex;
                bFirst = false;
            }
                
            /* Get the default parameters first */
            ret = BRAP_SRCCH_P_GetDefaultParams(&sSrcChParams);
            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_srcch;} 

            if((BRAP_ChannelType_eDecode == hRapCh->eChannelType))
            {
                sSrcChParams.eBufDataMode = BRAP_BufDataMode_eStereoNoninterleaved;
                
           		if(true == bCompress)
        	    {
        			sSrcChParams.bCompress = true;
        			/* Set bits per sample = 16, as DSP generates 16 bits per sample for compressed data */
        			sSrcChParams.eInputBitsPerSample = BRAP_InputBitsPerSample_e16;
        	    }
        		else
                {
        			sSrcChParams.bCompress = false;
        			/* Set bits per sample = 32, as DSP generates 32 bits per sample for PCM data */
        			sSrcChParams.eInputBitsPerSample = BRAP_InputBitsPerSample_e32;
                }
                 
            }
            else if (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
            {
                if((BRAP_P_UsgPath_eDecodePcmPostMixing == pPath->eUsgPath) ||
                   (BRAP_P_UsgPath_ePPBranchPostMixing == pPath->eUsgPath))
                {
                    sSrcChParams.eBufDataMode = BRAP_BufDataMode_eStereoNoninterleaved;                
               		if(true == bCompress)
            	    {
            			sSrcChParams.bCompress = true;
            			sSrcChParams.eInputBitsPerSample = BRAP_InputBitsPerSample_e16;
            	    }
            		else
                    {
            			sSrcChParams.bCompress = false;
            			/* Set bits per sample = 32, as DSP generates 32 bits per sample for PCM data */
            			sSrcChParams.eInputBitsPerSample = BRAP_InputBitsPerSample_e32;
        		    }
                }
                else
                {
                    /* 
                        For PCM Playback channel and non loopback path
                        the parameters from applicatoin are to be used.
                    */
                    sSrcChParams.eBufDataMode = pAudioParams->eBufDataMode;
                    if(pAudioParams->eBufDataMode == BRAP_BufDataMode_eMono)
                    {
                        /* If Mono route to it both Lout and Rout */
                            sSrcChParams.eLRDataCntl = BRAP_SRCCH_P_LRDataControl_L_2_LR;
                    }
        			sSrcChParams.eInputBitsPerSample = pAudioParams->eInputBitsPerSample;
                    
               		if(true == bCompress)
            	    {
            			sSrcChParams.bCompress = true;
            	    }
            		else
                    {
            			sSrcChParams.bCompress = false;
#if (BRAP_UNSIGNED_PCM_SUPPORTED == 1)                    
                        sSrcChParams.bIsSigned = pAudioParams->bIsPcmSigned;
#endif
                    }

                    sSrcChParams.bNotPauseWhenEmpty = pAudioParams->bLoopAroundEn;
                }
            }
            else if(BRAP_ChannelType_ePcmCapture == hRapCh->eChannelType)
            {
                sSrcChParams.eBufDataMode = pAudioParams->eBufDataMode;
                if(pAudioParams->eBufDataMode == BRAP_BufDataMode_eMono)
                {
                    /* If Mono route to it both Lout and Rout */
                        sSrcChParams.eLRDataCntl = BRAP_SRCCH_P_LRDataControl_L_2_LR;
                }                
              
#if (BRAP_3548_FAMILY ==1)

           		if(true == bCompress)
        	    {
        			sSrcChParams.bCompress = true;
        			/* Set bits per sample = 16, as DSP generates 16 bits per sample for compressed data */
        			sSrcChParams.eInputBitsPerSample = BRAP_InputBitsPerSample_e16;
        	    }
        		else
                {
        			sSrcChParams.bCompress = false;
        			/* Set bits per sample = 32, as DSP generates 32 bits per sample for PCM data */
        			sSrcChParams.eInputBitsPerSample = BRAP_InputBitsPerSample_e32;
                }
#else                
                if(true == bCompress)
                {
                    sSrcChParams.bCompress = true;
                }
                else
                {
                    sSrcChParams.bCompress = false;
                }
                sSrcChParams.eInputBitsPerSample = pAudioParams->eInputBitsPerSample;
                sSrcChParams.bNotPauseWhenEmpty = pAudioParams->bLoopAroundEn;           
#if (BRAP_UNSIGNED_PCM_SUPPORTED == 1)                    
                sSrcChParams.bIsSigned = pAudioParams->bIsPcmSigned;
#endif                  
#endif                
            }
            else
                BDBG_ASSERT(0); /* TODO: support for other channel types */



#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)
            if(hRapCh->bIndepDelayEnabled == true)
            {
                BDBG_MSG(("pPath->uiMasterpathId =%d , hRapCh->pPath[pPath->uiMasterpathId] = %#x "
                    ,pPath->uiMasterpathId,hRapCh->pPath[pPath->uiMasterpathId]));
                if((pPath->uiMasterpathId != BRAP_INVALID_VALUE)
                    &&(hRapCh->pPath[pPath->uiMasterpathId] != NULL)
                    &&(hRapCh->pPath[pPath->uiMasterpathId]->sSrcCh[eChPair].hSrcCh != NULL))
                {

                
                    if (    (hRapCh->eChannelType == BRAP_ChannelType_eDecode)
#if (BRAP_3548_FAMILY ==1)
                        || (hRapCh->eChannelType == BRAP_ChannelType_ePcmCapture)
#endif
                        )
                    {
                        sSrcChParams.bSharedRbuf = false;
                    }
                    else
                    {                     
                    sSrcChParams.bSharedRbuf = true;
                    sSrcChParams.uiMasterSrcCh = hRapCh->pPath[pPath->uiMasterpathId]->sSrcCh[eChPair].hSrcCh->uiIndex;                    
                    }
                }
            }
            else
#endif 
            {
                sSrcChParams.bSharedRbuf = false;
                sSrcChParams.uiMasterSrcCh = BRAP_RM_P_INVALID_INDEX;
            }

            if((BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)&&
                (BRAP_DataEndian_eSwap == pAudioParams->eDataSwap))
            {
                /* swap system data endianness */
                sSrcChParams.eDataSwap = BRAP_DataEndian_eSwap;
            }
            else
            {
                /* don't swap system data endianness */
                sSrcChParams.eDataSwap = BRAP_DataEndian_eSame;
            }

#if (BRAP_7405_FAMILY == 1) || (BRAP_3548_FAMILY == 1)
            if ( (hRapCh->eChannelType == BRAP_ChannelType_ePcmCapture) ||
                 ( (BRAP_ChannelType_eDecode == hRapCh->eChannelType) &&
                   (BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode) &&
                   (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) &&
                   ( (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort)||
                     (BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)
                   )
                 )
               )
            {
                sSrcChParams.bStartSelection = false;            
            }
            else
            {
                sSrcChParams.bStartSelection = true;
            }
#else
            sSrcChParams.bStartSelection = true;
#endif
            sSrcChParams.bCapDirect2SrcFIFO = false;

            if((BRAP_ChannelType_eDecode == hRapCh->eChannelType )&&
            (BRAP_ChannelSubType_eNone ==hRapCh->eChannelSubType))
            {
                sSrcChParams.bProcessIdHigh = false;
                /* Check for bProcessIdHigh once sample rate change interrupt comes in */
        	}
            else
            {
            ret = BRAP_P_ConvertSR(pAudioParams->eInputSR, &uiSR);

            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_srcch;}

   			sSrcChParams.bProcessIdHigh = (uiSR >= 96000) ? true : false;
            }
            sSrcChParams.uiGroupId = uiGrpId;

            /* Start the SrcCh */
       		ret = BRAP_SRCCH_P_Start(hSrcCh, &sSrcChParams);
	        if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_srcch;}
	        BDBG_MSG(("Source channel %d started", hSrcCh->uiIndex));
        }
    }/* for eChPair */

    /* Program Adaptive Rate ctrl  for the Path, If the its DecodeMode.*/
        BRAP_P_EnableAdaptiveRate(hRapCh,&bAdaptiveRateEnable,pAudioParams->sDspChParams.bPPMCorrection);        
        BDBG_MSG(("pAudioParams->sDspChParams.bPPMCorrection = %d, bAdaptiveRateEnable =%d ",pAudioParams->sDspChParams.bPPMCorrection,bAdaptiveRateEnable));
        
        if(bAdaptiveRateEnable == true)
        {
        ret = BRAP_P_ProgramAdaptRateCtrl (hRapCh,uiPth);
        if(BERR_SUCCESS != ret)
        {
            BDBG_ERR(("BRAP_P_StartDecPath: BRAP_P_ProgramAdaptRateCtrl failed %d", ret));
            return BERR_TRACE(ret);              
        }            
    }
    
#if (BRAP_7550_FAMILY !=1)
    /* Start DstCh here */
    BDBG_MSG(("Starting DstCh"));
    for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        hDstCh = pPath->sDstCh[eChPair].hDstCh;
        if(hDstCh != NULL)
        {
            /* Get the default parameters first */
            ret = BRAP_DSTCH_P_GetDefaultParams(&sDstChParams);
            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_dstch;} 

            if(BRAP_ChannelType_ePcmCapture == hRapCh->eChannelType)
            {
                if (0 == uiPth)
                    sDstChParams.eCapMode = pAudioParams->eCapMode;
                else
                    sDstChParams.eCapMode = BRAP_CaptureMode_eCaptureOnly;
            }
            else if ( (BRAP_ChannelType_eDecode == hRapCh->eChannelType) &&
                      (BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode) &&
                      (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) &&
                      ( (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort)||
                        (BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)
                      ) &&
                      (0 == uiPth)
                     )
            {
                /* Put DSTCH in passthru mode only when SPDIF RX is in passthru */
                sDstChParams.eCapMode = BRAP_CaptureMode_eByPass;
            }
                      
            else
            {
                /* TODO: to check if it is correct */
                sDstChParams.eCapMode = BRAP_CaptureMode_eCaptureOnly; /* TODO: XCD Check */
                
            }

            if ((BRAP_ChannelType_ePcmCapture == hRapCh->eChannelType) && (0 == uiPth))
            {
                sDstChParams.eBufDataMode = 
                 hRap->sInputSettings[pAudioParams->eCapInputPort].eBufDataMode;
            }
            else
            {
            
                bBreakLoop =false;
                for(i=0; i<BRAP_P_MAX_DST_PER_RAPCH; i++)
                {

                    for(j =0 ; j < BRAP_P_MAX_DST_PER_RAPCH; j++)
                    {
                        if( hRapCh->pDstDetails[i]!= NULL && 
                            hRapCh->pDstDetails[i]->eAudioDst == BRAP_AudioDst_eRingBuffer &&
                            hRapCh->pPath[uiPth]->pDstDetails[j] == hRapCh->pDstDetails[i])
                        {
                            sDstChParams.eBufDataMode = 
                             hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.eBufDataMode[BRAP_OutputChannelPair_eCaptureLR];
                            
                            /* Note: If bNotPauseWhenFull is true, BF interrupts(e.g. full/free 
                               watermark) don't come. So, set it to false. */
                            sDstChParams.bNotPauseWhenFull = 
                            hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.bDontPauseWhenFull;                        
                            bBreakLoop =true;
                            break;
                        }
                        else
                        {
                            sDstChParams.eBufDataMode = BRAP_BufDataMode_eStereoNoninterleaved;
                        }                    
                    }                
                    if(bBreakLoop == true)
                        break;

                }
            }

            if(  sDstChParams.eCapMode != BRAP_CaptureMode_eCaptureOnly )
            {
                sDstChParams.uiSrcChId = 
                            hRapCh->pPath[uiPth+1]->sRsrcGrnt.uiSrcChId[eChPair];

            }

            if((BRAP_ChannelType_eDecode == hRapCh->eChannelType )&&
            (BRAP_ChannelSubType_eNone ==hRapCh->eChannelSubType))
            {
                sDstChParams.bProcessIdHigh = false;
                /* Check for bProcessIdHigh once sample rate change interrupt comes in */
        	}
            else
            {
            ret = BRAP_P_ConvertSR(pAudioParams->eInputSR, &uiSR);
            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_dstch;} 

            sDstChParams.bProcessIdHigh = (uiSR >= 96000) ? true : false;
            }

           
            ret = BRAP_P_PrepareFciId(pPath, 
                                &(pPath->sDstCh[eChPair].sDstChInLink), 
                                (uint32_t *)&(sDstChParams.uiInputFciId),
                                BRAP_INVALID_VALUE,false);
            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret);goto stop_dstch;}


#if (BRAP_3548_FAMILY ==1)
            if ( (BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource) &&
                 (0 == uiPth) &&
                 ( (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort)||
                   (BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)
                 )
               )
            {
                if (BRAP_DSPCHN_AudioType_ePcm == pAudioParams->sDspChParams.eType)
                {
                    sDstChParams.eBufDataMode = BRAP_BufDataMode_eStereoNoninterleaved;
                }
                else
                {
                    sDstChParams.eBufDataMode = BRAP_BufDataMode_eMono;
                }
            }
#endif
           /* Start the DstCh */
       		ret = BRAP_DSTCH_P_Start(hDstCh, &sDstChParams);
	        if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_dstch;}
	        BDBG_MSG(("Destination channel %d started", hDstCh->uiIndex));
        }
    }/* for eChPair */
   
    /* Start Cap port here */
    BDBG_MSG(("Starting CapPort"));    
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {

        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            hCapPort = pPath->sCapPort[eChPair][uiPp].hCapPort;
            if((hCapPort != NULL) && 
               (BRAP_P_UsgPath_eCapture == pPath->eUsgPath) &&
               (true == BRAP_P_IsInternalCapPort(hCapPort->eCapPort)) &&
               ( (BRAP_CapInputPort_eAdc != hRapCh->eCapInputPort) || (uiPth!=0)))
            {
                continue;                
            }
                
            if(hCapPort != NULL)
            {
                    /* Get the default parameters first */
                    ret = BRAP_CAPPORT_P_GetDefaultParams(&sCapPortParams);
                    if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_capport;} 
#if (BRAP_7405_FAMILY == 1)
                uiGrpId = BRAP_INVALID_VALUE;

                    switch(hCapPort->eCapPort)
                    {
                    case BRAP_CapInputPort_eExtI2s0:
                        uiGrpId = 4;
                        break;
                        case BRAP_CapInputPort_eIntCapPort0:
                            uiGrpId = 0;
                            break;
                        case BRAP_CapInputPort_eIntCapPort1:
                            uiGrpId = 1;
                            break;
                        case BRAP_CapInputPort_eIntCapPort2:
                            uiGrpId = 2;
                            break;
                        case BRAP_CapInputPort_eIntCapPort3:
                            uiGrpId = 3;
                            break;
                        case BRAP_CapInputPort_eIntCapPort4:
                            uiGrpId = 4;
                            break;
                        case BRAP_CapInputPort_eIntCapPort5:
                            uiGrpId = 5;
                            break;
                        case BRAP_CapInputPort_eIntCapPort6:
                            uiGrpId = 6;
                            break;
                        case BRAP_CapInputPort_eIntCapPort7:
                            uiGrpId = 7;
                            break;
                        default:
                            BDBG_ASSERT(0);
                    }
                
                sCapPortParams.uiGrpId = uiGrpId;
#endif


                switch(hCapPort->eCapPort)
                {
                    case BRAP_CapInputPort_eIntCapPort0:
                    case BRAP_CapInputPort_eIntCapPort1:
                    case BRAP_CapInputPort_eIntCapPort2:
                    case BRAP_CapInputPort_eIntCapPort3:
                    case BRAP_CapInputPort_eIntCapPort4:
                    case BRAP_CapInputPort_eIntCapPort5:
                    case BRAP_CapInputPort_eIntCapPort6:
                    case BRAP_CapInputPort_eIntCapPort7:                    
                        sCapPortParams.eInputBitsPerSample = BRAP_InputBitsPerSample_e32;
                        sCapPortParams.eSamplingRate = BAVC_AudioSamplingRate_e48k;
                    
                        ret = BRAP_P_PrepareFciId(
                                pPath, 
                                &(pPath->sCapPort[eChPair][uiPp].sCapPortInLink), 
                                (uint32_t *)&(sCapPortParams.uiInputFciId),
                                BRAP_INVALID_VALUE,
                                false);

                        if(ret != BERR_SUCCESS)
                        {
                            ret = BERR_TRACE(ret);
                            goto stop_capport;
                        }         
                        break;

                    default:
                        sCapPortParams.eInputBitsPerSample = hRap->sInputSettings[hCapPort->eCapPort].eInputBitsPerSample;                        
                        sCapPortParams.eSamplingRate = hRap->sInputSettings[hCapPort->eCapPort].eSampleRate;                        
                        /* Other capture ports need not be considered here*/
                        break;
                }
                
                /* The below values might have to be derived instead of hardcoding 
                later using the Fs Timing, SRC and PLL logic */
                sCapPortParams.ePll = BRAP_OP_Pll_ePll0;
                sCapPortParams.uiFsTmgSrc = 0;
                /* Start the Capture port */
                ret = BRAP_CAPPORT_P_Start(hCapPort, &sCapPortParams);
                if (ret != BERR_SUCCESS)
                {
                    ret = BERR_TRACE(ret);
                    goto stop_capport;
                }
                BDBG_MSG(("Capture port %d Started",hCapPort->eCapPort));

                
            }
        }/* for eChPair */
    }/* for uiPp */
#endif

    if(BERR_SUCCESS == ret)
        goto end_fmm_start;
#if (BRAP_7550_FAMILY !=1)            
stop_capport:
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            hCapPort = pPath->sCapPort[eChPair][uiPp].hCapPort;
            if(hCapPort != NULL)
            {
                ret1 = BRAP_CAPPORT_P_Stop(hCapPort);
                if(ret1 != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_P_StartOpPathFmmModules: BRAP_CAPPORT_P_Stop()"
                        " failed!!! Ignoring error!!! "));
                    ret1 = BERR_TRACE(ret1);
                }
			    BDBG_MSG(("Capture Port %d stopped", hCapPort->eCapPort));
            }
        }
    }

stop_dstch:
    for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        hDstCh = pPath->sDstCh[eChPair].hDstCh;
        if(hDstCh != NULL)
        {
            ret1 = BRAP_DSTCH_P_Stop(hDstCh);
		    if(ret1 != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_P_StartOpPathFmmModules: BRAP_DSTCH_P_Stop()"
                    " failed!!! Ignoring error!!! "));
                ret1 = BERR_TRACE(ret1);
            }
			BDBG_MSG(("Destination Channel %d stopped", hDstCh->uiIndex));        
        }
    }
#endif
stop_srcch:
	ui32RegMask=0x0;
    for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        hSrcCh = pPath->sSrcCh[eChPair].hSrcCh;
        if(hSrcCh != NULL)
        {
            ret1 = BRAP_SRCCH_P_Stop(hSrcCh);
		    if(ret1 != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_P_StartOpPathFmmModules: BRAP_SRCCH_P_Stop()"
                    " failed!!! Ignoring error!!! "));
                ret1 = BERR_TRACE(ret1);
            }
			BDBG_MSG(("Source Channel %d stopped", hSrcCh->uiIndex));        

			/*[Gautam] TODO: Mask should be formed for this stop sequence only 
			when its start count has reached to zero */
			
			ui32RegMask |= (1 << hSrcCh->uiIndex);
        }
    }

	/*
	BF Limitation in the FMM Arch:
	When the channel group is disabled with both runs and enables are set to 0, it 
	is required either to read the grouped enable status and wait till the status 
	for all the grouped enables are zero before the SRC can be disabled or the
	channel group is disabled
	*/
	uiTimeOutCtr = BRAP_P_STOP_TIMEOUT_COUNTER;
	do
	{
		if(BRAP_P_STOP_TIMEOUT_COUNTER != uiTimeOutCtr)
		{
			BKNI_Sleep(1);
		}	
		ui32RegVal = BRAP_Read32(hRapCh->hRegister,BCHP_AUD_FMM_BF_CTRL_SOURCECH_GROUP_ENABLE);		
		ui32RegVal = BCHP_GET_FIELD_DATA(ui32RegVal, AUD_FMM_BF_CTRL_SOURCECH_GROUP_ENABLE, STATUS);		
		ui32RegVal &= ui32RegMask;
		uiTimeOutCtr--;	
	}while((0!=ui32RegVal) && (0!=uiTimeOutCtr));

	if(0!=ui32RegVal)
	{
		BDBG_WRN(("AUD_FMM_BF_CTRL_SOURCECH_GROUP_ENABLE_STATUS=%#x is not disabled. [Time out]",ui32RegVal));
	}

stop_rbuf:
    for(uiCh = 0; uiCh < BRAP_RM_P_MAX_OP_CHANNELS; uiCh++)
    {
        hRBuf = pPath->hRBuf[uiCh];
        if(hRBuf != NULL)
        {
            ret1 = BRAP_RBUF_P_Stop(hRBuf);
		    if(ret1 != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_P_StartFmmModules: BRAP_RBUF_P_Stop()"
                    " failed!!! Ignoring error!!! "));
                ret1 = BERR_TRACE(ret1);
            }
			BDBG_MSG(("Ring buffer %d stopped", hRBuf->uiIndex));
		}
    }    
    
stop_src_mixer:
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {
            for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
            {

#if (BRAP_7550_FAMILY != 1)
                for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
                {
                    hSrc = pPath->sSrc[uiLvl][eChPair][uiPp].hSrc[uiCsc];
                    if(hSrc != NULL)
                    {
                        ret1 = BRAP_SRC_P_Stop(hSrc);
            		    if(ret1 != BERR_SUCCESS)
                        {
                            BDBG_ERR(("BRAP_P_StartFmmModules: BRAP_SRC_P_Stop()"
                                " failed!!! Ignoring error!!! "));
                            ret1 = BERR_TRACE(ret1);
                        }
            			BDBG_MSG(("SRC %d in SRC Block %d stopped", 
                            hSrc->uiIndex, hSrc->uiBlkId));
                    }
                }
#endif
                hMixer = pPath->sMixer[uiLvl][eChPair][uiPp].hMixer;
                if(hMixer != NULL)
                {
                    for(i = 0; i <BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
                    {
                        uiMixInId = pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].sMixerGrant[eChPair][uiPp].uiMixerInputId[i];

                        if(hMixer->eInputState[uiMixInId] != BRAP_P_State_eStarted)
                            continue;
                                            
                        ret1 = BRAP_MIXER_P_Stop(hMixer, uiMixInId);
            		    if(ret1 != BERR_SUCCESS)
                        {
                            BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_MIXER_P_Stop()"
                                " failed for input %d!!! Ignoring error!!! ",uiMixInId));
                            ret1 = BERR_TRACE(ret);
                        }
        	            BDBG_MSG(("Mixer %d MixerIn %d in DP Blk %d stopped", 
        			            hMixer->uiMixerIndex, hMixer->uiDpIndex));                        
                    }
                }
            
            }
        }
    }
#if BRAP_P_EQUALIZER
stop_srceq:    
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
            {
                hSrc = pPath->sSrcEq[eChPair][uiPp].hSrcEq[uiCsc];
                if(hSrc != NULL)
                {
                    ret1 = BRAP_SRC_P_Stop(hSrc);
        		    if(ret1 != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_P_StartFmmModules: BRAP_SRC_P_Stop() for EQ"
                            " failed!!! Ignoring error!!! "));
                        ret1 = BERR_TRACE(ret1);
                    }
        			BDBG_MSG(("SRC %d in SRC Block %d stopped for Equalizer", 
                        hSrc->uiIndex, hSrc->uiBlkId));
                }
            }    
        }
    }
#endif
    
stop_op:
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; 
                         eChPair++, hOp = NULL, pOpParams = NULL)
        {
            hOp = pPath->sOp[eChPair][uiPp].hOp;
            if(hOp != NULL)
            {
                ret1 = BRAP_OP_P_Stop(hOp);
                if(ret1 != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_P_StartFmmModules: BRAP_OP_P_Stop()"
                        " failed!!! Ignoring error!!! "));
                    ret1 = BERR_TRACE(ret1);
                }
		        BDBG_MSG(("Output port type %d stopped", hOp->eOutputPort));

                hSpdifFm = pPath->sOp[eChPair][uiPp].hSpdifFm;
                if(hSpdifFm != NULL)
                {
                    ret1 = BRAP_SPDIFFM_P_Stop(hSpdifFm);
                    if(ret1 != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_P_StartFmmModules: BRAP_SPDIFFM_P_Stop()"
                            " failed!!! Ignoring error!!! "));
                        ret1 = BERR_TRACE(ret1);
                    }
            		BDBG_MSG(("Spdiffm %d - stream %d stopped", 
				        hSpdifFm->uiIndex, hSpdifFm->uiStreamIndex)); 
                }
            }
            /* Special handling for Mai tapping data from another Output Port */
            if(pPath->sOp[eChPair][uiPp].hMaiOp != NULL)
            {
                ret1 = BRAP_OP_P_Stop(pPath->sOp[eChPair][uiPp].hMaiOp);
                if(ret1 != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_P_StartFmmModules: BRAP_OP_P_Stop()"
                        " failed!!! Ignoring error!!! "));
                    ret1 = BERR_TRACE(ret1);
                }
		        BDBG_MSG(("Output port type %d stopped", pPath->sOp[eChPair][uiPp].hMaiOp->eOutputPort));
            }/* hMaiOp */
        }/* for eChPair */
    }/* for uiPp */
    
end_fmm_start:    
    BDBG_MSG(("Leaving BRAP_P_StartFmmModuleHandles"));
    BDBG_LEAVE(BRAP_P_StartFmmModuleHandles);
    return ret;
}

/**************************************************************************
Summary:
    Private function that stops FMM module handles for a particular path.
**************************************************************************/
BERR_Code BRAP_P_StopFmmModuleHandles(
    BRAP_ChannelHandle          hRapCh,         /* [in] Channel Handle */
    unsigned int                uiPth           /* [in] Path id */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_P_ObjectHandles    *pPath = NULL;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    unsigned int            uiLvl = BRAP_INVALID_VALUE;
    unsigned int            uiPp = BRAP_INVALID_VALUE;
#if (BRAP_7550_FAMILY != 1)
    unsigned int            uiCsc = BRAP_INVALID_VALUE; 
    BRAP_SRC_P_Handle       hSrc = NULL;
    BRAP_CAPPORT_P_Handle hCapPort = NULL;
    BRAP_DSTCH_P_Handle	hDstCh = NULL;    
#endif
    void                    *pOpParams = NULL;
    BRAP_Handle             hRap = NULL;
    BRAP_OP_P_Handle        hOp = NULL;
    BRAP_SPDIFFM_P_Handle   hSpdifFm = NULL;
    BRAP_RBUF_P_Handle      hRBuf = NULL;
    unsigned int            uiCh = BRAP_INVALID_VALUE;
    BRAP_SRCCH_P_Handle     hSrcCh = NULL;
    BRAP_MIXER_P_Handle     hMixer = NULL;
    unsigned int            i = 0;
    unsigned int            uiMixIp=0;
	uint32_t				ui32RegVal = 0;
	uint32_t				uiTimeOutCtr=0;
	uint32_t				ui32RegMask = 0;
#if (BRAP_3548_FAMILY != 1)    
   unsigned int uiNumSrcInGrp=0;
#endif
    BDBG_ENTER(BRAP_P_StopFmmModuleHandles);

    /* Check params */
    BDBG_ASSERT(hRapCh);

    if(uiPth >= BRAP_P_MAX_PATHS_IN_A_CHAN)
    {
        BDBG_ERR(("uiPth = %d  can't be greater  or equal to than BRAP_P_MAX_PATHS_IN_A_CHAN = %d",uiPth,BRAP_P_MAX_PATHS_IN_A_CHAN));
        BDBG_ASSERT(0);
        return BERR_TRACE(BERR_INVALID_PARAMETER);
    }

    BDBG_ASSERT(hRapCh->pPath[uiPth]);

    hRap = hRapCh->hRap;
    pPath = hRapCh->pPath[uiPth];

    /* stop_srcch: */
	ui32RegMask=0x0;

    ret = BRAP_P_ResetAdaptRateCtrl(hRapCh,uiPth);
    if(ret != BERR_SUCCESS)
    {
        BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_P_ResetAdaptRateCtrl()"
            " failed!!! Ignoring error!!! "));
        ret = BERR_TRACE(ret);
    }
    
#if (BRAP_3548_FAMILY != 1)
    for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        hSrcCh = pPath->sSrcCh[eChPair].hSrcCh;
        if(hSrcCh != NULL)
        {	
		ui32RegMask |= (1 << hSrcCh->uiIndex);
               uiNumSrcInGrp++;
        }
    }
    BDBG_MSG(("ui32RegMask = %d , uiNumSrcInGrp =%d",ui32RegMask,uiNumSrcInGrp));
    if(uiNumSrcInGrp == 1)
    {
        /*Stop Src_Mixer*/
        for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)    
        {
            for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
            {
                for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
                {
#if (BRAP_7550_FAMILY != 1)
                    for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
                    {
                        hSrc = pPath->sSrc[uiLvl][eChPair][uiPp].hSrc[uiCsc];
                        if(hSrc != NULL)
                        {
                            ret = BRAP_SRC_P_Stop(hSrc);
                		    if(ret != BERR_SUCCESS)
                            {
                                BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_SRC_P_Stop()"
                                    " failed!!! Ignoring error!!! "));
                                ret = BERR_TRACE(ret);
                            }
                			BDBG_MSG(("SRC %d in SRC Block %d stopped", 
                                hSrc->uiIndex, hSrc->uiBlkId));
                        }
                    }/* for uiCsc */
#endif     
                    hMixer = pPath->sMixer[uiLvl][eChPair][uiPp].hMixer;
                    if(hMixer != NULL)
                    {
                        for(i = 0; i <BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
                        {
                            uiMixIp = pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].sMixerGrant[eChPair][uiPp].uiMixerInputId[i];
                            if (BRAP_RM_P_INVALID_INDEX != uiMixIp)
                            {
                                ret = BRAP_MIXER_P_Stop(hMixer, uiMixIp);
                    		    if(ret != BERR_SUCCESS)
                                {
                                    BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_MIXER_P_Stop()"
                                        " failed for input %d!!! Ignoring error!!! ",uiMixIp));
                                    ret = BERR_TRACE(ret);
                                }
                	            BDBG_MSG(("Mixer %d MixerIn %d in DP Blk %d stopped", 
                			            hMixer->uiMixerIndex, uiMixIp,hMixer->uiDpIndex));
                            }
                        }
                    }
                }/* for eChPair */
            }/* for uiPp */
        }

/*Set GROUP_SYNC_DIS=1 for the channel(s) being shutdown*/
       BRAP_Write32(hRapCh->hRegister, BCHP_AUD_FMM_BF_CTRL_SOURCECH_GROUP_SYNC_DIS, ui32RegMask);        

    }
#endif
    
    for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        hSrcCh = pPath->sSrcCh[eChPair].hSrcCh;
        if(hSrcCh != NULL)
        {
            ret = BRAP_SRCCH_P_Stop(hSrcCh);
		    if(ret != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_SRCCH_P_Stop()"
                    " failed!!! Ignoring error!!! "));
                ret = BERR_TRACE(ret);
            }
			BDBG_MSG(("Source Channel %d stopped", hSrcCh->uiIndex));        
#if (BRAP_3548_FAMILY == 1)            
			ui32RegMask |= (1 << hSrcCh->uiIndex);
#endif            
        }
    }



	/*
	BF Limitation in the FMM Arch:
	When the channel group is disabled with both runs and enables are set to 0, it 
	is required either to read the grouped enable status and wait till the status 
	for all the grouped enables are zero before the SRC can be disabled or the
	channel group is disabled
	*/
	uiTimeOutCtr = BRAP_P_STOP_TIMEOUT_COUNTER;
	do
	{
		if(BRAP_P_STOP_TIMEOUT_COUNTER != uiTimeOutCtr)
		{
			BKNI_Sleep(1);
		}
		ui32RegVal = BRAP_Read32(hRapCh->hRegister,BCHP_AUD_FMM_BF_CTRL_SOURCECH_GROUP_ENABLE);
		ui32RegVal = BCHP_GET_FIELD_DATA(ui32RegVal, AUD_FMM_BF_CTRL_SOURCECH_GROUP_ENABLE, STATUS);
		ui32RegVal &= ui32RegMask;
		uiTimeOutCtr--;		
	}while((0!=ui32RegVal) && (0!=uiTimeOutCtr));

	if(0!=ui32RegVal)
	{
		BDBG_ERR(("AUD_FMM_BF_CTRL_SOURCECH_GROUP_ENABLE_STATUS=%#x is not disabled. [Time out]",ui32RegVal));
	}
#if (BRAP_3548_FAMILY != 1)
    if(uiNumSrcInGrp == 1)
    {
/*Set GROUP_SYNC_DIS=0 for the channel(s) being shutdown*/
        ui32RegVal = BRAP_Read32(hRapCh->hRegister, BCHP_AUD_FMM_BF_CTRL_SOURCECH_GROUP_SYNC_DIS );
        ui32RegVal ^= ui32RegMask;
        
        BRAP_Write32(hRapCh->hRegister, BCHP_AUD_FMM_BF_CTRL_SOURCECH_GROUP_SYNC_DIS, ui32RegMask);        
	}
#endif
    /* stop_rbuf: */
    for(uiCh = 0; uiCh < BRAP_RM_P_MAX_OP_CHANNELS; uiCh++)
    {
        hRBuf = pPath->hRBuf[uiCh];
        if(hRBuf != NULL)
        {
            ret = BRAP_RBUF_P_Stop(hRBuf);
		    if(ret != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_RBUF_P_Stop()"
                    " failed!!! Ignoring error!!! "));
                ret = BERR_TRACE(ret);
            }
			BDBG_MSG(("Ring buffer %d stopped", hRBuf->uiIndex));
		}
    }/* for uiCh */    
#if (BRAP_3548_FAMILY != 1)
    if(uiNumSrcInGrp > 1)
#endif        
    {
    /* stop_src_mixer: */
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {
            for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
            {
#if (BRAP_7550_FAMILY != 1)
                for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
                {
                    hSrc = pPath->sSrc[uiLvl][eChPair][uiPp].hSrc[uiCsc];
                    if(hSrc != NULL)
                    {
                        ret = BRAP_SRC_P_Stop(hSrc);
            		    if(ret != BERR_SUCCESS)
                        {
                            BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_SRC_P_Stop()"
                                " failed!!! Ignoring error!!! "));
                            ret = BERR_TRACE(ret);
                        }
            			BDBG_MSG(("SRC %d in SRC Block %d stopped", 
                            hSrc->uiIndex, hSrc->uiBlkId));
                    }
                }/* for uiCsc */
 #endif
                hMixer = pPath->sMixer[uiLvl][eChPair][uiPp].hMixer;
                if(hMixer != NULL)
                {
                    for(i = 0; i <BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
                    {
                        uiMixIp = pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].sMixerGrant[eChPair][uiPp].uiMixerInputId[i];
                        if (BRAP_RM_P_INVALID_INDEX != uiMixIp)
                        {
                            ret = BRAP_MIXER_P_Stop(hMixer, uiMixIp);
                		    if(ret != BERR_SUCCESS)
                            {
                                BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_MIXER_P_Stop()"
                                    " failed for input %d!!! Ignoring error!!! ",uiMixIp));
                                ret = BERR_TRACE(ret);
                            }
            	            BDBG_MSG(("Mixer %d MixerIn %d in DP Blk %d stopped", 
            			            hMixer->uiMixerIndex, uiMixIp,hMixer->uiDpIndex));
                        }
                    }
                }
            }/* for eChPair */
        }/* for uiPp */
    }/* for uiLvl */
    }
#if BRAP_P_EQUALIZER
    /* stop_src_eq: */
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
            {
                hSrc = pPath->sSrcEq[eChPair][uiPp].hSrcEq[uiCsc];
                if(hSrc != NULL)
                {
                    BRAP_OutputChannelPair  eOpChPair = BRAP_OutputChannelPair_eMax;
                    unsigned int            uiOpPp = BRAP_INVALID_VALUE;
                    BRAP_P_DstDetails       *pPvtDstDetails;
                    unsigned int            uiAssocId = 0, j=0, k=0, l=0;
                    bool                    bSrcCoeffWasCopied = false;

                    pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
                    if ( NULL==pPvtDstDetails )
                    {
                        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
                        goto end;                
                    }
                    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));                      

                    /* Get the output port information from Out Link of SRC-EQ */
                    eOpChPair = pPath->sSrcEq[eChPair][uiPp].sSrcEqOutLink[0].eChnPair;
                    uiOpPp = pPath->sSrcEq[eChPair][uiPp].sSrcEqOutLink[0].uiPrlPth;

                    /* Find if coefficient address was not allocated for this SRC 
                       but was copied as it was already allocated and had to be shared.
                    */
                    for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
                    {
                        if(NULL == hRapCh->pDstDetails[i])
                            continue;
                        
                        /* hEqualizer is present in Private structure. Get it */
                        ret = BRAP_P_GetPvtDstDetails(hRapCh,hRapCh->pDstDetails[i],pPvtDstDetails,&uiAssocId);
                        if(BERR_SUCCESS!=ret)
                        {
                            continue;
                        }

                        if( (pPvtDstDetails->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                            (pPath->sOp[eOpChPair][uiOpPp].hOp != NULL) &&                             
                            (pPvtDstDetails->sExtDstDetails.uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR]
                                == pPath->sOp[eOpChPair][uiOpPp].hOp->eOutputPort)
                          )
                        {
                            if (pPvtDstDetails->hEqualizer != NULL)
                            {
                                /* Coeff address allocation was done only for the first
                                   SrcEq that was started, for rest all it was copied.
                                   Deallocation need to happen only for that SrcEq, 
                                   which gets stopped at the last */

                                for(j=0; j<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; j++)
                                {
                                    for(k=0; k<BRAP_RM_P_MAX_PARALLEL_PATHS; k++)
                                    {
                                        for(l=0; l<BRAP_P_MAX_PATHS_IN_A_CHAN; l++)
                                        {             
                                            if((NULL != pPvtDstDetails->hEqualizer->hSrcEq[uiCsc][j][k][l]) &&
                                               (BRAP_P_State_eStarted == pPvtDstDetails->hEqualizer->
                                                   hSrcEq[uiCsc][j][k][l]->eState))
                                            {
                                                if(hSrc != pPvtDstDetails->hEqualizer->hSrcEq[uiCsc][j][k][l])
                                {
                                    hSrc->uiCoeffAddr = BRAP_INVALID_VALUE;  
                                                    bSrcCoeffWasCopied = true;
                                    BDBG_MSG(("SRCEQ_Stop: Invalidating the copied Coefficient Address."
                                        "Index = %d, Block =%d", hSrc->uiIndex, hSrc->uiBlkId));
                                                    break;                                                    
                                                }
                                            }
                                        }
                                        if(true == bSrcCoeffWasCopied)
                                            break;
                                    }
                                    if(true == bSrcCoeffWasCopied)
                                        break;                            
                                }
                            }
                            break;
                        }
                    }
                    
                    ret = BRAP_SRC_P_Stop(hSrc);
        		    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_SRC_P_Stop() for Equalizer"
                            " failed!!! Ignoring error!!! "));
                        ret = BERR_TRACE(ret);
                    }
        			BDBG_MSG(("SRC %d in SRC Block %d stopped for Equalizer", 
                        hSrc->uiIndex, hSrc->uiBlkId));
                }
            }/* for uiCsc */
        }
    }
#endif    

#if (BRAP_7550_FAMILY != 1)
    /* stop_cap_port: */
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            hCapPort = pPath->sCapPort[eChPair][uiPp].hCapPort;
            if(hCapPort != NULL)
            {
                ret = BRAP_CAPPORT_P_Stop(hCapPort);
                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_CAPPORT_P_Stop()"
                        " failed!!! Ignoring error!!! "));
                    ret = BERR_TRACE(ret);
                }
			    BDBG_MSG(("Capture Port %d stopped", hCapPort->eCapPort));
            }
        }
    }

    for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        hDstCh = pPath->sDstCh[eChPair].hDstCh;
        if(hDstCh != NULL)
        {
            ret = BRAP_DSTCH_P_Stop(hDstCh);
		    if(ret != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_DSTCH_P_Stop()"
                    " failed!!! Ignoring error!!! "));
                ret = BERR_TRACE(ret);
            }         
			BDBG_MSG(("Destination Channel %d stopped", hDstCh->uiIndex));        
        }
    }
#endif

    /* stop_op: */
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; 
                         eChPair++, hOp = NULL, pOpParams = NULL)
        {
            hOp = pPath->sOp[eChPair][uiPp].hOp;
            if(hOp != NULL)
            {
                ret = BRAP_OP_P_Stop(hOp);
                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_OP_P_Stop()"
                        " failed!!! Ignoring error!!! "));
                    ret = BERR_TRACE(ret);
                }
		        BDBG_MSG(("Output port type %d stopped", hOp->eOutputPort));


                /* Special handling for hMaiOp tapping data from another Op */
                if(pPath->sOp[eChPair][uiPp].hMaiOp != NULL)
                {
                    ret = BRAP_OP_P_Stop(pPath->sOp[eChPair][uiPp].hMaiOp);
                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_OP_P_Stop()"
                            " failed!!! Ignoring error!!! "));
                        ret = BERR_TRACE(ret);
                    }
    		        BDBG_MSG(("Output port type %d stopped", 
                        pPath->sOp[eChPair][uiPp].hMaiOp->eOutputPort));
                }

                hSpdifFm = pPath->sOp[eChPair][uiPp].hSpdifFm;
                if(hSpdifFm != NULL)
                {
                    BRAP_SPDIFFM_P_Stop(hSpdifFm);
                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_SPDIFFM_P_Stop()"
                            " failed!!! Ignoring error!!! "));
                        ret = BERR_TRACE(ret);
                    }
            		BDBG_MSG(("Spdiffm %d - stream %d stopped", 
				        hSpdifFm->uiIndex, hSpdifFm->uiStreamIndex)); 
                }
            }
        }
    }
#if BRAP_P_EQUALIZER
end:
#endif
    BDBG_LEAVE(BRAP_P_StopFmmModuleHandles);
    return ret;
}

/**************************************************************************
Summary:
    Private function that links various FMM module handles as required for  
    a particular path.
**************************************************************************/    
BERR_Code BRAP_P_LinkFmmModuleHandles(
    BRAP_ChannelHandle      hRapCh,     /* [in] Channel Handle */
    unsigned int            uiPth       /* [in] Path id */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    BRAP_OutputChannelPair  ePrivChP = BRAP_OutputChannelPair_eMax;    
    unsigned int            uiLvl = BRAP_INVALID_VALUE;
    unsigned int            uiPp = BRAP_INVALID_VALUE;
    unsigned int            uiPrivPp = BRAP_INVALID_VALUE;
    BRAP_P_ObjectHandles    *pPath = NULL;
    BRAP_P_SrcChHandleInfo  *pSrcCh = NULL;
#if (BRAP_7550_FAMILY != 1)
    BRAP_P_DstChHandleInfo  *pDstCh = NULL;
    BRAP_P_SrcHandleInfo    *pSrc = NULL, *pPrivSrc=NULL;
    bool    bFound =false;
    BRAP_P_CapPortHandleInfo *pCap = NULL; 
    unsigned int            i = 0;    
#endif
    BRAP_P_MixerHandleInfo  *pMixer = NULL, *pPrivMixer = NULL;
    BRAP_RM_P_MixerGrant    *pMixerGrant = NULL;
    unsigned int            j=0, n = 0;
#if BRAP_P_EQUALIZER
    BRAP_P_SrcEqHandleInfo  *pSrcEq = NULL;
#endif
    BRAP_OutputPortDetails  *pOpDetails = NULL;
    BRAP_P_OpHandleInfo     *pOp = NULL;
    unsigned int uiPPStart = 0;

#if (BRAP_INDEP_OP_DELAY_SUPPORTED ==1)
    bool bMulPPEnabled = false;
#endif
        
    /* Check params */
    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(hRapCh->pPath[uiPth]);

#if (BRAP_INDEP_OP_DELAY_SUPPORTED ==1)
    /* Find if MulPP is added */
    bMulPPEnabled = false;
/*    for(i=0;i<BRAP_P_MAX_PATHS_IN_A_CHAN;i++)
    {
        if(NULL == hRapCh->pPath[i])
            break;
        if(hRapCh->pPath[i]->uiPPBranchId > 0)
        {
            bMulPPEnabled = true;
            break;
        }
    }*/
#endif

    pPath = hRapCh->pPath[uiPth];

    BDBG_ENTER(BRAP_P_LinkFmmModuleHandles);

    /* Link info for the source channels:
        ------------------------------------------------------------------------
        sSrcCh[ch] 		Resource    Level     ChPair    ParallelPath
        ----------      --------    -----     ------    ------------
        sSrcChInLink	Rbuf	    NA	        0-3	        NA
        sSrcChSelfLink	SrcCh	    NA	        0-3	        NA
        sSrcChOutLink	Src	        0           0-3	        NA 
        				Mixer		0			0-3			NA
        				Output		NA			0-3			NA
        ------------------------------------------------------------------------
    */
    BDBG_MSG(("Linking SrcCh"));
    for(eChPair=0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        if(pPath->sSrcCh[eChPair].hSrcCh != NULL)
        {
            BDBG_MSG(("pPath->sSrcCh[%d].hSrcCh",eChPair));
            pSrcCh = &(pPath->sSrcCh[eChPair]);

            /* Set bValid */
            pSrcCh->bValid = true;
            
            /* Set self link */
            BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChSelfLink, BRAP_P_Rsrc_eSrcCh,
                BRAP_INVALID_VALUE, eChPair, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

            /* Set in link */            
            BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChInLink, BRAP_P_Rsrc_eRBuf, 
                BRAP_INVALID_VALUE, eChPair, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

            /* Outlink will be programmed in the level0 SRC */
        }
    }/* for eChPair */

#if (BRAP_7550_FAMILY != 1)
    /* Link info for the SRCs:
        ------------------------------------------------------------------------
        sSrc[lvl][chp][pp] 		        Resource    Level   ChPair  ParallelPath
        ------------------              --------    -----   ------  ------------
        sSrcInLink	                    SrcCh	    NA	    0-3	    NA
    	                                Mixer 	    Lvl-1	0-3	    Incoming Pp (= mixer output id)
        sSrcSelfLink	                Src	        Lvl	    0-3	    self Pp
        sSrcOutLink[MAX_TO_SAME_SRC]	Mixer	    Lvl	    0-3	    Outgoing Pp
                                                                    to Mixer
                                        CapPort		NA		0-3		Outgoing Pp to CapPort		
        ------------------------------------------------------------------------                                                                    
    */
    BDBG_MSG(("Linking SRCs"));
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {
            for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
            {
                pSrc = &(pPath->sSrc[uiLvl][eChPair][uiPp]);
                if(pSrc->hSrc[0] != NULL)
                {
                    BDBG_MSG(("pPath->sSrc[lvl=%d][chp=%d][pp=%d]",uiLvl,eChPair,uiPp));
                    /* Set bValid */
                    pSrc->bValid = true;
                    
                    /* Set self link */
                    BRAP_P_SET_LINK_INFO(pSrc->sSrcSelfLink,BRAP_P_Rsrc_eSrc,
                        uiLvl, eChPair, uiPp,BRAP_INVALID_VALUE);
#if (BRAP_3548_FAMILY == 1)
                    if ( (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) && 
                         (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort) &&
                         (BRAP_P_UsgPath_eCapture == pPath->eUsgPath) &&
                         (0 == uiPth)
                       )

                    {
                        /* This is the case of ADC */
                        
                        /* Set inlink */
                        BRAP_P_SET_LINK_INFO(pSrc->sSrcInLink, BRAP_P_Rsrc_eCapPort,
                            BRAP_INVALID_VALUE, eChPair+i, 0,BRAP_INVALID_VALUE);
                        
                    }
                    else
#endif
                    {
                        /* Decide the inlink details */
                        if(0 == uiLvl)
                        {
                            /* Level-0, inlink resource is SrcCh */
                            /* Set inlink */
                            BRAP_P_SET_LINK_INFO(pSrc->sSrcInLink, BRAP_P_Rsrc_eSrcCh,
                                BRAP_INVALID_VALUE, eChPair, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

                            /* Set outlink of SrcCh */
                            pSrcCh = &(pPath->sSrcCh[eChPair]);
                            BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChOutLink, BRAP_P_Rsrc_eSrc,
                                uiLvl, eChPair, uiPp,BRAP_INVALID_VALUE);
                        }
                        else
                        {
                            /* Other than Level-0, inlink resource is Mixer */
                            for(uiPrivPp=0; uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPrivPp++)
                            {
                                if((pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl-1].
                                    sMixerGrant[eChPair][uiPrivPp].uiMixerId != 
                                    BRAP_RM_P_INVALID_INDEX) &&
                                   (pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl-1].
                                    sMixerGrant[eChPair][uiPrivPp].uiDpId != 
                                    BRAP_RM_P_INVALID_INDEX))
                                {
                                    /* Got the previous mixer's self location */
                                    break;
                                }
                            }
                            if(uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS)
                            {
                                /* Set outlink of privious level Mixer */
                                pMixer = &(pPath->sMixer[uiLvl-1][eChPair][uiPp]);
                                /* Only output 2 of previous mixer can feed to next level SRC
                                   check if previous mixer's 2nd output is free */
                                if(BRAP_P_Rsrc_eMax != pMixer->sMixerOutLink[1].eRsrcType)
                                {
                                    BDBG_ERR(("BRAP_P_LinkFmmModuleHandles: Can't find"
                                        " free previous mixer outlink"));
                                    return BERR_TRACE(BRAP_ERR_DEVICE_UNINTIALIZED);
                                }
                                BRAP_P_SET_LINK_INFO(pMixer->sMixerOutLink[1], BRAP_P_Rsrc_eSrc,
                                    uiLvl, eChPair, uiPp,BRAP_INVALID_VALUE);

                                /* Set inlink */
                                BRAP_P_SET_LINK_INFO(pSrc->sSrcInLink, BRAP_P_Rsrc_eMixer,
                                    uiLvl-1, eChPair, uiPrivPp,1);


                            }
                        }
                    }

                    /* Outlink will be programmed in the next level mixer */
                    
                }/* if hSrc != NULL */                    
            }/* for eChPair */
        }/* for uiPp */
    }/* for uiLvl */
#endif

    /* Link info for the Mixers:
        ------------------------------------------------------------------------
        sMixer[lvl][chp][pp]            Resource    Level   ChPair  ParallelPath
        --------------------            --------    -----   ------  ------------
        sMixerInLink[MAX_MIXER_INPUTS]	Src	        Lvl	    0-3	    Incoming Pp
	                                    Mixer	    Lvl-1	0-3	    Incoming Pp
	                                    SrcCh		NA		0-3		NA
        sMixerSelfLink	                Mixer	    Lvl	    0-3	    Incoming Pp
        sMixerOutLink[MAX_MIXER_OUTPUTS]Src	        Lvl+1	0-3	    Outgoing Pp
                                                                    to SRC
	                                    Mixer	    Lvl+1	0-3	    Outgoing Pp
	                                                                to Mixer
	                                    Op/Cap      NA      0-3     Outgoing Pp
                                                	                to Op/Cap
        ------------------------------------------------------------------------                                                	                
    */
    BDBG_MSG(("Linking Mixers"));
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {
            for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
            {
                pMixer = &(pPath->sMixer[uiLvl][eChPair][uiPp]);
                if(pMixer->hMixer != NULL)
                {
                    BDBG_MSG(("pPath->sMixer[lvl=%d][chp=%d][pp=%d]",uiLvl,eChPair,uiPp));
                    BDBG_MSG(("Aud Mode In(%d, %d) Out(%d, %d)",
                        pPath->sMixingLevels[uiLvl].eInputAudMode,
                        pPath->sMixingLevels[uiLvl].bInputLfeOn,
                        pPath->sMixingLevels[uiLvl].eOutputAudMode,
                        pPath->sMixingLevels[uiLvl].bOutputLfeOn));

                    /* Set bValid */
                    pMixer->bValid = true;
                    
                    /* Set self link */
                    BRAP_P_SET_LINK_INFO(pMixer->sMixerSelfLink, 
                        BRAP_P_Rsrc_eMixer, uiLvl, eChPair, uiPp,BRAP_INVALID_VALUE);

                    /* For each mixer input set the in link */
                    pMixerGrant = &(pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].
                                sMixerGrant[eChPair][uiPp]);
                    for(ePrivChP=0; ePrivChP < BRAP_OutputChannelPair_eMax; ePrivChP++)
                    {
                        if(pMixerGrant->uiMixerInputId[ePrivChP] != 
                                BRAP_RM_P_INVALID_INDEX)
                        {
                            BDBG_MSG(("Valid MixInput %d at ePrivChP = %d", 
                                pMixerGrant->uiMixerInputId[ePrivChP], 
                                ePrivChP));
                            
                            /* Check if SRC in the same level is an input to 
                               this mixer */

                            for(uiPrivPp=0; uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPrivPp++)
                            {
                                if((pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].
                                    sSrcGrant[0][ePrivChP][uiPrivPp].uiSrcId != 
                                        BRAP_RM_P_INVALID_INDEX) &&
                                   (pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].
                                    sSrcGrant[0][ePrivChP][uiPrivPp].uiSrcBlkId != 
                                        BRAP_RM_P_INVALID_INDEX))
                                {
                                    BDBG_MSG(("Valid SRC Id=%d Blk=%d at ePrivChP=%d ePrivPp = %d", 
                                        pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].sSrcGrant[0][ePrivChP][uiPrivPp].uiSrcId, 
                                        pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].sSrcGrant[0][ePrivChP][uiPrivPp].uiSrcBlkId, 
                                        ePrivChP,uiPrivPp));

#if (BRAP_7550_FAMILY != 1)
                                    /* Got the previous SRC's self location */
                                    /* Set Inlink of the Mixer */
                                    BRAP_P_SET_LINK_INFO(
                                        pMixer->sMixerInLink[pMixerGrant->uiMixerInputId[ePrivChP]],
                                        BRAP_P_Rsrc_eSrc, uiLvl, 
                                        ePrivChP, uiPrivPp,BRAP_INVALID_VALUE);

                                    /* Get input SRC */
                                    pSrc = &(pPath->sSrc[uiLvl][ePrivChP][uiPrivPp]);
                                    for(i=0; i< BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
                                    {         
                                        if(BRAP_P_Rsrc_eMax == pSrc->sSrcOutLink[i].eRsrcType)
                                        {
                                            break;
                                        }
                                    }
                                    if(i >= BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC)
                                    {
                                        BDBG_ERR(("BRAP_P_LinkFmmModuleHandles: Can't find"
                                            " previous SRC"));
                                        return BERR_TRACE(BRAP_ERR_DEVICE_UNINTIALIZED);
                                    }
                                    
                                    /* Set outlink of input SRC */                                    
                                    BRAP_P_SET_LINK_INFO(pSrc->sSrcOutLink[i], 
                                    BRAP_P_Rsrc_eMixer, uiLvl, eChPair,uiPp,BRAP_INVALID_VALUE);

                                    /* Inlink to mixer and outlink of SRC set */                                    
#else /* For 7550 family only */
                                    /* Got the previous SRCCH's self location */
                                    /* Set Inlink of the Mixer */
                                    BRAP_P_SET_LINK_INFO(
                                        pMixer->sMixerInLink[pMixerGrant->uiMixerInputId[ePrivChP]],
                                        BRAP_P_Rsrc_eSrcCh, uiLvl, 
                                        ePrivChP, uiPrivPp,BRAP_INVALID_VALUE);

                                    /* Set outlink of SrcCh */
                                    pSrcCh = &(pPath->sSrcCh[eChPair]);
                                    BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChOutLink, 
                                    BRAP_P_Rsrc_eMixer, uiLvl, eChPair,uiPp,BRAP_INVALID_VALUE);
                                    
                                    /* Inlink to mixer and outlink of SRCCH set */
#endif                                    
                                    break;
                                }
                            }/* for uiPrivPp */
                            
                            if(uiPrivPp >= BRAP_RM_P_MAX_PARALLEL_PATHS)
                            {
							/* If  Level=0 and since no Src of same lvl is 
							feeding this mixer then, SrcCh must be feeding
							this mixer input */

							if(0 == uiLvl && (pPath->sMixingLevels[uiLvl].eInputSR == pPath->sMixingLevels[uiLvl].eOutputSR))
		                    {
		                        /* Level-0, inlink resource is SrcCh */
		                        /* Set inlink */
								BRAP_P_SET_LINK_INFO(
                                        pMixer->sMixerInLink[pMixerGrant->uiMixerInputId[ePrivChP]],
                                        BRAP_P_Rsrc_eSrcCh,BRAP_INVALID_VALUE, 
                                        ePrivChP, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE); /*Check the Last parameter*/

		                        /* Set outlink of SrcCh */
		                        pSrcCh = &(pPath->sSrcCh[eChPair]);
								if(pSrcCh->bValid==true)
								{
		                        	BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChOutLink, BRAP_P_Rsrc_eMixer,
		                            	uiLvl, eChPair, uiPp,BRAP_INVALID_VALUE);
								}
								else
								{
									BDBG_ERR(("Valid SrcCh not available to link with Mixer"));
									return BERR_TRACE(BERR_INVALID_PARAMETER);
								}
								BDBG_MSG(("Linking Mixer to SrcCh"));
		                    }
							else
							{
                                /* If no SRC is an input to this mixer, then 
                                   previous level mixer must be an input to this
                                   mixer */
                                   
                                /* Find previous level mixer feeding to this level 
                                   mixer directly */
#if BRAP_P_CUSTOM_MIXER_REQUIREMENT
                                for(uiPrivPp=uiPp; uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPrivPp++)
#else
                                for(uiPrivPp=0; uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPrivPp++)
#endif
                                {
                                    if((pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl-1].
                                        sMixerGrant[ePrivChP][uiPrivPp].uiMixerId != 
                                            BRAP_RM_P_INVALID_INDEX) &&
                                       (pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl-1].
                                        sMixerGrant[ePrivChP][uiPrivPp].uiDpId != 
                                            BRAP_RM_P_INVALID_INDEX))
                                    {
                                        BDBG_MSG(("Valid Mixer Id=%d Blk=%d at ePrivPp = %d, ePrivChP=%d", 
                                                    pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl-1].sMixerGrant[ePrivChP][uiPrivPp].uiMixerId,
                                                    pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl-1].sMixerGrant[ePrivChP][uiPrivPp].uiDpId,
                                                    uiPrivPp,ePrivChP));
                                        /* Got the previous Mixer's self location */

                                        /* Set outlink of previous level Mixer */ 
                                        pPrivMixer = &(pPath->sMixer[uiLvl-1][ePrivChP][uiPrivPp]);

                                       /* Set Inlink of this level Mixer */
                                        BRAP_P_SET_LINK_INFO(
                                            pMixer->sMixerInLink[pMixerGrant->uiMixerInputId[ePrivChP]],
                                            BRAP_P_Rsrc_eMixer, uiLvl-1, 
                                            ePrivChP, uiPrivPp,1);
                                        
                                        BRAP_P_SET_LINK_INFO(pPrivMixer->sMixerOutLink[1], 
                                            BRAP_P_Rsrc_eMixer, uiLvl, eChPair, uiPp,BRAP_INVALID_VALUE);
                                        /* Inlink to mixer and outlink of SRC set */
                                        break;
                                    }
                                }/* for uiPrivPp */
							}                            
                            }                        
                        }
                    }/* for ePrivChP */
                }                    
            }/* for eChPair */
        }/* for uiPp */
    }/* for uiLvl */



    

    /* Link info for the Outputs:
        ------------------------------------------------------------------------
        sOp[chp][pp]                    Resource    Level   ChPair  ParallelPath
        ------------                    --------    -----   ------  ------------
        sOpInLink	                    Mixer	    Lvl	    0-3	    Incoming Pp
        								SrcCh		NA		0-3		NA		
        sOpSelfLink	                    Op			NA      0-3     self Pp
        ------------------------------------------------------------------------                                                	                
    */
    BDBG_MSG(("Linking OutputPorts"));
    /* Also Linking SRC - Equalizers */ 
    
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        pOpDetails = NULL;
        for(j=0; j < BRAP_RM_P_MAX_PARALLEL_PATHS; j++)          
        {
            if((NULL == pPath->sMixingLevels[uiLvl].pDstDetails[j]) ||
               (pPath->sMixingLevels[uiLvl].pDstDetails[j]->eAudioDst != 
               BRAP_AudioDst_eOutputPort))
            {
                /* There is no OpPort as destination in this level. Goto next */
                continue;        
            }
            else
            {
                BDBG_MSG(("Found DST at pPath->sMixingLevels[uiLvl=%d].pDstDetails[j=%d]",
                    uiLvl,j));
                pOpDetails = 
                &(pPath->sMixingLevels[uiLvl].pDstDetails[j]->uDstDetails.sOpDetails);
            }

            for(eChPair= 0; eChPair < BRAP_OutputChannelPair_eMax; eChPair++)
            {
                if(pOpDetails->eOutput[eChPair] != BRAP_OutputPort_eMax)
                {
#if BRAP_P_CUSTOM_MIXER_REQUIREMENT                
                    for(uiPp = j; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
#else 
                    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
#endif
                    {                    
                        pOp = &(pPath->sOp[eChPair][uiPp]);
                        
                        
                        if((false == pOp->bValid) && (pOp->hOp != NULL) &&
                           (pOp->hOp->eOutputPort == pOpDetails->eOutput[eChPair]))
                        {
                            BDBG_MSG(("uiPp = %d, eChPair = %d", uiPp, eChPair));
#if BRAP_P_EQUALIZER
                            pSrcEq = &(pPath->sSrcEq[eChPair][uiPp]);

                            if (pSrcEq->hSrcEq[0] != NULL)
                            {
                                BDBG_MSG(("OpPort<->SrcEQ: pPath->sSrcEq[chp=%d][pp=%d]",eChPair,uiPp));
                                pSrcEq->bValid = true;

                                BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqSelfLink, 
                                    BRAP_P_Rsrc_eSrcEq, BRAP_RM_P_INVALID_INDEX,
                                    eChPair, uiPp,BRAP_INVALID_VALUE);

                                for(i=0; i< BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
                                {         
                                    if(BRAP_P_Rsrc_eMax == pSrcEq->sSrcEqOutLink[i].eRsrcType)
                                    {
                                        break;
                                    }
                                }
                                if(i >= BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC)
                                {
                                    BDBG_ERR(("BRAP_P_LinkFmmModuleHandles: Can't find"
                                        " previous SRC-EQ"));
                                    return BERR_TRACE(BRAP_ERR_DEVICE_UNINTIALIZED);
                                }                                

                                BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqOutLink[i], 
                                    BRAP_P_Rsrc_eOpPort, BRAP_RM_P_INVALID_INDEX,
                                    eChPair, uiPp,BRAP_INVALID_VALUE);

                                /* Set In Link of OP pointing to this Equalizer */
	                            BRAP_P_SET_LINK_INFO(pOp->sOpInLink, 
	                                BRAP_P_Rsrc_eSrcEq, BRAP_RM_P_INVALID_INDEX, 
	                                eChPair, uiPp, BRAP_INVALID_VALUE);                                
                            }
#endif
                            /* Set bValid */
                            pOp->bValid = true;
                            
                            /* Set self link */
                            BRAP_P_SET_LINK_INFO(pOp->sOpSelfLink, 
                                BRAP_P_Rsrc_eOpPort, BRAP_RM_P_INVALID_INDEX,
                                eChPair, uiPp,BRAP_INVALID_VALUE);

                            if(true == hRapCh->hRap->sSettings.bIndOpVolCtrl)
                            {
                                uiPPStart = uiPp;
                            }
                            else
                            {
                                uiPPStart = 0;
                            }
                            for(uiPrivPp=uiPPStart; uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPrivPp++)
                            {
                                pPrivMixer = &(pPath->sMixer[uiLvl][eChPair][uiPrivPp]);
                                for(n=0; n < BRAP_RM_P_MAX_MIXER_OUTPUTS; n++)
                                {
                                    BDBG_MSG(("n = %d SelfLinkRsrc = %d OutLinkRsrc = %d",
                                        n, pPrivMixer->sMixerSelfLink.eRsrcType,
                                        pPrivMixer->sMixerOutLink[n].eRsrcType));
                                    if((BRAP_P_Rsrc_eMax == 
                                        pPrivMixer->sMixerOutLink[n].eRsrcType) &&
                                       (BRAP_P_Rsrc_eMixer == 
                                        pPrivMixer->sMixerSelfLink.eRsrcType) )
                                    {
                                        /* Got n */
                                        BDBG_MSG(("Got n = %d",n));
                                        break;                            
                                    }
                                }
                                if(n < BRAP_RM_P_MAX_MIXER_OUTPUTS)
                                {
                                    /* Got uiPrivPp */
                                    BDBG_MSG(("Got uiPrivPp = %d",uiPrivPp));
                                    break;
                                }
                            }/* for uiPrivPp */

							if((uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS) && (n < BRAP_RM_P_MAX_MIXER_OUTPUTS))
							{
#if BRAP_P_EQUALIZER
                                if (pSrcEq->hSrcEq[0] != NULL)
                                {
    	                            /* Set In Link of Equalizer pointing to some mixer */
    	                            BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqInLink, 
    	                                BRAP_P_Rsrc_eMixer, uiLvl, eChPair, uiPrivPp, n);

    	                            /* Set outlink of previous Mixer to Equalizer */
    	                            BRAP_P_SET_LINK_INFO(pPrivMixer->sMixerOutLink[n], 
    	                                BRAP_P_Rsrc_eSrcEq, BRAP_RM_P_INVALID_INDEX, 
    	                                eChPair, uiPp,BRAP_INVALID_VALUE);
                                
                                }
                                else
#endif                                    
                                {
    	                            /* Set In Link of OP pointing to some mixer */
    	                            BRAP_P_SET_LINK_INFO(pOp->sOpInLink, 
    	                                BRAP_P_Rsrc_eMixer, uiLvl, eChPair, uiPrivPp, n);

    	                            /* Set outlink of previous Mixer */
    	                            BRAP_P_SET_LINK_INFO(pPrivMixer->sMixerOutLink[n], 
    	                                BRAP_P_Rsrc_eOpPort, BRAP_RM_P_INVALID_INDEX, 
    	                                eChPair, uiPp,BRAP_INVALID_VALUE);
                                }

							}
							else
								pOp->bValid = false;
                        }
                    }/* for uiPp */
                } 
            }/* for chpair */
        }/* for j */
    }/* uiLvl */

	/* No Mixer is the Inlink of Output Port */
		pOpDetails = NULL;
        for(j=0; j <BRAP_P_MAX_DST_PER_RAPCH ; j++)
        {
            if((NULL == pPath->pDstDetails[j]) ||
               (pPath->pDstDetails[j]->eAudioDst != BRAP_AudioDst_eOutputPort))
            {
                /* There is no OpPort as destination in this level. Goto next */
                continue;        
            }
            else
            {
                BDBG_MSG(("Found DST at pPath->pDstDetails[j=%d]",j));
                pOpDetails = &(pPath->pDstDetails[j]->uDstDetails.sOpDetails);
            }
			for(eChPair= 0; eChPair < BRAP_OutputChannelPair_eMax; eChPair++)
            {
                if(pOpDetails->eOutput[eChPair] != BRAP_OutputPort_eMax)
                {
					uiPp=0;
                    pOp = &(pPath->sOp[eChPair][uiPp]);
                      
                   					
                    if((false == pOp->bValid) && (pOp->hOp != NULL) &&
                       (pOp->hOp->eOutputPort == pOpDetails->eOutput[eChPair]))
                    {

                        /* Set bValid */
                        pOp->bValid = true;
                        
                        /* Set self link */
                        BRAP_P_SET_LINK_INFO(pOp->sOpSelfLink, 
                            BRAP_P_Rsrc_eOpPort, BRAP_RM_P_INVALID_INDEX,
                            eChPair, uiPp,BRAP_INVALID_VALUE);

                                           
                        /* Set In Link of OP pointing to some SrcCh */
                        BRAP_P_SET_LINK_INFO(pOp->sOpInLink, 
                            BRAP_P_Rsrc_eSrcCh,BRAP_INVALID_VALUE, eChPair,BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

                        pSrcCh = &(pPath->sSrcCh[eChPair]);
						if(pSrcCh->bValid==true)
						{
				            BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChOutLink, BRAP_P_Rsrc_eOpPort,
					            BRAP_INVALID_VALUE, eChPair, uiPp,BRAP_INVALID_VALUE);
						}
						else
						{
							BDBG_ERR(("Valid SrcCh not available to link with Output"));
							return BERR_TRACE(BERR_INVALID_PARAMETER);
						}
                    }

                    if((pOpDetails->eOutput[eChPair] == BRAP_OutputPort_eI2s5)||
                       (pOpDetails->eOutput[eChPair] == BRAP_OutputPort_eI2s6)||
                       (pOpDetails->eOutput[eChPair] == BRAP_OutputPort_eI2s7)||
                       (pOpDetails->eOutput[eChPair] == BRAP_OutputPort_eI2s8))
                       break;
                }
			}
        }

#if (BRAP_7550_FAMILY != 1)
    /* Link info for the CapPort:
        ------------------------------------------------------------------------
        sCapPort[chp][pp]               Resource    Level   ChPair  ParallelPath
        ------------                    --------    -----   ------  ------------
        sCapInLink	                    Mixer	    Lvl	    0-3	    Incoming Pp
        								Src			Lvl		0-3		Incoming Pp
        sCapSelfLink                    Cap			NA      0-3     self Pp
        sCapoutLink                     DstCh		NA      0-3     NA
        ------------------------------------------------------------------------                                                	                
    */
    BDBG_MSG(("Linking CapPorts"));
    /* Go to last mixing level and find out the properties */
    /* TODO : The capture can be from any mixing level. Enable that
       support later */

    if ( (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) && 
         (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort) &&
         (BRAP_P_UsgPath_eCapture == pPath->eUsgPath) &&
         (0 == uiPth)         
       )
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {                
            for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
            { 
                pCap = &(pPath->sCapPort[eChPair][uiPp]);
                /* We are interested in the internal capture only*/
                if (NULL != pCap->hCapPort)
                {
                    /* The actual ADC capture has to be treated as usual*/
                    if (BRAP_CapInputPort_eAdc == pCap->hCapPort->eCapPort)
                    {
                        continue;
                    }
                
                    pCap->bValid = true;

                    /* Set self link */
	                    BRAP_P_SET_LINK_INFO(pCap->sCapPortSelfLink, 
	                        BRAP_P_Rsrc_eCapPort, BRAP_RM_P_INVALID_INDEX,
	                        eChPair, 0,BRAP_INVALID_VALUE);
#if (BRAP_7550_FAMILY != 1)
                    /* Set In Link */
                    BRAP_P_SET_LINK_INFO(pCap->sCapPortInLink, 
                        BRAP_P_Rsrc_eSrc, 0, eChPair, 0,0);   
#endif
                }
            }
        }
    }

    
    for(uiLvl =  0;uiLvl <  BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(i =0;i<BRAP_RM_P_MAX_MIXER_OUTPUTS;i++)
        {
            if(NULL != pPath->sMixingLevels[uiLvl].pIntDstDetails[i])
            {
                /* Got the Capture port Level */
                for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
                {
                    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
                    { 
#if BRAP_P_EQUALIZER                    
                        int uiSrcEqPP = 0;
                        bool bSrcEqFound = false;
#endif                        
                        
    	                pCap = &(pPath->sCapPort[eChPair][uiPp]);

    	                if((false == pCap->bValid) && (NULL != pCap->hCapPort) && 
    	                   (pCap->hCapPort->eCapPort == 
    	                     pPath->sMixingLevels[uiLvl].pIntDstDetails[i]->eCapPort[eChPair]))
    	                {
    	                    BDBG_MSG(("pPath->sCapPort[eChPair=%d][uiPp=%d]",eChPair,uiPp));
    	                    /* Set bValid */
    	                    pCap->bValid = true;

#if BRAP_P_EQUALIZER
                            for(uiSrcEqPP = 0; uiSrcEqPP < BRAP_RM_P_MAX_PARALLEL_PATHS; uiSrcEqPP++)
                            { 
                                pSrcEq = &(pPath->sSrcEq[eChPair][uiSrcEqPP]);

                                if (pSrcEq->hSrcEq[0] != NULL)
                                {
                                    if (pSrcEq->sSrcEqInLink.eRsrcType != BRAP_P_Rsrc_eMixer)
                                    {
                                        bSrcEqFound = true;
                                        break;
                                    }
                                }

                            }
                           
                            if (true == bSrcEqFound)
                            {
                                /* If the equalizer SRC is not tied to an Output Port it is available 
                                   for this internal capport */
                                BDBG_MSG(("Capport<->SrcEQ: pPath->sSrcEq[chp=%d][pp=%d]",eChPair,uiSrcEqPP));
                                pSrcEq->bValid = true;

                                BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqSelfLink, 
                                    BRAP_P_Rsrc_eSrcEq, BRAP_RM_P_INVALID_INDEX,
                                    eChPair, uiSrcEqPP,BRAP_INVALID_VALUE);

                                for(i=0; i< BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
                                {         
                                    if(BRAP_P_Rsrc_eMax == pSrcEq->sSrcEqOutLink[i].eRsrcType)
                                    {
                                        break;
                                    }
                                }
                                if(i >= BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC)
                                {
                                    BDBG_ERR(("BRAP_P_LinkFmmModuleHandles: Can't find"
                                        " previous SRC-EQ"));
                                    return BERR_TRACE(BRAP_ERR_DEVICE_UNINTIALIZED);
                                }                                

                                BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqOutLink[i], 
                                    BRAP_P_Rsrc_eCapPort, BRAP_RM_P_INVALID_INDEX,
                                    eChPair, uiPp,BRAP_INVALID_VALUE);

                                /* Set In Link of CAP pointing to this Equalizer */
	                            BRAP_P_SET_LINK_INFO(pCap->sCapPortInLink, 
	                                BRAP_P_Rsrc_eSrcEq, BRAP_RM_P_INVALID_INDEX, 
	                                eChPair, uiSrcEqPP, BRAP_INVALID_VALUE);                                
                            }
#endif                            
    	                    
    	                    /* Set self link */
    	                    BRAP_P_SET_LINK_INFO(pCap->sCapPortSelfLink, 
    	                        BRAP_P_Rsrc_eCapPort, BRAP_RM_P_INVALID_INDEX,
    	                        eChPair, 0,BRAP_INVALID_VALUE);

    	                    bFound = false;
    	                    for(uiPrivPp=0; uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPrivPp++)
    	                    {
    	                        pPrivMixer = &(pPath->sMixer[uiLvl][eChPair][uiPrivPp]);
    	                        for(n=0; n < BRAP_RM_P_MAX_MIXER_OUTPUTS; n++)
    	                        {
    	                            if((BRAP_P_Rsrc_eMax == 
    	                                pPrivMixer->sMixerOutLink[n].eRsrcType) &&
    	                               (BRAP_P_Rsrc_eMixer == 
    	                                pPrivMixer->sMixerSelfLink.eRsrcType) )
    	                            {
    	                                /* Got n */
                                        bFound =true;                                        
    	                                break;                            
    	                            }
    	                        }
                                 if(bFound == true)                                        
    	                        {
                                    /* Got uiPrivPp */
                                    break;
                                }
                            }/* for uiPrivPp */
                                
                            if(bFound == false)
                            {
                                BDBG_ERR(("BRAP_P_LinkFmmModuleHandles: Can't find"
                                    " free previous mixer outlink"));
                                return BERR_TRACE(BRAP_ERR_DEVICE_UNINTIALIZED);
                            }
                            bFound = false;
                            if(uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS)
                            {

#if BRAP_P_EQUALIZER
                                if (true == bSrcEqFound)
                                {
    	                            /* Set In Link of Equalizer pointing to some mixer */
    	                            BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqInLink, 
    	                                BRAP_P_Rsrc_eMixer, uiLvl, eChPair, uiPrivPp, n);

    	                            /* Set outlink of previous Mixer to Equalizer */
    	                            BRAP_P_SET_LINK_INFO(pPrivMixer->sMixerOutLink[n], 
    	                                BRAP_P_Rsrc_eSrcEq, BRAP_RM_P_INVALID_INDEX, 
    	                                eChPair, bSrcEqFound,BRAP_INVALID_VALUE);
                                
                                }
                                else
#endif
                                {
                                    /* Set In Link of OP pointing to some mixer */
                                    BRAP_P_SET_LINK_INFO(pCap->sCapPortInLink, 
                                    BRAP_P_Rsrc_eMixer, uiLvl, eChPair, uiPrivPp,n);

                                    /* Set outlink of previous Mixer */
                                    BRAP_P_SET_LINK_INFO(pPrivMixer->sMixerOutLink[n], 
                                    BRAP_P_Rsrc_eCapPort, BRAP_RM_P_INVALID_INDEX, 
                                    eChPair, uiPp,BRAP_INVALID_VALUE);
                                }
                            }
#if (BRAP_7550_FAMILY != 1)
                            else /*SRC is the inlink of the CapPort */
                            {
                                for(uiPrivPp=0; uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPrivPp++)
                                {
                                    pPrivSrc = &(pPath->sSrc[uiLvl][eChPair][uiPrivPp]);
                                    for(n=0; n < BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; n++)
                                    {
                                        if((BRAP_P_Rsrc_eMax == pPrivSrc->sSrcOutLink[n].eRsrcType) &&
                                        (BRAP_P_Rsrc_eSrc == pPrivSrc->sSrcSelfLink.eRsrcType) )
                                        {
                                            /* Got n */
                                            bFound =true;
                                            break;                            
                                        }
                                    }
                                     if(bFound == true)                                        
                                    {
                                        /* Got uiPrivPp */
                                        break;
                                    }
                                }/* for uiPrivPp */
                                if(bFound == false)
                                    {
                                        BDBG_ERR(("BRAP_P_LinkFmmModuleHandles: Can't find"
                                        " free previous src outlink"));
                                        return BERR_TRACE(BRAP_ERR_DEVICE_UNINTIALIZED);
                                    }
                                /* Set In Link of OP pointing to some mixer */
                                BRAP_P_SET_LINK_INFO(pCap->sCapPortInLink, 
                                BRAP_P_Rsrc_eSrc, uiLvl, eChPair, uiPrivPp,BRAP_INVALID_VALUE);

                                /* Set outlink of previous Src */
                                BRAP_P_SET_LINK_INFO(pPrivSrc->sSrcOutLink[n], 
                                BRAP_P_Rsrc_eCapPort, BRAP_INVALID_VALUE, 
                                eChPair, uiPp,BRAP_INVALID_VALUE);
                            }
#endif                            
    	                }/* if */
    	             }
                }/* for eChPair */
            }/* if */
        }
    }/* for uiLvl */

    /* Link info for the Destination channels:
        ------------------------------------------------------------------------
        sDstCh[ch] 		Resource    Level     ChPair    ParallelPath
        ----------      --------    -----     ------    ------------
        sDstChInLink	CapPort	    NA	        0-3	        0
        sDstChSelfLink	DstCh	    NA	        0-3	        NA
        sDstChOutLink	Rbuf        NA          0-3	        NA 
        ------------------------------------------------------------------------
    */
    BDBG_MSG(("Linking DstCh"));
    for(eChPair=0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        pDstCh = &(pPath->sDstCh[eChPair]);
        if((pPath->sDstCh[eChPair].hDstCh != NULL) && (false == pDstCh->bValid))
        {
            BDBG_MSG(("pPath->sDstCh[eChPair=%d]",eChPair));    
            /* Set bValid */
            pDstCh->bValid = true;
            
            /* Set self link */
            BRAP_P_SET_LINK_INFO(pDstCh->sDstChSelfLink, BRAP_P_Rsrc_eDstCh,
                BRAP_INVALID_VALUE, eChPair, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
            
            if ( (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) && 
                 (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort) &&
                 (BRAP_P_UsgPath_eCapture == pPath->eUsgPath) &&
                 (0 == uiPth)
               )
            {
                /* Set in link */            
                BRAP_P_SET_LINK_INFO(pDstCh->sDstChInLink, BRAP_P_Rsrc_eCapPort, 
                    BRAP_INVALID_VALUE, eChPair, 1,BRAP_INVALID_VALUE);

                /* Set Outlink of Capport */
                BRAP_P_SET_LINK_INFO( pPath->sCapPort[eChPair][1].sCapPortoutLink,
                BRAP_P_Rsrc_eDstCh,BRAP_INVALID_VALUE , eChPair, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
            
            }
            else
            {

                /* Set in link */            
                BRAP_P_SET_LINK_INFO(pDstCh->sDstChInLink, BRAP_P_Rsrc_eCapPort, 
                    BRAP_INVALID_VALUE, eChPair, 0,BRAP_INVALID_VALUE);

                /* Set Outlink of Capport */
                BRAP_P_SET_LINK_INFO( pPath->sCapPort[eChPair][0].sCapPortoutLink,
                BRAP_P_Rsrc_eDstCh,BRAP_INVALID_VALUE , eChPair, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
            }

            /* Set outlink of DstCh */
            BRAP_P_SET_LINK_INFO(pDstCh->sDstChOutLink, BRAP_P_Rsrc_eRBuf, 
                BRAP_INVALID_VALUE, eChPair, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
        }
    }/* for eChPair */
#endif
    
    BDBG_MSG(("All Linking done!!"));

#if BRAP_P_DBG_LINK_INFO
    /* Debug print all the linkage info */
    for(eChPair=0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        /* TODO */
        BDBG_MSG(("sSrcCh[%d]:\tbValid = %d \thSrcCh = %p\n"
                  "          :\teRsrcType \teLvl \teChp \tePp\n"
                  "In[%d]=%x%x%x Self[%d]=%x%x%x Out[%d]=%x%x%x\n",
                  eChPair, pPath->sSrcCh[eChPair].bValid, 
                  pPath->sSrcCh[eChPair].hSrcCh,
                  pPath->sSrcCh[eChPair].sSrcChInLink.eRsrcType,
                  pPath->sSrcCh[eChPair].sSrcChInLink.uiLevel,
                  pPath->sSrcCh[eChPair].sSrcChInLink.eChnPair,
                  pPath->sSrcCh[eChPair].sSrcChInLink.uiPrlPth));
    }
#endif
    
    BDBG_LEAVE(BRAP_P_LinkFmmModuleHandles);
    return ret;
}

/**************************************************************************
Summary:
    Private function that unlinks various FMM module handles for a particular
    path.
**************************************************************************/    
BERR_Code BRAP_P_UnlinkFmmModuleHandles(
    BRAP_ChannelHandle      hRapCh,     /* [in] Channel Handle */
    unsigned int            uiPth       /* [in] Path id */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    unsigned int            uiLvl = BRAP_INVALID_VALUE;
    unsigned int            uiPp = BRAP_INVALID_VALUE;
    unsigned int            i = 0;    
    BRAP_P_ObjectHandles    *pPath = NULL;
    BRAP_P_SrcChHandleInfo  *pSrcCh = NULL;
    BRAP_P_SrcHandleInfo    *pSrc = NULL;
#if BRAP_P_EQUALIZER
    BRAP_P_SrcEqHandleInfo  *pSrcEq = NULL;    
#endif
    BRAP_P_MixerHandleInfo  *pMixer = NULL;
    BRAP_P_OpHandleInfo     *pOp = NULL;

    BDBG_ENTER(BRAP_P_UnlinkFmmModuleHandles);        

    /* Check params */
    BDBG_ASSERT(hRapCh);

    if(uiPth >= BRAP_P_MAX_PATHS_IN_A_CHAN)
    {
        BDBG_ERR(("uiPth = %d  can't be greater  or equal to than BRAP_P_MAX_PATHS_IN_A_CHAN = %d",uiPth,BRAP_P_MAX_PATHS_IN_A_CHAN));
        BDBG_ASSERT(0);
        return BERR_TRACE(BERR_INVALID_PARAMETER);
    }
    BDBG_ASSERT(hRapCh->pPath[uiPth]);
        
    pPath = hRapCh->pPath[uiPth];

    /* Unlink info for the source channels: */
    for(eChPair=0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        if(pPath->sSrcCh[eChPair].hSrcCh != NULL)
        {
            pSrcCh = &(pPath->sSrcCh[eChPair]);

            /* Reset bValid */
            pSrcCh->bValid = false;
            
            /* Reset self link */
            BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChSelfLink, BRAP_P_Rsrc_eMax,
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

            /* Reset in link */            
            BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChInLink, BRAP_P_Rsrc_eMax, 
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

            /* Reset out link */            
            BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChOutLink, BRAP_P_Rsrc_eMax, 
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
        }
    }/* for eChPair */

    /* Unlink info for the SRCs: */
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {
            for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
            {
                pSrc = &(pPath->sSrc[uiLvl][eChPair][uiPp]);
                /* Reset bValid */
                pSrc->bValid = false;
                    
                /* Reset self link */
                BRAP_P_SET_LINK_INFO(pSrc->sSrcSelfLink, BRAP_P_Rsrc_eMax, 
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
                    
                /* Reset in link */
                BRAP_P_SET_LINK_INFO(pSrc->sSrcInLink, BRAP_P_Rsrc_eMax, 
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

                /* Reset out link */
                for(i=0; i< BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
                {
                    BRAP_P_SET_LINK_INFO(pSrc->sSrcOutLink[i], BRAP_P_Rsrc_eMax, 
                    BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
                }/* for i */                   
            }/* for eChPair */
        }/* for uiPp */
    }/* for uiLvl */

    /* Unlink info for the Mixers: */
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {
            for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
            {
                pMixer = &(pPath->sMixer[uiLvl][eChPair][uiPp]);

                /* Reset bValid */
                pMixer->bValid = false;
                    
                /* Reset self link */
                BRAP_P_SET_LINK_INFO(pMixer->sMixerSelfLink, BRAP_P_Rsrc_eMax, 
                    BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

                /* For each mixer input, reset the in link */
                for(i=0; i<BRAP_RM_P_MAX_MIXER_INPUTS; i++)
                {
                    /* Set Inlink of the Mixer */
                    BRAP_P_SET_LINK_INFO(pMixer->sMixerInLink[i], BRAP_P_Rsrc_eMax, 
                        BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
                }/* for i */

                /* for each mixer output, reset the out link */
                for(i=0; i<BRAP_RM_P_MAX_MIXER_OUTPUTS; i++)
                {
                    /* Set Inlink of the Mixer */
                    BRAP_P_SET_LINK_INFO(pMixer->sMixerOutLink[i], BRAP_P_Rsrc_eMax, 
                        BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
                }/* for i */
    
            }/* for eChPair */
        }/* for uiPp */
    }/* for uiLvl */

#if BRAP_P_EQUALIZER
    /* Unlink info for the SRC-EQs: */
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            pSrcEq = &(pPath->sSrcEq[eChPair][uiPp]);
            /* Reset bValid */
            pSrcEq->bValid = false;
                
            /* Reset self link */
            BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqSelfLink, BRAP_P_Rsrc_eMax, 
            BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
                
            /* Reset in link */
            BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqInLink, BRAP_P_Rsrc_eMax, 
            BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

            /* Reset out link */
            for(i=0; i< BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
            {
                BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqOutLink[i], BRAP_P_Rsrc_eMax, 
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
            }/* for i */                   
        }/* for eChPair */
    }/* for uiPp */
#endif

    /* Unlink info for the Outputs: */
    for(eChPair = 0; eChPair < BRAP_OutputChannelPair_eMax; eChPair++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {                    
            pOp = &(pPath->sOp[eChPair][uiPp]);

            /* Reset bValid */
            pOp->bValid = false;
                    
            /* Reset self link */
            BRAP_P_SET_LINK_INFO(pOp->sOpSelfLink, BRAP_P_Rsrc_eMax, 
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

            /* Reset in link */
            BRAP_P_SET_LINK_INFO(pOp->sOpInLink, BRAP_P_Rsrc_eMax, 
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

        }/* for uiPp */
    }/* eChPair */

    BDBG_LEAVE(BRAP_P_UnlinkFmmModuleHandles);
    return ret;
}

/**************************************************************************
Summary:
    Private function that returns the FCI Id.
**************************************************************************/ 
BERR_Code 
BRAP_P_PrepareFciId(
    BRAP_P_ObjectHandles    *psPath,        /* [in] Pointer to usage path */
    BRAP_P_LinkInfo         *psInLink,      /* [in] Pointer to the inlink */     
    uint32_t                *pui32FciId,    /* [out] FCI id to be returned */
    unsigned int            uiSrcCascade,   /* [in] Cascade index. Valid only 
                                               for SRC */
    bool                    bLoopBack
    )
{
    BERR_Code       ret = BERR_SUCCESS;
    uint32_t        ui32FciId = 0;
    uint32_t        ui32BlkId = 0 , ui32RsrcId = 0;
    BRAP_OutputChannelPair eChPair = BRAP_OutputChannelPair_eMax;
    unsigned int    uiLvl = 0;
    unsigned int    uiPp = 0;
    unsigned int    uiMixOutput = 0;
#if (BRAP_7550_FAMILY != 1)
    unsigned int    uiCsc = 0;
    BRAP_SRC_P_Handle hSrc = NULL;
    BRAP_CAPPORT_P_Handle hCap = NULL;    
#endif
    BRAP_MIXER_P_Handle hMixer = NULL;
    unsigned int    i = 0, uiMixOp = BRAP_INVALID_VALUE;
    
    BDBG_ENTER(BRAP_P_PrepareFciId);
#if (BRAP_7550_FAMILY == 1)
    BSTD_UNUSED(uiSrcCascade);
#endif
    BSTD_UNUSED(bLoopBack);
            
    eChPair = psInLink->eChnPair;
    uiLvl = psInLink->uiLevel;
    uiPp = psInLink->uiPrlPth;
    uiMixOutput = psInLink->uiMixerOutput;

    BDBG_MSG(("BRAP_P_PrepareFciId: psInLink->eRsrcType = %d", psInLink->eRsrcType));
    BDBG_MSG(("eChPair = %d, uiLvl = %d, uiPp = %d", eChPair, uiLvl, uiPp));
    switch(psInLink->eRsrcType)
    {        
        case BRAP_P_Rsrc_eRBuf:
            return BERR_TRACE(BERR_INVALID_PARAMETER);
            break;
#if (BRAP_7550_FAMILY != 1)
        case BRAP_P_Rsrc_eSrcCh:
            
            if(0 == uiSrcCascade)
            {
                ui32BlkId = BRAP_P_FCI_BLK_ID_BF_PLAYBACK;
                ui32RsrcId = psPath->sSrcCh[eChPair].hSrcCh->uiIndex;
            }
            else
            {
                hSrc = psPath->sSrc[0][eChPair][0].hSrc[uiSrcCascade-1];
                if(hSrc == NULL)
                {
                    BDBG_ASSERT(0);
                    return BERR_TRACE(BERR_INVALID_PARAMETER);
                }
                if(0 == hSrc->uiBlkId)
                    ui32BlkId = BRAP_P_FCI_BLK_ID_SRC0;
                else if(1 == hSrc->uiBlkId)
                    ui32BlkId = BRAP_P_FCI_BLK_ID_SRC1;
                else
                    return BERR_TRACE(BERR_INVALID_PARAMETER);

                ui32RsrcId = hSrc->uiIndex;
            }
            break;
        case BRAP_P_Rsrc_eSrc: 
            for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
            {
                if(psPath->sSrc[uiLvl][eChPair][uiPp].hSrc[uiCsc] != NULL)
                   hSrc = psPath->sSrc[uiLvl][eChPair][uiPp].hSrc[uiCsc]; 
            }
            if(hSrc == NULL)
            {
                BDBG_ASSERT(0);
                return BERR_TRACE(BERR_INVALID_PARAMETER);
            }
            if(0 == hSrc->uiBlkId)
                ui32BlkId = BRAP_P_FCI_BLK_ID_SRC0;
            else if(1 == hSrc->uiBlkId)
                ui32BlkId = BRAP_P_FCI_BLK_ID_SRC1;
            else
                return BERR_TRACE(BERR_INVALID_PARAMETER);

            ui32RsrcId = hSrc->uiIndex;
            break;
        case BRAP_P_Rsrc_eSrcEq: 
            for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
            {
                if(psPath->sSrcEq[eChPair][uiPp].hSrcEq[uiCsc] != NULL)
                   hSrc = psPath->sSrcEq[eChPair][uiPp].hSrcEq[uiCsc]; 
            }
            if(hSrc == NULL)
            {
                BDBG_ASSERT(0);
                return BERR_TRACE(BERR_INVALID_PARAMETER);
            }
            if(0 == hSrc->uiBlkId)
                ui32BlkId = BRAP_P_FCI_BLK_ID_SRC0;
            else if(1 == hSrc->uiBlkId)
                ui32BlkId = BRAP_P_FCI_BLK_ID_SRC1;
            else
                return BERR_TRACE(BERR_INVALID_PARAMETER);

            ui32RsrcId = hSrc->uiIndex;
            break; 
#else /* For 7550 family only*/
        case BRAP_P_Rsrc_eSrcCh:
            ui32BlkId = BRAP_P_FCI_BLK_ID_BF_PLAYBACK;
            ui32RsrcId = psPath->sSrcCh[eChPair].hSrcCh->uiIndex;
            break;
#endif
            
        case BRAP_P_Rsrc_eMixer:
            if ((BRAP_INVALID_VALUE == uiSrcCascade) || (0 == uiSrcCascade))
            {
                hMixer = psPath->sMixer[uiLvl][eChPair][uiPp].hMixer;
                if(0 == hMixer->uiDpIndex)
                    ui32BlkId = BRAP_P_FCI_BLK_ID_DP0;
                else if(1 == hMixer->uiDpIndex)
                    ui32BlkId = BRAP_P_FCI_BLK_ID_DP1;
                else
                    return BERR_TRACE(BERR_INVALID_PARAMETER);

                /* Prepare the LSB */
                for(i=0; i < BRAP_RM_P_MAX_MIXER_OUTPUTS; i++)
                {
                    uiMixOp = psPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].
                        sMixerGrant[eChPair][uiPp].uiMixerOutputId[i];
                    if(uiMixOutput == uiMixOp)
                    {
                        break;
                    }
                }

                if(BRAP_INVALID_VALUE == uiMixOp)
                {
                    BDBG_ERR(("BRAP_P_PrepareFciId: Could not find uiMixOp"));    
                    return BERR_TRACE(BERR_INVALID_PARAMETER);
                }
                else
                {
                    BDBG_MSG(("BRAP_P_PrepareFciId: uiMixOp = %d ", uiMixOp));
                }

                ui32RsrcId = (hMixer->uiMixerIndex * BRAP_RM_P_MAX_MIXER_OUTPUTS) +
                                uiMixOp;
            }
#if BRAP_P_EQUALIZER
            else
            {
                unsigned int uiPpSrcEqCsc = 0;

                /* The two SRCs for Eq are treated as one block and so both have inlink as Mixer.
                   To find out parent SRC connected in cascade to this SRC we need the corresponding 
                   parallel path of the SrcEq which is stored in sMixerOutLink */                
                uiPpSrcEqCsc = psPath->sMixer[uiLvl][eChPair][uiPp].sMixerOutLink[uiMixOutput].uiPrlPth;
                hSrc = psPath->sSrcEq[eChPair][uiPpSrcEqCsc].hSrcEq[uiSrcCascade-1];
                if(hSrc == NULL)
                {
                    BDBG_ASSERT(0);
                    return BERR_TRACE(BERR_INVALID_PARAMETER);
                }
                if(0 == hSrc->uiBlkId)
                    ui32BlkId = BRAP_P_FCI_BLK_ID_SRC0;
                else if(1 == hSrc->uiBlkId)
                    ui32BlkId = BRAP_P_FCI_BLK_ID_SRC1;
                else
                    return BERR_TRACE(BERR_INVALID_PARAMETER);

                ui32RsrcId = hSrc->uiIndex;                        
            }
#endif      
            break;
#if (BRAP_7550_FAMILY != 1)            
        case BRAP_P_Rsrc_eCapPort:
            ui32BlkId = BRAP_P_FCI_BLK_ID_IOP_CAPTURE;
            hCap = psPath->sCapPort[eChPair][uiPp].hCapPort;
		    BDBG_MSG(("hCap > %x", hCap));
            BDBG_ASSERT(hCap != NULL);

            switch(hCap->eCapPort)
            {
                case BRAP_CapInputPort_eIntCapPort0:
                    ui32RsrcId = 0;
                    break;
                case BRAP_CapInputPort_eIntCapPort1:
                    ui32RsrcId = 1;
                    break;
                case BRAP_CapInputPort_eIntCapPort2:
                    ui32RsrcId = 2;
                    break;
                case BRAP_CapInputPort_eIntCapPort3:
                    ui32RsrcId = 3;
                    break;
                case BRAP_CapInputPort_eIntCapPort4:
                    ui32RsrcId = 4;
                    break;                      
                case BRAP_CapInputPort_eIntCapPort5:
                    ui32RsrcId = 5;
                    break;                      
                case BRAP_CapInputPort_eIntCapPort6:
                    ui32RsrcId = 6;
                    break;                      
                case BRAP_CapInputPort_eIntCapPort7:
                    ui32RsrcId = 7;
                    break;  
                /* External Capture Port Resource IDs based on the chip */    
#if  (BRAP_3548_FAMILY == 1) 
                case BRAP_CapInputPort_eExtI2s0:    
                    ui32RsrcId = 4;
                    break;
                case BRAP_CapInputPort_eRfAudio:    
                    ui32RsrcId = 5;
                    break;
                case BRAP_CapInputPort_eAdc:
#if (BCHP_VER==BCHP_VER_A0)
                    ui32RsrcId = 7;
#else
                    ui32RsrcId = 10;
#endif
                    break;
                case BRAP_CapInputPort_eSpdif:    
                case BRAP_CapInputPort_eHdmi:                        
                    ui32RsrcId = 6;
                    break;
#elif (BRAP_7405_FAMILY == 1)                    
                case BRAP_CapInputPort_eExtI2s0:    
                    ui32RsrcId = 4;
                    break;
#endif                    
                default:
                    BDBG_ERR(("BRAP_P_PrepareFciId: Unsupported CapPort"));
                    return BERR_TRACE(BERR_INVALID_PARAMETER);
                    break;
            }
            break;            
        case BRAP_P_Rsrc_eDstCh:
            /* TODO */
#endif            
        default:
            BDBG_ERR(("BRAP_P_PrepareFciId: Unsupported Rsrc type = %d",
                 psInLink->eRsrcType));
            return BERR_TRACE(BERR_INVALID_PARAMETER);
    }
    
    BRAP_P_PREPARE_FCI_ID(ui32FciId, ui32BlkId, ui32RsrcId);
    *pui32FciId = ui32FciId;

    BDBG_MSG(("ui32FciId = 0x%x, ui32BlkId = 0x%x, ui32RsrcId = 0x%x", 
        ui32FciId, ui32BlkId, ui32RsrcId));
    
    BDBG_LEAVE(BRAP_P_PrepareFciId);
    return ret;
}

/***************************************************************************
Summary:
    Private function that updates the already allocated output and spdiffm 
    ids in the resource grant structure.
****************************************************************************/
static BERR_Code
BRAP_P_UpdateOpResrcGrant(
    BRAP_ChannelHandle      hRapCh,         /* [in] Raptor device handle */
    BRAP_P_ObjectHandles    *pPath,         /* [in] Path which carries output 
                                               details */
    BRAP_RM_P_ResrcGrant    *pRsrcGrnt      /* [out] Resource grant to update */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_OutputPortDetails  *pOpDetails = NULL;
    BRAP_DstDetails         *pDstDetails = NULL;
    unsigned int            uiLvl = 0,uiPp=0, i = 0,j=0;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    BRAP_OutputPort         eOp = BRAP_OutputPort_eMax;
    BRAP_OutputPort         eMaiMuxOp = BRAP_OutputPort_eMax;

    BDBG_ASSERT(pPath);
    BDBG_ASSERT(pRsrcGrnt);

    BDBG_ENTER(BRAP_P_UpdateOpResrcGrant);

    /* Check if Mai has been added as a destination with a valid Mux-Selector */
    for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        pDstDetails = hRapCh->pDstDetails[i];
        if((NULL == pDstDetails) || 
           (BRAP_AudioDst_eOutputPort != pDstDetails->eAudioDst))
        {
            continue;
        }
#if 0
        if(BRAP_OutputPort_eMai == pDstDetails->uDstDetails.sOpDetails.
            eOutput[BRAP_OutputChannelPair_eLR])
#endif            
        {
            eMaiMuxOp = hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].
                uOutputPortSettings.sMaiSettings.eMaiMuxSelector;
        }
    }/* for i */
    uiPp = 0;
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(j=0; j < BRAP_RM_P_MAX_PARALLEL_PATHS; j++)          
        {
#if BRAP_P_CUSTOM_MIXER_REQUIREMENT        
            uiPp = j;
#endif            
            if((NULL == pPath->sMixingLevels[uiLvl].pDstDetails[j]) ||
               (pPath->sMixingLevels[uiLvl].pDstDetails[j]->eAudioDst != 
                    BRAP_AudioDst_eOutputPort))
            {
                /* This mixing level is not feeding to any output port directly */
                continue;
            }

            pOpDetails = 
                &(pPath->sMixingLevels[uiLvl].pDstDetails[j]->uDstDetails.sOpDetails);
            
            for(i = 0; i < BRAP_OutputChannelPair_eMax; i++)
            {
                eOp = pOpDetails->eOutput[i];
                
                if(eOp != BRAP_OutputPort_eMax)
                {
                    /* Note: uiPp can not be more than it's max. If required for 
                       a chip, the max should be increased. */
                    if(uiPp >= BRAP_RM_P_MAX_PARALLEL_PATHS)
                    {
                        BDBG_ERR(("uiPp = %d  can't be greater  or equal to than BRAP_RM_P_MAX_PARALLEL_PATHS = %d",uiPp,BRAP_RM_P_MAX_PARALLEL_PATHS));
                        BDBG_ASSERT(0);
                        return BERR_TRACE(BRAP_ERR_BAD_DEVICE_STATE);
                    }
                
                    eChPair = i;
                    pRsrcGrnt->sOpPortGrnt[eChPair].eOutputPort = eOp;
                    pPath->sOp[eChPair][uiPp].hOp = hRapCh->hRap->hFmm[0]->hOp[eOp];

     
                    if(BRAP_OutputPort_eMai == eOp)
                        ret = BRAP_RM_P_GetSpdifFmForOpPort(
                                hRapCh->hRap->hRm,
                                eOp,
                                eMaiMuxOp,
                                &(pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmId),
                                &(pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmStreamId));
                    else
                    ret = BRAP_RM_P_GetSpdifFmForOpPort(
                            hRapCh->hRap->hRm,
                            eOp,
                            BRAP_OutputPort_eMax,
                            &(pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmId),
                            &(pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmStreamId));
                    
                    if(BERR_SUCCESS != ret)
                    {
                        BDBG_ERR(("BRAP_P_UpdateOpResrcGrant: "
                            "BRAP_RM_P_GetSpdifFmForOpPort failed %d", ret));
                    }
                    /* TODO: Is hardcoding the PP to 0 okay?? */
                    pPath->sOp[eChPair][uiPp].hSpdifFm = 
                        hRapCh->hRap->hFmm[0]->hSpdifFm[pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmStreamId];

                    /* If this output port is the mux-selector for MAI, special 
                       handling for Mai tapping data from this output port */                   
#if (BRAP_7405_FAMILY == 1) /* Need this only for I2S Mux */
                    if((eOp == eMaiMuxOp)&&(eOp != BRAP_OutputPort_eMai))
                    {
                        hRapCh->hRap->hFmm[0]->hOp[BRAP_OutputPort_eMai]->uOpSettings.sMai.sExtSettings
                            = hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiSettings;
                        pPath->sOp[eChPair][uiPp].hMaiOp = 
                            hRapCh->hRap->hFmm[0]->hOp[BRAP_OutputPort_eMai];
                                
                        /* TODO: Do we need to have a separate SPDIFFM?? */
#if 1 /*(BRAP_7405_FAMILY != 1) */
                        ret = BRAP_RM_P_GetSpdifFmForOpPort(
                                hRapCh->hRap->hRm,
                                BRAP_OutputPort_eMai,
                                eOp,
                                &(pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmId),
                                &(pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmStreamId));
                        if(BERR_SUCCESS != ret)
                        {
                            BDBG_ERR(("BRAP_P_UpdateOpResrcGrant: "
                                "BRAP_RM_P_GetSpdifFmForOpPort failed %d", ret));
                    }
                        /* TODO: Is hardcoding the PP to 0 okay?? */
                        pPath->sOp[eChPair][uiPp].hSpdifFm = 
                            hRapCh->hRap->hFmm[0]->hSpdifFm[pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmStreamId];
#endif                        
                    }
#endif                    
                    /* TODO: Commneting here and moving outside for loop. Verify if it breaks any feature
					uiPp++;
					*/
                }
            }/* for i */
#if (!BRAP_P_CUSTOM_MIXER_REQUIREMENT)
            uiPp++;
#endif
        }/* for  */
    }/* for uiLvl */

    BDBG_LEAVE(BRAP_P_UpdateOpResrcGrant);   
    return ret;
}

/***************************************************************************
Summary:
    Private function that resets/removes output port and spdiffm ids from the
    resource grant structure.
****************************************************************************/
static BERR_Code
BRAP_P_ResetOpResrcGrant(
    BRAP_Handle             hRap,           /* [in] Raptor device handle */
    BRAP_P_ObjectHandles    *pPath,         /* [in] Path which carries output 
                                               details */
    BRAP_RM_P_ResrcGrant    *pRsrcGrnt      /* [out] Resource grant to update */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    unsigned int            uiPp = 0;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;

    BDBG_ENTER(BRAP_P_ResetOpResrcGrant);

    BDBG_ASSERT(pPath);
    BDBG_ASSERT(pRsrcGrnt);
    BSTD_UNUSED(hRap);

    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_OutputChannelPair_eMax; eChPair++)
        {
            if(pPath->sOp[eChPair][uiPp].hOp != NULL)
            {
                /* Note: The actual freeing of handles will happen in 
                   RemoveDestination() */
                pPath->sOp[eChPair][uiPp].hOp = NULL;
                pPath->sOp[eChPair][uiPp].hSpdifFm = NULL;
                pRsrcGrnt->sOpPortGrnt[eChPair].eOutputPort = 
                                                        BRAP_OutputPort_eMax;
                pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmId = 
                                                        BRAP_INVALID_VALUE;
                pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmStreamId = 
                                                        BRAP_INVALID_VALUE;
            }

            /* Similarly for hMaiOp */                   
            if(pPath->sOp[eChPair][uiPp].hMaiOp != NULL)
            {
                pPath->sOp[eChPair][uiPp].hMaiOp = NULL;
                /* TODO: Handle dedicated spdifFm (if any later) */
            }
        }/* eChPair */
    }/* uiPp */

    BDBG_LEAVE(BRAP_P_ResetOpResrcGrant);
    return ret;
}

/***************************************************************************
Summary:
    Private function gets the burst repetition period for an algo type.

    Recommended Burst Repetition Periods for various algo types are as follows:
    AC3 and DTS = PER_3
    MPEG-2 Layers 1, 2, and 3 < 32kHz = PER_64
    MPEG-1, MPEG-2/AAC, and any other MPEG-2 formats = PER_32
****************************************************************************/
BERR_Code BRAP_P_GetBurstRepetitionPeriodForAlgo(
    BAVC_StreamType                 eStreamType,
                                        /* [in] audio stream type*/
    BRAP_DSPCHN_AudioType           eAudioType, 
                                        /* [in] audio type for which 
                                           burst repetition period is 
                                           sought */
    BRAP_SPDIFFM_P_BurstRepPeriod   *pBurstRepPeriod
                                        /* [out] corresponding burst 
                                           repetition period for the 
                                           algo type passed */
    )
{
    BERR_Code ret = BERR_SUCCESS;
    BDBG_ENTER(BRAP_P_GetBurstRepetitionPeriodForAlgo);

    /* validate input */
    BDBG_ASSERT(pBurstRepPeriod);

    switch(eAudioType)
    {
        /* Here we return PER_32 for both MPEG-1 and MPEG-2. For
           MPEG-2 < 32KHz, PER_64 is set from SamplingRateChange_isr */
        case BRAP_DSPCHN_AudioType_eMpeg:
		case BRAP_DSPCHN_AudioType_eMpegMc:			
            if((eStreamType == BAVC_StreamType_ePS) ||
               (eStreamType == BAVC_StreamType_eMpeg1System) ||
               (eStreamType == BAVC_StreamType_eTsMpeg)) 
                *pBurstRepPeriod = BRAP_SPDIFFM_P_BurstRepPeriod_ePer32;
            else
                *pBurstRepPeriod = BRAP_SPDIFFM_P_BurstRepPeriod_eNone;
            break;

        /*Note: AC3+ simul mode uses SPDIFFM */
        case BRAP_DSPCHN_AudioType_eAc3:
        case BRAP_DSPCHN_AudioType_eAc3Lossless:
       	case BRAP_DSPCHN_AudioType_eDts:
        case BRAP_DSPCHN_AudioType_eDtsBroadcast:            
       	case BRAP_DSPCHN_AudioType_eDtshd:
        case BRAP_DSPCHN_AudioType_eDtshdSub:
       	case BRAP_DSPCHN_AudioType_eDdp7_1:			
            *pBurstRepPeriod = BRAP_SPDIFFM_P_BurstRepPeriod_ePer3;
            break;
            
            case BRAP_DSPCHN_AudioType_eAc3Plus:
                *pBurstRepPeriod = BRAP_SPDIFFM_P_BurstRepPeriod_ePer4;
            break;
            
            case BRAP_DSPCHN_AudioType_eAac:
            case BRAP_DSPCHN_AudioType_eAacLoas:                        
            case BRAP_DSPCHN_AudioType_eAacSbr:
            case BRAP_DSPCHN_AudioType_eAacSbrAdts:
            *pBurstRepPeriod = BRAP_SPDIFFM_P_BurstRepPeriod_ePer32;
            break;

        /* Not supported / un-compressed algo types */
       	case BRAP_DSPCHN_AudioType_eLpcmBd:
       	case BRAP_DSPCHN_AudioType_eLpcmHdDvd:            
       	case BRAP_DSPCHN_AudioType_eLpcmDvd:  
        case BRAP_DSPCHN_AudioType_eLpcmDvdA:
        case BRAP_DSPCHN_AudioType_ePcm:
		case BRAP_DSPCHN_AudioType_eWmaStd:
		case BRAP_DSPCHN_AudioType_eWmaPro:
		case BRAP_DSPCHN_AudioType_eMlp:
		case BRAP_DSPCHN_AudioType_eDtsLbr:            
        case BRAP_DSPCHN_AudioType_ePcmWav:
        case BRAP_DSPCHN_AudioType_eAmr:            
            case BRAP_DSPCHN_AudioType_eRealAudioLbr:                        
            *pBurstRepPeriod = BRAP_SPDIFFM_P_BurstRepPeriod_eNone;
            break;
            
        case BRAP_DSPCHN_AudioType_eDra:            
            *pBurstRepPeriod = BRAP_SPDIFFM_P_BurstRepPeriod_ePer1024;
            break;
            
        case BRAP_DSPCHN_AudioType_eInvalid:
        default: 
            return BERR_TRACE(BERR_INVALID_PARAMETER);
    }
    BDBG_LEAVE(BRAP_P_GetBurstRepetitionPeriodForAlgo);
    return ret;
}

/***************************************************************************
Summary:
    Private function that gets the PLL for the output port.
****************************************************************************/
#if (BRAP_7550_FAMILY != 1)
BERR_Code
BRAP_P_GetPllForOp(
	const BRAP_Handle 	    hRap,           /* [in] The RAP handle */
	const BRAP_OutputPort	eOutputPort,    /* [in] Output port */
    BRAP_OP_Pll             *pPll           /* [out] The Pll associated with 
                                               this output port */
    )
{
    BERR_Code ret = BERR_SUCCESS;
    BRAP_OutputPort eMaiMuxSelect = BRAP_OutputPort_eMax;
    
    BDBG_ENTER(BRAP_P_GetPllForOp);
    BDBG_ASSERT(hRap);
    BDBG_ASSERT(pPll);
    
    /* Make sure  port is configured */
    if(hRap->bOpSettingsValid[eOutputPort] == false)    
    {
        BDBG_ERR(("BRAP_P_GetPllForOp: Output port %d is not configured. Please"
            " configure before calling this PI.", eOutputPort));
        return BERR_TRACE(BRAP_ERR_OUTPUT_NOT_CONFIGURED);
    }       

    switch(eOutputPort)
    {
        case BRAP_OutputPort_eSpdif:
        case BRAP_OutputPort_eSpdif1:
            *pPll = hRap->sOutputSettings[eOutputPort].uOutputPortSettings.sSpdifSettings.ePll;                            
            break;
        case BRAP_OutputPort_eI2s0:
        case BRAP_OutputPort_eI2s1:
        case BRAP_OutputPort_eI2s2:              
        case BRAP_OutputPort_eI2s3:
        case BRAP_OutputPort_eI2s4:
        case BRAP_OutputPort_eI2s5:
        case BRAP_OutputPort_eI2s6:
        case BRAP_OutputPort_eI2s7:              
        case BRAP_OutputPort_eI2s8:
            *pPll = hRap->sOutputSettings[eOutputPort].uOutputPortSettings.sI2sSettings.ePll;                             
            break;
        case BRAP_OutputPort_eDac0:
        case BRAP_OutputPort_eDac1:
        case BRAP_OutputPort_eDac2:                      
            *pPll = BRAP_RM_P_INVALID_INDEX;
            break;
        case BRAP_OutputPort_eMai:
            eMaiMuxSelect = hRap->sOutputSettings[eOutputPort].uOutputPortSettings.sMaiSettings.eMaiMuxSelector;
            if(BRAP_OutputPort_eMax != eMaiMuxSelect)
            {
#if (BRAP_7405_FAMILY == 1)
                *pPll =  hRap->sOutputSettings[eMaiMuxSelect].
                                uOutputPortSettings.sMaiSettings.ePll; 
#else
                *pPll =  hRap->sOutputSettings[eMaiMuxSelect].
                                uOutputPortSettings.sSpdifSettings.ePll; 
#endif
            }
            break;
        case BRAP_OutputPort_eMaiMulti0:
        case BRAP_OutputPort_eMaiMulti1:
        case BRAP_OutputPort_eMaiMulti2:
        case BRAP_OutputPort_eMaiMulti3:   
            *pPll = hRap->sOutputSettings[eOutputPort].uOutputPortSettings.sMaiMultiSettings.ePll;                  
            break;
        case BRAP_OutputPort_eFlex:
            break;
        default:
            BDBG_ERR(("BRAP_P_GetPllForOp:  Output port type %d not supported",
                    eOutputPort ));
            return BERR_TRACE(BRAP_ERR_OUPUT_PORT_NOT_SUPPORTED);   
    }

    BDBG_MSG(("BRAP_P_GetPllForOp: Pll %d is associated with ouput port %d", *pPll, eOutputPort));

    BDBG_LEAVE (BRAP_P_GetPllForOp);        
    return ret;
}
#else /* For 7550 family only */
BERR_Code
BRAP_P_GetPllForOp(
	const BRAP_Handle 	    hRap,           /* [in] The RAP handle */
	const BRAP_OutputPort	eOutputPort,    /* [in] Output port */
    BRAP_OP_MClkRate        *eMClkRate      /* [out] The MCLK associated with 
                                               this output port */
    )
{
    BERR_Code ret = BERR_SUCCESS;
    BRAP_OutputPort eMaiMuxSelect = BRAP_OutputPort_eMax;
    
    BDBG_ENTER(BRAP_P_GetPllForOp);
    BDBG_ASSERT(hRap);
    BDBG_ASSERT(eMClkRate);
    
    /* Make sure  port is configured */
    if(hRap->bOpSettingsValid[eOutputPort] == false)    
    {
        BDBG_ERR(("BRAP_P_GetPllForOp: Output port %d is not configured. Please"
            " configure before calling this PI.", eOutputPort));
        return BERR_TRACE(BRAP_ERR_OUTPUT_NOT_CONFIGURED);
    }       

    switch(eOutputPort)
    {
        case BRAP_OutputPort_eSpdif:
        case BRAP_OutputPort_eSpdif1:
            *eMClkRate = hRap->sOutputSettings[eOutputPort].uOutputPortSettings.sSpdifSettings.eMClkRate;                            
            break;
        case BRAP_OutputPort_eDac0:
        case BRAP_OutputPort_eDac1:
        case BRAP_OutputPort_eDac2:                      
            *eMClkRate = BRAP_RM_P_INVALID_INDEX;
            break;
        case BRAP_OutputPort_eMai:
            eMaiMuxSelect = hRap->sOutputSettings[eOutputPort].uOutputPortSettings.sMaiSettings.eMaiMuxSelector;
            if(BRAP_OutputPort_eMax != eMaiMuxSelect)
            {
#if (BRAP_7405_FAMILY == 1)
                *eMClkRate =  hRap->sOutputSettings[eMaiMuxSelect].
                                uOutputPortSettings.sMaiSettings.eMClkRate; 
#else
                *eMClkRate =  hRap->sOutputSettings[eMaiMuxSelect].
                                uOutputPortSettings.sSpdifSettings.eMClkRate; 
#endif
            }
            break;
        case BRAP_OutputPort_eMaiMulti0:
        case BRAP_OutputPort_eMaiMulti1:
        case BRAP_OutputPort_eMaiMulti2:
        case BRAP_OutputPort_eMaiMulti3:   
            *eMClkRate = hRap->sOutputSettings[eOutputPort].uOutputPortSettings.sMaiMultiSettings.eMClkRate;                  
            break;            
        case BRAP_OutputPort_eFlex:
            break;
        default:
            BDBG_ERR(("BRAP_P_GetPllForOp:  Output port type %d not supported",
                    eOutputPort ));
            return BERR_TRACE(BRAP_ERR_OUPUT_PORT_NOT_SUPPORTED);   
    }

    BDBG_MSG(("BRAP_P_GetPllForOp: eMClkRate %d is associated with ouput port %d", *eMClkRate, eOutputPort));

    BDBG_LEAVE (BRAP_P_GetPllForOp);        
    return ret;
}
#endif
/**************************************************************************
Summary:
    Private function that checks the compatibility between the HDMI and 
    its mux selector.
**************************************************************************/
BERR_Code BRAP_P_IsMaiAndMuxSelectorCompatible(
    BRAP_Handle                     hRap,
    BRAP_AssociatedChannelHandle    hAssociatedCh,     
    BRAP_DstDetails                 *pDstDetails    
    )
{
    BERR_Code                   ret = BERR_SUCCESS;
    BRAP_OutputPortDetails      *pMuxOpDetails = NULL;
    BRAP_OP_MaiSettings         *pMaiSettings = NULL;
    BRAP_DstDetails             *pTmpDstDetails = NULL;
    int i = 0;
    int j = 0;
    BRAP_ProcessingType        eAudioProcessing = BRAP_ProcessingType_eNone;
    
    BDBG_ENTER(BRAP_P_IsMaiAndMuxSelectorCompatible);

    if((BRAP_AudioDst_eOutputPort == pDstDetails->eAudioDst) && 
       (BRAP_OutputPort_eMai == pDstDetails->uDstDetails.sOpDetails.
                            eOutput[BRAP_OutputChannelPair_eLR]))
    {
        pMaiSettings = &(hRap->sOutputSettings[BRAP_OutputPort_eMai].
                                uOutputPortSettings.sMaiSettings);
        if(BRAP_OutputPort_eMai == pMaiSettings->eMaiMuxSelector)
        {
            /* HDMI taking data straight from mixer */
            BDBG_LEAVE(BRAP_P_IsMaiAndMuxSelectorCompatible);
            return BERR_SUCCESS;
        }

        /* Check if the mux selector output port is already added as destination 
           or not */
#if BRAP_P_MAI_NEEDS_MUX_SELECTOR
        if(BRAP_OutputPort_eMax == pMaiSettings->eMaiMuxSelector)
        {
            BDBG_ERR(("BRAP_P_IsMaiAndMuxSelectorCompatible: eMaiMuxSelector not set"));
            return BERR_TRACE(BRAP_ERR_OUTPUT_NOT_CONFIGURED);            
        }
#endif        
        if(BRAP_OutputPort_eMax != pMaiSettings->eMaiMuxSelector)
        {

            /* If MAI Mux Select is I2S_Multi0 or I2S_Multi1,then MAI and SPDIF1
               can not coexist in the system. Check and return error if so. */
            for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
            {
                if(BRAP_AudioDst_eOutputPort == hAssociatedCh->sDstDetails[i].sExtDstDetails.eAudioDst) 
                {
                    for(j=0; j < BRAP_OutputChannelPair_eMax; j++)
                    {
                        if(((pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s0)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s1)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s2)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s3)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s5)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s6)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s7)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s8)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eMaiMulti0)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eMaiMulti1)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eMaiMulti2)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eMaiMulti3)                           
                            )&&
                           (BRAP_OutputPort_eSpdif1 == 
                            hAssociatedCh->sDstDetails[i].sExtDstDetails.uDstDetails.sOpDetails.eOutput[j]))
                        {
                            BDBG_ERR(("BRAP_P_IsMaiAndMuxSelectorCompatible: SPDIF1 cannot co-exist"
                                      "with HDMI with Mux Select I2s_Multi0 or I2S_Multi1"));
                            return BERR_TRACE(BERR_NOT_SUPPORTED);
                        }
                        
                    }/* for j */
                }
            }/* for i */

        
            /* Check if the mux selector has already been added, else return */
            for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
            {
                if(BRAP_AudioDst_eOutputPort == hAssociatedCh->sDstDetails[i].sExtDstDetails.eAudioDst) 
                {
                    for(j=0; j < BRAP_OutputChannelPair_eMax; j++)
                    {
                        if(pMaiSettings->eMaiMuxSelector ==
                            hAssociatedCh->sDstDetails[i].sExtDstDetails.uDstDetails.sOpDetails.eOutput[j])
                        {
                            /* matched, break from the j for loop */
                            pMuxOpDetails = &(hAssociatedCh->sDstDetails[i].sExtDstDetails.uDstDetails.sOpDetails);
                            pTmpDstDetails = &(hAssociatedCh->sDstDetails[i].sExtDstDetails);
                            break;
                        }
                    }/* for j */

                    if(j < BRAP_OutputChannelPair_eMax)
                    {
                        /* matched, break from the i for loop */
                        break;
                    }
                }
            }/* for i */

            if(i >= BRAP_P_MAX_DST_PER_RAPCH)
            {
                /* Mux selector has not been added, return with error */
                BDBG_ERR(("BRAP_P_IsMaiAndMuxSelectorCompatible: Add eMaiMuxSelector"
                    " before adding the HDMI output port"));
                return BERR_TRACE(BRAP_ERR_OUTPUT_NOT_CONFIGURED);
            }
            else
            {
                if((BRAP_OutputPort_eSpdif == pMaiSettings->eMaiMuxSelector)||
                   (BRAP_OutputPort_eSpdif1 == pMaiSettings->eMaiMuxSelector)) 
                {
                    /* Verify if Mai and mux-selector's settings are identical */
                    if((hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].bCompressed != 
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].bCompressed) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].eOutputSR !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].eOutputSR) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.bProfessionalMode !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.bProfessionalMode) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.bSwCopyRight !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.bSwCopyRight) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.ui16CategoryCode !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.ui16CategoryCode) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.ui16ClockAccuracy != 
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.ui16ClockAccuracy) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.bSeparateLRChanNum !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.bSeparateLRChanNum) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.uiCGMS_A!=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.uiCGMS_A) ||                        
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdiffmSettings.bEnableDither != 
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdiffmSettings.bEnableDither) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdiffmSettings.eBurstType !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdiffmSettings.eBurstType) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].uiOutputBitsPerSample !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].uiOutputBitsPerSample))
                    {
                        BDBG_ERR(("BRAP_P_IsMaiAndMuxSelectorCompatible: Mis-match "
                            "in eMuxSelector(%d)and HDMI Settings: "
                            "\n\t bCompressed (%d, %d)"
                            "\n\t eOutputSR (%d, %d)"
                            "\n\t ChanStatusParams ((%d %d %d %d %d), (%d %d %d %d %d)"
                            "\n\t SpdifFmSettings ((%d %d), (%d, %d))"
                            "\n\t uiOpBitsPerSample (%d, %d)",
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].bCompressed,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].bCompressed, 
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].eOutputSR,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].eOutputSR,
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.bProfessionalMode, 
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.bSwCopyRight, 
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.ui16CategoryCode, 
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.ui16ClockAccuracy, 
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.bProfessionalMode,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.bSwCopyRight,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.ui16CategoryCode,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.ui16ClockAccuracy,
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.bSeparateLRChanNum, 
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdiffmSettings.bEnableDither,
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdiffmSettings.eBurstType,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.bSeparateLRChanNum,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdiffmSettings.bEnableDither,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdiffmSettings.eBurstType,
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].uiOutputBitsPerSample,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].uiOutputBitsPerSample));
                        return BERR_TRACE(BERR_NOT_SUPPORTED);
                    }/* if sOutputSettings */                   
                }
                else if (BRAP_OutputPort_eMax != pMaiSettings->eMaiMuxSelector)
                {
                    /* Verify if Mai and mux-selector's settings are identical */
                    if((hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].eOutputSR !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].eOutputSR) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].uiOutputBitsPerSample !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].uiOutputBitsPerSample))
                    {
                        BDBG_ERR(("BRAP_P_IsMaiAndMuxSelectorCompatible: Mis-match "
                            "in eMuxSelector(%d)and HDMI Settings: "
                            "\n\t eOutputSR (%d, %d)"
                            "\n\t uiOpBitsPerSample (%d, %d)",pMaiSettings->eMaiMuxSelector,
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].eOutputSR,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].eOutputSR,
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].uiOutputBitsPerSample,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].uiOutputBitsPerSample));
                        return BERR_TRACE(BERR_NOT_SUPPORTED);
                    }/* if sOutputSettings */                   
                }
                else
                {
                    /* Do nothing for now */
                }

                eAudioProcessing = hAssociatedCh->sDstDetails[i].eAudioProcessing;
                
                /* Verify if Mai and mux-selector's DstDetails are identical */
                if((pMuxOpDetails->bLfeOn != 
                        pDstDetails->uDstDetails.sOpDetails.bLfeOn) ||
                   (pMuxOpDetails->eAudioMode != 
                        pDstDetails->uDstDetails.sOpDetails.eAudioMode) ||
                   (hAssociatedCh->sDstDetails[i].eAudioProcessing != eAudioProcessing))
                {
                    BDBG_ERR(("BRAP_P_IsMaiAndMuxSelectorCompatible: Mis-match"\
                        " in sOpDetails between the eMuxSelector(%d) and HDMI:"
                        "\n\t bLfeOn (%d, %d)"
                        "\n\t eAudioMode (%d, %d)"
                        "\n\t eAudioProcessing (%d, %d)",
                        pMuxOpDetails->bLfeOn,
                        pDstDetails->uDstDetails.sOpDetails.bLfeOn,
                        pMuxOpDetails->eAudioMode,
                        pDstDetails->uDstDetails.sOpDetails.eAudioMode,
                        hAssociatedCh->sDstDetails[i].eAudioProcessing,
                        eAudioProcessing));
                    return BERR_TRACE(BERR_NOT_SUPPORTED);                
                }/* if DstDetails */
            }/* if i */
        }/* if eMaiMuxSelector */
    }/* if eAudioDst */
        
    BDBG_LEAVE(BRAP_P_IsMaiAndMuxSelectorCompatible);
    return ret;
}

bool BRAP_P_IsMaiFedByPath(BRAP_P_ObjectHandles *pPath)
{
    unsigned int i, j;
    bool bMaiFed = false;

    for (i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        if ((pPath->pDstDetails[i]!=NULL)
            && (BRAP_AudioDst_eOutputPort==pPath->pDstDetails[i]->eAudioDst))
        {
            for (j = 0; j < BRAP_OutputChannelPair_eMax; j++)
            {
                if ( (BRAP_OutputPort_eMai==pPath->pDstDetails[i]->uDstDetails.sOpDetails.eOutput[j])
#if (BRAP_3548_FAMILY == 1)                    
                    ||(BRAP_OutputPort_eSpdif==pPath->pDstDetails[i]->uDstDetails.sOpDetails.eOutput[j])
#endif                    
                    )
                {
                    bMaiFed = true;
                    break;
                }
            }
        }
        if (true==bMaiFed)
            break;
    }
    return bMaiFed;
}

bool BRAP_P_IsDacFedByPath(BRAP_P_ObjectHandles *pPath)
{
    unsigned int i, j;
    bool bDacFed = false;

    for (i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        if ((pPath->pDstDetails[i]!=NULL)
            && (BRAP_AudioDst_eOutputPort==pPath->pDstDetails[i]->eAudioDst))
        {
            for (j = 0; j < BRAP_OutputChannelPair_eMax; j++)
            {
                if ( (BRAP_OutputPort_eDac0==pPath->pDstDetails[i]->uDstDetails.sOpDetails.eOutput[j])  
                    ||(BRAP_OutputPort_eDac1==pPath->pDstDetails[i]->uDstDetails.sOpDetails.eOutput[j])
                    ||(BRAP_OutputPort_eDac2==pPath->pDstDetails[i]->uDstDetails.sOpDetails.eOutput[j])
                    )
                {
                    bDacFed = true;
                    break;
                }
            }
        }
        if (true==bDacFed)
            break;
    }
    return bDacFed;
}



BERR_Code BRAP_P_IsVolumeControlSupported(BRAP_Handle     hRap,
                BRAP_OutputPort eOpType,
                BRAP_ProcessingType eProcessingType
                )
{
    BERR_Code   ret = BERR_SUCCESS;
    uint32_t i=0,j=0;
	BDBG_ASSERT(hRap);
     
    for(i=0;i<BRAP_MAX_PP_SUPPORTED;i++)
    {
        if((hRap->hAudioProcessingStageHandle[i]!=NULL)&&
            (hRap->hAudioProcessingStageHandle[i]->sProcessingStageSettings.eAudioProcessing == eProcessingType))
        {
            for(j=0;j<BRAP_P_MAX_DEST_PER_PROCESSING_STAGE;j++)
            {                
                if((hRap->hAudioProcessingStageHandle[i]->hDestHandle[j]!=NULL)&&
                (hRap->hAudioProcessingStageHandle[i]->hDestHandle[j]->sExtDstDetails. \
                uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR] == eOpType))
                {
                    BDBG_ERR(("BTSC Encode post processing is added on DAC0. So Volume control cannot be done on DAC"));
            	    return BERR_TRACE (BERR_NOT_SUPPORTED);    
                }
            }
        }
    }
    return ret;
}

/**************************************************************************
Summary:
    Private function that checks if a destination or its sub-part is already
    present in the channel. Valid only for an output port destination.
**************************************************************************/
bool BRAP_P_IsDstAlreadyPresent(
    BRAP_Handle                     hRap,
    BRAP_AssociatedChannelHandle    hAssociatedCh,     
    BRAP_DstDetails                 *pDstDetails    
    )
{
    int             i = 0, j =0, k = 0;
    BRAP_OutputPort eOp = BRAP_OutputPort_eMax;
    
    BDBG_ENTER(BRAP_P_IsDstAlreadyPresent);
    
    if(BRAP_AudioDst_eOutputPort == pDstDetails->eAudioDst)
    {
        for(i=0; i<BRAP_OutputChannelPair_eMax; i++)
        {
            eOp = pDstDetails->uDstDetails.sOpDetails.eOutput[i];
            if(BRAP_OutputPort_eMax == eOp)
            {
                continue;
            }
            
            for(j=0; j<BRAP_P_MAX_DST_PER_RAPCH; j++)
            {
                if(BRAP_AudioDst_eOutputPort == hAssociatedCh->sDstDetails[j].sExtDstDetails.eAudioDst)
                {
                    for(k=0; k < BRAP_OutputChannelPair_eMax; k++)
                    {
                        if(eOp == hAssociatedCh->sDstDetails[j].sExtDstDetails.uDstDetails.
                            sOpDetails.eOutput[k])
                        {                                   
                            BDBG_ERR (("BRAP_P_IsDstAlreadyPresent: Requested"
                                " output port %d is already used by this"
                                " association", eOp));
                            return true;                                    
                        }/* if eOp */

                        if((true == hRap->sOutputSettings[eOp].bHbrEnable)&&
                           (true == hRap->sOutputSettings[eOp].bCompressed)&&
                           (true == hRap->sOutputSettings[hAssociatedCh->sDstDetails[j].
                           sExtDstDetails.uDstDetails.sOpDetails.eOutput[k]].bCompressed))
                        {
                            BDBG_ERR(("No other compressed DST can be added in the system"
                                      "eOp=%d already present in compressed mode",
                                      hAssociatedCh->sDstDetails[j].sExtDstDetails.uDstDetails.sOpDetails.eOutput[k]));
                            return true;
                        }

                        if((true == hRap->sOutputSettings[hAssociatedCh->sDstDetails[j].
                           sExtDstDetails.uDstDetails.sOpDetails.eOutput[k]].bHbrEnable)&&
                           (true == hRap->sOutputSettings[hAssociatedCh->sDstDetails[j].
                           sExtDstDetails.uDstDetails.sOpDetails.eOutput[k]].bCompressed)&&
                           (true == hRap->sOutputSettings[eOp].bCompressed))
                        {
                            BDBG_ERR(("No other compressed DST can be added in the system"
                                      "eOp=%d already present in compressed mode",
                                      hAssociatedCh->sDstDetails[j].sExtDstDetails.uDstDetails.sOpDetails.eOutput[k]));
                            return true;
                        }
                           
                    }/* for k */
                }/* if eAudioDst */
            }/* for j */
        }/* for i */
    }
    else if(BRAP_AudioDst_eRingBuffer == pDstDetails->eAudioDst)
    {
        /* TODO */
        
    }
    else
    {
        /* TODO : Assert since the control should not come here */
        
    }/* if eAudioDst */
    
    BDBG_LEAVE(BRAP_P_IsDstAlreadyPresent);
    return false;
}

/***************************************************************************
Summary:
    Private function that programs the downmixing coefficients for a mixer    
**************************************************************************/
BERR_Code BRAP_P_ProgramDownMixCoefficients(
    BRAP_ChannelHandle          hRapCh,         /* [in] Rap channel Handle */
    unsigned int                uiPath
)
{
    BERR_Code                       ret=BERR_SUCCESS;
    unsigned int                    chPair = 0, i=0,pp=0;
    unsigned int                    lvl=0,inChp =0;
    BRAP_P_MixingLevelProp          *pMixingLvl = NULL;
    bool                            bDwmixEn = false;
    BRAP_MIXER_P_Handle             hMixer = NULL;
    BRAP_P_MixerCoefficientsInfo    sMixingInfo;
    BRAP_Handle                     hRap = hRapCh->hRap;
    BRAP_DownMixingCoef             sDnMixCoef;
    unsigned int                    m =0, n=0;
    bool                            bProgrammingDone = false;
    
    BDBG_ENTER(BRAP_P_ProgramDownMixCoefficients);
    BDBG_ASSERT(hRapCh);

    sDnMixCoef.eInputMode = BRAP_OutputMode_eLast;
    sDnMixCoef.eOutputMode = BRAP_OutputMode_eLast;
    sDnMixCoef.bInputLfePresent = false;
    sDnMixCoef.bOutputLfePresent = false;

    /* Invalid Init sMixingInfo structure */
    BKNI_Memset(&sMixingInfo, 0, sizeof(BRAP_P_MixerCoefficientsInfo));
    for(i=0; i<BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
    {
        for(chPair =0 ; chPair < BRAP_OutputChannelPair_eMax; chPair++)
        {
            sMixingInfo.uiMixerIp[i][chPair] = BRAP_INVALID_VALUE;
        }
    }
    if(uiPath >= BRAP_P_MAX_PATHS_IN_A_CHAN)
    {
        BDBG_ERR(("BRAP_P_ProgramDownMixCoefficients: Could not find DecPCM path"));
        return BERR_TRACE(BERR_NOT_SUPPORTED);
    }    

    for(lvl=0;lvl< BRAP_RM_P_MAX_MIXING_LEVELS; lvl++)
    {
        pMixingLvl = &(hRapCh->pPath[uiPath]->sMixingLevels[lvl]);
        
        if((0 != lvl)&&
           (BRAP_OutputMode_eLast != pMixingLvl->eInputAudMode)&&
           (BRAP_OutputMode_eLast != pMixingLvl->eOutputAudMode))
        {
            ret = BRAP_P_DecideDwnMixing(pMixingLvl->eInputAudMode,
                                             pMixingLvl->bInputLfeOn,
                                             pMixingLvl->eOutputAudMode,
                                             pMixingLvl->bOutputLfeOn,
                                             &bDwmixEn);
            BDBG_MSG(("BRAP_P_DecideDwnMixing: inMode %d outMode %d bDwnMixEn %d ",
                pMixingLvl->eInputAudMode,pMixingLvl->eOutputAudMode,bDwmixEn));
            if(BERR_SUCCESS != ret)
            {
                BDBG_ERR(("BRAP_P_DecideDwnMixing returned %d", ret));
                return BERR_TRACE(ret);
            }
            if(true == bDwmixEn)
            {
                for(i =0 ; i<BRAP_P_MAX_DOWN_MIX_COEFF; i++)
                {
                    BDBG_MSG(("hRap->sDnMixCoeff[i=%d].eInputMode=%d"
                              "hRap->sDnMixCoeff[i].eOutputMode=%d"
                              "pMixingLvl->eInputAudMode=%d"
                              "pMixingLvl->eOutputAudMode=%d"
                              "hRap->sDnMixCoeff[i].bInputLfePresent=%d"
                              "hRap->sDnMixCoeff[i].bOutputLfePresent=%d"
                              "pMixingLvl->bInputLfeOn=%d"
                              "pMixingLvl->bOutputLfeOn=%d",
                              i,hRap->sDnMixCoeff[i].eInputMode,
                              hRap->sDnMixCoeff[i].eOutputMode,
                              pMixingLvl->eInputAudMode,
                              pMixingLvl->eOutputAudMode,
                              hRap->sDnMixCoeff[i].bInputLfePresent,
                              hRap->sDnMixCoeff[i].bOutputLfePresent,
                              pMixingLvl->bInputLfeOn,
                              pMixingLvl->bOutputLfeOn));

                    if((hRap->sDnMixCoeff[i].eInputMode == pMixingLvl->eInputAudMode)&&
                       (hRap->sDnMixCoeff[i].eOutputMode == pMixingLvl->eOutputAudMode)&&
                       (hRap->sDnMixCoeff[i].bInputLfePresent == pMixingLvl->bInputLfeOn)&&
                       (hRap->sDnMixCoeff[i].bOutputLfePresent== pMixingLvl->bOutputLfeOn))
                    {
                        sDnMixCoef = hRap->sDnMixCoeff[i];
                        break;
                    }
                }

                if(BRAP_OutputMode_eLast == sDnMixCoef.eInputMode)
                {
                    BDBG_ERR(("Coefficients not available for requested downmix"));
                    BDBG_ASSERT(0);
                }
                
                for(chPair =0 ; chPair < BRAP_OutputChannelPair_eMax; chPair++)
                {
                    for(pp=0;pp<BRAP_RM_P_MAX_PARALLEL_PATHS;pp++)
                    {
                        if (true == hRapCh->pPath[uiPath]->sMixer[lvl][chPair][pp].bValid)
                        {
                            hMixer = hRapCh->pPath[uiPath]->sMixer[lvl][chPair][pp].hMixer;
                            sMixingInfo.hMixer[0] = hMixer;

                            for(inChp =0;inChp<BRAP_OutputChannelPair_eMax;inChp++)
                            {
                                sMixingInfo.uiMixerIp[0][inChp] = 
                                hRapCh->pPath[uiPath]->sRsrcGrnt.sSrcMixerGrnt[lvl].
                                    sMixerGrant[chPair][pp].uiMixerInputId[inChp];

                                switch(chPair)
                                {
                                    case BRAP_OutputChannelPair_eLR:
                                        switch(inChp)
                                        {
                                            case BRAP_OutputChannelPair_eLR:
                                                m=0; n=0;
                                                break;
                                            case BRAP_OutputChannelPair_eLRSurround:
                                                m=0; n=2;
                                                break;
                                            case BRAP_OutputChannelPair_eCentreLF:
                                                m=0; n=4;
                                                break;
                                            case BRAP_OutputChannelPair_eLRRear:
                                                m=0; n=6;
                                                break;
                                            case BRAP_OutputChannelPair_eMax:
                                            default:
                                                BDBG_ASSERT(0);
                                        }
                                        break;

                                     case BRAP_OutputChannelPair_eLRSurround:
                                        switch(inChp)
                                        {
                                            case BRAP_OutputChannelPair_eLR:
                                                m=2; n=0;
                                                break;
                                            case BRAP_OutputChannelPair_eLRSurround:
                                                m=2; n=2;
                                                break;
                                            case BRAP_OutputChannelPair_eCentreLF:
                                                m=2; n=4;
                                                break;
                                            case BRAP_OutputChannelPair_eLRRear:
                                                m=2; n=6;
                                                break;
                                            case BRAP_OutputChannelPair_eMax:
                                            default:
                                                BDBG_ASSERT(0);
                                        }
                                        break;

                                     case BRAP_OutputChannelPair_eCentreLF:
                                        switch(inChp)
                                        {
                                            case BRAP_OutputChannelPair_eLR:
                                                m=4; n=0;
                                                break;
                                            case BRAP_OutputChannelPair_eLRSurround:
                                                m=4; n=2;
                                                break;
                                            case BRAP_OutputChannelPair_eCentreLF:
                                                m=4; n=4;
                                                break;
                                            case BRAP_OutputChannelPair_eLRRear:
                                                m=4; n=6;
                                                break;
                                            case BRAP_OutputChannelPair_eMax:
                                            default:
                                                BDBG_ASSERT(0);
                                        }
                                        break;
                                        
                                     case BRAP_OutputChannelPair_eLRRear:
                                        switch(inChp)
                                        {
                                            case BRAP_OutputChannelPair_eLR:
                                                m=6; n=0;
                                                break;
                                            case BRAP_OutputChannelPair_eLRSurround:
                                                m=6; n=2;
                                                break;
                                            case BRAP_OutputChannelPair_eCentreLF:
                                                m=6; n=4;
                                                break;
                                            case BRAP_OutputChannelPair_eLRRear:
                                                m=6; n=6;
                                                break;
                                            case BRAP_OutputChannelPair_eMax:
                                            default:
                                                BDBG_ASSERT(0);
                                        }
                                        break;
                                     default:
                                        BDBG_ASSERT(0);
                                }
                                if((BRAP_OutputMode_e3_2 == sDnMixCoef.eInputMode)&&
                                   (BRAP_OutputMode_e2_0 == sDnMixCoef.eOutputMode))
                                {
                                    sMixingInfo.sCoeff0[0][inChp].ui32Left  =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef5_1To2_0[m][n];
                                    sMixingInfo.sCoeff0[0][inChp].ui32Right =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef5_1To2_0[m][(n+1)];
                                    sMixingInfo.sCoeff1[0][inChp].ui32Left  =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef5_1To2_0[(m+1)][n];
                                    sMixingInfo.sCoeff1[0][inChp].ui32Right = 
                                        sDnMixCoef.uDnCoeff.ui32DnCoef5_1To2_0[(m+1)][(n+1)];
                                }
                                else if((BRAP_OutputMode_e3_4 == sDnMixCoef.eInputMode)&&
                                   (BRAP_OutputMode_e2_0 == sDnMixCoef.eOutputMode))
                                {
                                    sMixingInfo.sCoeff0[0][inChp].ui32Left  =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To2_0[m][n];
                                    sMixingInfo.sCoeff0[0][inChp].ui32Right =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To2_0[m][(n+1)];
                                    sMixingInfo.sCoeff1[0][inChp].ui32Left  =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To2_0[(m+1)][n];
                                    sMixingInfo.sCoeff1[0][inChp].ui32Right = 
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To2_0[(m+1)][(n+1)];
                                }
                                else if((BRAP_OutputMode_e3_4 == sDnMixCoef.eInputMode)&&
                                   (BRAP_OutputMode_e3_2 == sDnMixCoef.eOutputMode))
                                {
                                    sMixingInfo.sCoeff0[0][inChp].ui32Left  =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To5_1[m][n];
                                    sMixingInfo.sCoeff0[0][inChp].ui32Right =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To5_1[m][(n+1)];
                                    sMixingInfo.sCoeff1[0][inChp].ui32Left  =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To5_1[(m+1)][n];
                                    sMixingInfo.sCoeff1[0][inChp].ui32Right = 
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To5_1[(m+1)][(n+1)];
                                }
                                BDBG_MSG(("InputChp=%d, OutputChp=%d, m=%d,n=%d",chPair,inChp,m,n));
                                BDBG_MSG(("LeftCoeff0=0x%x, RightCoeff0=0x%x, LeftCoeff1=0x%x,RightCoeff1=0x%x",
                                  sMixingInfo.sCoeff0[0][inChp].ui32Left,sMixingInfo.sCoeff0[0][inChp].ui32Right,
                                  sMixingInfo.sCoeff1[0][inChp].ui32Left,sMixingInfo.sCoeff1[0][inChp].ui32Right));
                            }/* For inChp */

                            /* Call the Mixer API to program the coeffients for this 
                               channel pair */
                            ret = BRAP_MIXER_P_ProgramPingPongCoeff(&sMixingInfo,
                                                                    &bProgrammingDone);
                            if(BERR_SUCCESS != ret)
                            {
                                BDBG_ERR(("BRAP_P_ProgramCoefficients: Returned Error"));
                                return BERR_TRACE(ret);
                            }
                        }/* if bValid */
                    }/* for pp */
                }/* for chPair */
            }/* if bDwmixEn */
        }/* if eInputAudMode */
    }/* for lvl */
    BDBG_LEAVE(BRAP_P_ProgramDownMixCoefficients);
    return ret;
}

/**************************************************************************
Summary:
    Private function that returns the output sampling rate for the output 
    port(s) carried in pOpDetails.
**************************************************************************/
BAVC_AudioSamplingRate 
BRAP_P_GetSRFromOpDetails(
    BRAP_ChannelHandle      hRapCh,
    BRAP_OutputPortDetails  *pOpDetails
    )
{
    BAVC_AudioSamplingRate eSR = BAVC_AudioSamplingRate_eUnknown;
    BRAP_OutputPort eOp = BRAP_OutputPort_eMax;
    BRAP_OutputChannelPair eChP = BRAP_OutputChannelPair_eMax;
    
    BDBG_ENTER(BRAP_P_GetSRFromOpDetails);
    BDBG_ASSERT(pOpDetails);
    BDBG_ASSERT(hRapCh);
    
    for(eChP = 0; eChP < BRAP_OutputChannelPair_eMax; eChP++)
    {
        eOp = pOpDetails->eOutput[eChP];
        if(BRAP_OutputPort_eMax != eOp)
        {
            /* Got the output port */
            break;
        }
    }

    /* Get the corresponding sampling rate */
    if(eOp != BRAP_OutputPort_eMax)
    {
       eSR = hRapCh->hRap->sOutputSettings[eOp].eOutputSR;
    }

    BDBG_LEAVE(BRAP_P_GetSRFromOpDetails);
    return eSR;

}


#if (BRAP_OPEN_TIME_RBUF_ALLOCATION==1)

/***************************************************************************
Summary:
   This Funtion allocates device specific Rbuf Memory as per the settings
   provided in the device handle. 
***************************************************************************/
BERR_Code
BRAP_P_AllocateDeviceRBufPool(
    BRAP_Handle hRap
    )
{
    BERR_Code       ret = BERR_SUCCESS;
    unsigned int    i = 0, j = 0,k=0;
    BRAP_P_RBufMem  *pRBufMem = NULL;
    BRAP_P_RBufMem  sRBufMem;
    size_t          uiSize = 0;
    void *cacheAddr=NULL;    
    unsigned int uiNumHbrBuf=0;
        
    BDBG_ENTER(BRAP_P_AllocateDeviceRBufPool);

    /* pExtRBufPoolSettings */
    hRap->sDeviceRBufPool.pExtRBufPoolSettings = &(hRap->sSettings.sDeviceRBufPool);

    /* Invalid init */
    sRBufMem.bUsed = false;
    sRBufMem.pRBufPtr = NULL;
    sRBufMem.uiSize = 0;
    for(i=0; i < BRAP_ProcessingType_eMax; i++)
    {
        for(j = 0; j < BRAP_OutputChannelPair_eMax*2; j++)
        {
            hRap->sDeviceRBufPool.sDestRBuf[j] = sRBufMem;
        }/* for j */
    }/* for i */

    for(i=0; i < BRAP_MAX_DEVICE_INPUT_BUFFER; i++)
    {
        hRap->sDeviceRBufPool.sInputBuffer[i]= sRBufMem;
    }
    for(i=0; i < BRAP_MAX_DEVICE_OUTPUT_BUFFER; i++)
    {    
        hRap->sDeviceRBufPool.sOutputBuffer[i] = sRBufMem;
    }


    for (i = 0; i < BRAP_NUM_HBR_BUFFERS; i++)
    {
        hRap->sDeviceRBufPool.sHbrRBuf[i] = sRBufMem;
    }

        /* Validate */
    if(hRap->sSettings.sDeviceRBufPool.uiNumPostMixingInputBuffers > BRAP_MAX_DEVICE_INPUT_BUFFER)
    {
        BDBG_ERR(("BRAP_P_AllocateDeviceRBufPool: uiMaxNumInputBuffer=%d "
                    "exceeds max permissible %d",
        hRap->sSettings.sDeviceRBufPool.uiNumPostMixingInputBuffers,
        BRAP_MAX_DEVICE_INPUT_BUFFER));
        ret = BERR_TRACE(BERR_NOT_SUPPORTED);
        goto free;
    }

    if(hRap->sSettings.sDeviceRBufPool.uiNumPostMixingOutputBuffers > BRAP_MAX_DEVICE_OUTPUT_BUFFER)
    {
        BDBG_ERR(("BRAP_P_AllocateDeviceRBufPool: uiMaxNumOutputBuffer=%d "
                    "exceeds max permissible %d",
        hRap->sSettings.sDeviceRBufPool.uiNumPostMixingOutputBuffers,
        BRAP_MAX_DEVICE_OUTPUT_BUFFER));
        ret = BERR_TRACE(BERR_NOT_SUPPORTED);
        goto free;
    }

    /* Note: Every audio processing can have different rbuf size requirements */
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)
    uiSize = BRAP_RBUF_P_DEFAULT_DELAY_RBUF_SIZE;
#else
    uiSize = BRAP_RBUF_P_DEFAULT_SIZE; 
#endif

    for(j = 0; j < hRap->sSettings.sDeviceRBufPool.uiNumPostMixingInputBuffers; j++)
    {
        pRBufMem = &(hRap->sDeviceRBufPool.sInputBuffer[j]);

        pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRap, uiSize, 8, 0);
        if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
        {
            ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
            goto free;
        }

        /* Update size */
        pRBufMem->uiSize = uiSize;

        /* Mark as free */
        pRBufMem->bUsed = false;
    } /* for j */

    for(j = 0; j < hRap->sSettings.sDeviceRBufPool.uiNumPostMixingOutputBuffers; j++)
    {
        pRBufMem = &(hRap->sDeviceRBufPool.sOutputBuffer[j]);

        pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRap, uiSize, 8, 0);
        if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
        {
            ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
            goto free;
        }
        /* Update size */
        pRBufMem->uiSize = uiSize;

        /* Mark as free */
        pRBufMem->bUsed = false;
    } /* for j */            


    /* sDestRBuf */
    for(i = 0,k=0; i < BRAP_OutputChannelPair_eMax; i++)
    {
        if(0 == hRap->sSettings.sDeviceRBufPool.uiMaxNumRBuf[i])
        {
            continue;
        }
            
        /* Validate */
        if(hRap->sSettings.sDeviceRBufPool.uiMaxNumRBuf[i] > 
            BRAP_RM_P_MAX_RBUFS_PER_DSTCH)
        {
            BDBG_ERR(("BRAP_P_AllocateDeviceRBufPool: uiMaxNumOutChPairs[%d]=%d "
                "exceeds max permissible %d",i,
                hRap->sSettings.sDeviceRBufPool.uiMaxNumRBuf[i],
                BRAP_RM_P_MAX_RBUFS_PER_DSTCH));
            ret = BERR_TRACE(BERR_NOT_SUPPORTED);
            goto free;
        }
		pRBufMem = &(hRap->sDeviceRBufPool.sDestRBuf[k++]);
        uiSize = hRap->sSettings.sDeviceRBufPool.sDstBufSettings[i].uiSize; 
	    uiSize = (uiSize == 0) ? BRAP_RBUF_P_DEFAULT_SIZE : uiSize;
        if(hRap->sSettings.sDeviceRBufPool.sDstBufSettings[i].pLeftBufferStart != NULL)
        {
            pRBufMem->pRBufPtr = hRap->sSettings.sDeviceRBufPool.sDstBufSettings[i].pLeftBufferStart;
        }
        else
        {
            pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRap, uiSize, 8, 0);
            if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
            {
                ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
                goto free;
            }
        }
        pRBufMem->uiSize = uiSize;
        pRBufMem->bUsed = false;
        BMEM_Heap_ConvertAddressToCached(hRap->hHeap, pRBufMem->pRBufPtr,(void **)&cacheAddr);
        BMEM_Heap_FlushCache(hRap->hHeap,cacheAddr, uiSize);
        if(hRap->sSettings.sDeviceRBufPool.uiMaxNumRBuf[i] == BRAP_RM_P_MAX_RBUFS_PER_DSTCH)
        {
   			pRBufMem = &(hRap->sDeviceRBufPool.sDestRBuf[k++]);
            if(hRap->sSettings.sDeviceRBufPool.sDstBufSettings[i].pRightBufferStart != NULL)
            {
                pRBufMem->pRBufPtr = hRap->sSettings.sDeviceRBufPool.sDstBufSettings[i].pRightBufferStart;
            }
            else
            {
                pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRap, uiSize, 8, 0);
                if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
                {
                    ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
                    goto free;
                }
            }
			pRBufMem->uiSize = uiSize;
	        pRBufMem->bUsed = false;
            BMEM_Heap_ConvertAddressToCached(hRap->hHeap, pRBufMem->pRBufPtr,(void **)&cacheAddr);
            BMEM_Heap_FlushCache(hRap->hHeap,cacheAddr, uiSize);            
        }
    }

    if(true==hRap->sSettings.sDeviceRBufPool.bHbrMode)
    {
        uiNumHbrBuf += BRAP_NUM_BUFFER_FOR_DDP_PASSTHRU;
    }
#ifdef RAP_BTSC_SUPPORT
    uiNumHbrBuf += BRAP_NUM_BUFFER_FOR_BTSC;
#endif
    for (i = 0; i < uiNumHbrBuf; i++)
    {
        pRBufMem = &(hRap->sDeviceRBufPool.sHbrRBuf[i]);
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)
        pRBufMem->pRBufPtr = (void *) BRAP_P_AllocAligned(hRap, BRAP_P_HBR_DELAY_RBUF_SIZE, 8, 0);
        if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
        {
            ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
            goto free;
        }
        pRBufMem->uiSize = BRAP_P_HBR_DELAY_RBUF_SIZE;
        pRBufMem->bUsed = false;
#else
        pRBufMem->pRBufPtr = (void *) BRAP_P_AllocAligned(hRap, BRAP_P_HBR_RBUF_SIZE, 8, 0);
        if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
        {
            ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
            goto free;
        }
        pRBufMem->uiSize = BRAP_P_HBR_RBUF_SIZE;
        pRBufMem->bUsed = false;
#endif            
    }
    
    if(BERR_SUCCESS == ret)
        goto exit;
    
free:
    BRAP_P_FreeDeviceRBufPool(hRap);
    
exit:

    /* Debugging messages */
    BDBG_MSG(("\n\n Device Memory Allocation Details ::"));
    for(i=0; i < BRAP_MAX_DEVICE_INPUT_BUFFER; i++)
    {
        BDBG_MSG(("\n sInputBuffer[%d]:",i));
        if(hRap->sDeviceRBufPool.sInputBuffer[i].pRBufPtr)
        {
            BDBG_MSG(("\n\t\t sInRBuf[%d].pLeftRBufPtr = %p"
                "\n\t\t sInRBuf[].bUsed = %d"
                "\n\t\t sInRBuf[].uiSize = %d",i,
            hRap->sDeviceRBufPool.sInputBuffer[i].pRBufPtr,
            hRap->sDeviceRBufPool.sInputBuffer[i].bUsed,
            hRap->sDeviceRBufPool.sInputBuffer[i].uiSize));
        }
    }
    
    for(i=0; i < BRAP_MAX_DEVICE_OUTPUT_BUFFER; i++)
    {        
        if(hRap->sDeviceRBufPool.sOutputBuffer[i].pRBufPtr)
        {
            BDBG_MSG(("\n\t\t sOutRBuf[%d].pLeftRBufPtr = %p"
                "\n\t\t sOutRBuf[].bUsed = %d"
                "\n\t\t sOutRBuf[].uiSize = %d",i,
            hRap->sDeviceRBufPool.sOutputBuffer[i].pRBufPtr,
            hRap->sDeviceRBufPool.sOutputBuffer[i].bUsed,
            hRap->sDeviceRBufPool.sOutputBuffer[i].uiSize));
        }
    }/* for i */
    
    for(j = 0; j < BRAP_OutputChannelPair_eMax*2; j++)
    {
        if(hRap->sDeviceRBufPool.sDestRBuf[j].pRBufPtr)
        {
            BDBG_MSG(("\tsDestRBuf[%d]:"
                "\n\t\t sDestRBuf[].pLeftRBufPtr = %p"
                "\n\t\t sDestRBuf[].bUsed = %d"
                "\n\t\t sDestRBuf[].uiSize = %d", j,
            hRap->sDeviceRBufPool.sDestRBuf[j].pRBufPtr,
            hRap->sDeviceRBufPool.sDestRBuf[j].bUsed,
            hRap->sDeviceRBufPool.sDestRBuf[j].uiSize));       
        }
    }/* for j */
    
    for (j = 0; j < uiNumHbrBuf; j++)
    {
        if(hRap->sDeviceRBufPool.sHbrRBuf[j].pRBufPtr)
        {
            BDBG_MSG(("\tsDestRBuf[%d]:"
                "\n\t\t sHbrRBuf[].pLeftRBufPtr = %p"
                "\n\t\t sHbrRBuf[].bUsed = %d"
                "\n\t\t sHbrRBuf[].uiSize = %d", j,
            hRap->sDeviceRBufPool.sHbrRBuf[j].pRBufPtr,
            hRap->sDeviceRBufPool.sHbrRBuf[j].bUsed,
            hRap->sDeviceRBufPool.sHbrRBuf[j].uiSize));       
        }
    }/* for j */        

    
    BDBG_LEAVE(BRAP_P_AllocateDeviceRBufPool);
    return ret;
}

/***************************************************************************
Summary:
   This Funtion frees device specific Rbuf Memory.
***************************************************************************/
void
BRAP_P_FreeDeviceRBufPool(
    BRAP_Handle hRap
    )
{
    unsigned int    i = 0, j = 0;
    BRAP_P_RBufMem  sRBufMem;
        
    BDBG_ENTER(BRAP_P_FreeDeviceRBufPool);
    BDBG_ASSERT(hRap);

    /* Invalid init */
    sRBufMem.bUsed = false;
    sRBufMem.pRBufPtr = NULL;
    sRBufMem.uiSize = 0;
    
    /* sInRBuf */    
    for(i=0; i < BRAP_MAX_DEVICE_INPUT_BUFFER; i++)
    {
        if(hRap->sDeviceRBufPool.sInputBuffer[i].pRBufPtr != NULL)
        {
            BRAP_P_Free(hRap,
            hRap->sDeviceRBufPool.sInputBuffer[i].pRBufPtr);
        }
        hRap->sDeviceRBufPool.sInputBuffer[i] = sRBufMem;          
    }
    /* sOutRBuf */
    for(i = 0; i < BRAP_MAX_DEVICE_OUTPUT_BUFFER; i++)
    {  
        if(hRap->sDeviceRBufPool.sOutputBuffer[i].pRBufPtr != NULL)
        {
            BRAP_P_Free(hRap,
            hRap->sDeviceRBufPool.sOutputBuffer[i].pRBufPtr);                
        }
        hRap->sDeviceRBufPool.sOutputBuffer[i] = sRBufMem;            

    }/* for i */
            
	for(j = 0; j < BRAP_OutputChannelPair_eMax*2; j++)
    {
            /* sDestRBuf */
        if(hRap->sDeviceRBufPool.sDestRBuf[j].pRBufPtr != NULL
			&& hRap->sSettings.sDeviceRBufPool.sDstBufSettings[j/2].pLeftBufferStart == NULL)
        {
            BRAP_P_Free(hRap,hRap->sDeviceRBufPool.sDestRBuf[j].pRBufPtr);
        }
        hRap->sDeviceRBufPool.sDestRBuf[j] = sRBufMem;

        j++;
        if(j >= BRAP_OutputChannelPair_eMax*2)
        {
            BDBG_ERR(("j should be less than %d",BRAP_OutputChannelPair_eMax*2));        
            return;
        }
        if(hRap->sDeviceRBufPool.sDestRBuf[j].pRBufPtr != NULL
			&& hRap->sSettings.sDeviceRBufPool.sDstBufSettings[j/2].pRightBufferStart == NULL)
        {
            BRAP_P_Free(hRap,hRap->sDeviceRBufPool.sDestRBuf[j].pRBufPtr);
        }
        hRap->sDeviceRBufPool.sDestRBuf[j] = sRBufMem;
	}

    for (i=0; i < BRAP_NUM_HBR_BUFFERS; i++)
    {
        if (hRap->sDeviceRBufPool.sHbrRBuf[i].pRBufPtr!=NULL)
        {
            BRAP_P_Free(hRap,hRap->sDeviceRBufPool.sHbrRBuf[i].pRBufPtr);
        }
        hRap->sDeviceRBufPool.sHbrRBuf[i] = sRBufMem;
    }
	
    /* pExtRBufPoolSettings */
    hRap->sDeviceRBufPool.pExtRBufPoolSettings = NULL; /*will doing like this free the memory??? */

    BDBG_LEAVE(BRAP_P_FreeDeviceRBufPool);
    return;
}

/***************************************************************************
Summary:
   This Funtion allocates channel specific Rbuf Memory as per the settings 
   provided in the channel handle.   
***************************************************************************/
BERR_Code
BRAP_P_AllocateChannelRBufPool(
    BRAP_ChannelHandle hRapCh
    )
{
    BERR_Code       ret = BERR_SUCCESS;
    unsigned int    i = 0, j = 0,k=0;
    BRAP_P_RBufMem  *pRBufMem = NULL;
    BRAP_P_RBufMem  sRBufMem;
    bool            bAllocateBothLR = false;
    size_t          uiSize = 0;
        
    BDBG_ENTER(BRAP_P_AllocateChannelRBufPool);

    /* Invalid init */
    sRBufMem.bUsed = false;
    sRBufMem.pRBufPtr = NULL;
    sRBufMem.uiSize = 0;
    for(i=0; i < BRAP_MAX_FW_PROC_BRANCHES; i++)
    {
        for(j = 0; j < BRAP_MAX_OUT_CH_PER_FW_PROC_BRANCH; j++)
        {
            hRapCh->sChanRBufPool.sDecOutRBuf[i][j] = sRBufMem;
        }/* for j */
    }/* for i */

    for(i=0; i < BRAP_MAX_DEC_CHAN_WITH_CAPPORT_SOURCE; i++)
    {
        for(j = 0; j < BRAP_MAX_IN_CH_PER_FW_PROC_BRANCH; j++)
        {
            hRapCh->sChanRBufPool.sDecInRBuf[i][j] = sRBufMem;
        }/* for j */
    }/* for i */
	
    for(i=0; i < BRAP_P_MAX_RBUF_PER_PBCH; i++)
    {
    	hRapCh->sChanRBufPool.sPbRBuf[i] = sRBufMem;
    }/* for i */

  	/* sDecOutRBuf */
    for(i=0; i < BRAP_MAX_FW_PROC_BRANCHES; i++)
    {
        /* Validate */
        if(hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumOutChPairs[i] > 
            BRAP_MAX_OUT_CHPAIRS_PER_FW_PROC_BRANCH)
        {
            BDBG_ERR(("BRAP_P_AllocateChannelRBufPool: uiMaxNumOutChPairs[%d]=%d "
                "exceeds max permissible %d",i,
                hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumOutChPairs[i],
                BRAP_MAX_OUT_CHPAIRS_PER_FW_PROC_BRANCH));
            ret = BERR_TRACE(BERR_NOT_SUPPORTED);
            goto free;
        }

         /* Incoming channel pairs for an audio processing type */
        bAllocateBothLR = true;

        /* Note: Every audio processing can have different rbuf size requirements */
        if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
        {
            uiSize = BRAP_PB_P_RBUF_DEFAULT_SIZE;
        }
        else
        {
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)
            if(true == hRapCh->bIndepDelayEnabled)
            {
        	    uiSize = BRAP_RBUF_P_DEFAULT_DELAY_RBUF_SIZE;
            }
            else
            {
    	    uiSize = BRAP_RBUF_P_DEFAULT_SIZE;
        }
#else
       	    uiSize = BRAP_RBUF_P_DEFAULT_SIZE;
#endif
        }
         

        for(j = 0,k=0; j < hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumOutChPairs[i]; j++)
        {
            pRBufMem = &(hRapCh->sChanRBufPool.sDecOutRBuf[i][k++]);

            /* Allocate Left */
            pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRapCh->hRap, uiSize, 8, 0);
            if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
            {
                ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
                goto free;
            }
            /* Update size */
            pRBufMem->uiSize = uiSize;

            /* Mark as free */
            pRBufMem->bUsed = false;
			
            if(true == bAllocateBothLR)
            {
            	pRBufMem = &(hRapCh->sChanRBufPool.sDecOutRBuf[i][k++]);
                /* Allocate Right */
                pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRapCh->hRap, uiSize, 8, 0);
                if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
                {
                    ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
                    goto free;
                }
			    /* Update size */
	            pRBufMem->uiSize = uiSize;

	            /* Mark as free */
	            pRBufMem->bUsed = false;
            }/* if bAllocateBothLR */
        }/* for j */
    }/* for i */

    /* sDecInRBuf */
    for(i=0; i < BRAP_MAX_DEC_CHAN_WITH_CAPPORT_SOURCE; i++)
    {
        /* Validate */
        if(hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumInChPairs[i] > 
            BRAP_MAX_IN_CHPAIRS_PER_FW_PROC_BRANCH)
        {
            BDBG_ERR(("BRAP_P_AllocateChannelRBufPool: uiMaxNumInChPairs[%d]=%d "
                "exceeds max permissible %d",i,
                hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumInChPairs[i],
                BRAP_MAX_IN_CHPAIRS_PER_FW_PROC_BRANCH));
            ret = BERR_TRACE(BERR_NOT_SUPPORTED);
            goto free;
        }

         /* Incoming channel pairs for an audio processing type */
        bAllocateBothLR = true;

        /* Note: Every audio processing can have different rbuf size requirements */
        if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
        {
            uiSize = BRAP_PB_P_RBUF_DEFAULT_SIZE;
        }
        else
        {
    	    uiSize = BRAP_RBUF_P_DEFAULT_SIZE;
        } 

        for(j = 0,k=0; j < hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumInChPairs[i]; j++)
        {
            pRBufMem = &(hRapCh->sChanRBufPool.sDecInRBuf[i][k++]);

            /* Allocate Left */
            pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRapCh->hRap, uiSize, 8, 0);
            if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
            {
                ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
                goto free;
            }
            /* Update size */
            pRBufMem->uiSize = uiSize;

            /* Mark as free */
            pRBufMem->bUsed = false;
			
            if(true == bAllocateBothLR)
            {
   	            pRBufMem = &(hRapCh->sChanRBufPool.sDecInRBuf[i][k++]);
                /* Allocate Right */
                pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRapCh->hRap, uiSize, 8, 0);
                if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
                {
                    ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
                    goto free;
                }
	            /* Update size */
	            pRBufMem->uiSize = uiSize;

	            /* Mark as free */
	            pRBufMem->bUsed = false;
				
            }/* if bAllocateBothLR */
        }/* for j */
    }/* for i */

    /* sPbRBuf */	
    if(hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumRBuf != 0)
    {
	    /* Validate */
	    if(hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumRBuf > 
	        BRAP_P_MAX_RBUF_PER_PBCH)
	    {
	        BDBG_ERR(("BRAP_P_AllocateChannelRBufPool: uiMaxNumOutChPairs[%d]=%d "
	            "exceeds max permissible %d",i,
	            hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumRBuf,
	            BRAP_P_MAX_RBUF_PER_PBCH));
	        ret = BERR_TRACE(BERR_NOT_SUPPORTED);
	        goto free;
	    }

		for(j = 0 ; j < hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumRBuf; j++)
	    {
		    pRBufMem = &(hRapCh->sChanRBufPool.sPbRBuf[j]);
		    uiSize = hRapCh->sChanRBufPool.sExtRBufPoolSettings.sBufSettings.uiSize; 
            if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
            {
                uiSize = (uiSize == 0) ? BRAP_PB_P_RBUF_DEFAULT_SIZE : uiSize;
            }
            else
            {
        	    uiSize = (uiSize == 0) ? BRAP_RBUF_P_DEFAULT_SIZE : uiSize;
            }
		    
		    if(hRapCh->sChanRBufPool.sExtRBufPoolSettings.sBufSettings.pLeftBufferStart != NULL)
		    {
		        pRBufMem->pRBufPtr = hRapCh->sChanRBufPool.sExtRBufPoolSettings.sBufSettings.pLeftBufferStart;
		    }
		    else
		    {
		        pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRapCh->hRap, uiSize, 8, 0);
		        if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
		        {
		            ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
		            goto free;
		        }
		    }

   		    pRBufMem->uiSize = uiSize;
		    pRBufMem->bUsed = false;

/* What is the purpose of this code? Is it required?
   Todo: Remove after found unharmful. */            
#if 0
			/*j++;*/
		    if(hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumRBuf == BRAP_P_MAX_RBUF_PER_PBCH)
		    {
 		    	pRBufMem = &(hRapCh->sChanRBufPool.sPbRBuf[j]);
		        if(hRapCh->sChanRBufPool.sExtRBufPoolSettings.sBufSettings.pRightBufferStart != NULL)
		        {
		            pRBufMem->pRBufPtr = hRapCh->sChanRBufPool.sExtRBufPoolSettings.sBufSettings.pRightBufferStart;
		        }
		        else
		        {
		            pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRapCh->hRap, uiSize, 8, 0);
		            if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
		            {
		                ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
		                goto free;
		            }
		        }
			    pRBufMem->uiSize = uiSize;
			    pRBufMem->bUsed = false;
		    }
#endif
		}
    }
    if(BERR_SUCCESS == ret)
        goto exit;
    
free:
    BRAP_P_FreeChannelRBufPool(hRapCh);
    
exit:

    /* Debugging messages */
	BDBG_MSG(("\n\n Channel Memory Allocation Details ::"));
	for(i=0; i < BRAP_MAX_FW_PROC_BRANCHES; i++)
    {
        BDBG_MSG(("\tsDecOutRBuf[%d]:",i));
        for(j = 0; j < BRAP_MAX_OUT_CH_PER_FW_PROC_BRANCH; j++)
        {
            if(hRapCh->sChanRBufPool.sDecOutRBuf[i][j].pRBufPtr)
            {
    			BDBG_MSG(("\n\t\t sDecOutRBuf[%d][%d].pRBufPtr = %p"
    			"\n\t\t sDecOutRBuf[][].bUsed = %d"
    			"\n\t\t sDecOutRBuf[][].uiSize = %d",i,j,
    			hRapCh->sChanRBufPool.sDecOutRBuf[i][j].pRBufPtr,
    			hRapCh->sChanRBufPool.sDecOutRBuf[i][j].bUsed,
    			hRapCh->sChanRBufPool.sDecOutRBuf[i][j].uiSize));
            }
        }/* for j */
    }/* for i */

    for(i=0; i < BRAP_MAX_DEC_CHAN_WITH_CAPPORT_SOURCE; i++)
    {
            BDBG_MSG(("\tsDecInRBuf[%d]:",i));
        for(j = 0; j < BRAP_MAX_IN_CH_PER_FW_PROC_BRANCH; j++)
        {
            if(hRapCh->sChanRBufPool.sDecInRBuf[i][j].pRBufPtr)
            {
			BDBG_MSG(("\n\t\t sDecInRBuf[%d][%d].pRBufPtr = %p"
			"\n\t\t sDecInRBuf[][].bUsed = %d"
			"\n\t\t sDecInRBuf[][].uiSize = %d",i,j,
			hRapCh->sChanRBufPool.sDecInRBuf[i][j].pRBufPtr,
			hRapCh->sChanRBufPool.sDecInRBuf[i][j].bUsed,
			hRapCh->sChanRBufPool.sDecInRBuf[i][j].uiSize));
            }
        }/* for j */
    }/* for i */
	
    for(i=0; i < BRAP_P_MAX_RBUF_PER_PBCH; i++)
    {
        if(hRapCh->sChanRBufPool.sPbRBuf[i].pRBufPtr)
        {
		BDBG_MSG(("\n\t\t sPbRBuf[%d].pLeftRBufPtr = %p"
		"\n\t\t sPbRBuf[].bUsed = %d"
		"\n\t\t sPbRBuf[].uiSize = %d",i,
		hRapCh->sChanRBufPool.sPbRBuf[i].pRBufPtr,
		hRapCh->sChanRBufPool.sPbRBuf[i].bUsed,
		hRapCh->sChanRBufPool.sPbRBuf[i].uiSize));
        }
    }/* for i */

    BDBG_LEAVE(BRAP_P_AllocateChannelRBufPool);
    return ret;
}

/***************************************************************************
Summary:
   This Funtion frees channel specific Rbuf Memory.
***************************************************************************/
void
BRAP_P_FreeChannelRBufPool(
    BRAP_ChannelHandle hRapCh
    )
{
	unsigned int    i = 0, j = 0;
    BRAP_P_RBufMem  sRBufMem;
        
    BDBG_ENTER(BRAP_P_FreeChannelRBufPool);
    BDBG_ASSERT(hRapCh);

    /* Invalid init */
    sRBufMem.bUsed = false;
    sRBufMem.pRBufPtr = NULL;
    sRBufMem.uiSize = 0;
    
   for(i=0; i < BRAP_MAX_FW_PROC_BRANCHES; i++)
    {
        for(j = 0; j < BRAP_MAX_OUT_CH_PER_FW_PROC_BRANCH; j++)
        {
            /* sDecOutRBuf */
            if(hRapCh->sChanRBufPool.sDecOutRBuf[i][j].pRBufPtr != NULL)
            {
                BRAP_P_Free(hRapCh->hRap,
                    hRapCh->sChanRBufPool.sDecOutRBuf[i][j].pRBufPtr);
            }
            hRapCh->sChanRBufPool.sDecOutRBuf[i][j] = sRBufMem;            
        
        }/* for j */
    }/* for i */

	for(i=0; i < BRAP_MAX_DEC_CHAN_WITH_CAPPORT_SOURCE; i++)
    {
        for(j = 0; j < BRAP_MAX_IN_CH_PER_FW_PROC_BRANCH; j++)
        {
            /* sDecInRBuf */
            if(hRapCh->sChanRBufPool.sDecInRBuf[i][j].pRBufPtr != NULL)
            {
                BRAP_P_Free(hRapCh->hRap,
                    hRapCh->sChanRBufPool.sDecInRBuf[i][j].pRBufPtr);
            }
            hRapCh->sChanRBufPool.sDecInRBuf[i][j] = sRBufMem;            
        
        }/* for j */
    }/* for i */
	
	for(i=0; i < BRAP_P_MAX_RBUF_PER_PBCH; i++)
    {
	 /* sDecInRBuf */
        if((hRapCh->sChanRBufPool.sPbRBuf[i].pRBufPtr != NULL )
			&& (hRapCh->sChanRBufPool.sExtRBufPoolSettings.sBufSettings.pLeftBufferStart == NULL))
        {
            BRAP_P_Free(hRapCh->hRap,
                hRapCh->sChanRBufPool.sPbRBuf[i].pRBufPtr);
        }
        hRapCh->sChanRBufPool.sPbRBuf[i] = sRBufMem;

		i++;
		if((hRapCh->sChanRBufPool.sPbRBuf[i].pRBufPtr != NULL )
			&& (hRapCh->sChanRBufPool.sExtRBufPoolSettings.sBufSettings.pRightBufferStart == NULL))
        {
            BRAP_P_Free(hRapCh->hRap,
                hRapCh->sChanRBufPool.sPbRBuf[i].pRBufPtr);
        }
        hRapCh->sChanRBufPool.sPbRBuf[i] = sRBufMem;
		
    }/* for i */
	
    /* pExtRBufPoolSettings */

    BDBG_LEAVE(BRAP_P_FreeChannelRBufPool);
    return;
}

#endif /* OPEN_TIME_RBUF_ALLOCATION */


/**************************************************************************
Summary:
    Private function that mallocs and invalid inits the pPath data structure.
**************************************************************************/
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
BERR_Code
BRAP_P_MallocPath(
    BRAP_ChannelHandle  hRapCh,         /* [in] */
    uint32_t uiPth,     /* [in] */
    BRAP_P_ObjectHandles **pPath /* [out] */    
    )
#else
BERR_Code
BRAP_P_MallocPath(
    BRAP_P_ObjectHandles **pPath /* [out] */
    )
#endif    
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_P_ObjectHandles    *pTempPath = NULL; 
    BRAP_P_SrcHandleInfo    sSrcInfo;
    BRAP_P_SrcEqHandleInfo  sSrcEqInfo;
    int i=0, j=0, k=0;
    
    BDBG_ENTER(BRAP_P_MallocPath);
    BDBG_ASSERT(pPath);

    *pPath = NULL;
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION        
    pTempPath = hRapCh->pMemPath[uiPth];
#else    
    /* Malloc path handle */
    pTempPath = (BRAP_P_ObjectHandles *)BKNI_Malloc(sizeof(BRAP_P_ObjectHandles));
    if(NULL == pTempPath)
    {
        BDBG_ERR(("pPath malloc failed"));
		return BERR_TRACE( BERR_OUT_OF_SYSTEM_MEMORY );
    }
    BKNI_Memset(pTempPath , 0, sizeof(BRAP_P_ObjectHandles));  
#endif
    /* RM Grant */
    BRAP_RM_P_InitResourceGrant(&(pTempPath->sRsrcGrnt),true);
    for(i = 0; i < BRAP_RM_P_MAX_SRC_IN_CASCADE; i++)
    {
        BRAP_P_InitSrcHandleInfo(&sSrcInfo, i);    
        BRAP_P_InitSrcEqHandleInfo (&sSrcEqInfo, i);
    }
    /* Invalid Init */
    pTempPath->eUsgPath = BRAP_P_UsgPath_eMax;
    pTempPath->uiDestcount = 0;
    
    for (i=0;i<BRAP_P_MAX_IN_PARALLEL_FMM_PATH;i++)
    {
        pTempPath->sInPathProp[i].uiPathIdx = BRAP_INVALID_VALUE;
    }

    pTempPath->uiSelfPathArrIdx = BRAP_INVALID_VALUE;

    for (i=0;i<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH;i++)
    {
        pTempPath->sOutPathProp[i].uiPathIdx = BRAP_INVALID_VALUE;
    }

    pTempPath->uiPthOpenCnt = 0;
    pTempPath->uiPthStartCnt = 0;
    
	pTempPath->hFmm = NULL;
    pTempPath->hDsp = NULL;
    pTempPath->hDspCh = NULL;
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNELS; i++)
    {
        pTempPath->hRBuf[i] = NULL;	
    }
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        BRAP_P_InitSrcChHandleInfo(&(pTempPath->sSrcCh[i]));
        BRAP_P_InitDstChHandleInfo(&(pTempPath->sDstCh[i]));
    }
    for(i = 0; i < BRAP_RM_P_MAX_MIXING_LEVELS; i++)
    {
        for(j = 0; j < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; j++)
        {
            for(k = 0; k < BRAP_RM_P_MAX_PARALLEL_PATHS; k++)
            {
                pTempPath->sSrc[i][j][k] = sSrcInfo;
                BRAP_P_InitMixerHandleInfo(&(pTempPath->sMixer[i][j][k]));
            }
        }
    }
    for(j = 0; j < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; j++)
    {
        for(k = 0; k < BRAP_RM_P_MAX_PARALLEL_PATHS; k++)
        {
            pTempPath->sSrcEq[j][k] = sSrcEqInfo;
        }
    }
    for(j = 0; j < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; j++)
    {
        for(k = 0; k < BRAP_RM_P_MAX_PARALLEL_PATHS; k++)
        {
            BRAP_P_InitOpHandleInfo(&(pTempPath->sOp[j][k]));
            BRAP_P_InitCapPortHandleInfo(&(pTempPath->sCapPort[j][k]));
        }
    }
    for(i = 0; i < BRAP_RM_P_MAX_MIXING_LEVELS; i++)
    {
        pTempPath->sMixingLevels[i] = sMixingLevelPropInvalid;
    }
    for(i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        pTempPath->pDstDetails[i] = NULL;
    }
    pTempPath->uiAssocId = BRAP_INVALID_VALUE;
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1) 
    pTempPath->uiMasterpathId = BRAP_INVALID_VALUE;
#endif
    /* Populate return handle */
    *pPath = pTempPath;    

    BDBG_LEAVE(BRAP_P_MallocPath);
    return ret;
}

/**************************************************************************
Summary:
    Private function that frees the pPath data structure. It returns the NULL
    pPath.
**************************************************************************/
void
BRAP_P_FreePath(
    BRAP_P_ObjectHandles **pPath /* [in] */
    )
{
    BDBG_ENTER(BRAP_P_FreePath);
    BDBG_ASSERT(pPath);
#ifndef BRAP_OPEN_TIME_PATH_ALLOCATION        
    BKNI_Free(*pPath);
#endif
    *pPath = NULL;

    BDBG_LEAVE(BRAP_P_FreePath);
    return;
}


/**************************************************************************
Summary:
    Private function that gets the current channel settings.
**************************************************************************/
BERR_Code
BRAP_P_GetCurrentChannelSettings (
	BRAP_ChannelHandle	    hRapCh,         /* [in] Decode channel handle */
	BRAP_ChannelSettings    *pChanSettings  /* [out] Current channel settings */
	)
{
    BERR_Code ret = BERR_SUCCESS;
    BDBG_ENTER(BRAP_P_GetCurrentChannelSettings);
    BDBG_ASSERT(hRapCh);
	BDBG_ASSERT(pChanSettings);

    pChanSettings->eChType = hRapCh->eChannelType;
    pChanSettings->eChSubType = hRapCh->eChannelSubType;
#if (BRAP_OPEN_TIME_RBUF_ALLOCATION == 1)
    pChanSettings->sChnRBufPool = hRapCh->sChanRBufPool.sExtRBufPoolSettings;
#endif

    BDBG_LEAVE(BRAP_P_GetCurrentChannelSettings);
    return ret;
}


/**************************************************************************
Summary:
    Private function that finds the matching reference path in a channel 
    handle and returns the started corresponding path index.
    If the path is not found, uiStartedPathId BRAP_INVALID_VALUE is returned.
**************************************************************************/
BERR_Code
BRAP_P_GetCorrespondingStartedPath(
    BRAP_ChannelHandle      hRefRapCh,
    unsigned int            uiRefPth,
    unsigned int            uiRefPathOutIdx,
    BRAP_ChannelHandle      hStartedRapCh,
    unsigned int            *uiStartedPathId )
{
    BERR_Code               ret = BERR_SUCCESS;
    unsigned int            uiPth = 0;
    BRAP_P_ObjectHandles    *pRefPath = NULL;
        
    BDBG_ENTER(BRAP_P_GetCorrespondingStartedPath);
    BDBG_MSG(("uiRefPth = %d uiRefPathOutIdx = %d", uiRefPth, uiRefPathOutIdx));

    BDBG_ASSERT(hStartedRapCh);
    BDBG_ASSERT(hRefRapCh);
    BDBG_ASSERT(uiStartedPathId);
    BSTD_UNUSED(uiRefPathOutIdx);
    
    pRefPath = hRefRapCh->pPath[uiRefPth];
    BDBG_ASSERT(pRefPath);

    *uiStartedPathId = BRAP_INVALID_VALUE;

    for(uiPth = 0; 
        (uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN) && (*uiStartedPathId == BRAP_INVALID_VALUE);
        uiPth++)
    {        
        if(NULL == hStartedRapCh->pPath[uiPth])
        {
            continue;
        }

        BDBG_MSG(("hStartedRapCh->pPath[uiPth=%d]->eUsgPath = %d pRefPath->eUsgPath = %d",
            uiPth, hStartedRapCh->pPath[uiPth]->eUsgPath, pRefPath->eUsgPath));        
        /* For the same self path */
        if(hStartedRapCh->pPath[uiPth]->eUsgPath == pRefPath->eUsgPath)
        {
#if 1
            /* Got the matching uiPth path */
            *uiStartedPathId = uiPth;
            break;
#else
            /* Is this extra logic required?? later?? */
            /* Verify if the out path in target path is same as the out path in 
               the reference path */
            for(uiOutPth=0; uiOutPth <BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; uiOutPth++)
            {
                uiTgtOutPthIdx = hStartedRapCh->pPath[uiPth]->sOutPathProp[uiOutPth].uiPathIdx;
                uiRfrOutPthIdx = pRefPath->sOutPathProp[uiRefPathOutIdx].uiPathIdx;
                
                BDBG_ERR(("uiTgtOutPthIdx = %d, uiRfrOutPthIdx = %d", 
                    uiTgtOutPthIdx,uiRfrOutPthIdx ));
                if((BRAP_INVALID_VALUE == uiTgtOutPthIdx) || 
                   (BRAP_INVALID_VALUE == uiRfrOutPthIdx))
                {
                    continue;
                }

                BDBG_ASSERT(hStartedRapCh->pPath[uiTgtOutPthIdx]);
                BDBG_ASSERT(hRefRapCh->pPath[uiTgtOutPthIdx]);

                BDBG_MSG((" hStartedRapCh->pPath[uiTgtOutPthIdx =%d]->eUsgPath = %d"
                   "hRefRapCh->pPath[uiTgtOutPthIdx =%d]->eUsgPath = %d",
                   uiTgtOutPthIdx, hStartedRapCh->pPath[uiTgtOutPthIdx]->eUsgPath,
                   uiTgtOutPthIdx, hRefRapCh->pPath[uiTgtOutPthIdx]->eUsgPath));
                   
                if(hStartedRapCh->pPath[uiTgtOutPthIdx]->eUsgPath == 
                   hRefRapCh->pPath[uiTgtOutPthIdx]->eUsgPath)
                {
                    /* Got the matching uiPth path */
                    *uiStartedPathId = uiPth;
                    break;
                }
            }/* for uiOutPth */        
#endif    
        }/* if eUsgPath */
    }/* for uiPth */

    BDBG_MSG(("GetCorrespondingStrtPath: *uiStartedPathId = %d",
        *uiStartedPathId));

    BDBG_LEAVE(BRAP_P_GetCorrespondingStartedPath);
    return ret;
}

/**************************************************************************
Summary:
    Private function that finds the PLL that can support a particular 
    sampling rate.
**************************************************************************/
BERR_Code
BRAP_P_GetPLLForSR(
    BRAP_ChannelHandle      hRapCh, /* [in] */
    BAVC_AudioSamplingRate  eSR,    /* [in] */
    BRAP_OP_Pll             *ePll   /* [out] */
    )
{
    BERR_Code           ret = BERR_SUCCESS;
    unsigned int        i = 0;
    BRAP_OP_P_Handle    hOp = NULL;
    BRAP_OP_Pll         eOpPll = BRAP_OP_Pll_eMax;
    BAVC_AudioSamplingRate  eOpBaseSR = BAVC_AudioSamplingRate_eUnknown;
    BAVC_AudioSamplingRate  eBaseSR = BAVC_AudioSamplingRate_eUnknown;
    
    BDBG_ENTER(BRAP_P_GetPLLForSR);
    *ePll = BRAP_OP_Pll_eMax;

    eBaseSR = BRAP_P_GetBaseSR(eSR);
    if(BAVC_AudioSamplingRate_eUnknown == eBaseSR)
    {
        return BERR_TRACE(BERR_NOT_SUPPORTED);
    }

    for(i=0; i < BRAP_RM_P_MAX_OUTPUTS; i++)
    {
        hOp = hRapCh->hRap->hFmm[0]->hOp[i];
        if(NULL == hOp)
        {
            continue;
        }

        if(hOp->uiStartCnt > 0)
        {
            switch(hOp->eOutputPort)
            {
                case BRAP_OutputPort_eI2s0:
                case BRAP_OutputPort_eI2s1:
                case BRAP_OutputPort_eI2s2:
                case BRAP_OutputPort_eI2s3:
                case BRAP_OutputPort_eI2s4:                    
                case BRAP_OutputPort_eI2s5:
                case BRAP_OutputPort_eI2s6:
                case BRAP_OutputPort_eI2s7:
                case BRAP_OutputPort_eI2s8:
                    eOpBaseSR = BRAP_P_GetBaseSR(hOp->eSamplingRate);                    
                    eOpPll = hRapCh->hRap->sOutputSettings[hOp->eOutputPort].
                        uOutputPortSettings.sI2sSettings.ePll;
                    break;
                case BRAP_OutputPort_eSpdif:
                case BRAP_OutputPort_eSpdif1:    
                    eOpBaseSR = BRAP_P_GetBaseSR(hOp->eSamplingRate);                    
                    eOpPll = hRapCh->hRap->sOutputSettings[hOp->eOutputPort].
                        uOutputPortSettings.sSpdifSettings.ePll;
                    break;
                default:
                    continue;
            }/* switch */
        }/* uiStartCnt */

        if(eOpBaseSR == eBaseSR)
        {
            *ePll = eOpPll;
            break;
        }
    }

    BDBG_LEAVE(BRAP_P_GetPLLForSR);
    return ret;    
}

/**************************************************************************
Summary:
    Private function that returns the base sampling rate for a given sampling 
    rate.
    
    Following are the base sampling rates:
        - 32 for (32, 64, 128) 
        - 48 for (48, 96, 192)
        - 44.1 for (44.1, 88.2, 176.4)    
**************************************************************************/
BAVC_AudioSamplingRate 
BRAP_P_GetBaseSR(
    BAVC_AudioSamplingRate eSR /* [in] */
    )
{
    BAVC_AudioSamplingRate eBaseSR = BAVC_AudioSamplingRate_eUnknown;
    BDBG_ENTER(BRAP_P_GetBaseSR);
    
	switch(eSR)
    {   
        case BAVC_AudioSamplingRate_e32k:
        case BAVC_AudioSamplingRate_e64k:
        case BAVC_AudioSamplingRate_e128k:
            eBaseSR = BAVC_AudioSamplingRate_e32k; 
            break;
        case BAVC_AudioSamplingRate_e44_1k:
        case BAVC_AudioSamplingRate_e88_2k:
        case BAVC_AudioSamplingRate_e176_4k:
            eBaseSR = BAVC_AudioSamplingRate_e44_1k;
            break;            
        case BAVC_AudioSamplingRate_e48k:
        case BAVC_AudioSamplingRate_e96k:
        case BAVC_AudioSamplingRate_e192k:
            eBaseSR = BAVC_AudioSamplingRate_e48k;
            break;            
        default:
            eBaseSR = BAVC_AudioSamplingRate_eUnknown;
            break;
    }
    
    BDBG_LEAVE(BRAP_P_GetBaseSR);
    return eBaseSR;
}

/**************************************************************************
Summary:
    Private function that returns true if eCapPort is an internal capPort.
**************************************************************************/
bool
BRAP_P_IsInternalCapPort(
    BRAP_CapInputPort       eCapPort
    )
{
    switch(eCapPort)
    {
    case BRAP_CapInputPort_eIntCapPort0:
    case BRAP_CapInputPort_eIntCapPort1:
    case BRAP_CapInputPort_eIntCapPort2:
    case BRAP_CapInputPort_eIntCapPort3:
    case BRAP_CapInputPort_eIntCapPort4:
    case BRAP_CapInputPort_eIntCapPort5:
    case BRAP_CapInputPort_eIntCapPort6:
    case BRAP_CapInputPort_eIntCapPort7:
        return true;
    default:
        return false;
    }
}


BERR_Code
BRAP_P_GetAssocId(
    BRAP_ChannelHandle  hRapCh,         /* [in] */
    BRAP_DstDetails     *pDstDetails,   /* [in] */
    unsigned int            *ui32AssocId
    )    
{
    BERR_Code ret = BERR_SUCCESS;
    BRAP_P_DstDetails   *pTmpDst = NULL;
    unsigned int uiDstId = 0,j=0;
    bool    flag=false;
    BDBG_ENTER(BRAP_P_GetAssocId);
    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(pDstDetails);

    BDBG_MSG(("pDstDetails = 0x%x",pDstDetails));
    for(j=0; j<BRAP_MAX_ASSOCIATED_GROUPS; j++)
    {
        BDBG_MSG(("j=%d hRapCh->uiAssociationId[j]=%d",j,hRapCh->uiAssociationId[j]));
        if(hRapCh->uiAssociationId[j] == BRAP_INVALID_VALUE)
            continue;
        
        for(uiDstId=0; uiDstId<BRAP_P_MAX_DST_PER_RAPCH; uiDstId++)
        {

            pTmpDst = &(hRapCh->hRap->sAssociatedCh[hRapCh->uiAssociationId[j]].sDstDetails[uiDstId]);
            BDBG_MSG(("uiDstId = %d pTmpDst=0x%x",uiDstId,&(pTmpDst->sExtDstDetails)));
            if(&(pTmpDst->sExtDstDetails) == pDstDetails)
            {
                *ui32AssocId = hRapCh->uiAssociationId[j];
                flag = true;
                break;
            }
        }
        if(flag == true)
        {
            break;
        }
    }
    
    BDBG_MSG(("BRAP_P_GetAssocId uiDstId=%d",uiDstId));
    if(uiDstId >= BRAP_P_MAX_DST_PER_RAPCH)
    {
        ret = BERR_TRACE(BERR_NOT_INITIALIZED);
    }
    
    BDBG_LEAVE(BRAP_P_GetAssocId);
    return ret;
}
BERR_Code
BRAP_P_GetPvtDstDetails(
    BRAP_ChannelHandle  hRapCh,         /* [in] */
    BRAP_DstDetails     *pDstDetails,   /* [in] */
    BRAP_P_DstDetails   *pPvtDstDetails, /* [out] */
    unsigned int            *ui32AssocId
    )    
{
    BERR_Code ret = BERR_SUCCESS;
    BRAP_P_DstDetails   *pTmpDst = NULL;
    unsigned int uiDstId = 0,j=0;
    bool    flag=false;
    BDBG_ENTER(BRAP_P_GetPvtDstDetails);
    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(pDstDetails);
    BDBG_ASSERT(pPvtDstDetails);

    for(j=0; j<BRAP_MAX_ASSOCIATED_GROUPS; j++)
    {
        BDBG_MSG(("j=%d hRapCh->uiAssociationId[j]=%d",j,hRapCh->uiAssociationId[j]));
        if(hRapCh->uiAssociationId[j] == BRAP_INVALID_VALUE)
            continue;
        
    for(uiDstId=0; uiDstId<BRAP_P_MAX_DST_PER_RAPCH; uiDstId++)
    {

            pTmpDst = &(hRapCh->hRap->sAssociatedCh[hRapCh->uiAssociationId[j]].sDstDetails[uiDstId]);
            BDBG_MSG(("j = %d pTmpDst=%x",j,&(pTmpDst->sExtDstDetails)));
        if(&(pTmpDst->sExtDstDetails) == pDstDetails)
        {
            *pPvtDstDetails = *pTmpDst;
                *ui32AssocId = hRapCh->uiAssociationId[j];
                flag = true;
                break;
            }
        }
        if(flag == true)
        {
            break;
        }
    }
    /* Taking the mute value from hRap since if app uses BRAP_SetOutputMute() call instead of BRAP_SetDestinationMute() the mute status 
                    will not be updated in destiantion details */
    if(pPvtDstDetails->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
    {
        for(j=0; j<BRAP_OutputChannelPair_eMax; j++) 
        {            
            if(pPvtDstDetails->sExtDstDetails.uDstDetails.sOpDetails.eOutput[j] != BRAP_OutputPort_eMax)
            {    
                pPvtDstDetails->bMute[j] = pPvtDstDetails->hAssociation->hRap->bOutputMute[pPvtDstDetails->sExtDstDetails.uDstDetails.sOpDetails.eOutput[j]];
            }
        }
    }

    BDBG_MSG(("BRAP_P_GetPvtDstDetails uiDstId=%d",uiDstId));
    if(uiDstId >= BRAP_P_MAX_DST_PER_RAPCH)
    {
        ret = BERR_TRACE(BERR_NOT_INITIALIZED);
    }
    
    BDBG_LEAVE(BRAP_P_GetPvtDstDetails);
    return ret;
}


/**************************************************************************
Summary:
    Private function that returns Spdif channel parametrs.
	If in the Path
		- Only SPDIF0 exist : return channel params of SPDIF0
		- Only SPDIF1 exist : return channel params of SPDIF1		
		- If both SPDIF0 and SPDIF1 exist : both should have same c-bit config 
			params. And any one of them is returned.
**************************************************************************/
BERR_Code BRAP_P_GetSpdifChanStatusParams(
	BRAP_ChannelHandle 				hRapCh,
	const unsigned int 				uiPth,
	BRAP_OP_SpdifChanStatusParams	*psSpdifChStatusParams,
	bool							*pbUpdateChStatusParams
)
{
  	BERR_Code               ret = BERR_SUCCESS;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    BRAP_OutputPort         eOp = BRAP_OutputPort_eMax;
    unsigned int            uiPp = 0;
	bool bSpdifEnable=false,bSpdif1Enable=false;
	BRAP_OP_SpdifChanStatusParams sSpdifParams,sSpdif1Params;
    
    BDBG_ENTER(BRAP_P_GetSpdifChanStatusParams);
	BDBG_ASSERT(hRapCh);
	BDBG_ASSERT(psSpdifChStatusParams);
	BDBG_ASSERT(pbUpdateChStatusParams);	
    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth]);
    
    for(uiPp=0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
	    for(eChPair = 0; eChPair < BRAP_OutputChannelPair_eMax; eChPair++)
	    {
	        BDBG_MSG(("BRAP_P_GetSpdifChanStatusParams: eChPair = %d", eChPair));
	        if((true == hRapCh->pPath[uiPth]->sOp[eChPair][uiPp].bValid) &&
	          (NULL != hRapCh->pPath[uiPth]->sOp[eChPair][uiPp].hOp))
	        {
	            eOp = hRapCh->pPath[uiPth]->sOp[eChPair][uiPp].hOp->eOutputPort;
	            BDBG_MSG(("BRAP_P_GetSpdifChanStatusParams: eOp = %d", eOp));        

	            if(true == hRapCh->hRap->bOpSettingsValid[eOp])
	            {
	               if(BRAP_OutputPort_eSpdif == eOp)
				   		bSpdifEnable = true;
				   else if(BRAP_OutputPort_eSpdif1 == eOp)
				   		bSpdif1Enable = true;
	            }
	            else
	            {
	                BDBG_ERR(("BRAP_P_GetSpdifChanStatusParams: OpPort %d not configured",
	                    eOp));
	                return BERR_TRACE(ret);
	            }        
	        }
	    }
    }/* for */

	if((true == bSpdifEnable) && (true == bSpdif1Enable))
	{
		sSpdifParams =  hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].sSpdifChanStatusParams;
		sSpdif1Params =  hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif1].sSpdifChanStatusParams;		

		if((sSpdifParams.bProfessionalMode != sSpdif1Params.bProfessionalMode) ||
		   (sSpdifParams.bSeparateLRChanNum != sSpdif1Params.bSeparateLRChanNum)||
		   (sSpdifParams.bSwCopyRight != sSpdif1Params.bSwCopyRight) ||
		   (sSpdifParams.ui16CategoryCode != sSpdif1Params.ui16CategoryCode) ||
		   (sSpdifParams.ui16ClockAccuracy != sSpdif1Params.ui16ClockAccuracy)||
		   (sSpdifParams.uiCGMS_A != sSpdif1Params.uiCGMS_A) )
		{
			BDBG_ERR(("BRAP_P_GetSpdifChanStatusParams:Spdif channel status params"
				" for output port SPDIF0 and SPDIF1 should be same if they carry same decoded data"));

			BDBG_ERR(("sSpdifParams.bProfessionalMode =%d , sSpdif1Params.bProfessionalMode =%d"
					  "sSpdifParams.bSeparateLRChanNum =%d , sSpdif1Params.bSeparateLRChanNum =%d"
					  "sSpdifParams.bSwCopyRight =%d , sSpdif1Params.bSwCopyRight =%d"
					  "sSpdifParams.ui16CategoryCode =%d , sSpdif1Params.ui16CategoryCode =%d"
					  "sSpdifParams.ui16ClockAccuracy =%d , sSpdif1Params.ui16ClockAccuracy =%d",
					  sSpdifParams.bProfessionalMode,sSpdif1Params.bProfessionalMode,
					  sSpdifParams.bSeparateLRChanNum,sSpdif1Params.bSeparateLRChanNum,
					  sSpdifParams.bSwCopyRight,sSpdif1Params.bSwCopyRight,
					  sSpdifParams.ui16CategoryCode,sSpdif1Params.ui16CategoryCode,
					  sSpdifParams.ui16ClockAccuracy,sSpdif1Params.ui16ClockAccuracy,
					  sSpdifParams.uiCGMS_A,sSpdif1Params.uiCGMS_A));

			return BERR_TRACE(BERR_NOT_SUPPORTED);
		}
		
		*psSpdifChStatusParams = 
                hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].sSpdifChanStatusParams;
		*pbUpdateChStatusParams =
			!( hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].bUseSpdifPackedChanStatusBits );
			
	}
	else if((false == bSpdif1Enable) && (true == bSpdifEnable))
	{
		*psSpdifChStatusParams = 
                hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].sSpdifChanStatusParams;
		*pbUpdateChStatusParams =
			!( hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].bUseSpdifPackedChanStatusBits );
	}
	else if((false == bSpdifEnable) && (true == bSpdif1Enable))
	{
		*psSpdifChStatusParams = 
                hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif1].sSpdifChanStatusParams;
		*pbUpdateChStatusParams =
			!( hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif1].bUseSpdifPackedChanStatusBits );
	}
	
    BDBG_LEAVE(BRAP_P_GetSpdifChanStatusParams);
    return ret;

}

BERR_Code BRAP_P_GetChannelForOpPort(
    const BRAP_Handle       hRap, 	        /* [in] The RAP Device handle */
    const BRAP_OutputPort   eOpType,        /* [in] Output port */    
    BRAP_ChannelHandle      *phChannel,     /* [out] Channel handle */
    BRAP_DSPCHN_Handle      *phDspCh        /* [out] DSP Channel handle */
    )
{
    BERR_Code               ret=BERR_SUCCESS;
    BRAP_ChannelHandle      hRapCh= NULL;
    int                     i=0,j=0,k=0;
    bool                    bFound = false;

    BDBG_ENTER(BRAP_P_GetChannelForOpPort);

    BDBG_ASSERT(hRap);
    BDBG_ASSERT(phChannel);

    /* Find the channel which is outputing to this port */
    for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
    {
        hRapCh = hRap->hRapDecCh[i];
        if ( hRapCh != NULL )
        {
            for(j=0;j<BRAP_P_MAX_DST_PER_RAPCH;j++)
            {
                if(NULL == hRapCh->pDstDetails[j])
                {
                    continue;
                }
                if(BRAP_AudioDst_eOutputPort != hRapCh->pDstDetails[j]->eAudioDst)
                {
                    continue;
                }
                for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                {
                    if(BRAP_OutputPort_eMax == hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k])
                    {
                        continue;
                    }
                    if(hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k] == eOpType)
                    {
                        bFound = true;
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
            if(true==bFound)
            {
                break;
            }
        }
    }
    if (false == bFound)
    {
        for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
        {
            hRapCh = hRap->hRapCapCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_DST_PER_RAPCH;j++)
                {
                    if(NULL == hRapCh->pDstDetails[j])
                    {
                        continue;
                    }
                    if(BRAP_AudioDst_eOutputPort != hRapCh->pDstDetails[j]->eAudioDst)
                    {
                        continue;
                    }
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        if(BRAP_OutputPort_eMax == hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k])
                        {
                            continue;
                        }
                        if(hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k] == eOpType)
                        {
                            bFound = true;
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
        }
    }
    if (false == bFound)
    {
        for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
        {
            hRapCh = hRap->hRapPbCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_DST_PER_RAPCH;j++)
                {
                    if(NULL == hRapCh->pDstDetails[j])
                    {
                        continue;
                    }
                    if(BRAP_AudioDst_eOutputPort != hRapCh->pDstDetails[j]->eAudioDst)
                    {
                        continue;
                    }
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        if(BRAP_OutputPort_eMax == hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k])
                        {
                            continue;
                        }
                        if(hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k] == eOpType)
                        {
                            bFound = true;
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
        }
    }

    /* If this output port is not found in any of the active channels, return
       Error */
    if(false == bFound)
    {
        BDBG_MSG(("BRAP_P_GetChannelForOpPort: The Output Port %d is not Active",eOpType));
        return BERR_TRACE(BERR_INVALID_PARAMETER);
    }

    /* Rap Channel found, find DSP Channel handle */
    bFound = false;
    for(i = 0; i < BRAP_P_MAX_PATHS_IN_A_CHAN; i++)
    {
        if(NULL == hRapCh->pPath[i])
            continue;
        for(j=0;j<BRAP_P_MAX_DST_PER_RAPCH;j++)
        {
            if(NULL == hRapCh->pPath[i]->pDstDetails[j])
            {
                continue;
            }
            if(BRAP_AudioDst_eOutputPort != hRapCh->pPath[i]->pDstDetails[j]->eAudioDst)
            {
                continue;
            }
            for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
            {
                if(BRAP_OutputPort_eMax == hRapCh->pPath[i]->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k])
                {
                    continue;
                }
                if(hRapCh->pPath[i]->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k] == eOpType)
                {
                    *phDspCh = hRapCh->pPath[i]->hDspCh;
                    bFound = true;
                    break;
                }
            }
            if(true==bFound)
            {
                break;
            }
        }
        if(true==bFound)
        {
            break;
        }
    }
    
    if(false == bFound)
    {
        BDBG_MSG(("BRAP_P_GetChannelForOpPort: DSPCH not found!"));
        BDBG_MSG(("BRAP_P_GetChannelForOpPort: PI should program the CBITs"));
    }

    *phChannel = hRapCh;
    BDBG_LEAVE(BRAP_P_GetChannelForOpPort);
    return ret;
}
/**************************************************************************
Summary:
    Private function that Resets the CHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK
    bit for the SrcCh which is unmasked to recieve the interrupt.
    Resetting this bit is a part of hardware workaround. For resetting the 
    bit, First set it to 0, then set the bit to 1 again
**************************************************************************/

void BRAP_P_ReArmFreeMarkInterrupt (
	BRAP_ChannelHandle	hRapch
	)
{
	BDBG_ENTER(BRAP_P_ReArmFreeMarkInterrupt);
	BDBG_ASSERT(hRapch);

    BKNI_EnterCriticalSection();
    BRAP_P_ReArmFreeMarkInterrupt_isr(hRapch);
    BKNI_LeaveCriticalSection();

    BDBG_LEAVE(BRAP_P_ReArmFreeMarkInterrupt);
    return;
}

/**************************************************************************
Summary:
	Isr version of BRAP_P_ReArmFreeMarkInterrupt.
**************************************************************************/


void BRAP_P_ReArmFreeMarkInterrupt_isr(
	BRAP_ChannelHandle	hRapch
	)
{
	uint32_t 	ui32RegVal =0x0,ui32ReArmBitFreeMark=0x0,ui32ReArmBitFullMark=0x0;
	int i=0,uiPth=0;
	
	BDBG_ENTER(BRAP_P_ReArmFreeMarkInterrupt_isr);
	BDBG_ASSERT(hRapch);
	
	if(BRAP_ChannelType_ePcmPlayback == hRapch->eChannelType)
	{
		for(i=0 ; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS ; i++)
		{
			if(hRapch->pPath[BRAP_P_UsgPath_eDecodePcm]->sRsrcGrnt.uiSrcChId[i] != (unsigned int) BRAP_RM_P_INVALID_INDEX)
			{
				ui32ReArmBitFreeMark |= (1 << hRapch->pPath[BRAP_P_UsgPath_eDecodePcm]->sRsrcGrnt.uiSrcChId[i]);
			}
		}
	}
		
	for(uiPth=0 ; uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN ; uiPth++)
	{

        if(NULL == hRapch->pPath[uiPth])
        {
            continue;
        }
		
        /* The first capture path is omitted as that case is for SPDIF HDMI In */
		if ( (uiPth !=0) && (BRAP_P_UsgPath_eCapture == hRapch->pPath[uiPth]->eUsgPath))
		{
			for(i=0 ; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS ; i++)
			{
				if(hRapch->pPath[uiPth]->sRsrcGrnt.uiDstChId[i] != (unsigned int) BRAP_RM_P_INVALID_INDEX)
				{
					ui32ReArmBitFullMark |= (1 << hRapch->pPath[uiPth]->sRsrcGrnt.uiDstChId[i]);
				}
			}
			break;
		}
	}
		
	/* First set 0 to Re-Arm bits of source channel and destination channels, then set them to 1 */
	ui32RegVal = BRAP_Read32_isr(hRapch->hRegister,BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK );
	ui32RegVal = (~ui32ReArmBitFreeMark) & ui32RegVal;
	ui32RegVal = (~(ui32ReArmBitFullMark<<8)) & ui32RegVal;
	BRAP_Write32_isr (hRapch->hRegister, BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK,ui32RegVal);


	ui32RegVal = BRAP_Read32_isr(hRapch->hRegister,BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK );
	ui32RegVal |= BCHP_FIELD_DATA(AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK, 
                    	REARM_FREEMARK, ui32ReArmBitFreeMark);
#if (BRAP_7550_FAMILY != 1)
	ui32RegVal |= BCHP_FIELD_DATA(AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK, 
                    	REARM_FULLMARK, ui32ReArmBitFullMark);	
#endif
	BRAP_Write32_isr (hRapch->hRegister,  
              			BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK,ui32RegVal);
	
	BDBG_LEAVE(BRAP_P_ReArmFreeMarkInterrupt_isr);
	return;
	

}

/**************************************************************************
Summary:
    Private function that Resets the CHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK
    bit for the Destination which is unmasked to recieve the interrupt.
    Resetting this bit is a part of hardware workaround. For resetting the 
    bit, First set it to 0, then set the bit to 1 again
**************************************************************************/

void BRAP_P_ReArmFullMarkInterrupt(
	BRAP_DestinationHandle        hDstHandle
	)
{
	BDBG_ENTER(BRAP_P_ReArmFullMarkInterrupt);
	BDBG_ASSERT(hDstHandle);

    BKNI_EnterCriticalSection();
    BRAP_P_ReArmFullMarkInterrupt_isr(hDstHandle);
    BKNI_LeaveCriticalSection();

    BDBG_LEAVE(BRAP_P_ReArmFullMarkInterrupt);
    return;
}

/**************************************************************************
Summary:
	Isr version of BRAP_P_ReArmFullMarkInterrupt.
**************************************************************************/
void BRAP_P_ReArmFullMarkInterrupt_isr(
	BRAP_DestinationHandle        hDstHandle
	)
{
	uint32_t 	        ui32RegVal =0x0,ui32ReArmBitFullMark=0x0;
	unsigned int        uichannelpair = 0;    
	
	BDBG_ENTER(BRAP_P_ReArmFullMarkInterrupt_isr);
	BDBG_ASSERT(hDstHandle);

    for (uichannelpair = 0; uichannelpair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; uichannelpair++)
	{
		if (hDstHandle->sExtDstDetails.uDstDetails.sRBufDetails.uiDstChId[uichannelpair] != (unsigned int)BRAP_RM_P_INVALID_INDEX)
		{
		    ui32ReArmBitFullMark |= (1 << hDstHandle->sExtDstDetails.uDstDetails.sRBufDetails.uiDstChId[uichannelpair]);    		
	    }
    }
	/* First set 0 to Re-Arm bits corresponding to destination channel id, then set them to 1 */
	ui32RegVal = BRAP_Read32_isr(hDstHandle->hAssociation->hRap->hRegister,BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK );
	ui32RegVal = (~(ui32ReArmBitFullMark<<8)) & ui32RegVal;
	BRAP_Write32_isr (hDstHandle->hAssociation->hRap->hRegister, BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK,ui32RegVal);


	ui32RegVal = BRAP_Read32_isr(hDstHandle->hAssociation->hRap->hRegister,BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK );
#if (BRAP_7550_FAMILY != 1)
	ui32RegVal |= BCHP_FIELD_DATA(AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK, REARM_FULLMARK, ui32ReArmBitFullMark);	
#endif
	BRAP_Write32_isr (hDstHandle->hAssociation->hRap->hRegister, BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK, ui32RegVal);
	
	BDBG_LEAVE(BRAP_P_ReArmFullMarkInterrupt_isr);
	return;
}

BERR_Code BRAP_P_ProgramAdaptRateCtrl (
                BRAP_ChannelHandle		hRapCh,
                const unsigned int          uiPth       	/* [in] Path idx corresponding 
                                                                       to pPath[] array element */	
		)
{

    BERR_Code ret = BERR_SUCCESS;
    unsigned int  ui32RegVal = 0, ui32Offset=0;   
    unsigned int  i=0, uiAdaptRateCtrlId=0;

    BDBG_ENTER (BRAP_P_ProgramAdaptRateCtrl);
    BDBG_ASSERT (hRapCh);           
    BDBG_ASSERT(hRapCh->pPath[uiPth]);
    /* If this channel has a SrcCh which carries PCM data, program the 
    AUD_FMM_BF_CTRL_ADAPTRATE_X accordingly */
    ui32Offset = (BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_1_CFG -  BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG);
        
    for(i=0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        if (hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh == NULL) 
        {
            continue;
        }
        else
        {
            /* Make sure the SrcCh is carrying PCM data.
            Note: whether the srcch is carrying PCM or Comp is determined only 
            at start time. So make sure the Srcch has been started.*/
            if ((hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh->eState == BRAP_SRCCH_P_State_eRunning) 
                && (hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh->sParams.bCompress == false))
            {
                uiAdaptRateCtrlId = hRapCh->pPath[uiPth]->sRsrcGrnt.uiAdaptRateCtrlId[i];   

                if(BRAP_RM_P_INVALID_INDEX == uiAdaptRateCtrlId)
                {
                    continue;
                }
                
                ui32RegVal = BRAP_Read32(hRapCh->hRegister, 
                BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG + (uiAdaptRateCtrlId*ui32Offset));

                ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, ADAPTIVE_SFIFO_SEL));                
                ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                                ADAPTIVE_SFIFO_SEL, hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh->uiIndex));            

                ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                                    TRIWINDOW_WIDTH_SEL));

                /* TODO: hardcoding window width field to 8 ie actual window 
                width of 256. This has to be changed later to be taken from 
                application */
                ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                                TRIWINDOW_WIDTH_SEL, TRIWINDOW_WIDTH_SEL_VALUE));
                
                /* Earlier, for a decode channel FW was setting the enable flag. 
                Now we're doing AdaptRate control for PCM channels also. So let the 
                PI set this flag always */                
#if (BRAP_7420_FAMILY == 1)||(BRAP_7550_FAMILY == 1)
            ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, ADAPTIVE_RATE_ENABLE));                
            ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                            ADAPTIVE_RATE_ENABLE, 0));  
#else
                ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, ADAPTIVE_RATE_ENABLE));                
                ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                                ADAPTIVE_RATE_ENABLE, 1));  
#endif                


#if ((BRAP_7420_FAMILY != 1)|| ((BCHP_CHIP==7420)&&((BCHP_VER == A0)||(BCHP_VER == BCHP_VER_A1))))&&(BRAP_7550_FAMILY != 1)
                /* Program ADAPTIVE_RATE_THRESHOLD required */
                ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, ADAPTIVE_RATE_THRESHOLD));                
                ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                                ADAPTIVE_RATE_THRESHOLD, ADAPTIVE_RATE_THRESHOLD_VALUE));
#endif

#if (BRAP_7420_FAMILY == 1)||(BRAP_7550_FAMILY == 1)
            /* Program ADAPTIVE_RATE_MASTER_ENABLE  */
            ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, ADAPTIVE_RATE_MASTER_ENABLE));                
            ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                            ADAPTIVE_RATE_MASTER_ENABLE, 1));

#endif

                BDBG_MSG(("For AdaptRateControl: channel pair %d, SrcFifo %d"
                    ", AdaptRateThreshold=5 and WindowWidth = 256 ", i, 
                    hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh->uiIndex));
                
                BRAP_Write32(hRapCh->hRegister, 
                            BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG + (uiAdaptRateCtrlId*ui32Offset), 
                            ui32RegVal);
#if ((BRAP_7420_FAMILY == 1)&&((BCHP_CHIP==7420)&&(BCHP_VER != A0)&&(BCHP_VER != BCHP_VER_A1)))||(BRAP_7550_FAMILY == 1)
                ui32RegVal = BRAP_Read32(hRapCh->hRegister, 
                    BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_THRESHOLD_0 + (uiAdaptRateCtrlId*ui32Offset));

                ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_THRESHOLD_0, ADAPTIVE_RATE_THRESHOLD));                
                ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_THRESHOLD_0, 
                                ADAPTIVE_RATE_THRESHOLD, ADAPTIVE_RATE_THRESHOLD_VALUE));

                BRAP_Write32(hRapCh->hRegister, 
                    BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_THRESHOLD_0 + (uiAdaptRateCtrlId*ui32Offset),
                    ui32RegVal);

#endif
            }
    	}
    }  

    BDBG_LEAVE (BRAP_P_ProgramAdaptRateCtrl);
    return ret;    
}



BERR_Code BRAP_P_ResetAdaptRateCtrl (
                BRAP_ChannelHandle		hRapCh,
                const unsigned int          uiPth       	/* [in] Path idx corresponding 
                                                                       to pPath[] array element */	
		)
{

    BERR_Code ret = BERR_SUCCESS;
    unsigned int  ui32RegVal = 0, ui32Offset=0;   
    unsigned int  i=0, uiAdaptRateCtrlId=0;

    BDBG_ENTER (BRAP_P_ResetAdaptRateCtrl);
    BDBG_ASSERT (hRapCh);           
    BDBG_ASSERT(hRapCh->pPath[uiPth]);
    /* If this channel has a SrcCh which carries PCM data, program the 
    AUD_FMM_BF_CTRL_ADAPTRATE_X accordingly */
    ui32Offset = (BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_1_CFG -  BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG);
        
    for(i=0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        if (hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh == NULL) 
        {
            continue;
        }
        else
        {
            /* Make sure the SrcCh is carrying PCM data.
            Note: whether the srcch is carrying PCM or Comp is determined only 
            at start time. So make sure the Srcch has been started.*/
            if ((hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh->eState == BRAP_SRCCH_P_State_eRunning) 
                && (hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh->sParams.bCompress == false))
            {
                uiAdaptRateCtrlId = hRapCh->pPath[uiPth]->sRsrcGrnt.uiAdaptRateCtrlId[i];   

                if(BRAP_RM_P_INVALID_INDEX == uiAdaptRateCtrlId)
                {
                    continue;
                }
                
                BRAP_Write32(hRapCh->hRegister, 
                            BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_REPEATDROP_WRCNT_0 + (uiAdaptRateCtrlId*ui32Offset), 
                            0x0);   
                
                ui32RegVal = BRAP_Read32(hRapCh->hRegister, 
                BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG + (uiAdaptRateCtrlId*ui32Offset));
                
                /* Earlier, for a decode channel FW was setting the enable flag. 
                Now we're doing AdaptRate control for PCM channels also. So let the 
                PI set this flag always */                
                ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, ADAPTIVE_RATE_ENABLE));                
                ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                                ADAPTIVE_RATE_ENABLE, 0));  

#if (BRAP_7420_FAMILY == 1)||(BRAP_7550_FAMILY == 1)                
            /* Reset ADAPTIVE_RATE_MASTER_ENABLE  */
            ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, ADAPTIVE_RATE_MASTER_ENABLE));                
            ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                            ADAPTIVE_RATE_MASTER_ENABLE, 0));

#endif


                BDBG_MSG(("Disabling AdaptRateControl: channel pair %d, SrcFifo %d"
                    " ", i, 
                    hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh->uiIndex));
                
                BRAP_Write32(hRapCh->hRegister, 
                            BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG + (uiAdaptRateCtrlId*ui32Offset), 
                            ui32RegVal);    
            }
    	}
    }  

    BDBG_LEAVE (BRAP_P_ResetAdaptRateCtrl);
    return ret;    
}


/**************************************************************************************
SUMMARY:
function to show the current settings of all the post processing stages 
***************************************************************************************/


void BRAP_P_ShowHandleStage( BRAP_ChannelHandle hRapCh)
{
	/*
    int i=0, loop=0;
    int destdevice=0;
    int stgsdevice=0;	
    */
    uint32_t i=0,loop=0,destdevice=0,stgsdevice=0;

    BDBG_MSG(("\n SETTINGS FOR THE STAGES"));
    BDBG_MSG(("\n*****************************"));


    for(i=0;i<BRAP_MAX_ASSOCIATED_GROUPS;i++)
    {  
        if (i >= 2)
        {
            break;
        }
        if(hRapCh->uiAssociationId[i] == BRAP_INVALID_VALUE)
            continue;
        BDBG_MSG(("\n GROUP ASSOCIATION NUMBER: %d",i));
        BDBG_MSG(("\n $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"));

        for(destdevice=0;destdevice<BRAP_P_MAX_DST_PER_RAPCH;destdevice++)
        { 
            if(hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].hAssociation == NULL)
            { 
                BDBG_MSG(("\n This Destination:%d is Not Valid ",destdevice));
                continue;
            }

            BDBG_MSG(("\n\n SETTINGS FOR THE DESTINATION: %d",destdevice));
            BDBG_MSG(("\n,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"));
            BDBG_MSG(("\n Destination of the audio data from the Raptor Channel :%d",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].sExtDstDetails.eAudioDst));
            BDBG_MSG(("\n Destination Detaols:%x",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].sExtDstDetails.uDstDetails));
            BDBG_MSG(("\n Associated Channel Handle to which the destination belongs :%x",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].hAssociation));
            BDBG_MSG(("\n Parent Destination Handle :%x",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].hParentDestHandle));
            BDBG_MSG(("\n Forking Stage :%d",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].uiForkingStage));
            BDBG_MSG(("\n The main audio processing for this destination %d\n",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].eAudioProcessing));

            /* hDestHandle is same as &(hRap->sAssociatedCh[i].sDstDetails[destdevice]) */
            for (loop=0;loop<BRAP_P_MAX_RAPCH_PER_DST+1;loop++)
            {

                if(NULL == hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].psProcessingSettings[loop])
                {
                    /*BDBG_MSG (("The PP Settings Array for index = %d is NULL", loop));*/
                    continue;
                }

                BDBG_MSG(("\n PP Settings are present in Index : %d",loop));
                BDBG_MSG(("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"));

                for(stgsdevice=0;stgsdevice<BRAP_MAX_PP_PER_BRANCH_SUPPORTED;stgsdevice++)
                {  
                    if(hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].psProcessingSettings[loop]->sExternalSettings.hAudProcessing[stgsdevice]==NULL)
                    {
                        BDBG_MSG(("\n hAudProcessing for stage %d is NULL",stgsdevice));
                        continue;
                    } 

                    BDBG_MSG(("\n Processing Stage=%d",stgsdevice));
                    BDBG_MSG(("\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"));


                    BDBG_MSG( ("\n TESTING OUR PP ALGO:: %d", hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].psProcessingSettings[loop]->sExternalSettings.hAudProcessing[stgsdevice]->sProcessingStageSettings.eAudioProcessing));
                    /*BDBG_MSG(("\n TESTING OUR PP ALGO uconfig:: %d", hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].psProcessingSettings[loop]->sExternalSettings.hAudProcessing[stgsdevice]->sProcessingStageSettings.uConfigParams));*/
                    BDBG_MSG(("\n TESTING OUR PP ALGO uistage position ::%d",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].psProcessingSettings[loop]->sExternalSettings.hAudProcessing[stgsdevice]->uiStagePosition));
                    BDBG_MSG(("\n TESTING OUR PP ALGO hRap::%x",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].psProcessingSettings[loop]->sExternalSettings.hAudProcessing[stgsdevice]->hRap));
                    BDBG_MSG(("\n TESTING OUR PP ALGO hRapCh::%x",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].psProcessingSettings[loop]->sExternalSettings.hAudProcessing[stgsdevice]->uHandle.hRapCh));
                }
            }
        }
    } 
}


/**************************************************************************************
SUMMARY:
function to show the current settings of all the CIT structure 

***************************************************************************************/


void BRAP_P_ShowCitSettings(BRAP_P_AudioProcNetwork *psAudProcNetwork, BRAP_CIT_P_InputInfo    *pCitInputStruct)
{  
    uint32_t  i=0,j=0,k=0,l=0,m=0, n = 0;

    BDBG_MSG( ("\n Showing the CIT input Structure settings"));
    BDBG_MSG(("\n **********************************************************"));

    BDBG_MSG(("\n The number of outputs :%d ",pCitInputStruct->ui32NumOutputs));
    BDBG_MSG(("\n ---------------------------------------------------------------"));

    for(j=0; j< pCitInputStruct->ui32NumOutputs; j++)
    {
        BDBG_MSG(("\n OutPut num : %d",j));
        BDBG_MSG(("\n ------------------------------"));
        BDBG_MSG(("\n\npCitInputStruct->sPortCfg[j].sFmmDstDetails.uFmmDstPortType.eOpType > %d", pCitInputStruct->sPortCfg[j].sFmmDstDetails.uFmmDstPortType.eOpType));
        BDBG_MSG(("\npsCitInputStruct->sPortCfg[j].ui32PllIndex > %d", pCitInputStruct->sPortCfg[j].ui32PllIndex));
        if(BRAP_OutputPort_eSpdif == pCitInputStruct->sPortCfg[j].sFmmDstDetails.uFmmDstPortType.eOpType)
            BDBG_MSG(("psCitInputStruct->sPortCfg[j].uOpCfg.sSpdifCfg.bPcmOnSpdif > %d", pCitInputStruct->sPortCfg[j].uOpCfg.sSpdifCfg.bPcmOnSpdif));
    }  

    BDBG_MSG(("\n The number of branches :%d",pCitInputStruct->ui32NumBranches));
    BDBG_MSG(("\n-------------------------------------------------------------------"));

    for(j=0; j< pCitInputStruct->ui32NumBranches; j++)
    {
        BDBG_MSG(("\n Branch number:%d ",j));
        BDBG_MSG(("\n---------------------------"));
        BDBG_MSG(("\npsCitInputStruct->sBranchInfo[%d].ui32NumStages = %d",j,pCitInputStruct->pBranchInfo[j]->ui32NumStages));
        for(k =0; k < pCitInputStruct->pBranchInfo[j]->ui32NumStages; k++)
        { 
            BDBG_MSG(("\n Stage number :%d",k));
            BDBG_MSG(("\n----------------------------"));
            BDBG_MSG(("\n Branch info:"));
            BDBG_MSG(("\n======================"));
            BDBG_MSG(("\nsFwStgInfo[%d].ui32BranchId = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].ui32BranchId));
            BDBG_MSG(("sFwStgInfo[%d].ui32StageId = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].ui32StageId));
            BDBG_MSG(("sFwStgInfo[%d].eAudioAlgoType = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].eAudioAlgoType));
            BDBG_MSG(("sFwStgInfo[%d].uAlgorithm.eAudioType = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].uAlgorithm.eDecAudioAlgo));
            BDBG_MSG(("sFwStgInfo[%d].uAudioMode.eDecAudioMode = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].uAudioMode.eDecAudioMode));
            BDBG_MSG(("sFwStgInfo[%d].sStgConnectivity.ui32NumSrc = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.ui32NumSrc));
            BDBG_MSG(("sFwStgInfo[%d].sStgConnectivity.sSrcDetails[0].eType = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].eType));
            BDBG_MSG(("sFwStgInfo[%d].sStgConnectivity.sSrcDetails[0].uDetails = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails));

            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.eBufferType = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffId.eBufferType));				

            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.ui32NumBuffers = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32NumBuffers));				

            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32BufferId[0] = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32BufferId[0]));				
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32BufferId[1] = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32BufferId[1]));								
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32ReadAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32ReadAddr));								
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WriteAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WriteAddr));								
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WrapAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WrapAddr));								


            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32BaseAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[1].ui32BaseAddr));				
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32EndAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[1].ui32EndAddr));								
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32ReadAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[1].ui32ReadAddr));								
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WriteAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[1].ui32WriteAddr));								
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WrapAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[1].ui32WrapAddr));

            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32BranchId = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32BranchId));
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32DistinctOpNum = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32DistinctOpNum));
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32OpNum = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32OpNum));
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32StageId = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32StageId));					







            BDBG_MSG(("\n pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.ui32NumDistinctOp:%d ",pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.ui32NumDistinctOp));
            BDBG_MSG(("\n-----------------------------------------------------------------------------------------------"));
            for( m=0;m<pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.ui32NumDistinctOp;m++)
            { 
                BDBG_MSG(("\n m=%d",m));
                BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.ui32NumDst[%d] =%d",m,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.ui32NumDst[m]));                
                BDBG_MSG(("\npsCitInputStruct->sBranchInfo[%d].sFwStgInfo[%d].sStgConnectivity.eDistinctOpType[%d] = %d",j,k,m,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.eDistinctOpType[m]));				                

                for(i = 0; i< pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.ui32NumDst[m]; i++)
                {	
                    BDBG_MSG(("\n i=%d",i));		
                    BDBG_MSG(("\npsCitInputStruct->sBranchInfo[%d].sFwStgInfo[%d].sStgConnectivity.sDstDetails[%d][%d].eType = %d",j,k,m,i,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].eType));				

                    BDBG_MSG(("psCitInputStruct->sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffId.uiBufferId[0] = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32BufferId[0]));		
                    BDBG_MSG(("psCitInputStruct->sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffId.uiBufferId[1] = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32BufferId[1]));						
                    BDBG_MSG(("psCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffId.eBufferType = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffId.eBufferType));		
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32NumBuffers = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32NumBuffers));

                    for(n = 0; n <  BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;n++)
                    {
                        BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32AdaptRateCtrlIds[%d] = %d",m,i,n,
                        pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32AdaptRateCtrlIds[n]));
                    }

                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffer.eBufferType = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffer.eBufferType));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffer.ui32NumBuffers = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffer.ui32NumBuffers));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32BaseAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32BaseAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32EndAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32EndAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32ReadAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32ReadAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WrapAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WrapAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WriteAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WriteAddr));

                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.eBufferType = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.eBufferType));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.ui32NumBuffers = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.ui32NumBuffers));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32BaseAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32BaseAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32EndAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32EndAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32ReadAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32ReadAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32WrapAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32WrapAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32WriteAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32WriteAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffId.eBufferType = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffId.eBufferType));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffId.ui32BufferId = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffId.ui32BufferId));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffId.ui32NumBuffer = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffId.ui32NumBuffers));


                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sFwStage.ui32BranchId = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sFwStage.ui32BranchId));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sFwStage.ui32DistinctOpNum = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sFwStage.ui32DistinctOpNum));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sFwStage.ui32OpNum = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sFwStage.ui32OpNum));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sFwStage.ui32StageId = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sFwStage.ui32StageId));
                }				
            }
        }
    }

    BDBG_MSG(("psCitInputStruct->sMemInfo.ui32SharedMemPhysAdr = %d",pCitInputStruct->sMemInfo.ui32SharedMemPhysAdr));
    BDBG_MSG(("psCitInputStruct->sMemInfo.ui32SharedMemSize = %d",pCitInputStruct->sMemInfo.ui32SharedMemSize));
    BDBG_MSG(("psCitInputStruct->sMemInfo.ui32TaskMemPhysAdr = %d",pCitInputStruct->sMemInfo.ui32TaskMemPhysAdr));
    BDBG_MSG(("psCitInputStruct->sMemInfo.ui32TaskMemSize = %d",pCitInputStruct->sMemInfo.ui32TaskMemSize));

    BDBG_MSG(("\n Details of the master Index Table "));
    BDBG_MSG(("\n @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"));
    for(l=0;l<BRAP_AF_P_AlgoId_eMax;l++)
    {
        if(pCitInputStruct->psMit==NULL)
        {
            continue;
        }
        if(pCitInputStruct->psMit->sAlgoDwnldDetail[l].ui32AlgoCodePtr != 0xffffffff)
        {
        BDBG_MSG(("psCitInputStruct->psMit->sAlgoDwnldDetail[%d].ui32AlgoCodePtr :%d",l,pCitInputStruct->psMit->sAlgoDwnldDetail[l].ui32AlgoCodePtr));
        BDBG_MSG(("psCitInputStruct->psMit->sAlgoDwnldDetail[%d].ui32AlgoCodeSize :%d",l,pCitInputStruct->psMit->sAlgoDwnldDetail[l].ui32AlgoCodeSize));
        BDBG_MSG(("psCitInputStruct->psMit->sAlgoDwnldDetail[%d].ui32AlgoDataPtr:%d",l,pCitInputStruct->psMit->sAlgoDwnldDetail[l].ui32AlgoDataPtr));
        BDBG_MSG(("psCitInputStruct->psMit->sAlgoDwnldDetail[%d].ui32AlgoDataSize:%d",l,pCitInputStruct->psMit->sAlgoDwnldDetail[l].ui32AlgoDataSize));
        }
    }

    BDBG_MSG(("\n RdbCfg Details"));
    BDBG_MSG(("\n #####################"));
    BDBG_MSG(("\npsCitInputStruct->sRdbCfg.ui32RDBBaseOffset: %d",pCitInputStruct->sRdbCfg.ui32RdbBaseOffset));
    BDBG_MSG(("psCitInputStruct->sRdbCfg.ui32RDBChipOffset: %d",pCitInputStruct->sRdbCfg.ui32RdbDspOffset));

    BDBG_MSG(("\n Network Details "));
    BDBG_MSG(("\n==========================================\n"));

    for(i=0;i<BRAP_P_MAX_DST_PER_RAPCH;i++)
    { 
            for (j=0; j<BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED;j++)
            { 
                if(psAudProcNetwork!=NULL)
                {
                    if(BRAP_P_STAGE_VALID(psAudProcNetwork->sAudProcessingStage,i,j))                        
                    {
                        BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].bDecoderStage: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].bDecoderStage));
                        BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].bCloneStage: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].bCloneStage));
                        BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].ui32MasterBranchId: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].ui32MasterBranchId));
                        BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].ui32MasterStageId: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].ui32MasterStageId));

                        if(NULL != psAudProcNetwork->sAudProcessingStage[i][j].hAudioProcessing)
                            BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].hAudioProcessing.sProcessingStageSettings.eAudioProcessing: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].hAudioProcessing->sProcessingStageSettings.eAudioProcessing));
                        for(l=0;l<BRAP_P_MAX_DEST_PER_PROCESSING_STAGE;l++)
                        {   
                            if (psAudProcNetwork->sAudProcessingStage[i][j].hDestHandle[l]!=NULL)
                            {
                                BDBG_MSG(("\n l=%d",l));
                                BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].hDestHandle->eAudioProcessing: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].hDestHandle[l]->eAudioProcessing));
                                BDBG_MSG(("\n this was AudioProcessing,now we get AudProcessing\n"));
                                BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].hDestHandle->eAudProcessing: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].hDestHandle[l]->eAudProcessing));
                                BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].hDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].hDestHandle[l]->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]));
                            }
                        }	 
                    }						 
                    else
                    {
                        break;
                    }
                }
        }
    }
}

BERR_Code BRAP_P_SetOutputVolumeGain( 
    BRAP_Handle         hRap,       /*[in] Rap Handle */
    BRAP_OutputPort     eOpType,    /*[in] Output Port */
    unsigned int            uiLVolume,      /* [in] Left channel volume in 0.23 format */
    unsigned int            uiRVolume       /* [in] Right channel volume in in 0.23 format*/
)    
{
    BRAP_MIXER_P_Handle     hMixer = NULL;
    unsigned int            uiMixerOutput=0;    
    BERR_Code               ret = BERR_SUCCESS;
    

	/* Get the Mixer handle for mixer linked to this output port */
	ret = BRAP_P_GetMixerForOpPort(hRap,eOpType,&hMixer,&uiMixerOutput);
    
	if(BERR_INVALID_PARAMETER == ret)
	{
		/* Channel not started yet */
		ret = BERR_SUCCESS;
	}
	else if(BERR_SUCCESS == ret)
	{
		/* Call the Mixer volume control API */
		ret = BRAP_MIXER_P_SetOutputVolumeGain(hMixer,uiMixerOutput,uiLVolume,uiRVolume);
		if(BERR_SUCCESS != ret)
		{
			BDBG_ERR(("BRAP_P_SetOutputVolumeGain:BRAP_MIXER_P_SetOutputVolumeGain returned"
				"Error"));
		}
	}
	else
	{
		BDBG_ERR(("BRAP_P_SetOutputVolumeGain:BRAP_P_GetMixerForOpPort returned"
			"Error"));
		ret = BERR_TRACE(ret);
	}

    return ret;

}
bool   BRAP_P_IsPassthruSupportedWithoutLicense(BRAP_DSPCHN_AudioType  eType)
{

    if(
#ifdef  RAP_AC3_PASSTHRU_SUPPORT                       
        (eType == BRAP_DSPCHN_AudioType_eAc3)||
#endif        
#ifdef  RAP_DTSBROADCAST_PASSTHRU_SUPPORT                       
        (eType == BRAP_DSPCHN_AudioType_eDtsBroadcast)||
#endif        
#ifdef  RAP_DTSHD_PASSTHRU_SUPPORT                       
        (eType == BRAP_DSPCHN_AudioType_eDtshd)||
#endif
#ifdef  RAP_DDP_PASSTHRU_SUPPORT                       
        (eType == BRAP_DSPCHN_AudioType_eAc3Plus)||
#endif
#ifdef  RAP_MPEG_PASSTHRU_SUPPORT                               
        (eType == BRAP_DSPCHN_AudioType_eMpeg)||
#endif
#ifdef  RAP_AACSBR_PASSTHRU_SUPPORT                               
        (eType == BRAP_DSPCHN_AudioType_eAacAdts)||                                     
        (eType == BRAP_DSPCHN_AudioType_eAacLoas)||        
        (eType == BRAP_DSPCHN_AudioType_eAacSbrAdts)||        
        (eType == BRAP_DSPCHN_AudioType_eAacSbrLoas)||
#endif        
#ifdef  RAP_DRA_PASSTHRU_SUPPORT               
        (eType == BRAP_DSPCHN_AudioType_eDra)||       
#endif        
#ifdef  RAP_REALAUDIOLBR_PASSTHRU_SUPPORT               
                (eType == BRAP_DSPCHN_AudioType_eRealAudioLbr)||       
#endif     

        (false)
        )
    {
        return  true;
    }
    else
    {
        return  false;
    }
}

BERR_Code BRAP_P_GetAlgorithmProfileId(
    uint8_t     *pui8AlgoProfileId
    )
{
    BERR_Code       ret = BERR_SUCCESS;

    BDBG_ENTER(BRAP_P_GetAlgorithmProfileId);
    
#if defined(RAP_DTSENC_SUPPORT)

#if defined(RAP_DTSBROADCAST_SUPPORT) && defined(RAP_DTSHD_SUPPORT)
    *pui8AlgoProfileId = 4;
#elif defined(RAP_DTSBROADCAST_SUPPORT)
    *pui8AlgoProfileId = 3;
#else
    *pui8AlgoProfileId = 2;
#endif

#else

#if defined(RAP_DTSHD_SUPPORT)
    *pui8AlgoProfileId = 1;
#else
    *pui8AlgoProfileId = 0; /* Invalid Profile */
#endif

#endif

    BDBG_LEAVE(BRAP_P_GetAlgorithmProfileId);
return ret;
}


/***************************************************************************
Summary:
    Creates Multi Stream Decoder object.
Description:
    This function creates Multi Stream Decoder object. F
Returns:
    BERR_SUCCESS on success
    Error code on failure
See Also:
    BRAP_P_SetMultiStreamDecoderObject
    BRAP_P_GetMultiStreamDecoderObject    
    BRAP_P_DestroyMultiStreamDecoderObject

**************************************************************************/
BERR_Code BRAP_P_CreateMultiStreamDecoderObject(
    BRAP_Handle hRap, 
    BRAP_MultiStreamDecoderHandle *phMultiStreamDecoder
    )
{
    BERR_Code ret  = BERR_SUCCESS;
    unsigned int uiMsObjIndex = 0,uiStgIp=0;

    BDBG_ENTER(BRAP_P_CreateMultiStreamDecoderObject);

    /* Validate input params */
    BDBG_ASSERT (hRap);
    BDBG_ASSERT (phMultiStreamDecoder);    

    *phMultiStreamDecoder = NULL;
    for (uiMsObjIndex=0; uiMsObjIndex<BRAP_P_MAX_MULTI_STREAM_DECODER_OBJECTS; uiMsObjIndex++)
    {
        if (true == hRap->sMultiStreamDecoderObjs[uiMsObjIndex].bAvailable)
        {
            break;
        }
    }
    if (BRAP_P_MAX_MULTI_STREAM_DECODER_OBJECTS == uiMsObjIndex)
    {
        BDBG_ERR(("BRAP_P_CreateMultiStreamDecoderObject: Max Multi Stream Decoder object reached"));
        ret = BERR_TRACE(BERR_NOT_SUPPORTED);
        goto exit;      
    }

    /* ui32InterTaskIoBufferAddress is allocated(in BRAP_P_OpenDecPath()) from RBUF pool */
    
    for (uiStgIp=0; uiStgIp<BRAP_P_MAX_FW_STG_INPUTS; uiStgIp++)
    {    
        hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32InterTaskIoGenericBufferAddress[uiStgIp] = (uint32_t)BRAP_P_AllocAligned(hRap, BRAP_AF_P_INTERTASK_IOGENBUFFER_SIZE,2, 0);    /* 32 bit aligned*/    
        if((void *) BRAP_P_INVALID_DRAM_ADDRESS == (void *)hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32InterTaskIoGenericBufferAddress[uiStgIp])
        {
            BDBG_ERR(("BRAP_P_CreateMultiStreamDecoderObject: Unable to Allocate memory for IO Gen Buffer!"));
            ret = BERR_TRACE(BERR_OUT_OF_DEVICE_MEMORY);
            goto exit;
        }
        BKNI_Memset((void *)(hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32InterTaskIoGenericBufferAddress[uiStgIp]), 0, BRAP_AF_P_INTERTASK_IOGENBUFFER_SIZE );    
    }

    hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32FeedbackBufferAddress = (uint32_t)BRAP_P_AllocAligned(hRap, (BRAP_AF_P_INTERTASK_FEEDBACK_BUFFER_SIZE + 4) ,2, 0);    /* 32 bit aligned*/
    if((void *) BRAP_P_INVALID_DRAM_ADDRESS == (void *)hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32FeedbackBufferAddress)
    {
        BDBG_ERR(("BRAP_P_CreateMultiStreamDecoderObject: Unable to Allocate memory for Feedback  Buffer !"));
        ret = BERR_TRACE(BERR_OUT_OF_DEVICE_MEMORY);
        goto exit;
    }
    BKNI_Memset((void *)(hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32FeedbackBufferAddress), 0, (BRAP_AF_P_INTERTASK_FEEDBACK_BUFFER_SIZE + 4));

    hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32ReconfiguredCITAddress = (uint32_t)BRAP_P_AllocAligned(hRap, sizeof(BRAP_AF_P_sTASK_CONFIG) ,2, 0);    /* 32 bit aligned*/
    if( (void *)BRAP_P_INVALID_DRAM_ADDRESS == (void *)hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32ReconfiguredCITAddress)
    {
        BDBG_ERR(("BRAP_P_CreateMultiStreamDecoderObject: Unable to Allocate memory for Reconfigured CIT output !"));
        ret = BERR_TRACE(BERR_OUT_OF_DEVICE_MEMORY);
        goto exit;
    }
    BKNI_Memset((void *)(hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32ReconfiguredCITAddress), 0, sizeof(BRAP_AF_P_sTASK_CONFIG));

    hRap->sMultiStreamDecoderObjs[uiMsObjIndex].hRap = hRap;
    hRap->sMultiStreamDecoderObjs[uiMsObjIndex].bAvailable = false;
    
    *phMultiStreamDecoder = &(hRap->sMultiStreamDecoderObjs[uiMsObjIndex]);

exit:
    BDBG_LEAVE(BRAP_P_CreateMultiStreamDecoderObject);
    return ret;
}


/***************************************************************************
Summary:
    Destroys Multi Stream Decoder object.
Description:
    This function destroys Multi Stream Decoder object. 
Returns:
    BERR_SUCCESS on success
    Error code on failure
See Also:
    BRAP_P_CreateMultiStreamDecoderObject
    BRAP_P_SetMultiStreamDecoderObject
    BRAP_P_GetMultiStreamDecoderObject    
**************************************************************************/
BERR_Code BRAP_P_DestroyMultiStreamDecoderObject(
    BRAP_MultiStreamDecoderHandle hMultiStreamDecoder
    )
{
    BERR_Code ret  = BERR_SUCCESS;
    unsigned int uiStgIp=0, k=0;

    BDBG_ENTER(BRAP_P_DestroyMultiStreamDecoderObject);

    /* Validate input params */
    BDBG_ASSERT (hMultiStreamDecoder);

    hMultiStreamDecoder->sExtMultiStreamDecoderDetails.uiNumSecondaryChannel = 0;
    hMultiStreamDecoder->sExtMultiStreamDecoderDetails.hPrimaryChannel = NULL;

    for (k=0; k<BRAP_MAX_SEC_CHANNEL_FOR_MS_DECODER; k++)
    {     
        hMultiStreamDecoder->sExtMultiStreamDecoderDetails.hSecondaryChannel[k] = NULL;
    }
    
    if((uint32_t)NULL != hMultiStreamDecoder->ui32ReconfiguredCITAddress)
    {
        BRAP_P_Free (hMultiStreamDecoder->hRap, (void*)hMultiStreamDecoder->ui32ReconfiguredCITAddress);    
    }
    hMultiStreamDecoder->ui32ReconfiguredCITAddress = (uint32_t)NULL;
    
    if((uint32_t)NULL != hMultiStreamDecoder->ui32FeedbackBufferAddress)
    {
        BRAP_P_Free (hMultiStreamDecoder->hRap, (void*)hMultiStreamDecoder->ui32FeedbackBufferAddress);
    }
    hMultiStreamDecoder->ui32FeedbackBufferAddress = (uint32_t)NULL;
    
    for (uiStgIp=0; uiStgIp<BRAP_P_MAX_FW_STG_INPUTS; uiStgIp++)
    {
        if((uint32_t)NULL != hMultiStreamDecoder->ui32InterTaskIoGenericBufferAddress[uiStgIp])
        {
            BRAP_P_Free (hMultiStreamDecoder->hRap, (void*)hMultiStreamDecoder->ui32InterTaskIoGenericBufferAddress[uiStgIp]);
        }
        hMultiStreamDecoder->ui32InterTaskIoGenericBufferAddress[uiStgIp] = (uint32_t)NULL;
    }

    hMultiStreamDecoder->hRap = NULL;
    hMultiStreamDecoder->bAvailable = true;
   
    BDBG_LEAVE(BRAP_P_DestroyMultiStreamDecoderObject);
    return ret;
}


/***************************************************************************
Summary:
    Sets the Multi Stream Decoder Object
Description:
    This function sets the Multi Stream Decoder Object. 
    
Returns:
    BERR_SUCCESS on success
    Error code on failure
See Also:
    BRAP_P_GetMultiStreamDecoderObject
    BRAP_P_CreateMultiStreamDecoderObject
    BRAP_P_DestroyMultiStreamDecoderObject
**************************************************************************/
BERR_Code BRAP_P_SetMultiStreamDecoderObject(
    BRAP_MultiStreamDecoderHandle hMultiStreamDecoder,     /* [in] Audio Desc handle */ 
    BRAP_P_MultiStreamDecoderparams *psParams /* [in] Audio Desc Params */
    )
{
    BERR_Code ret  = BERR_SUCCESS;

    BDBG_ENTER(BRAP_P_SetMultiStreamDecoderObject);

    /* Validate input params */
    BDBG_ASSERT (hMultiStreamDecoder);
    BDBG_ASSERT (psParams);

    hMultiStreamDecoder->sExtMultiStreamDecoderDetails= (*psParams);
  
    BDBG_LEAVE(BRAP_P_SetMultiStreamDecoderObject);
    return ret;
}


/***************************************************************************
Summary:
    Gets the Multi Stream Decoder Object
Description:
    This function gets the Multi Stream Decoder Object. 
    
Returns:
    BERR_SUCCESS on success
    Error code on failure
See Also:
    BRAP_P_SetMultiStreamDecoderObject
    BRAP_P_CreateMultiStreamDecoderObject
    BRAP_P_DestroyMultiStreamDecoderObject

**************************************************************************/
BERR_Code BRAP_P_GetMultiStreamDecoderObject(
    BRAP_MultiStreamDecoderHandle hMultiStreamDecoder,     /* [in] Audio Desc handle */ 
    BRAP_P_MultiStreamDecoderparams *psParams  /* [out] Audio Desc Params */
    )
{
    BERR_Code ret  = BERR_SUCCESS;

    BDBG_ENTER(BRAP_P_GetMultiStreamDecoderObject);

    /* Validate input params */
    BDBG_ASSERT (hMultiStreamDecoder);
    BDBG_ASSERT (psParams);

    if (false == hMultiStreamDecoder->bAvailable)
    {
        /* This hMultiStreamDecoder has been allocated and in use */
        (*psParams) = hMultiStreamDecoder->sExtMultiStreamDecoderDetails;
    }
    else
    {
        /* This hMultiStreamDecoder has been already destroyed */
        return BERR_TRACE(BERR_INVALID_PARAMETER);
    }
  
    BDBG_LEAVE(BRAP_P_GetMultiStreamDecoderObject);
    return ret;
}

bool    BRAP_P_IsPPPresent(
    BRAP_ChannelHandle  hRapCh,
    bool                bAssociationNw,	    
    BRAP_ProcessingType ePPType)
{
    unsigned int i =0 , j= 0;
    BDBG_ASSERT(hRapCh);

    if(bAssociationNw ==  false)
    {
        for(i = 0 ; i < BRAP_P_MAX_DST_PER_RAPCH ; i++)
        {
            for(j =0 ; j < BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED; j++)
            {        
                if(BRAP_P_IsPointerValid((void *)hRapCh->sChAudProcessingStage[i][j].hAudioProcessing))
                {
                    if(hRapCh->sChAudProcessingStage[i][j].hAudioProcessing->sProcessingStageSettings.eAudioProcessing == ePPType)
                    {
                        return true;
                    }
                }
            }
        }
    }
    else
    {
        unsigned int    uiAssocId=0;    
        for(uiAssocId = 0 ; uiAssocId < BRAP_MAX_ASSOCIATED_GROUPS ; uiAssocId++)
        {
            if((hRapCh->uiAssociationId[uiAssocId] == BRAP_INVALID_VALUE) ||
               (!(BRAP_P_IsPointerValid((void *)hRapCh->hRap->sAssociatedCh[hRapCh->uiAssociationId[uiAssocId]].hMultiStreamDecoder))))
                continue;
            for(i = 0 ; i < BRAP_P_MAX_DST_PER_RAPCH ; i++)
            {        
                for(j =0 ; j < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; j++)
                {        
                    if(BRAP_P_IsPointerValid((void *)hRapCh->hRap->sAssociatedCh[hRapCh->uiAssociationId[uiAssocId]].
                        sAudProcessingStage[i][j].hAudioProcessing))
                    {
                        if(hRapCh->hRap->sAssociatedCh[hRapCh->uiAssociationId[uiAssocId]].sAudProcessingStage[i][j].
                            hAudioProcessing->sProcessingStageSettings.eAudioProcessing == ePPType)
                        {
                            return true;
                        }
                    }
                }
            }
        }    
    }
    return false;
}

bool    BRAP_P_IsPPPresentOnOutput(
    BRAP_ChannelHandle  hRapCh,
    BRAP_ProcessingType ePPType,
    BRAP_OutputPort    eOpType)
{
    unsigned int i =0 , j= 0;
    BDBG_ASSERT(hRapCh);

    for(i = 0 ; i < BRAP_P_MAX_DST_PER_RAPCH ; i++)
    {
        for(j =0 ; j < BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED; j++)
        {        
            if(hRapCh->sChAudProcessingStage[i][j].hAudioProcessing != NULL)
            {
                if((hRapCh->sChAudProcessingStage[i][j].hAudioProcessing->sProcessingStageSettings.eAudioProcessing == ePPType)
                    &&(hRapCh->sChAudProcessingStage[i][j].hValidDestHandle != NULL)
                    &&(hRapCh->sChAudProcessingStage[i][j].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                    &&(hRapCh->sChAudProcessingStage[i][j].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]== eOpType))
                {
                    return true;
                }
            }
        }
    }
    return false;
}


bool BRAP_P_IsMs11UsageMode(
    BRAP_ChannelHandle  hRapCh)
{
    BDBG_ASSERT(hRapCh);

    if(      
       (BRAP_P_IsPPPresent(hRapCh,true,BRAP_ProcessingType_eDDRE) == true)
       ||(BRAP_P_IsPPPresent(hRapCh,false,BRAP_ProcessingType_eDDRE) == true))
        return true;
    else
    return false;
}


bool BRAP_P_IsMs10UsageMode(
    BRAP_ChannelHandle  hRapCh)
{

    BDBG_ASSERT(hRapCh);
    
    if((BRAP_P_IsPointerValid((void *)hRapCh->hMultiStreamDecoder)) &&
       (BRAP_P_IsPPPresent(hRapCh,true,BRAP_ProcessingType_eFwMixer) == true) &&
       (BRAP_P_IsPPPresent(hRapCh,true,BRAP_ProcessingType_eDDRE) == false))
        return true;
    else
        return false;
}

bool BRAP_P_IsMultiStreamDecodeUsageMode(
    BRAP_ChannelHandle  hRapCh)
{
    BDBG_ASSERT(hRapCh);
    
    return ( BRAP_P_IsMs10UsageMode(hRapCh) || BRAP_P_IsMs11UsageMode(hRapCh) );
}

bool BRAP_P_IsFwMixingPostLoopbackEnabled(
    BRAP_ChannelHandle  hRapCh)
{
    BDBG_ASSERT(hRapCh);
    
    if((BRAP_P_IsPointerValid((void *)hRapCh->hMultiStreamDecoder)) &&
       (BRAP_P_IsPPPresent(hRapCh,true,BRAP_ProcessingType_eFwMixer) == true))
        return true;
    else
        return false;
}


BERR_Code BRAP_P_EnableAdaptiveRate(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	bool                *bAdaptiveRateEnable,
	bool                bPPMCorrection
    )
{
    unsigned int i=0;
    bool bCompress = false;

    BDBG_ENTER(BRAP_P_EnableAdaptiveRate);
    
    if(hRapCh->eChannelType == BRAP_ChannelType_eDecode)
    {
        *bAdaptiveRateEnable =bPPMCorrection;    
        for(i =0 ; i< BRAP_P_MAX_PATHS_IN_A_CHAN; i++)
        {
            if(hRapCh->pPath[i] != NULL)
            {
                bCompress =false;
                BRAP_P_IsPathOutputCompress(hRapCh,i,&bCompress);
                if(bCompress == true)
                {
                    break;
                }
            }
        } 

        if((bCompress == true) ||
           (BRAP_P_IsMs10UsageMode(hRapCh)))
        {
            *bAdaptiveRateEnable = false;
        }
    }
    else
    {
        *bAdaptiveRateEnable = false;
    }

    BDBG_LEAVE(BRAP_P_EnableAdaptiveRate);
    return BERR_SUCCESS;
}

/* Return whether Association Network(PP) is valid */
bool BRAP_P_IsAssociationNWValid(
    BRAP_P_DstDetails   *pPvtDstDetails)
{
    BDBG_ASSERT(pPvtDstDetails);

    /* BRAP_P_MAX_RAPCH_PER_DST + 1 th entry of psProcessingSettings has 
       the Association Network details of the destination */
    if((BRAP_P_IsPointerValid((void *) pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST])) &&
       (BRAP_P_IsPointerValid((void *) pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->
                                sExternalSettings.hAudProcessing[0])))
        return true;
    else
        return false;
}

BERR_Code BRAP_P_IsFMMPathAllocated(
	BRAP_ChannelHandle      hRapCh,             /* [in] RAP Channel handle */
	unsigned int            uiPth,
	bool                    *bFMMPathAllocated  /* [Out] FMM Path not required/allocated */
    )
{
    BERR_Code       ret = BERR_SUCCESS;
    unsigned int    uiAssocId=0;
    BRAP_P_DstDetails   *pPvtDstDetails = NULL;
    
    BDBG_ASSERT(hRapCh);

	pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
	if ( NULL==pPvtDstDetails )
	{
	    ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        return ret;                                
	}
    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));
    
    if((BRAP_ChannelType_eDecode == hRapCh->eChannelType) &&
       (BRAP_INVALID_VALUE != hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx) &&
       (BRAP_P_IsPointerValid((void *)hRapCh->pPath[hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx])) &&
       ((BRAP_P_UsgPath_eDecodePcmPostMixing == hRapCh->pPath[hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx]->eUsgPath)||
        (BRAP_P_UsgPath_eDecodeCompressPostMixing == hRapCh->pPath[hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx]->eUsgPath)) &&
       (BRAP_P_IsPointerValid((void *)hRapCh->pPath[hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx]->pDstDetails[0])))
    {
        ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                    hRapCh->pPath[hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx]->pDstDetails[0],
                    pPvtDstDetails,
                    &uiAssocId);
        if(BERR_SUCCESS!=ret)
        {
            ret = BERR_TRACE(ret);
            return ret;
        }
        if(BRAP_ProcessingType_eFwMixer == 
            pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->
            sExternalSettings.hAudProcessing[0]->sProcessingStageSettings.eAudioProcessing)
        {
            *bFMMPathAllocated = false;
        }
    }
    else
        *bFMMPathAllocated = true;

    return ret;
}

/***************************************************************************
Description: Refer to Prototype
****************************************************************************/
bool BRAP_P_DspToConfigureOutputClock(
    BRAP_ChannelHandle  hRapCh,         /* [in] RAP Channel handle */
    BRAP_DstDetails     *pDstDetails    /* [in] Pointer to Destination details */
    )
{
    unsigned int uiAssocId=0, uiDstIndex=0;
    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(hRapCh->hRap);

    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
    {
        for(uiDstIndex=0; uiDstIndex<BRAP_P_MAX_DST_PER_RAPCH; uiDstIndex++)
        {
            /* Compare if structure values are same */
            if( !(BKNI_Memcmp(pDstDetails, &(hRapCh->hRap->sAssociatedCh[uiAssocId].sDstDetails[uiDstIndex].sExtDstDetails), sizeof(pDstDetails))))                
            {
                return (BRAP_P_SECONDARY_CHANNEL_SRC(hRapCh,uiAssocId) ? false:true);
            }
        }
    }
    BDBG_WRN(("Did not find specified Destination details in any of the Associations"));
    return true;
}

