/***************************************************************************
 *     Copyright (c) 2003-2012, Broadcom Corporation
 *     All Rights Reserved
 *     Confidential Property of Broadcom Corporation
 *
 *  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
 *  AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
 *  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
 *
 * $brcm_Workfile: bxpt_xcbuf.c $
 * $brcm_Revision: Hydra_Software_Devel/50 $
 * $brcm_Date: 5/4/12 4:40p $
 *
 * Porting interface code for the data transport core. 
 *
 * Revision History:
 *
 * $brcm_Log: /magnum/portinginterface/xpt/7400/bxpt_xcbuf.c $
 * 
 * Hydra_Software_Devel/50   5/4/12 4:40p gmullen
 * SW7420-2302: Default XC buffers to disabled. (Hw resets into enabled
 * state)
 * 
 * Hydra_Software_Devel/49   5/3/12 1:49p gmullen
 * SW7420-2302: Fixed overrun
 * 
 * Hydra_Software_Devel/48   4/24/12 8:21a gmullen
 * SW7420-2127: Merged to Hydra
 * 
 * Hydra_Software_Devel/SW7420-2127/1   4/10/12 4:18p gmullen
 * SW7420-2127: Stored user bandrate in BXPT_XcBuf_SetBandDataRate() and
 * BXPT_RsBuf_SetBandDataRate()
 * 
 * Hydra_Software_Devel/47   10/12/11 9:50a gmullen
 * SW7342-241: Removed duplicated code and update RS blockout calc
 * 
 * Hydra_Software_Devel/46   4/12/11 8:40a gmullen
 * SW7342-241: Removed define for refsw builds. Should be enabled only
 * through makefile
 * 
 * Hydra_Software_Devel/45   1/18/11 11:36a rjlewis
 * SW7420-1383: Added support for BDBG_OBJECT interface
 * 
 * Hydra_Software_Devel/44   11/1/10 5:52p gmullen
 * SW7342-241: Ported fix to LATEST. Define SW7432_241_WORKAROUND to
 * enable it
 * 
 * Hydra_Software_Devel/43   7/27/10 5:11p gmullen
 * SW3548-3013: Added error checking to BMEM allocs
 * 
 * Hydra_Software_Devel/42   12/17/09 9:34a gmullen
 * SW7630-62: Merged fix to mainline
 * 
 * Hydra_Software_Devel/SW7630-62/1   12/17/09 9:13a gmullen
 * SW7630-62: Buffer enums were incorrect
 * 
 * Hydra_Software_Devel/41   10/12/09 8:10a piyushg
 * SW7342-44: Fix a memory leak during xcbuff shutdown.
 * 
 * Hydra_Software_Devel/40   10/7/09 10:39a piyushg
 * SW7342-44: Delete unwanted debug messages.
 * 
 * Hydra_Software_Devel/39   10/6/09 5:22p piyushg
 * SW7342-44: XPT shutdown causing bus error.
 * BXPT_P_MAX_PLAYBACKS is not a reliable define to use
 * while initializing XC buffers.
 * 
 * Hydra_Software_Devel/38   9/9/09 8:07a piyushg
 * SW7630-30: Add 7630 XPT PI support.
 * Added directory element "7630".
 * 
 * Hydra_Software_Devel/37   8/11/09 11:13a piyushg
 * PR55216: Fix compilation error.
 * 
 * Hydra_Software_Devel/36   8/11/09 10:40a piyushg
 * PR55216: Added initial 7340 XPT support.
 * 
 * Hydra_Software_Devel/35   8/5/09 4:52p piyushg
 * PR55545: Add 7125 XPT PI support
 * Added file element "bxpt_rave_ihex.c".
 * Added file element "bxpt_rave_ihex.h".
 * 
 * Hydra_Software_Devel/PR55545/1   7/24/09 10:50a mward
 * PR55548: Adapted for 7125 based on 7342, 7340.
 * 
 * Hydra_Software_Devel/34   7/14/09 10:23a piyushg
 * PR56771: Add XPT PI code for 7342.
 * 
 * Hydra_Software_Devel/33   4/16/09 7:20p piyushg
 * PR53728: Each of the XC buffer clients (Remux, RAVE, and the Mesg
 * filters) would get a separate API to set
 * their input bitrates. That API would take a client handle and the ID of
 * the parser band. The XPT PI would
 * then walk backwards through the pipeline, increasing only the bitrates
 * for the XC and RS buffers that it
 * needs to.
 * 
 * Hydra_Software_Devel/32   4/7/09 5:26p piyushg
 * PR52986: Add support for 7635
 * Added directory element "7635".
 * 
 * Hydra_Software_Devel/31   4/2/09 6:48p piyushg
 * PR51893: 7420 RDB has 6 FE PID parsers but 7 IBP XC Buffers.
 * They should both be matching.
 * 
 * Hydra_Software_Devel/30   3/25/09 3:22p piyushg
 * PR51893: Initializing XC buffers for playback 2 to 7.
 * Only 0 and 1 were being initialized causing bus error in
 * bxpt_close.
 * 
 * Hydra_Software_Devel/29   1/27/09 1:10p gmullen
 * PR51625: Added 7336 support
 * 
 * Hydra_Software_Devel/28   12/17/08 10:55p piyushg
 * PR47755: Added support for 8 playbacks for 7420.
 * 
 * Hydra_Software_Devel/27   11/26/08 4:15p gmullen
 * PR47755: Added support for 7420.
 * 
 * Hydra_Software_Devel/26   8/15/08 1:13p gmullen
 * PR45729: Fixed initial value for RsBufBO[] and XcBufBO[]
 * 
 * Hydra_Software_Devel/25   6/17/08 5:55p gmullen
 * PR43710: Fixed parser all-pass mode.
 * 
 * Hydra_Software_Devel/24   5/7/08 10:47a gmullen
 * PR42443: Removed call to change band rates when changing parser mode.
 * 
 * Hydra_Software_Devel/23   5/5/08 3:07p gmullen
 * PR42437: 7325, 3556, and 3548 only have 2 playback channels.
 * 
 * Hydra_Software_Devel/22   3/26/08 11:24a gmullen
 * PR38954: Added 3548 support to XPT PI.
 * 
 * Hydra_Software_Devel/21   2/22/08 11:09a gmullen
 * PR39874: Disabled XC buffer pause before disabling remux.
 * 
 * Hydra_Software_Devel/20   11/28/07 12:15p gmullen
 * PR36900: Added 7335 support
 * 
 * Hydra_Software_Devel/19   10/30/07 3:12p gmullen
 * PR35018: Added support for 7325
 * 
 * Hydra_Software_Devel/18   8/1/07 4:30p gmullen
 * PR33714: Disable mesg block pause to playbacks on 7440.
 * 
 * Hydra_Software_Devel/17   6/19/07 9:43a katrep
 * PR27642: Updated XcBuf table for 7405.
 * 
 * Hydra_Software_Devel/16   3/2/07 5:54p katrep
 * PR23114: Fixed the 7440 A0 compile problem after RMX defines removed
 * from RDB.
 * 
 * Hydra_Software_Devel/15   2/21/07 1:04p gmullen
 * PR26217: Added support for IB4 parser.
 * 
 * Hydra_Software_Devel/14   1/8/07 4:33p katrep
 * PR26929: Remux and Playback 3 are not available on 7440.
 * 
 * Hydra_Software_Devel/13   11/14/06 10:57a gmullen
 * PR25771: All buffers are 256 bytes, unless user specifies larger.
 * 
 * Hydra_Software_Devel/12   11/2/06 4:31p gmullen
 * PR25402: Added support for secure heap to RS and XC buffer code.
 * 
 * Hydra_Software_Devel/11   11/2/06 8:40a gmullen
 * PR23189: Added 3563 support.
 * 
 * Hydra_Software_Devel/10   8/25/06 10:14a gmullen
 * PR23896: Plugged leak.
 * 
 * Hydra_Software_Devel/9   8/17/06 6:01p katrep
 * PR23114: Added Support for 7440 chip
 * 
 * Hydra_Software_Devel/8   8/16/06 1:23p katrep
 * PR23616: Changed XcBuf init according to the order followed by
 * BXPT_XcBuf_Id.
 * 
 * Hydra_Software_Devel/7   7/24/06 6:37p gmullen
 * PR22836: If PB0 support is requested, force PB1 support.
 * 
 * Hydra_Software_Devel/6   7/20/06 5:30p katrep
 * PR22365: Added better mangement of XC buffer client BW for playback.XC
 * buf for PB is given max BW & BW throtle is done at PB engine.Spare BW
 * enabllag is used to provide more BW for PB if available.
 * 
 * Hydra_Software_Devel/5   7/17/06 5:19p gmullen
 * PR20624: Added code for 7118.
 * 
 * Hydra_Software_Devel/4   7/12/06 5:54p gmullen
 * PR21042: XC and RS buffers can be customized to reduce total memory
 * needs.
 * 
 * Hydra_Software_Devel/3   4/13/06 4:02p gmullen
 * PR20914: Ported over Prashant's fix from 7401A0
 * 
 * Hydra_Software_Devel/2   2/1/06 10:19a gmullen
 * PR18998: Fixed overflow issue in RAVE ITB/CDB, added support for PB
 * channels.
 * 
 * Hydra_Software_Devel/5   11/8/05 10:22a gmullen
 * PR15309: Updated.
 * 
 * Hydra_Software_Devel/4   8/26/05 2:01p gmullen
 * PR15309: Added DirecTV support, RAVE video support, cleaned up RS and
 * XC buffer code.
 * 
 * Hydra_Software_Devel/3   7/26/05 5:48p gmullen
 * PR15309: Fixed buffer size issue in bxpt_rave.c and added buffer
 * shutdown code to other blocks.
 * 
 * Hydra_Software_Devel/2   7/19/05 1:27p gmullen
 * PR15309: Fixed buffer alloc bugs.
 * 
 * Hydra_Software_Devel/1   7/15/05 9:04a gmullen
 * PR15309: Inita i
 * 
 *
 ***************************************************************************/

#include "bstd.h"
#include "bxpt_priv.h"
#include "bxpt.h"
#include "bkni.h"
#include "bxpt_xcbuf.h"

#include "bchp_xpt_xcbuff.h"

BDBG_MODULE( xpt_xcbuf );

#ifdef SW7342_241_WORKAROUND
    #define INITIAL_BITRATE (30000000 * 2)
#else
    #define INITIAL_BITRATE 25000000
#endif

/* give PB XC enough BW and limit the BW through Plaback engine BO_COUNT mechanism */
#define BXPT_MAX_PLAYBACK_RATE  ( 108000000 )

static struct 
{
    BXPT_XcBuf_Id Id;
    uint32_t BoRegAddr;
    uint32_t BufPtrRegAddr;
    unsigned long InitRate;
    unsigned long InitSize;     /* ToDo: Remove, since it's no longer used. */
    uint32_t EnableRegAddr;
    uint32_t EnableBitShift;
    uint32_t PauseBitShift;
}
const XcBuf[] = 
{
#if ( BCHP_CHIP == 7635 ) || ( BCHP_CHIP == 7630 )
        { BXPT_XcBuf_Id_RMX0_IBP0,  BCHP_XPT_XCBUFF_BO_RMX0_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_RMX0_IBP1,  BCHP_XPT_XCBUFF_BO_RMX0_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_RMX0_IBP2,  BCHP_XPT_XCBUFF_BO_RMX0_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_RMX0_IBP3,  BCHP_XPT_XCBUFF_BO_RMX0_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_RMX0_IBP4,  BCHP_XPT_XCBUFF_BO_RMX0_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_RMX0_IBP5,  BCHP_XPT_XCBUFF_BO_RMX0_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 21, 5 }, 
         
        { BXPT_XcBuf_Id_RMX0_PBP0,  BCHP_XPT_XCBUFF_BO_RMX0_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_RMX0_PBP1,  BCHP_XPT_XCBUFF_BO_RMX0_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 25, 9 }, 
        { BXPT_XcBuf_Id_RMX0_PBP2,  BCHP_XPT_XCBUFF_BO_RMX0_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RMX0_PBP3,  BCHP_XPT_XCBUFF_BO_RMX0_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 27, 11 },
         
        { BXPT_XcBuf_Id_RMX1_IBP0,  BCHP_XPT_XCBUFF_BO_RMX1_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_RMX1_IBP1,  BCHP_XPT_XCBUFF_BO_RMX1_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_RMX1_IBP2,  BCHP_XPT_XCBUFF_BO_RMX1_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_RMX1_IBP3,  BCHP_XPT_XCBUFF_BO_RMX1_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_RMX1_IBP4,  BCHP_XPT_XCBUFF_BO_RMX1_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_RMX1_IBP5,  BCHP_XPT_XCBUFF_BO_RMX1_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 21, 5 }, 
         
        { BXPT_XcBuf_Id_RMX1_PBP0,  BCHP_XPT_XCBUFF_BO_RMX1_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_RMX1_PBP1,  BCHP_XPT_XCBUFF_BO_RMX1_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 25, 9 }, 
        { BXPT_XcBuf_Id_RMX1_PBP2,  BCHP_XPT_XCBUFF_BO_RMX1_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RMX1_PBP3,  BCHP_XPT_XCBUFF_BO_RMX1_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 27, 11 },
         
        { BXPT_XcBuf_Id_RAVE_IBP0,  BCHP_XPT_XCBUFF_BO_RAVE_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_RAVE_IBP1,  BCHP_XPT_XCBUFF_BO_RAVE_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_RAVE_IBP2,  BCHP_XPT_XCBUFF_BO_RAVE_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_RAVE_IBP3,  BCHP_XPT_XCBUFF_BO_RAVE_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_RAVE_IBP4,  BCHP_XPT_XCBUFF_BO_RAVE_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_RAVE_IBP5,  BCHP_XPT_XCBUFF_BO_RAVE_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 21, 5 }, 
         
        { BXPT_XcBuf_Id_RAVE_PBP0,  BCHP_XPT_XCBUFF_BO_RAVE_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_RAVE_PBP1,  BCHP_XPT_XCBUFF_BO_RAVE_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 25, 9 }, 
        { BXPT_XcBuf_Id_RAVE_PBP2,  BCHP_XPT_XCBUFF_BO_RAVE_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RAVE_PBP3,  BCHP_XPT_XCBUFF_BO_RAVE_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 27, 11 },
                                  
        { BXPT_XcBuf_Id_MSG_IBP0,   BCHP_XPT_XCBUFF_BO_MSG_IBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP0,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_MSG_IBP1,   BCHP_XPT_XCBUFF_BO_MSG_IBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP1,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_MSG_IBP2,   BCHP_XPT_XCBUFF_BO_MSG_IBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP2,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_MSG_IBP3,   BCHP_XPT_XCBUFF_BO_MSG_IBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP3,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_MSG_IBP4,   BCHP_XPT_XCBUFF_BO_MSG_IBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP4,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_MSG_IBP5,   BCHP_XPT_XCBUFF_BO_MSG_IBP5,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP5,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 21, 5 }, 
         
        { BXPT_XcBuf_Id_MSG_PBP0,   BCHP_XPT_XCBUFF_BO_MSG_PBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP0,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_MSG_PBP1,   BCHP_XPT_XCBUFF_BO_MSG_PBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP1,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 25, 9 },
        { BXPT_XcBuf_Id_MSG_PBP2,   BCHP_XPT_XCBUFF_BO_MSG_PBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP2,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_MSG_PBP3,   BCHP_XPT_XCBUFF_BO_MSG_PBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP3,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 27, 11 },

#elif ( BCHP_CHIP == 7325 ) || ( BCHP_CHIP == 3548 ) || ( BCHP_CHIP == 3556 ) || ( BCHP_CHIP == 7420 ) 
        { BXPT_XcBuf_Id_RMX0_IBP0,  BCHP_XPT_XCBUFF_BO_RMX0_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_RMX0_IBP1,  BCHP_XPT_XCBUFF_BO_RMX0_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_RMX0_IBP2,  BCHP_XPT_XCBUFF_BO_RMX0_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_RMX0_IBP3,  BCHP_XPT_XCBUFF_BO_RMX0_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_RMX0_IBP4,  BCHP_XPT_XCBUFF_BO_RMX0_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_RMX0_IBP5,  BCHP_XPT_XCBUFF_BO_RMX0_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 21, 5 }, 
        { BXPT_XcBuf_Id_RMX0_IBP6,  BCHP_XPT_XCBUFF_BO_RMX0_IBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP6,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 22, 6 }, 

        { BXPT_XcBuf_Id_RMX0_PBP0,  BCHP_XPT_XCBUFF_BO_RMX0_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_RMX0_PBP1,  BCHP_XPT_XCBUFF_BO_RMX0_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 25, 9 }, 
#if ( BCHP_CHIP == 7420 ) 
        { BXPT_XcBuf_Id_RMX0_PBP2,  BCHP_XPT_XCBUFF_BO_RMX0_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RMX0_PBP3,  BCHP_XPT_XCBUFF_BO_RMX0_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 27, 11 },
        { BXPT_XcBuf_Id_RMX0_PBP4,  BCHP_XPT_XCBUFF_BO_RMX0_PBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP4,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 28, 12 },
        { BXPT_XcBuf_Id_RMX0_PBP5,  BCHP_XPT_XCBUFF_BO_RMX0_PBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP5,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 29, 13 },
        { BXPT_XcBuf_Id_RMX0_PBP6,  BCHP_XPT_XCBUFF_BO_RMX0_PBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP6,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 30, 14 },
        { BXPT_XcBuf_Id_RMX0_PBP7,  BCHP_XPT_XCBUFF_BO_RMX0_PBP7,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP7,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 31, 15 },
#endif
        { BXPT_XcBuf_Id_RMX1_IBP0,  BCHP_XPT_XCBUFF_BO_RMX1_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_RMX1_IBP1,  BCHP_XPT_XCBUFF_BO_RMX1_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_RMX1_IBP2,  BCHP_XPT_XCBUFF_BO_RMX1_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_RMX1_IBP3,  BCHP_XPT_XCBUFF_BO_RMX1_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_RMX1_IBP4,  BCHP_XPT_XCBUFF_BO_RMX1_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_RMX1_IBP5,  BCHP_XPT_XCBUFF_BO_RMX1_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 21, 5 }, 
        { BXPT_XcBuf_Id_RMX1_IBP6,  BCHP_XPT_XCBUFF_BO_RMX1_IBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP6,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 22, 6 }, 

        { BXPT_XcBuf_Id_RMX1_PBP0,  BCHP_XPT_XCBUFF_BO_RMX1_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_RMX1_PBP1,  BCHP_XPT_XCBUFF_BO_RMX1_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 25, 9 }, 
#if ( BCHP_CHIP == 7420 ) 
        { BXPT_XcBuf_Id_RMX1_PBP2,  BCHP_XPT_XCBUFF_BO_RMX1_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RMX1_PBP3,  BCHP_XPT_XCBUFF_BO_RMX1_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 27, 11 },
        { BXPT_XcBuf_Id_RMX1_PBP4,  BCHP_XPT_XCBUFF_BO_RMX1_PBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP4,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 28, 12 },
        { BXPT_XcBuf_Id_RMX1_PBP5,  BCHP_XPT_XCBUFF_BO_RMX1_PBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP5,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 29, 13 },
        { BXPT_XcBuf_Id_RMX1_PBP6,  BCHP_XPT_XCBUFF_BO_RMX1_PBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP6,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 30, 14 },
        { BXPT_XcBuf_Id_RMX1_PBP7,  BCHP_XPT_XCBUFF_BO_RMX1_PBP7,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP7,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 31, 15 },
#endif

        { BXPT_XcBuf_Id_RAVE_IBP0,  BCHP_XPT_XCBUFF_BO_RAVE_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_RAVE_IBP1,  BCHP_XPT_XCBUFF_BO_RAVE_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_RAVE_IBP2,  BCHP_XPT_XCBUFF_BO_RAVE_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_RAVE_IBP3,  BCHP_XPT_XCBUFF_BO_RAVE_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_RAVE_IBP4,  BCHP_XPT_XCBUFF_BO_RAVE_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_RAVE_IBP5,  BCHP_XPT_XCBUFF_BO_RAVE_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 21, 5 }, 
        { BXPT_XcBuf_Id_RAVE_IBP6,  BCHP_XPT_XCBUFF_BO_RAVE_IBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP6,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 22, 6 }, 

        { BXPT_XcBuf_Id_RAVE_PBP0,  BCHP_XPT_XCBUFF_BO_RAVE_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_RAVE_PBP1,  BCHP_XPT_XCBUFF_BO_RAVE_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 25, 9 }, 
#if ( BCHP_CHIP == 7420 ) 
        { BXPT_XcBuf_Id_RAVE_PBP2,  BCHP_XPT_XCBUFF_BO_RAVE_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RAVE_PBP3,  BCHP_XPT_XCBUFF_BO_RAVE_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 27, 11 },
        { BXPT_XcBuf_Id_RAVE_PBP4,  BCHP_XPT_XCBUFF_BO_RAVE_PBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP4,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 28, 12 },
        { BXPT_XcBuf_Id_RAVE_PBP5,  BCHP_XPT_XCBUFF_BO_RAVE_PBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP5,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 29, 13 },
        { BXPT_XcBuf_Id_RAVE_PBP6,  BCHP_XPT_XCBUFF_BO_RAVE_PBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP6,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 30, 14 },
        { BXPT_XcBuf_Id_RAVE_PBP7,  BCHP_XPT_XCBUFF_BO_RAVE_PBP7,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP7,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 31, 15 },
#endif

        { BXPT_XcBuf_Id_MSG_IBP0,   BCHP_XPT_XCBUFF_BO_MSG_IBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP0,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_MSG_IBP1,   BCHP_XPT_XCBUFF_BO_MSG_IBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP1,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_MSG_IBP2,   BCHP_XPT_XCBUFF_BO_MSG_IBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP2,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_MSG_IBP3,   BCHP_XPT_XCBUFF_BO_MSG_IBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP3,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_MSG_IBP4,   BCHP_XPT_XCBUFF_BO_MSG_IBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP4,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_MSG_IBP5,   BCHP_XPT_XCBUFF_BO_MSG_IBP5,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP5,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 21, 5 }, 
        { BXPT_XcBuf_Id_MSG_IBP6,   BCHP_XPT_XCBUFF_BO_MSG_IBP6,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP6,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 22, 6 }, 

        { BXPT_XcBuf_Id_MSG_PBP0,   BCHP_XPT_XCBUFF_BO_MSG_PBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP0,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_MSG_PBP1,   BCHP_XPT_XCBUFF_BO_MSG_PBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP1,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 25, 9 },
#if ( BCHP_CHIP == 7420 )
        { BXPT_XcBuf_Id_MSG_PBP2,   BCHP_XPT_XCBUFF_BO_MSG_PBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP2,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_MSG_PBP3,   BCHP_XPT_XCBUFF_BO_MSG_PBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP3,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 27, 11 },
        { BXPT_XcBuf_Id_MSG_PBP4,   BCHP_XPT_XCBUFF_BO_MSG_PBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP4,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 28, 12 },
        { BXPT_XcBuf_Id_MSG_PBP5,   BCHP_XPT_XCBUFF_BO_MSG_PBP5,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP5,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 29, 13 },
        { BXPT_XcBuf_Id_MSG_PBP6,   BCHP_XPT_XCBUFF_BO_MSG_PBP6,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP6,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 30, 14 },
        { BXPT_XcBuf_Id_MSG_PBP7,   BCHP_XPT_XCBUFF_BO_MSG_PBP7,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP7,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 31, 15 },
#endif

#elif ( BCHP_CHIP == 7335 ) || ( BCHP_CHIP == 7336  ) || ( BCHP_CHIP == 7342 )
        { BXPT_XcBuf_Id_RMX0_IBP0,  BCHP_XPT_XCBUFF_BO_RMX0_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_RMX0_IBP1,  BCHP_XPT_XCBUFF_BO_RMX0_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_RMX0_IBP2,  BCHP_XPT_XCBUFF_BO_RMX0_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_RMX0_IBP3,  BCHP_XPT_XCBUFF_BO_RMX0_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_RMX0_IBP4,  BCHP_XPT_XCBUFF_BO_RMX0_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_RMX0_IBP5,  BCHP_XPT_XCBUFF_BO_RMX0_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 21, 5 }, 
        { BXPT_XcBuf_Id_RMX0_IBP6,  BCHP_XPT_XCBUFF_BO_RMX0_IBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP6,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 22, 6 }, 

        { BXPT_XcBuf_Id_RMX0_PBP0,  BCHP_XPT_XCBUFF_BO_RMX0_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_RMX0_PBP1,  BCHP_XPT_XCBUFF_BO_RMX0_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 25, 9 }, 
        { BXPT_XcBuf_Id_RMX0_PBP2,  BCHP_XPT_XCBUFF_BO_RMX0_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 26, 10 }, 
        { BXPT_XcBuf_Id_RMX0_PBP3,  BCHP_XPT_XCBUFF_BO_RMX0_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 27, 11 }, 
        { BXPT_XcBuf_Id_RMX0_PBP4,  BCHP_XPT_XCBUFF_BO_RMX0_PBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP4,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 28, 12 }, 
	#if ( BCHP_CHIP == 7342 )
		{ BXPT_XcBuf_Id_RMX0_PBP5,  BCHP_XPT_XCBUFF_BO_RMX0_PBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP5,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 29, 13 }, 
        { BXPT_XcBuf_Id_RMX0_PBP6,  BCHP_XPT_XCBUFF_BO_RMX0_PBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP6,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 30, 14 }, 
        { BXPT_XcBuf_Id_RMX0_PBP7,  BCHP_XPT_XCBUFF_BO_RMX0_PBP7,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP7,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 31, 15 }, 
	#endif

        { BXPT_XcBuf_Id_RMX1_IBP0,  BCHP_XPT_XCBUFF_BO_RMX1_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_RMX1_IBP1,  BCHP_XPT_XCBUFF_BO_RMX1_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_RMX1_IBP2,  BCHP_XPT_XCBUFF_BO_RMX1_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_RMX1_IBP3,  BCHP_XPT_XCBUFF_BO_RMX1_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_RMX1_IBP4,  BCHP_XPT_XCBUFF_BO_RMX1_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_RMX1_IBP5,  BCHP_XPT_XCBUFF_BO_RMX1_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 21, 5 }, 
        { BXPT_XcBuf_Id_RMX1_IBP6,  BCHP_XPT_XCBUFF_BO_RMX1_IBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP6,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 22, 6 }, 

        { BXPT_XcBuf_Id_RMX1_PBP0,  BCHP_XPT_XCBUFF_BO_RMX1_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_RMX1_PBP1,  BCHP_XPT_XCBUFF_BO_RMX1_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 25, 9 }, 
        { BXPT_XcBuf_Id_RMX1_PBP2,  BCHP_XPT_XCBUFF_BO_RMX1_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 26, 10 }, 
        { BXPT_XcBuf_Id_RMX1_PBP3,  BCHP_XPT_XCBUFF_BO_RMX1_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 27, 11 }, 
        { BXPT_XcBuf_Id_RMX1_PBP4,  BCHP_XPT_XCBUFF_BO_RMX1_PBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP4,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 28, 12 }, 
	#if ( BCHP_CHIP == 7342 )
	    { BXPT_XcBuf_Id_RMX1_PBP5,  BCHP_XPT_XCBUFF_BO_RMX1_PBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP5,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 29, 13 }, 
	    { BXPT_XcBuf_Id_RMX1_PBP6,  BCHP_XPT_XCBUFF_BO_RMX1_PBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP6,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 30, 14 }, 
	    { BXPT_XcBuf_Id_RMX1_PBP7,  BCHP_XPT_XCBUFF_BO_RMX1_PBP7,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP7,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 31, 15 }, 
	#endif

        { BXPT_XcBuf_Id_RAVE_IBP0,  BCHP_XPT_XCBUFF_BO_RAVE_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_RAVE_IBP1,  BCHP_XPT_XCBUFF_BO_RAVE_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_RAVE_IBP2,  BCHP_XPT_XCBUFF_BO_RAVE_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_RAVE_IBP3,  BCHP_XPT_XCBUFF_BO_RAVE_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_RAVE_IBP4,  BCHP_XPT_XCBUFF_BO_RAVE_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_RAVE_IBP5,  BCHP_XPT_XCBUFF_BO_RAVE_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 21, 5 }, 
        { BXPT_XcBuf_Id_RAVE_IBP6,  BCHP_XPT_XCBUFF_BO_RAVE_IBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP6,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 22, 6 }, 

        { BXPT_XcBuf_Id_RAVE_PBP0,  BCHP_XPT_XCBUFF_BO_RAVE_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_RAVE_PBP1,  BCHP_XPT_XCBUFF_BO_RAVE_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 25, 9 }, 
        { BXPT_XcBuf_Id_RAVE_PBP2,  BCHP_XPT_XCBUFF_BO_RAVE_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 26, 10 }, 
        { BXPT_XcBuf_Id_RAVE_PBP3,  BCHP_XPT_XCBUFF_BO_RAVE_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 27, 11 }, 
        { BXPT_XcBuf_Id_RAVE_PBP4,  BCHP_XPT_XCBUFF_BO_RAVE_PBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP4,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 28, 12 }, 
	#if ( BCHP_CHIP == 7342 )
	    { BXPT_XcBuf_Id_RAVE_PBP5,  BCHP_XPT_XCBUFF_BO_RAVE_PBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP5,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 29, 13 }, 
	    { BXPT_XcBuf_Id_RAVE_PBP6,  BCHP_XPT_XCBUFF_BO_RAVE_PBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP6,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 30, 14 }, 
	    { BXPT_XcBuf_Id_RAVE_PBP7,  BCHP_XPT_XCBUFF_BO_RAVE_PBP7,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP7,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 31, 15 }, 
	#endif

        { BXPT_XcBuf_Id_MSG_IBP0,   BCHP_XPT_XCBUFF_BO_MSG_IBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP0,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_MSG_IBP1,   BCHP_XPT_XCBUFF_BO_MSG_IBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP1,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_MSG_IBP2,   BCHP_XPT_XCBUFF_BO_MSG_IBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP2,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_MSG_IBP3,   BCHP_XPT_XCBUFF_BO_MSG_IBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP3,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_MSG_IBP4,   BCHP_XPT_XCBUFF_BO_MSG_IBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP4,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_MSG_IBP5,   BCHP_XPT_XCBUFF_BO_MSG_IBP5,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP5,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 21, 5 }, 
        { BXPT_XcBuf_Id_MSG_IBP6,   BCHP_XPT_XCBUFF_BO_MSG_IBP6,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP6,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 22, 6 }, 

        { BXPT_XcBuf_Id_MSG_PBP0,   BCHP_XPT_XCBUFF_BO_MSG_PBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP0,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_MSG_PBP1,   BCHP_XPT_XCBUFF_BO_MSG_PBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP1,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 25, 9 },
        { BXPT_XcBuf_Id_MSG_PBP2,   BCHP_XPT_XCBUFF_BO_MSG_PBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP2,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 26, 10 }, 
        { BXPT_XcBuf_Id_MSG_PBP3,   BCHP_XPT_XCBUFF_BO_MSG_PBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP3,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 27, 11 },
        { BXPT_XcBuf_Id_MSG_PBP4,   BCHP_XPT_XCBUFF_BO_MSG_PBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP4,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 28, 12 },
	#if ( BCHP_CHIP == 7342 )
	    { BXPT_XcBuf_Id_MSG_PBP5,   BCHP_XPT_XCBUFF_BO_MSG_PBP5,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP5,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 29, 13 },
	    { BXPT_XcBuf_Id_MSG_PBP6,   BCHP_XPT_XCBUFF_BO_MSG_PBP6,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP6,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 30, 14 },
	    { BXPT_XcBuf_Id_MSG_PBP7,   BCHP_XPT_XCBUFF_BO_MSG_PBP7,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP7,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 31, 15 },
	#endif
#elif ( BCHP_CHIP == 7125) || ( BCHP_CHIP == 7340 )
        { BXPT_XcBuf_Id_RMX0_IBP0,  BCHP_XPT_XCBUFF_BO_RMX0_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_RMX0_IBP1,  BCHP_XPT_XCBUFF_BO_RMX0_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_RMX0_IBP2,  BCHP_XPT_XCBUFF_BO_RMX0_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_RMX0_IBP3,  BCHP_XPT_XCBUFF_BO_RMX0_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_RMX0_IBP4,  BCHP_XPT_XCBUFF_BO_RMX0_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_RMX0_IBP5,  BCHP_XPT_XCBUFF_BO_RMX0_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 21, 5 }, 

        { BXPT_XcBuf_Id_RMX0_PBP0,  BCHP_XPT_XCBUFF_BO_RMX0_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_RMX0_PBP1,  BCHP_XPT_XCBUFF_BO_RMX0_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 25, 9 }, 

        { BXPT_XcBuf_Id_RMX1_IBP0,  BCHP_XPT_XCBUFF_BO_RMX1_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_RMX1_IBP1,  BCHP_XPT_XCBUFF_BO_RMX1_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_RMX1_IBP2,  BCHP_XPT_XCBUFF_BO_RMX1_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_RMX1_IBP3,  BCHP_XPT_XCBUFF_BO_RMX1_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_RMX1_IBP4,  BCHP_XPT_XCBUFF_BO_RMX1_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_RMX1_IBP5,  BCHP_XPT_XCBUFF_BO_RMX1_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 21, 5 }, 

        { BXPT_XcBuf_Id_RMX1_PBP0,  BCHP_XPT_XCBUFF_BO_RMX1_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_RMX1_PBP1,  BCHP_XPT_XCBUFF_BO_RMX1_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 25, 9 }, 

        { BXPT_XcBuf_Id_RAVE_IBP0,  BCHP_XPT_XCBUFF_BO_RAVE_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_RAVE_IBP1,  BCHP_XPT_XCBUFF_BO_RAVE_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_RAVE_IBP2,  BCHP_XPT_XCBUFF_BO_RAVE_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_RAVE_IBP3,  BCHP_XPT_XCBUFF_BO_RAVE_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_RAVE_IBP4,  BCHP_XPT_XCBUFF_BO_RAVE_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_RAVE_IBP5,  BCHP_XPT_XCBUFF_BO_RAVE_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 21, 5 }, 

        { BXPT_XcBuf_Id_RAVE_PBP0,  BCHP_XPT_XCBUFF_BO_RAVE_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_RAVE_PBP1,  BCHP_XPT_XCBUFF_BO_RAVE_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 25, 9 }, 

        { BXPT_XcBuf_Id_MSG_IBP0,   BCHP_XPT_XCBUFF_BO_MSG_IBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP0,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_MSG_IBP1,   BCHP_XPT_XCBUFF_BO_MSG_IBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP1,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_MSG_IBP2,   BCHP_XPT_XCBUFF_BO_MSG_IBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP2,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_MSG_IBP3,   BCHP_XPT_XCBUFF_BO_MSG_IBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP3,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_MSG_IBP4,   BCHP_XPT_XCBUFF_BO_MSG_IBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP4,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 20, 4 }, 
        { BXPT_XcBuf_Id_MSG_IBP5,   BCHP_XPT_XCBUFF_BO_MSG_IBP5,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP5,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 21, 5 }, 

        { BXPT_XcBuf_Id_MSG_PBP0,   BCHP_XPT_XCBUFF_BO_MSG_PBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP0,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_MSG_PBP1,   BCHP_XPT_XCBUFF_BO_MSG_PBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP1,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 25, 9 },
#else
    #if ( BCHP_CHIP != 7440 )
        { BXPT_XcBuf_Id_RMX0_A,     BCHP_XPT_XCBUFF_BO_RMX0_A,     BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_A,     INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 1, 0 }, 
        { BXPT_XcBuf_Id_RMX0_B,     BCHP_XPT_XCBUFF_BO_RMX0_B,     BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_B,     INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 2, 0 }, 
    #endif

    #if ( BCHP_CHIP == 3563 )|| ( BCHP_CHIP == 7440 )
        /* These chips have only 1 remux. */
    #else
        /* Everybody else has 2 */
        { BXPT_XcBuf_Id_RMX1_A,     BCHP_XPT_XCBUFF_BO_RMX1_A,     BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_A,     INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 1, 0 }, 
        { BXPT_XcBuf_Id_RMX1_B,     BCHP_XPT_XCBUFF_BO_RMX1_B,     BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_B,     INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 2, 0 }, 
    #endif

        { BXPT_XcBuf_Id_RAVE_IBP0,  BCHP_XPT_XCBUFF_BO_RAVE_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_RAVE_IBP1,  BCHP_XPT_XCBUFF_BO_RAVE_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_RAVE_IBP2,  BCHP_XPT_XCBUFF_BO_RAVE_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_RAVE_IBP3,  BCHP_XPT_XCBUFF_BO_RAVE_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_RAVE_IBP4,  BCHP_XPT_XCBUFF_BO_RAVE_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 20, 4 }, 

    #if ( BCHP_CHIP == 7118 ) || ( BCHP_CHIP == 3563 )
        /* 7118 does not have IB5 or 6 */
    #else
        { BXPT_XcBuf_Id_RAVE_IBP5,  BCHP_XPT_XCBUFF_BO_RAVE_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 21, 5 }, 
        { BXPT_XcBuf_Id_RAVE_IBP6,  BCHP_XPT_XCBUFF_BO_RAVE_IBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP6,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 22, 6 }, 
    #endif

    #if ( BCHP_CHIP == 3563 )
        /* 3563 has only PB0 */
        { BXPT_XcBuf_Id_RAVE_PBP0,  BCHP_XPT_XCBUFF_BO_RAVE_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 24, 8 }, 
    #else
        { BXPT_XcBuf_Id_RAVE_PBP0,  BCHP_XPT_XCBUFF_BO_RAVE_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_RAVE_PBP1,  BCHP_XPT_XCBUFF_BO_RAVE_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 25, 9 }, 
    #endif

    #if ( BCHP_CHIP == 7118 ) || ( BCHP_CHIP == 3563 )
        /* Not in either of these chips */
    #else
        { BXPT_XcBuf_Id_RAVE_PBP2,  BCHP_XPT_XCBUFF_BO_RAVE_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 26, 10 }, 
        #if ( BCHP_CHIP != 7440 )
        { BXPT_XcBuf_Id_RAVE_PBP3,  BCHP_XPT_XCBUFF_BO_RAVE_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 27, 11 }, 
        #endif
    #endif  

    #if ( BCHP_CHIP == 7400 && BCHP_VER >= BCHP_VER_B0 ) || ( BCHP_CHIP == 7405 )
        { BXPT_XcBuf_Id_RAVE_PBP4,  BCHP_XPT_XCBUFF_BO_RAVE_PBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP4,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 28, 12 }, 
    #endif

        { BXPT_XcBuf_Id_MSG_IBP0,   BCHP_XPT_XCBUFF_BO_MSG_IBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP0,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 16, 0 }, 
        { BXPT_XcBuf_Id_MSG_IBP1,   BCHP_XPT_XCBUFF_BO_MSG_IBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP1,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 17, 1 }, 
        { BXPT_XcBuf_Id_MSG_IBP2,   BCHP_XPT_XCBUFF_BO_MSG_IBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP2,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 18, 2 }, 
        { BXPT_XcBuf_Id_MSG_IBP3,   BCHP_XPT_XCBUFF_BO_MSG_IBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP3,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 19, 3 }, 
        { BXPT_XcBuf_Id_MSG_IBP4,   BCHP_XPT_XCBUFF_BO_MSG_IBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP4,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 20, 4 }, 

    #if ( BCHP_CHIP == 7118 ) || ( BCHP_CHIP == 3563 )
        /* 7118 doesn't have either IB5 or 6 */
    #else
        { BXPT_XcBuf_Id_MSG_IBP5,   BCHP_XPT_XCBUFF_BO_MSG_IBP5,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP5,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 21, 5 }, 
        { BXPT_XcBuf_Id_MSG_IBP6,   BCHP_XPT_XCBUFF_BO_MSG_IBP6,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP6,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 22, 6 }, 
    #endif

    #if ( BCHP_CHIP == 3563 )
        /* 3563 has only PB0 */
        { BXPT_XcBuf_Id_MSG_PBP0,   BCHP_XPT_XCBUFF_BO_MSG_PBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP0,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 24, 8 }, 
    #else
        { BXPT_XcBuf_Id_MSG_PBP0,   BCHP_XPT_XCBUFF_BO_MSG_PBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP0,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 24, 8 }, 
        { BXPT_XcBuf_Id_MSG_PBP1,   BCHP_XPT_XCBUFF_BO_MSG_PBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP1,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 25, 9 },
    #endif

    #if ( BCHP_CHIP == 7118 ) || ( BCHP_CHIP == 3563 )
        /* Not in either of these chips */
    #else
        { BXPT_XcBuf_Id_MSG_PBP2,   BCHP_XPT_XCBUFF_BO_MSG_PBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP2,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 26, 10 }, 
        #if ( BCHP_CHIP != 7440 )
        { BXPT_XcBuf_Id_MSG_PBP3,   BCHP_XPT_XCBUFF_BO_MSG_PBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP3,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 27, 11 },
        #endif
    #endif

    #if ( BCHP_CHIP == 7400 && BCHP_VER >= BCHP_VER_B0 ) || ( BCHP_CHIP == 7405 )
        { BXPT_XcBuf_Id_MSG_PBP4,   BCHP_XPT_XCBUFF_BO_MSG_PBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP4,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 28, 12 },
    #endif
#endif
    { 0, 0, 0, 0, 0, 0, 0, 0 }      /* Last entry is a NULL. */
};

/* Number of buffers, which does NOT include the NULL entry at the end of the list */
#define NUM_BUFFERS (( sizeof( XcBuf ) / sizeof( XcBuf[ 0 ] )) - 1 )

#define MAX_BITRATE                 ( 108000000 )
#define BLOCKOUT_REG_STEPSIZE       4
#define BUFFER_PTR_REG_STEPSIZE     24

/* Threshold for pause generation when XC Buffer for a corresponding band is almost full */
#define DEFAULT_PACKET_PAUSE_LEVEL  ( 6 )

static BERR_Code AllocateBuffer(
    BXPT_Handle hXpt,               
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long Size          /* [in] Size in bytes. Must be a multiple of 256. */
    );

static BERR_Code DeleteBuffer(
    BXPT_Handle hXpt, 
    BXPT_XcBuf_Id Id
    );

static BERR_Code EnableBuffer( 
    BXPT_Handle hXpt, 
    BXPT_XcBuf_Id Id            
    );

static BERR_Code DisableBuffer( 
    BXPT_Handle hXpt, 
    BXPT_XcBuf_Id Id            
    );

static BXPT_XcBuf_Id GetBufferId( 
    BXPT_XcBuf_Id BaseId,
    unsigned WhichOne
    );

static BERR_Code SetBandDataRate(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long Rate,         /* [in] Max rate in bps */
    unsigned PacketLen          /* [in] size of mpeg packet */
    );

static BERR_Code SetBlockout(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long NewBO        
    );

BERR_Code BXPT_XcBuf_SetBandDataRate(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long Rate,         /* [in] Max rate in bps */
    unsigned PacketLen          /* [in] size of mpeg packet */
    )
{
#ifdef SW7342_241_WORKAROUND                                
    BSTD_UNUSED( hXpt );
    BSTD_UNUSED( Id );
    BSTD_UNUSED( Rate );
    BSTD_UNUSED( PacketLen );
    return BERR_SUCCESS;
#else
    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);
    hXpt->XcBufBO[ Id ] = BXPT_P_XcBuf_ComputeBlockOut( Rate, PacketLen );
    return SetBandDataRate( hXpt, Id, Rate, PacketLen );
#endif
}

static BERR_Code SetBandDataRate(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long Rate,         /* [in] Max rate in bps */
    unsigned PacketLen          /* [in] size of mpeg packet */
    )
{
    uint32_t NewB0;

    BERR_Code ExitCode = BERR_SUCCESS;

    NewB0 = BXPT_P_XcBuf_ComputeBlockOut( Rate, PacketLen );             /* default set for mpeg */
    ExitCode = SetBlockout( hXpt, Id, NewB0 );

    return( ExitCode );
}


uint32_t BXPT_P_XcBuf_ComputeBlockOut( 
	unsigned long PeakRate,			/* [in] Max data rate (in bps) the band will handle. */
    unsigned PacketLen             /* [in] Packet size ,130 for dss and 188 for mpeg */
    )
{
    uint32_t NewBO;

    NewBO = MAX_BITRATE / 1000000;
    PeakRate = PeakRate / 1000000;
    NewBO = (NewBO *PacketLen* 8) / PeakRate;             
    return NewBO;                
}

BERR_Code BXPT_XcBuf_SetBufferSize(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long Size          /* [in] Size in bytes. Must be a multiple of 256. */
    )
{
    BERR_Code ExitCode = BERR_SUCCESS;

    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);

    DisableBuffer( hXpt, Id );
    DeleteBuffer( hXpt, Id );
    AllocateBuffer( hXpt, Id, Size );
    EnableBuffer( hXpt, Id );
    
    return( ExitCode );
}

BERR_Code BXPT_P_XcBuf_Init(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    const BXPT_DramBufferCfg *Cfg
    )
{
    BXPT_XcBuf_Id Id;
    uint32_t Reg;
    unsigned ii;
    unsigned BufferSize;
    uint32_t InitialBlockOut;

    BERR_Code ExitCode = BERR_SUCCESS;
    unsigned long TotalXcMemory = 0;

    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);

#if BDBG_DEBUG_BUILD
    /* 
    ** We have to statically define BXPT_P_MAX_XC_BUFFERS in bxpt_priv.h since 
    ** that file is included before the XcBuf struct is declared. 
    */
    if( BXPT_P_MAX_XC_BUFFERS < NUM_BUFFERS )
    {
        BDBG_ERR(( "Number of XC Buffers used exceeds the max supported!!" ));
    }
#endif

    /* Default all buffers to disabled. */
    for( Id = 0; Id < NUM_BUFFERS; Id++ )
    {
        DisableBuffer( hXpt, Id );
    }

    InitialBlockOut = BXPT_P_XcBuf_ComputeBlockOut( BXPT_P_DEFAULT_PEAK_RATE, 188 );
    for( ii = 0; ii < BXPT_P_MAX_XC_BUFFERS; ii++ )
        hXpt->XcBufBO[ ii ] = InitialBlockOut;   
    
    /* Set Pause to 6 packets */
    Reg = BREG_Read32( hXpt->hRegister, BCHP_XPT_XCBUFF_PAUSE_THRESHOLD );
    Reg &= ~( BCHP_MASK( XPT_XCBUFF_PAUSE_THRESHOLD, PACKETS ) );
    Reg |= ( BCHP_FIELD_DATA( XPT_XCBUFF_PAUSE_THRESHOLD, PACKETS, DEFAULT_PACKET_PAUSE_LEVEL ) );
    BREG_Write32( hXpt->hRegister, BCHP_XPT_XCBUFF_PAUSE_THRESHOLD, Reg );
   
#if ( BCHP_CHIP == 7635 ) || ( BCHP_CHIP == 7630 )
    /* Remux architecture changed quite a bit on the these parts */
    {
        for( Id = BXPT_XcBuf_Id_RMX0_IBP0; Id <= BXPT_XcBuf_Id_RMX0_IBP5; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX0_PBP0; Id <= BXPT_XcBuf_Id_RMX0_PBP3; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_IBP0; Id <= BXPT_XcBuf_Id_RMX1_IBP5; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_PBP0; Id <= BXPT_XcBuf_Id_RMX1_PBP3; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }
    }              

#elif ( BCHP_CHIP == 7325 ) || ( BCHP_CHIP == 3548 ) || ( BCHP_CHIP == 3556 ) || ( BCHP_CHIP == 7420 )
    /* Remux architecture changed quite a bit on the these parts */
    {
        for( Id = BXPT_XcBuf_Id_RMX0_IBP0; Id <= BXPT_XcBuf_Id_RMX0_IBP6; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX0_PBP0; Id <= BXPT_XcBuf_Id_RMX0_PBP1; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

	    #if ( BCHP_CHIP == 7420 ) 
        for( Id = BXPT_XcBuf_Id_RMX0_PBP2; Id <= BXPT_XcBuf_Id_RMX0_PBP7; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }
		#endif 

        for( Id = BXPT_XcBuf_Id_RMX1_IBP0; Id <= BXPT_XcBuf_Id_RMX1_IBP6; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_PBP0; Id <= BXPT_XcBuf_Id_RMX1_PBP1; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

	    #if ( BCHP_CHIP == 7420 ) 
        for( Id = BXPT_XcBuf_Id_RMX1_PBP2; Id <= BXPT_XcBuf_Id_RMX1_PBP7; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }
		#endif 
    }             
 
#elif ( BCHP_CHIP == 7335 ) || ( BCHP_CHIP == 7336  ) 
    /* Remux architecture changed quite a bit on the these parts */
    {
        for( Id = BXPT_XcBuf_Id_RMX0_IBP0; Id <= BXPT_XcBuf_Id_RMX0_IBP6; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX0_PBP0; Id <= BXPT_XcBuf_Id_RMX0_PBP4; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_IBP0; Id <= BXPT_XcBuf_Id_RMX1_IBP6; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_PBP0; Id <= BXPT_XcBuf_Id_RMX1_PBP4; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }
    }              

#elif ( BCHP_CHIP == 7342 )
    /* Remux architecture changed quite a bit on the these parts */
    {
        for( Id = BXPT_XcBuf_Id_RMX0_IBP0; Id <= BXPT_XcBuf_Id_RMX0_IBP6; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX0_PBP0; Id <= BXPT_XcBuf_Id_RMX0_PBP7; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_IBP0; Id <= BXPT_XcBuf_Id_RMX1_IBP6; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_PBP0; Id <= BXPT_XcBuf_Id_RMX1_PBP7; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }
    }              
#elif ( BCHP_CHIP == 7125 ) || ( BCHP_CHIP == 7340 )
    /* Remux architecture changed quite a bit on the these parts */
    {
        for( Id = BXPT_XcBuf_Id_RMX0_IBP0; Id <= BXPT_XcBuf_Id_RMX0_IBP5; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );

#ifdef SW7342_241_WORKAROUND
            BXPT_P_XcBuf_Pause( hXpt, Id, false );
#endif

            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX0_PBP0; Id <= BXPT_XcBuf_Id_RMX0_PBP1; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );

#ifdef SW7342_241_WORKAROUND
            BXPT_P_XcBuf_Pause( hXpt, Id, false );
#endif

            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_IBP0; Id <= BXPT_XcBuf_Id_RMX1_IBP5; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_PBP0; Id <= BXPT_XcBuf_Id_RMX1_PBP1; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }
    }              
#elif ( BCHP_CHIP == 7440 )
    /* On the 7440, we don't want the Message block to apply
       back-pressure to playback (ie, don't want graphics or 
       advanced file data to throttle audio-video). */
    Reg = BREG_Read32( hXpt->hRegister, BCHP_XPT_XCBUFF_MSG_CTRL );
    Reg &= ~( BCHP_MASK( XPT_XCBUFF_MSG_CTRL, PAUSE_EN_PBP ) );
    BREG_Write32( hXpt->hRegister, BCHP_XPT_XCBUFF_MSG_CTRL, Reg );
#else
    for( ii = 0; ii < BXPT_P_MAX_REMULTIPLEXORS; ii++ )
    {
        /* PR 25771: Need a buffer of at least 256 bytes. */
        if( Cfg->RemuxXcCfg[ ii ].BandAXcSize )
            BufferSize = Cfg->RemuxXcCfg[ ii ].BandAXcSize * 1024;
        else
            BufferSize = 256;

        Id = GetBufferId( BXPT_XcBuf_Id_RMX0_A, ii );
        SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
        AllocateBuffer( hXpt, Id, BufferSize );
        EnableBuffer( hXpt, Id );

        TotalXcMemory += BufferSize;
        BDBG_MSG(( "Enabling XC buffer for Remux %lu, Band A", ii ));

        /* PR 25771: Need a buffer of at least 256 bytes. */
        if( Cfg->RemuxXcCfg[ ii ].BandBXcSize )
            BufferSize = Cfg->RemuxXcCfg[ ii ].BandBXcSize * 1024;
        else
            BufferSize = 256;

        Id = GetBufferId( BXPT_XcBuf_Id_RMX0_B, ii );
        SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate,188 );
        AllocateBuffer( hXpt, Id, BufferSize );
        EnableBuffer( hXpt, Id );

        TotalXcMemory += BufferSize;
        BDBG_MSG(( "Enabling XC buffer for Remux %lu, Band B", ii ));
    } 
#endif

	for( ii = 0; ii < BXPT_P_MAX_PID_PARSERS; ii++ )
    {
        /* PR 25771: Need a buffer of at least 256 bytes. */
        if( Cfg->RaveXcCfg.IbParserXcSize[ ii ] )
            BufferSize = Cfg->RaveXcCfg.IbParserXcSize[ ii ] * 1024;
        else
            BufferSize = 256;

        Id = GetBufferId( BXPT_XcBuf_Id_RAVE_IBP0, ii );
        SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate,188 );
        AllocateBuffer( hXpt, Id, BufferSize );
        EnableBuffer( hXpt, Id );

        TotalXcMemory += BufferSize;
        BDBG_MSG(( "Enabling XC buffer for Rave IB %lu", ii ));

        /* PR 25771: Need a buffer of at least 256 bytes. */
        if( Cfg->MesgBufXcCfg.IbParserXcSize[ ii ] )
            BufferSize = Cfg->MesgBufXcCfg.IbParserXcSize[ ii ] * 1024;
        else
            BufferSize = 256;

        Id = GetBufferId( BXPT_XcBuf_Id_MSG_IBP0, ii );
        SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
        AllocateBuffer( hXpt, Id, BufferSize );
        EnableBuffer( hXpt, Id );

        TotalXcMemory += BufferSize;
        BDBG_MSG(( "Enabling XC buffer for Mesg filter IB %lu", ii ));
    } 

#if ( BCHP_CHIP == 7342 )
    for( ii = 0; ii <= (BXPT_XcBuf_Id_RAVE_PBP7 - BXPT_XcBuf_Id_RAVE_PBP0); ii++ )
#else
    for( ii = 0; ii < BXPT_P_MAX_PLAYBACKS; ii++ )
#endif
    {
        /* PR 25771: Need a buffer of at least 256 bytes. */
        if( Cfg->RaveXcCfg.PbParserXcSize[ ii ] )
            BufferSize = Cfg->RaveXcCfg.PbParserXcSize[ ii ] * 1024;
        else
            BufferSize = 256;

        Id = GetBufferId( BXPT_XcBuf_Id_RAVE_PBP0, ii );
        SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
        AllocateBuffer( hXpt, Id, BufferSize );
        EnableBuffer( hXpt, Id );

        TotalXcMemory += BufferSize;
        BDBG_MSG(( "Enabling XC buffer for Rave PB %lu", ii ));

        /* PR 25771: Need a buffer of at least 256 bytes. */
        if( Cfg->MesgBufXcCfg.PbParserXcSize[ ii ] )
            BufferSize = Cfg->MesgBufXcCfg.PbParserXcSize[ ii ] * 1024;
        else
            BufferSize = 256;

        Id = GetBufferId( BXPT_XcBuf_Id_MSG_PBP0, ii );
        SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
        AllocateBuffer( hXpt, Id, BufferSize );
        EnableBuffer( hXpt, Id );

        TotalXcMemory += BufferSize;
        BDBG_MSG(( "Enabling XC buffer for Mesg filter PB %lu", ii ));
    } 

    /* WORKAROUND. PR 22836: If PB0 support is enabled, PB1 support must be also. */
    /* NOTE: PR 22836 is covered by the workaround for PR 25771. */

    BDBG_MSG(( "Total XC memory usage is %lu bytes", TotalXcMemory ));

    /* Store the initial BlockOut values we've set above */
	for( ii = 0; ii < BXPT_P_MAX_PID_PARSERS; ii++ )
        hXpt->XcBufBO[ BXPT_XcBuf_Id_RAVE_IBP0 + ii ] = BXPT_P_XcBuf_GetBlockout( hXpt, BXPT_XcBuf_Id_RAVE_IBP0 + ii );

#ifdef SW7342_241_WORKAROUND
    #if (BCHP_CHIP == 7340) || (BCHP_CHIP == 7342)  
    /* This bifield isn't supported on all devices. */
        Reg = BREG_Read32( hXpt->hRegister, BCHP_XPT_XCBUFF_NO_RD_HANG_CTRL );
        Reg |= ( 
    	BCHP_FIELD_DATA( XPT_XCBUFF_NO_RD_HANG_CTRL, MSG_NO_RD_HANG_ON_WRONG_PKT_LEN, 1 ) |
    	BCHP_FIELD_DATA( XPT_XCBUFF_NO_RD_HANG_CTRL, RAVE_NO_RD_HANG_ON_WRONG_PKT_LEN, 1 ) 
    	);
        BREG_Write32( hXpt->hRegister, BCHP_XPT_XCBUFF_NO_RD_HANG_CTRL, Reg );  
    #endif
#endif

    return( ExitCode );
}

BERR_Code BXPT_P_XcBuf_Shutdown(
    BXPT_Handle hXpt            /* [in] Handle for this transport */
    )
{
    BXPT_XcBuf_Id Id;

    BERR_Code ExitCode = BERR_SUCCESS;

    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);

    for( Id = 0; Id < NUM_BUFFERS; Id++ )
        if( BXPT_P_XcBuf_IsBufferEnabled( hXpt, Id ) )
        {
            DisableBuffer( hXpt, Id );
            DeleteBuffer( hXpt, Id );
        }

    return( ExitCode );
}

BERR_Code BXPT_P_XcBuf_Pause(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    bool Enable
    )
{
    uint32_t EnReg;

    BERR_Code ExitCode = BERR_SUCCESS;

    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);

    EnReg = BREG_Read32( hXpt->hRegister, XcBuf[ Id ].EnableRegAddr );
    if( Enable == true )
        EnReg |= ( 1ul << XcBuf[ Id ].PauseBitShift ); 
    else
        EnReg &= ~( 1ul << XcBuf[ Id ].PauseBitShift );
    BREG_Write32( hXpt->hRegister, XcBuf[ Id ].EnableRegAddr, EnReg );  
    
    return( ExitCode );
}

BERR_Code BXPT_P_XcBuf_RemuxPause(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    unsigned RemuxNum,          /* [in] Which client buffer we are dealing with */
    bool Enable
    )
{
    uint32_t EnReg, EnRegAddr;

    BERR_Code ExitCode = BERR_SUCCESS;

    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);

#if ( BCHP_CHIP == 7325 ) || ( BCHP_CHIP == 7335 ) || ( BCHP_CHIP == 7336  ) || ( BCHP_CHIP == 3548 ) || ( BCHP_CHIP == 3556 ) || ( BCHP_CHIP == 7420 ) \
    || ( BCHP_CHIP == 7635 ) || ( BCHP_CHIP == 7342 )  || ( BCHP_CHIP == 7125) || ( BCHP_CHIP == 7340 ) || ( BCHP_CHIP == 7630 )
    switch( RemuxNum )
    {
        case 0: 
        EnRegAddr = BCHP_XPT_XCBUFF_RMX0_CTRL;
        break;

        case 1: 
        EnRegAddr = BCHP_XPT_XCBUFF_RMX1_CTRL;
        break;

        default:
        BDBG_ERR(( "Unsupported remux instance: %u", RemuxNum ));
        ExitCode = BERR_NOT_SUPPORTED;
        goto Done;
    }

    EnReg = BREG_Read32( hXpt->hRegister, EnRegAddr );
    if( Enable == true )
        EnReg |= 0x1F7F; 
    else
        EnReg &= 0xFFFF0000;
    BREG_Write32( hXpt->hRegister, EnRegAddr, EnReg );  
#else
    switch( RemuxNum )
    {
        case 0: 
        EnRegAddr = BCHP_XPT_XCBUFF_RMX0_CTRL;
        break;

    #if ( BCHP_CHIP == 3563 )|| ( BCHP_CHIP == 7440 )
        /* These chips have only 1 remux. */
    #else
        case 1: 
        EnRegAddr = BCHP_XPT_XCBUFF_RMX1_CTRL;
        break;
    #endif

        default:
        BDBG_ERR(( "Unsupported remux instance: %u", RemuxNum ));
        ExitCode = BERR_NOT_SUPPORTED;
        goto Done;
    }

    EnReg = BREG_Read32( hXpt->hRegister, EnRegAddr );
    if( Enable == true )
        EnReg |= 0x01; 
    else
        EnReg &= 0xFFFFFFFE;
    BREG_Write32( hXpt->hRegister, EnRegAddr, EnReg );  
#endif
    
    Done:
    return( ExitCode );
}

static BERR_Code DisableBuffer( 
    BXPT_Handle hXpt, 
    BXPT_XcBuf_Id Id            
    )
{
    uint32_t EnReg;

    BERR_Code ExitCode = BERR_SUCCESS;

    EnReg = BREG_Read32( hXpt->hRegister, XcBuf[ Id ].EnableRegAddr );
    EnReg &= ~( 1ul << XcBuf[ Id ].EnableBitShift );
    BREG_Write32( hXpt->hRegister, XcBuf[ Id ].EnableRegAddr, EnReg );  
    
    return( ExitCode );
}

static BERR_Code EnableBuffer( 
    BXPT_Handle hXpt, 
    BXPT_XcBuf_Id Id            
    )
{
    uint32_t EnReg;

    BERR_Code ExitCode = BERR_SUCCESS;

    EnReg = BREG_Read32( hXpt->hRegister, XcBuf[ Id ].EnableRegAddr );
    EnReg |= ( 1ul << XcBuf[ Id ].EnableBitShift );
    BREG_Write32( hXpt->hRegister, XcBuf[ Id ].EnableRegAddr, EnReg );  
    
    return( ExitCode );
}

static BERR_Code DeleteBuffer(
    BXPT_Handle hXpt, 
    BXPT_XcBuf_Id Id
    )
{
    uint32_t Offset;
    void *Buffer;

    BERR_Code ExitCode = BERR_SUCCESS;

    /* If there is a secure heap defined, use it. */
    BMEM_Handle hMem = hXpt->hRHeap ? hXpt->hRHeap : hXpt->hMemory;

    Offset = BREG_Read32( hXpt->hRegister, XcBuf[ Id ].BufPtrRegAddr );
    BMEM_ConvertOffsetToAddress( hMem, Offset, ( void ** ) &Buffer );
    BMEM_Free( hMem, Buffer );
    
    return( ExitCode );
}

static BERR_Code AllocateBuffer(
    BXPT_Handle hXpt,               
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long Size          /* [in] Size in bytes. Must be a multiple of 256. */
    )
{
    uint32_t Offset, RegAddr;
    void *Buffer;

    BERR_Code ExitCode = BERR_SUCCESS;

    /* If there is a secure heap defined, use it. */
    BMEM_Handle hMem = hXpt->hRHeap ? hXpt->hRHeap : hXpt->hMemory;

    /* Size must be a multiple of 256 */
    Size = Size - ( Size % 256 );

    Buffer = BMEM_AllocAligned( hMem, Size, 8, 0 ); 
    if( !Buffer )
    {
        BDBG_ERR(( "XC buffer alloc failed!" ));
        ExitCode = BERR_TRACE( BERR_OUT_OF_DEVICE_MEMORY );
        goto Done;
    }
    BMEM_ConvertAddressToOffset( hMem, Buffer, &Offset );

    RegAddr = XcBuf[ Id ].BufPtrRegAddr;
    BREG_Write32( hXpt->hRegister, RegAddr, Offset );                   /* Set BASE */
    BREG_Write32( hXpt->hRegister, RegAddr + 4, Offset + Size - 1 );    /* Set END */
    BREG_Write32( hXpt->hRegister, RegAddr + 8, Offset - 1 );           /* Set WRITE */
    BREG_Write32( hXpt->hRegister, RegAddr + 12, Offset - 1 );          /* Set VALID */
    BREG_Write32( hXpt->hRegister, RegAddr + 16, Offset - 1 );          /* Set READ */
    BREG_Write32( hXpt->hRegister, RegAddr + 20, 0 );                   /* Set WATERMARK */

    BDBG_MSG(( "Allocating for xc buf ID %u, base reg 0x%lX, DRAM addr 0x%lX", (unsigned) Id, (unsigned long) RegAddr, (unsigned long) Offset ));

    Done:
    return( ExitCode );
}

static BXPT_XcBuf_Id GetBufferId( 
    BXPT_XcBuf_Id BaseId,
    unsigned WhichOne
    )
{
    BXPT_XcBuf_Id BufferId = BaseId + WhichOne;    

#if ( BCHP_CHIP == 7325 ) || ( BCHP_CHIP == 7335 ) || ( BCHP_CHIP == 7336  ) || ( BCHP_CHIP == 3548 ) || ( BCHP_CHIP == 3556 ) || ( BCHP_CHIP == 7420 ) \
    || ( BCHP_CHIP == 7635 ) || ( BCHP_CHIP == 7342 )  || ( BCHP_CHIP == 7125) || ( BCHP_CHIP == 7340 ) || ( BCHP_CHIP == 7630 )
    /* These chips follow the above rule. */
#else
        /* There are some exceptions to the above rule. */
        switch( BaseId )
        {
    #if ( BCHP_CHIP == 3563 ) || ( BCHP_CHIP == 7440 )
            /* 3563 has only 1 remux. */
    #else
            case BXPT_XcBuf_Id_RMX0_A:
            if( WhichOne )
                BufferId = BXPT_XcBuf_Id_RMX1_A;    
            break;

            case BXPT_XcBuf_Id_RMX0_B:
            if( WhichOne )
                BufferId = BXPT_XcBuf_Id_RMX1_B;    
            break;
    #endif

    #if ( BCHP_CHIP == 7118 ) || ( BCHP_CHIP == 3563 )
        /* Not in either of these chips */
    #else
            case BXPT_XcBuf_Id_RAVE_PBP0:
            if( WhichOne >= 2 )
                BufferId = BXPT_XcBuf_Id_RAVE_PBP2 + ( WhichOne - 2 );
            break;

            case BXPT_XcBuf_Id_MSG_PBP0:
            if( WhichOne >= 2 )
                BufferId = BXPT_XcBuf_Id_MSG_PBP2 + ( WhichOne - 2 );
            break;  
    #endif

            default:
            break;
        }
#endif

    return BufferId;
}

bool BXPT_P_XcBuf_IsBufferEnabled( 
    BXPT_Handle hXpt, 
    BXPT_XcBuf_Id Id
    )
{
    uint32_t EnReg;

    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);

    EnReg = BREG_Read32( hXpt->hRegister, XcBuf[ Id ].EnableRegAddr );
    return EnReg & ( 1ul << XcBuf[ Id ].EnableBitShift ) ? true : false;
}

unsigned long BXPT_P_XcBuf_GetBlockout(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id           /* [in] size of mpeg packet */
    )
{
    uint32_t Reg, RegAddr;

    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);

    RegAddr = XcBuf[ Id ].BoRegAddr;
    Reg = BREG_Read32( hXpt->hRegister, RegAddr );
	return( BCHP_GET_FIELD_DATA( Reg, XPT_XCBUFF_BO_RAVE_IBP0, BO_COUNT ) );
}

BERR_Code BXPT_P_XcBuf_SetBlockout(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long NewBO        
    )
{
#ifdef SW7342_241_WORKAROUND
    BSTD_UNUSED( hXpt );
    BSTD_UNUSED( Id );
    BSTD_UNUSED( NewBO );
    return( BERR_SUCCESS );
#else
    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);
    return SetBlockout( hXpt, Id, NewBO);
#endif
}

static BERR_Code SetBlockout(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long NewBO        
    )
{
    uint32_t Reg, RegAddr;

    BERR_Code ExitCode = BERR_SUCCESS;

    RegAddr = XcBuf[ Id ].BoRegAddr;
    Reg = BREG_Read32( hXpt->hRegister, RegAddr );
    Reg &= ~BCHP_MASK( XPT_XCBUFF_BO_RAVE_IBP0, BO_COUNT );
    Reg |= BCHP_FIELD_DATA( XPT_XCBUFF_BO_RAVE_IBP0, BO_COUNT, NewBO );
    BREG_Write32( hXpt->hRegister, RegAddr, Reg );

    return( ExitCode );
}


