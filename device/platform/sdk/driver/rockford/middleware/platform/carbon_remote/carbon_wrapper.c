#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <alloca.h>
#include <stdarg.h>
#include <assert.h>
#include <errno.h>

#include <pthread.h>

#include "nexus_memory.h"

#define NO_ACKS            1

#define PORT_NUMBER        27015
#define REMOTE_MACHINE     "10.178.65.76"

pthread_mutex_t socket_mutex;

typedef enum
{
   V3D_OPEN = 1,
   V3D_CLOSE,
   V3D_SLAVEWRITE,
   V3D_SLAVEREAD,
   V3D_RESET,
   V3D_FLUSHCACHE,
   V3D_PAGEREAD,     /* generated by the carbon model */
   V3D_PAGEWRITE,    /* generated by the carbon model */
   V3D_IRQ,          /* generated by the carbon model */
   V3D_OK = 0xFF
} v3d_command_e;


typedef struct
{
   int masterfd;    /* this file descriptor sends API calls to the carbon model */
   void * inst;     /* remote instance from the carbon model */

   void * irq_vector;

   pthread_t irq_thread;
   pthread_t vmem_thread;

   NEXUS_HeapHandle        heap;
   void                    *heapStartCached;
   uint32_t                heapStartPhys;
   uint32_t                heapSize;

} mwcom_t;

void error(const char *msg, ...)
{
   va_list ap;
   va_start(ap, msg);
   vfprintf(stderr, msg, ap);
   va_end(ap);
   exit(0);
};


static int read_all(int fd, void * buf, size_t count)
{
   int pos = 0;
   int res = count;
   do
   {
      int rc;
      rc = read(fd, &((char *)buf)[pos], count);
      if (rc == -1)
         error("[%s] ERROR BLOCK reading from socket\n", __FUNCTION__);
      count -= rc;
      pos += rc;
   }
   while (count != 0);

   return res;
}




void * irq_func(void *p)
{
   mwcom_t * mwcom = (mwcom_t *)p;
   if (mwcom)
   {
      /* need to open irq port */
      const int portno = PORT_NUMBER + 10;
      int irqfd, done = 0;
      struct sockaddr_in serv_addr;
      struct hostent *server;
      void (*irq_vector)(void) = (void (*)(void))mwcom->irq_vector;

      irqfd = socket(AF_INET, SOCK_STREAM, 0);
      if (irqfd < 0) 
         error("[%s] ERROR opening socket\n", __FUNCTION__);

      server = gethostbyname(REMOTE_MACHINE);
      if (server == NULL)
         error("[%s] ERROR no such host - $s\n", __FUNCTION__, REMOTE_MACHINE);

      memset((char *)&serv_addr, 0, sizeof(serv_addr));
      serv_addr.sin_family = AF_INET;

      memcpy((char *)&serv_addr.sin_addr.s_addr,
            (char *)server->h_addr,
            server->h_length);

      serv_addr.sin_port = htons(portno);

      if (connect(irqfd,(struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
         error("[%s] ERROR connecting\n", __FUNCTION__);

      while(!done)
      {
         int n;
         unsigned char buffer[2];

         /* blocking call, which is why this is in a seperate thread */
         n = read_all(irqfd, buffer, sizeof(buffer));
         if (n != sizeof(buffer))
            error("[%s] ERROR reading from socket\n", __FUNCTION__);

         if ((buffer[0] == V3D_IRQ) && (buffer[1] == 0))
            /* its an irq, dispatch the function */
            irq_vector();
         else if ((buffer[0] == V3D_CLOSE) && (buffer[1] == 0))
            /* otherwise quit (V3D_CLOSE) */
            done = 1;
         else
            error("[%s] ERROR incorrect response\n", __FUNCTION__);
      }
   }

   pthread_exit(NULL);
}

void * vmem_func(void *p)
{
   mwcom_t * mwcom = (mwcom_t *)p;
   if (mwcom)
   {
      /* need to open memory port */
      const int portno = PORT_NUMBER + 20;
      int vmemfd, done = 0;
      struct sockaddr_in serv_addr;
      struct hostent *server;

      vmemfd = socket(AF_INET, SOCK_STREAM, 0);
      if (vmemfd < 0) 
         error("[%s] ERROR opening socket\n", __FUNCTION__);

      server = gethostbyname(REMOTE_MACHINE);
      if (server == NULL)
         error("[%s] ERROR no such host - %s\n", __FUNCTION__, REMOTE_MACHINE);

      memset((char *)&serv_addr, 0, sizeof(serv_addr));
      serv_addr.sin_family = AF_INET;

      memcpy((char *)&serv_addr.sin_addr.s_addr,
            (char *)server->h_addr,
            server->h_length);

      serv_addr.sin_port = htons(portno);

      if (connect(vmemfd,(struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
         error("[%s] ERROR connecting", __FUNCTION__);

      while(!done)
      {
         int n;
         unsigned char buffer[2];

         /* blocking call, which is why this is in a seperate thread */
         n = read_all(vmemfd, buffer, sizeof(buffer));
         if (n != sizeof(buffer))
            error("ERROR reading from socket %d", n);

         if ((buffer[0] == V3D_PAGEREAD) && (buffer[1] == 8))
         {
            unsigned char payload[8];
            /* do a read from the address specified */
            unsigned int address;
#ifndef NO_ACKS
            unsigned char ack[2];
#endif /* NO_ACKS */
            int rc;
            int size;
            int i;
            void * cachedaddr;
            uint8_t *buf;

            /* read the payload */
            rc = read_all(vmemfd, payload, sizeof(payload));
            if (rc != sizeof(payload))
               error("[%s] ERROR reading from socket %d", __FUNCTION__, rc);
            address =  payload[0] | (payload[1] << 8) | (payload[2] << 16) | (payload[3] << 24);
            size = payload[4] | (payload[5] << 8) | (payload[6] << 16) | (payload[7] << 24);

            /* convert the address to cached */
            cachedaddr = (void*)((uintptr_t)mwcom->heapStartCached + (address - mwcom->heapStartPhys));

            buf = (uint8_t*)malloc(size);


/*
*((uint32_t*)cachedaddr) = 0xDDCCBBAA;
*((uint16_t*)(cachedaddr + 4)) = 0xFFEE;
*((uint16_t*)(cachedaddr + 6)) = 0x9988;
*((uint8_t*)(cachedaddr + 8)) = 0x12;
*((uint8_t*)(cachedaddr + 9)) = 0x34;
*((uint8_t*)(cachedaddr + 10)) = 0x56;
*((uint8_t*)(cachedaddr + 11)) = 0x78;

*/


            /* Read from memory as words (this should be endian agnostic).
               Set into send buffer, lsbyte first. */
            for (i = 0; i < size/4; i++)
            {
               uint32_t *p = cachedaddr + (i * 4);
               buf[i * 4 + 0] = (*p >> 0) & 0xFF;
               buf[i * 4 + 1] = (*p >> 8) & 0xFF;
               buf[i * 4 + 2] = (*p >> 16) & 0xFF;
               buf[i * 4 + 3] = (*p >> 24) & 0xFF;
            }

            /* send result to simulator */
            rc = write(vmemfd, buf, size);
            if (rc != size)
               error("[%s] ERROR writing to socket\n", __FUNCTION__);

#ifndef NO_ACKS
            /* read a response back, everything is sync'd */
            rc = read_all(vmemfd, ack, sizeof(ack));
            if (rc != sizeof(ack))
               error("[%s] ERROR reading from socket\n", __FUNCTION__);

            /* we could drop these lines once we know everything works */
            if ((ack[0] != V3D_OK) && (ack[1] != 0))
               error("[%s] ERROR incorrect response\n", __FUNCTION__);
#endif /* NO_ACKS */
            
            free(buf);
         }
         else if ((buffer[0] == V3D_PAGEWRITE) && (buffer[1] == 8))
         {
            unsigned char payload[8];
            /* do a write to the address specified */
            unsigned int address;
            unsigned int enables;
#ifndef NO_ACKS
            unsigned char ack[2] = { V3D_OK, 0 };
#endif /* NO_ACKS */
            int rc;
            int size;
            void * cachedaddr;
            uint32_t *buf;
            int i;

            /* read the payload */
            rc = read_all(vmemfd, payload, buffer[1]);
            if (rc == -1)
               error("[%s] ERROR BLOCK reading from socket\n", __FUNCTION__);
            address = payload[0] | (payload[1] << 8) | (payload[ 2] << 16) | (payload[ 3] << 24);
            size =    payload[4] | (payload[5] << 8) | (payload[ 6] << 16) | (payload[ 7] << 24);

            /* convert the address to cached */
            cachedaddr = (void*)((uintptr_t)mwcom->heapStartCached + (address - mwcom->heapStartPhys));

            buf = (uint32_t*)malloc(size);

            rc = read_all(vmemfd, (void*)buf, size);
            if (rc == -1)
               error("[%s] ERROR BLOCK reading from socket\n", __FUNCTION__);

            /* Read buffer lsbyte first.
               Write memory as words (should be endian agnostic) */
            for (i = 0; i < size/4; i++)
            {
               uint8_t *p = (uint8_t*)(buf + i);
               *((uint32_t*)(cachedaddr + (i * 4))) = (p[0] << 0) | (p[1] << 8) | (p[2] << 16) | (p[3] << 24);
            }

#ifndef NO_ACKS
            /* send an ack back to the simulator */
            rc = write(vmemfd, ack, sizeof(ack));
            if (rc != sizeof(ack))
               error("[%s] ERROR writing to socket\n", __FUNCTION__);
#endif /* NO_ACKS */

            free(buf);
         }
         else if ((buffer[0] == V3D_CLOSE) && (buffer[1] == 0))
            /* otherwise quit */
            done = 1;
         else
            error("[%s] ERROR incorrect response\n", __FUNCTION__);
      }
   }

   pthread_exit(NULL);
}









void * carbon_v3d_open(void* irq_vector, void* readmem, void* writemem)
{
   /* need to open the master port and create the threads */
   const int portno = PORT_NUMBER;
   struct sockaddr_in serv_addr;
   struct hostent *server;
   int rc;
   unsigned char buffer[6];
   /* send a message to open */
   const unsigned char cmd[2] = { V3D_OPEN, 0 };

   mwcom_t * mwcom;

   pthread_mutex_init(&socket_mutex, NULL);
   
   mwcom = malloc(sizeof(mwcom_t));
   if (mwcom)
   {
      NEXUS_MemoryStatus memStatus;

      mwcom->masterfd = socket(AF_INET, SOCK_STREAM, 0);
      if (mwcom->masterfd < 0) 
         error("[%s] ERROR opening socket\n", __FUNCTION__);

      server = gethostbyname(REMOTE_MACHINE);
      if (server == NULL)
         error("[%s] ERROR no such host - %s\n", __FUNCTION__, REMOTE_MACHINE);

      memset((char *)&serv_addr, 0, sizeof(serv_addr));
      serv_addr.sin_family = AF_INET;

      memcpy((char *)&serv_addr.sin_addr.s_addr,
            (char *)server->h_addr,
            server->h_length);

      serv_addr.sin_port = htons(portno);

      if (connect(mwcom->masterfd,(struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
         error("[%s] ERROR connecting\n", __FUNCTION__);

      mwcom->irq_vector = irq_vector;

      /* create a thread to recieve IRQ messages */
      rc = pthread_create(&mwcom->irq_thread, NULL, irq_func, mwcom);
      if (rc)
         error("[%s] ERROR pthread_create() irq_func\n", __FUNCTION__);

      rc = pthread_create(&mwcom->vmem_thread, NULL, vmem_func, mwcom);
      if (rc)
         error("[%s] ERROR pthread_create() vmem_func\n", __FUNCTION__);

      /* send the open command */
      rc = write(mwcom->masterfd, cmd, sizeof(cmd));
      if (rc != sizeof(cmd))
         error("[%s] ERROR writing to socket\n", __FUNCTION__);

      /* read a response back, everything is sync'd */
      rc = read_all(mwcom->masterfd, buffer, sizeof(buffer));
      if (rc < 0)
         error("[%s] ERROR reading from socket\n", __FUNCTION__);

      if ((buffer[0] != V3D_OK) && (buffer[1] != 4))
         error("[%s] ERROR incorrect response\n", __FUNCTION__);

      /* Store the heap settings */
      mwcom->heap = NEXUS_Platform_GetFramebufferHeap(0);
      NEXUS_Heap_GetStatus(mwcom->heap, &memStatus);
      mwcom->heapStartCached = memStatus.addr;
      mwcom->heapStartPhys = memStatus.offset;
      mwcom->heapSize = memStatus.size;

      /* return the inst to be used later */
      mwcom->inst = (void *)((uintptr_t)(buffer[2] | (buffer[3] << 8) | (buffer[4] << 16) | (buffer[5] << 24)));
   }

   return mwcom;
}


void carbon_v3d_close(void * inst)
{
   mwcom_t * mwcom = (mwcom_t *)inst;

   if (mwcom != NULL)
   {
      int n;
      unsigned char buffer[2];
      /* send a message to close down */
      const unsigned char cmd[6] = { V3D_CLOSE, 4,
         ((uintptr_t)inst >>  0) & 0xFF, ((uintptr_t)inst >>  8) & 0xFF,
         ((uintptr_t)inst >> 16) & 0xFF, ((uintptr_t)inst >> 24) & 0xFF };
      n = write(mwcom->masterfd, cmd, sizeof(cmd));
      if (n != sizeof(cmd))
            error("[%s] ERROR writing to socket\n", __FUNCTION__);

#ifndef NO_ACKS
      /* read a response back, everything is sync'd */
      n = read_all(mwcom->masterfd, buffer, sizeof(buffer));
      if (n != sizeof(buffer))
         error("[%s] ERROR reading from socket\n", __FUNCTION__);

      /* we could drop these lines once we know everything works */
      if ((buffer[0] != V3D_OK) && (buffer[1] != 0))
         error("[%s] ERROR incorrect response\n", __FUNCTION__);
#endif /* NO_ACKS */
   }

   pthread_mutex_destroy(&socket_mutex);

   close(mwcom->masterfd);
   free(mwcom);
}


void carbon_v3d_slavewrite(void * inst, unsigned int addr, unsigned int data)
{
   mwcom_t * mwcom = (mwcom_t *)inst;

   pthread_mutex_lock(&socket_mutex);

   if (mwcom != NULL)
   {
      int n;
      unsigned char buffer[2];
      /* send a message to write */
      unsigned char cmd[14] = { V3D_SLAVEWRITE, 12,
         ((uintptr_t)mwcom->inst >>  0) & 0xFF, ((uintptr_t)mwcom->inst >>  8) & 0xFF,
         ((uintptr_t)mwcom->inst >> 16) & 0xFF, ((uintptr_t)mwcom->inst >> 24) & 0xFF,
         (addr >>  0) & 0xFF, (addr >>  8) & 0xFF,
         (addr >> 16) & 0xFF, (addr >> 24) & 0xFF,
         (data >>  0) & 0xFF, (data >>  8) & 0xFF,
         (data >> 16) & 0xFF, (data >> 24) & 0xFF };

      n = write(mwcom->masterfd, cmd, sizeof(cmd));
      if (n < 0)
         error("[%s] ERROR writing to socket\n", __FUNCTION__);

#ifndef NO_ACKS
      /* read a response back, everything is sync'd */
      n = read_all(mwcom->masterfd, buffer, sizeof(buffer));
      if (n != sizeof(buffer))
         error("[%s] ERROR reading from socket\n", __FUNCTION__);

      /* we could drop these lines once we know everything works */
      if ((buffer[0] != V3D_OK) && (buffer[1] != 0))
         error("[%s] ERROR incorrect response\n", __FUNCTION__);
#endif /* NO_ACKS */
   }

   pthread_mutex_unlock(&socket_mutex);
}

unsigned int carbon_v3d_slaveread(void *inst, unsigned int addr)
{
   unsigned int response;
   mwcom_t * mwcom = (mwcom_t *)inst;

   pthread_mutex_lock(&socket_mutex);

   if (mwcom != NULL)
   {
      int n;
      unsigned char buffer[6];
      /* send a message to read */
      unsigned char cmd[10] = { V3D_SLAVEREAD, 8,
         ((uintptr_t)mwcom->inst >>  0) & 0xFF, ((uintptr_t)mwcom->inst >>  8) & 0xFF,
         ((uintptr_t)mwcom->inst >> 16) & 0xFF, ((uintptr_t)mwcom->inst >> 24) & 0xFF,
         (addr >>  0) & 0xFF, (addr >>  8) & 0xFF,
         (addr >> 16) & 0xFF, (addr >> 24) & 0xFF };

      n = write(mwcom->masterfd, cmd, sizeof(cmd));
      if (n != sizeof(cmd))
         error("[%s] ERROR writing to socket\n", __FUNCTION__);

      /* read a response back, everything is sync'd */
      n = read_all(mwcom->masterfd, buffer, sizeof(buffer));
      if (n != sizeof(buffer))
         error("[%s] ERROR reading from socket\n", __FUNCTION__);

      if ((buffer[0] != V3D_OK) || (buffer[1] != 4))
         error("[%s] ERROR incorrect response (%d,%d)\n", __FUNCTION__, buffer[0], buffer[1]);

      response = buffer[2] | (buffer[3] << 8) | (buffer[4] << 16) | (buffer[5] << 24);
   }
   else
      response = 0;

   pthread_mutex_unlock(&socket_mutex);

   return response;
}

void carbon_v3d_reset(void *inst)
{
   mwcom_t * mwcom = (mwcom_t *)inst;

   pthread_mutex_lock(&socket_mutex);

   if (mwcom)
   {
      int n;
#ifndef NO_ACKS
      unsigned char buffer[2];
#endif /* NO_ACKS */
      /* send a message to write */
      unsigned char cmd[6] = { V3D_RESET, 4,
         ((uintptr_t)mwcom->inst >>  0) & 0xFF, ((uintptr_t)mwcom->inst >>  8) & 0xFF,
         ((uintptr_t)mwcom->inst >> 16) & 0xFF, ((uintptr_t)mwcom->inst >> 24) & 0xFF };

      n = write(mwcom->masterfd, cmd, sizeof(cmd));
      if (n < 0)
         error("[%s] ERROR writing to socket\n", __FUNCTION__);

#ifndef NO_ACKS
      /* read a response back, everything is sync'd */
      n = read_all(mwcom->masterfd, buffer, sizeof(buffer));
      if (n != sizeof(buffer))
         error("[%s] ERROR reading from socket\n", __FUNCTION__);

      /* we could drop these lines once we know everything works */
      if ((buffer[0] != V3D_OK) && (buffer[1] != 0))
         error("[%s] ERROR incorrect response\n", __FUNCTION__);
#endif /* NO_ACKS */
   }

   pthread_mutex_unlock(&socket_mutex);
}

void carbon_v3d_flushcache(void *inst)
{
   mwcom_t * mwcom = (mwcom_t *)inst;

   pthread_mutex_lock(&socket_mutex);

   if (mwcom)
   {
      int n;
      unsigned char buffer[2];

      /* send a message to write */
      unsigned char cmd[6] = { V3D_FLUSHCACHE, 4,
         ((uintptr_t)mwcom->inst >>  0) & 0xFF, ((uintptr_t)mwcom->inst >>  8) & 0xFF,
         ((uintptr_t)mwcom->inst >> 16) & 0xFF, ((uintptr_t)mwcom->inst >> 24) & 0xFF };

      n = write(mwcom->masterfd, cmd, sizeof(cmd));
      if (n < 0)
         error("[%s] ERROR writing to socket\n", __FUNCTION__);

      /* read a response back, everything is sync'd */
      n = read_all(mwcom->masterfd, buffer, sizeof(buffer));
      if (n != sizeof(buffer))
         error("[%s] ERROR reading from socket\n", __FUNCTION__);

      /* we could drop these lines once we know everything works */
      if ((buffer[0] != V3D_OK) && (buffer[1] != 0))
         error("[%s] ERROR incorrect response\n", __FUNCTION__);
   }

   pthread_mutex_unlock(&socket_mutex);
}
